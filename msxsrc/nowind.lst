Sjasm Z80 Assembler v0.4 BETA 6 - www.xl2s.tk             [2010.02.05 - 23:49:18]

nowind.asm
Errors: 0

       1   00:0000                              define  DEBUG
       2   00:0000                              
       3   00:0000                      	;define	NOWINDVERSION_FIRSTBATCH			; our handmade first batch
       4   00:0000                      	define	NOWINDVERSION_SUNRISE				; sunrise first batch
       5   00:0000                      		        
       6   00:0000                      	ifdef	NOWINDVERSION_FIRSTBATCH
       7   00:0000                    ~ 	define	FLASHROMSIZE 512
       8   00:0000                    ~ 	endif
       9   00:0000                      		
      10   00:0000                      	ifdef	NOWINDVERSION_SUNRISE
      11   00:0000                      	define	FLASHROMSIZE 4096
      12   00:0000                      	endif
      13   00:0000                      
      14   00:0000                      		
      15   00:0000                      	output	"nowind.rom"
      16   00:0000                      	include "labels.asm"
       1.  00:0000                      ; BIOS routines
       2.  00:0000  (00:000C)           RDSLT           equ $000c
       3.  00:0000  (00:0014)           WRSLT           equ $0014
       4.  00:0000  (00:001C)           CALSLT          equ $001c
       5.  00:0000  (00:0024)           ENASLT          equ $0024
       6.  00:0000  (00:005F)           CHGMOD          equ $005f
       7.  00:0000  (00:0141)           SNSMAT          equ $0141
       8.  00:0000  (00:015F)           EXTROM          equ $015f
       9.  00:0000  (00:0185)           SDFSCR          equ $0185               ; restore screen parameters from clockchip (in SUBROM)
      10.  00:0000                      
      11.  00:0000                      ; BIOS variables (really?)
      12.  00:0000  (00:F33F)           LASTDRV         equ $f33f               ; stores CTRL-key status during boot
      13.  00:0000  (00:F342)           RAMAD1          equ $f342
      14.  00:0000  (00:F36E)           XFER            equ $f36e
      15.  00:0000                      
      16.  00:0000  (00:F663)           VALTYP          equ $f663
      17.  00:0000  (00:F7F6)           DAC             equ $f7f6
      18.  00:0000  (00:F864)           PTRFIL          equ $f864
      19.  00:0000  (00:F866)           FILNAM          equ $f866
      20.  00:0000                      
      21.  00:0000  (00:FCC1)           EXPTBL          equ $fcc1
      22.  00:0000  (00:FCC5)           SLTTBL          equ $fcc5
      23.  00:0000  (00:FCC9)           SLTATR          equ $fcc9
      24.  00:0000  (00:FD09)           SLTWRK          equ $fd09
      25.  00:0000  (00:FD89)           PROCNM          equ $fd89
      26.  00:0000  (00:FD99)           DEVICE          equ $fd99
      27.  00:0000  (00:FFCA)           EXTBIO          equ $ffca
      28.  00:0000                      
      29.  00:0000                      ; Diskrom routines
      30.  00:0000  (00:402D)           GETSLT          equ $402d
      31.  00:0000                               
      32.  00:0000                      ; Hooks
      33.  00:0000  (00:FECB)           H.RUNC          equ $fecb               ; Intercepted by diskrom
      34.  00:0000                      
      35.  00:0000                      ; Nowind hardware addresses
      36.  00:0000  (00:4000)           usbwr           equ $4000               ; 0x4000..0x5fff
      37.  00:0000  (00:2000)           usbrd           equ $2000               ; 0x2000..0x3fff
      38.  00:0000  (00:8000)           usb2            equ $8000               ; 0x8000..0x9fff (read and write)
      39.  00:0000  (00:6001)           mapper          equ $6001               ; 0x6001..0x7fff (odd numbers only)
      40.  00:0000                      
      41.  00:0000                      ; Host commands
      42.  00:0000  (00:0080)           C_DSKIO         equ $80
      43.  00:0000  (00:0081)           C_DSKCHG        equ $81
      44.  00:0000  (00:0082)           C_GETDPB        equ $82
      45.  00:0000  (00:0083)           C_CHOICE        equ $83
      46.  00:0000  (00:0084)           C_DSKFMT        equ $84
      47.  00:0000  (00:0085)           C_DRIVES        equ $85
      48.  00:0000  (00:0086)           C_INIENV        equ $86
      49.  00:0000  (00:0087)           C_SETDATE       equ $87
      50.  00:0000  (00:0088)           C_DEVICEOPEN    equ $88
      51.  00:0000  (00:0089)           C_DEVICECLOSE   equ $89
      52.  00:0000  (00:008A)           C_DEVICERNDIO   equ $8a
      53.  00:0000  (00:008B)           C_DEVICEWRITE   equ $8b
      54.  00:0000  (00:008C)           C_DEVICEREAD    equ $8c
      55.  00:0000  (00:008D)           C_DEVICEEOF     equ $8d
      56.  00:0000  (00:008E)           C_AUXIN         equ $8e
      57.  00:0000  (00:008F)           C_AUXOUT        equ $8f
      58.  00:0000  (00:0090)           C_MESSAGE       equ $90
      59.  00:0000  (00:0091)           C_CHANGEIMAGE   equ $91
      60.  00:0000  (00:0092)           C_BOOTARGS      equ $92
      61.  00:0000  (00:0093)           C_CMDREQUEST    equ $93
      62.  00:0000                      
      63.  00:0000                      ; BDOS commands 0x0F- 0x37 can just use their original command code in register C
      64.  00:0000                      
      65.  00:0000                      ; PATCH       
      66.  00:0000                              macro PATCH address, word
      67.  00:0000                    <         code ! address
      68.  00:0000                    <         dw word
      69.  00:0000                    <         endmacro
      70.  00:0000                      
      71.  00:0000                      ; DEBUGMESSAGE
      72.  00:0000                              macro DEBUGMESSAGE string
      73.  00:0000                    <         ifdef DEBUG
      74.  00:0000                    <         ld d,d
      75.  00:0000                    <         jr .skip
      76.  00:0000                    <         db string
      77.  00:0000                    < .skip:  
      78.  00:0000                    <         endif
      79.  00:0000                    <         endmacro
      80.  00:0000                      
      81.  00:0000                      ; MESSAGE
      82.  00:0000                              macro MESSAGE string
      83.  00:0000                    <         call sendMessage
      84.  00:0000                    <         db string
      85.  00:0000                    < .skip2: nop
      86.  00:0000                    <         endmacro
      87.  00:0000                      
      88.  00:0000                      ; DEBUGDUMPREGISTERS
      89.  00:0000                              macro DEBUGDUMPREGISTERS
      90.  00:0000                    <         ifdef DEBUG
      91.  00:0000                    <         db $ed,7
      92.  00:0000                    <         endif
      93.  00:0000                    <         
      94.  00:0000                    <         ifdef USBDEBUG
      95.  00:0000                    <         assert ($ < $8000)
      96.  00:0000                    <         call sendCpuInfo
      97.  00:0000                    <         endif
      98.  00:0000                    <         endmacro
      99.  00:0000                      
     100.  00:0000                      ; MAKEDPB macro
     101.  00:0000                              macro MAKEDPB media, sectorSize, sectorsPerCluster, maxEnt, maxSector, fatSiz, fatCount
     102.  00:0000                    < .firfat equ 1
     103.  00:0000                    < .firdir equ .firfat+(fatCount*fatSiz)
     104.  00:0000                    < .firrec equ .firdir+(maxEnt/(sectorSize/32))
     105.  00:0000                    <         if sectorSize = 512
     106.  00:0000                    < .shft   equ 4
     107.  00:0000                    <         elseif sectorSize = 256
     108.  00:0000                    < .shft   equ 3
     109.  00:0000                    <         endif
     110.  00:0000                    <         
     111.  00:0000                    <         db media                                        ; media descriptor
     112.  00:0000                    <         dw sectorSize                                   ; sector size
     113.  00:0000                    <         db (sectorSize/32)-1, .shft                     ; dirmsk
     114.  00:0000                    <         db sectorsPerCluster-1                          ; clusmsk 
     115.  00:0000                    <         db sectorsPerCluster                            ; clusshft (TODO: only correct for 1 and 2 sec/clus)         
     116.  00:0000                    <         dw .firfat
     117.  00:0000                    <         db fatCount, maxEnt
     118.  00:0000                    <         dw .firrec
     119.  00:0000                    <         dw (maxSector-.firrec)/sectorsPerCluster+1      ; maxclus
     120.  00:0000                    <         db fatSiz
     121.  00:0000                    <         dw .firdir
     122.  00:0000                    <         endmacro
     123.  00:0000                      
     124.  00:0000                      
     125.  00:0000                      ; ROMHEADER macro
     126.  00:0000                              macro romheader r   
     127.  00:0000                    < .addr := $4000        
     128.  00:0000                    <         repeat r
     129.  00:0000                    <         code ! .addr
     130.  00:0000                    < 
     131.  00:0000                    <         org $4000
     132.  00:0000                    <         db "AB"
     133.  00:0000                    <         dw .init
     134.  00:0000                    <         ds 12,0
     135.  00:0000                    < 
     136.  00:0000                    <         call .redir                     ; DSKIO
     137.  00:0000                    <         call .redir                     ; DSKCHG
     138.  00:0000                    <         call .redir                     ; GETDPB
     139.  00:0000                    <         call .redir                     ; CHOICE
     140.  00:0000                    <         call .redir                     ; DSKFMT
     141.  00:0000                    <         ds 3,0                          ; DRVOFF
     142.  00:0000                    < 
     143.  00:0000                    <         code ! .addr + $3fe7
     144.  00:0000                    <         org $7fe7
     145.  00:0000                    <         
     146.  00:0000                    < .init:  ld hl,romInit
     147.  00:0000                    <         push hl
     148.  00:0000                    <         jr .enableBank0        
     149.  00:0000                    < 
     150.  00:0000                    < .redir: ex (sp),hl
     151.  00:0000                    <         dec hl
     152.  00:0000                    <         dec hl
     153.  00:0000                    <         dec hl
     154.  00:0000                    <         ex (sp),hl
     155.  00:0000                    <         jr .enableBank0
     156.  00:0000                    < 
     157.  00:0000                    <         ld (mapper),a                   ; copyFromBank
     158.  00:0000                    <         ldir
     159.  00:0000                    < .enableBank0:
     160.  00:0000                    <         push af                         ; enable bank 0 (no registers changed)
     161.  00:0000                    <         xor a
     162.  00:0000                    <         ld (mapper),a
     163.  00:0000                    <         pop af
     164.  00:0000                    <         ret
     165.  00:0000                    <         
     166.  00:0000                    < .@addr := .addr + $4000
     167.  00:0000                    <         endrepeat
     168.  00:0000                    <         endmacro
     169.  00:0000                      
     170.  00:0000                      ; MACRO debugdisasm
     171.  00:0000                              macro DEBUGDISASM
     172.  00:0000                    <         db $ed, $0b
     173.  00:0000                    <         endmacro
     174.  00:0000                              
     175.  00:0000                      ; MACRO debugdisasmoff
     176.  00:0000                              macro DEBUGDISASMOFF
     177.  00:0000                    <         db $ed, $0c
     178.  00:0000                    <         endmacro        
     179.  00:0000                      
     180.  00:0000                      ; MACRO breakpoint
     181.  00:0000                              macro BREAKPOINT
     182.  00:0000                    <         ld b,b
     183.  00:0000                    <         jr $+2
     184.  00:0000                    <         endmacro
     185.  00:0000                      
     186.  00:0000                              
     187.  00:0000                              macro PRINTVDPTEXT string
     188.  00:0000                    <         
     189.  00:0000                    <         push hl
     190.  00:0000                    <         ld hl,.text 
     191.  00:0000                    <         call printVdpText2
     192.  00:0000                    <         pop hl
     193.  00:0000                    <         jr .skip
     194.  00:0000                    < .text   db string
     195.  00:0000                    <         db 0
     196.  00:0000                    < .skip:
     197.  00:0000                    <         endmacro
      17   00:0000                      
      18   00:0000                              defpage 0, $4000, $4000						; MSXDOS2 bank 0
      19   00:0000                              defpage 1, $4000, 3 * $4000					; MSXDOS2 bank 1..3
      20   00:0000                              defpage 2, $4000, $4000						; MSXDOS1
      21   00:0000                              defpage 3, 0, (512-80)*1024
      22   00:0000                      		
      23   00:0000                      ; insert MSXDOS2
      24   00:0000  (00)                        page 0
      25   00:4000                      	module	MSXDOS2_PART
      26   00:4000                      		
      27   00:4000                      	define 	MSXDOSVER 2
      28   00:4000                      ;	define	ROMINIT $47d6
      29   00:4000                      	define	PRINTTEXT $728e
      30   00:4000                      		
      31   00:4000  (32F0)                      incbin "..\roms\MSXDOS22.ROM", 0, $72f0-$4000
      32   00:72F0                                      
      33   00:72F0                              PATCH $4006, device
      33   00:72F0                    >         code ! address
      33   00:4006  98 7D             >         dw word
      34   00:4008                      
      35   00:4008                              code ! $4010
      36   00:4010  C3 9A 76                    jp DSKIO
      37   00:4013  C3 9D 77                    jp DSKCHG
      38   00:4016  C3 D4 77                    jp GETDPB
      39   00:4019  C3 40 78                    jp CHOICE
      40   00:401C  C3 45 78                    jp DSKFMT
      41   00:401F  00 00 00                    db 0,0,0                        ; no DRVOFF
      42   00:4022                              
      43   00:4022                              PATCH $47d7, getBootArgs
      43   00:4022                    >         code ! address
      43   00:47D7  F0 72             >         dw word
      44   00:47D9                      ;        PATCH $47dd, 0                  ; do not check for MSX1
      45   00:47D9                              PATCH $488d, MYSIZE
      45   00:47D9                    >         code ! address
      45   00:488D  08 00             >         dw word
      46   00:488F                              PATCH $489f, SECLEN
      46   00:488F                    >         code ! address
      46   00:489F  00 02             >         dw word
      47   00:48A1                              PATCH $48b9, DRIVES
      47   00:48A1                    >         code ! address
      47   00:48B9  DB 75             >         dw word
      48   00:48BB                              PATCH $48eb, DEFDPB - 1
      48   00:48BB                    >         code ! address
      48   00:48EB  8A 7B             >         dw word
      49   00:48ED                              PATCH $48f7, INIENV
      49   00:48ED                    >         code ! address
      49   00:48F7  44 76             >         dw word
      50   00:48F9                              PATCH $5797, OEMSTA
      50   00:48F9                    >         code ! address
      50   00:5797  50 79             >         dw word
      51   00:5799                      
      52   00:5799                              PATCH $4093, mapper
      52   00:5799                    >         code ! address
      52   00:4093  01 60             >         dw word
      53   00:4095                      
      54   00:4095                              code ! $4881
      55   00:4881  43                          db LOW initDiskBasic
      56   00:4882                              code ! $4884
      57   00:4884  73                          db HIGH initDiskBasic
      58   00:4885                       
      59   00:4885                              code ! $49a3
      60   00:49A3  21 DD 73                    ld hl,newAUX                    ; redirect AUX to host  
      61   00:49A6  11 27 F3                    ld de,$f327
      62   00:49A9  01 0A 00                    ld bc,10
      63   00:49AC  ED B0                       ldir
      64   00:49AE  00                          nop
      65   00:49AF  00                          nop
      66   00:49B0  00                          nop
      67   00:49B1  00                          nop
      68   00:49B2  00                          nop                             ; nops needed to override existing code!
      69   00:49B3                              
      70   00:49B3                              code @ $72f0
      71   00:72F0                                      
      72   00:72F0                      getBootArgs:
      73   00:72F0  CD 87 73                    call sendRegisters
      74   00:72F3  36 92                       ld (hl),C_BOOTARGS
      75   00:72F5  CD 18 75                    call enableNowindPage0
      76   00:72F8  26 20                       ld h,HIGH usbrd
      77   00:72FA  CD 99 73                    call getHeader
      78   00:72FD                      
      79   00:72FD  CD 23 75                    call restorePage0
      80   00:7300  DA 07 73                    jp c,bootMSXDOS1                ; no reply (host not connected?)
      81   00:7303                              
      82   00:7303  A7                          and a
      83   00:7304  C2 B8 75                    jp nz,INIHRD                    ; boot MSXDOS2
      84   00:7307                      
      85   00:7307                      bootMSXDOS1:
      86   00:7307  21 6F 57                    ld hl,$576f                     ; boot MSXDOS1
      87   00:730A  E5                          push hl
      88   00:730B  3E 04                       ld a,4
      89   00:730D  C3 FA 7F                    jp switchBank
      90   00:7310                                              
      91   00:7310                              include "common.asm"
       1.  00:7310                      ; Nowind specific
       2.  00:7310                      
       3.  00:7310                      nowindInit:
       4.  00:7310                              ;DEBUGMESSAGE "nowindInit"
       5.  00:7310  3A F8 FA                    ld a,($faf8)										; moet volgens bifi ld a,($2d) zijn, $faf8 is op msx1 deel van de rs232 area?
       6.  00:7313  B7                          or a 
       7.  00:7314  F5                          push af
       8.  00:7315  CC 5F 00                    call z,CHGMOD                   ; SCREEN 0 for MSX1
       9.  00:7318  F1                          pop af
      10.  00:7319  DD 21 85 01                 ld ix,SDFSCR                    ; restore screen mode from clockchip
      11.  00:731D  C4 5F 01                    call nz,EXTROM
      12.  00:7320                                      
      13.  00:7320  CD 8E 72                    call PRINTTEXT
      14.  00:7323                              ifndef DEBUG
      15.  00:7323                    ~         db "Nowind USB Diskrom!",0
      16.  00:7323                    ~         else
      17.  00:7323                              db "Nowind USB Diskrom! [debug]",0
      17.  00:7323  4E 6F 77 69 6E 64 20 55 53 42 20 44 69 73 6B 72 
      17.  00:7333  6F 6D 21 20 5B 64 65 62 75 67 5D 00 
      18.  00:733F                              endif
      19.  00:733F                      
      20.  00:733F                              ; call insertBootCode
      21.  00:733F  CD 6D 7C                    call flashWriter
      22.  00:7342  C9                          ret
      23.  00:7343                      
      24.  00:7343                      initDiskBasic:
      25.  00:7343                              DEBUGMESSAGE "initDiskBasic"
      25.  00:7343                    >         ifdef DEBUG
      25.  00:7343  52                >         ld d,d
      25.  00:7344  18 0D             >         jr .skip
      25.  00:7346                    >         db string
      25.  00:7346  69 6E 69 74 44 69 73 6B 42 61 73 69 63 
      25.  00:7353                    > .skip:
      25.  00:7353                    >         endif
      26.  00:7353  21 99 FD                    ld hl,DEVICE
      27.  00:7356  CB BE                       res 7,(hl)
      28.  00:7358                              
      29.  00:7358                              if MSXDOSVER = 1 
      30.  00:7358                    ~         jp $5897
      31.  00:7358                    ~         else
      32.  00:7358  C3 5B 49                    jp $495b
      33.  00:735B                              endif
      34.  00:735B                      
      35.  00:735B                      ; search call statement or device name
      36.  00:735B                      findStatementName:
      37.  00:735B                              DEBUGMESSAGE "findStatementName"
      37.  00:735B                    >         ifdef DEBUG
      37.  00:735B  52                >         ld d,d
      37.  00:735C  18 11             >         jr .skip
      37.  00:735E                    >         db string
      37.  00:735E  66 69 6E 64 53 74 61 74 65 6D 65 6E 74 4E 61 6D 
      37.  00:736E  65 
      37.  00:736F                    > .skip:
      37.  00:736F                    >         endif
      38.  00:736F  11 89 FD                    ld de,PROCNM
      39.  00:7372  1A                  .loop:  ld a,(de)
      40.  00:7373  BE                          cp (hl)
      41.  00:7374  20 06                       jr nz,.nextStatement
      42.  00:7376  23                          inc hl
      43.  00:7377  B7                          or a
      44.  00:7378  C8                          ret z                           ; name found
      45.  00:7379  13                          inc de
      46.  00:737A  18 F6                       jr .loop        
      47.  00:737C                      .nextStatement:
      48.  00:737C  AF                          xor a
      49.  00:737D  4F                          ld c,a
      50.  00:737E  ED B1                       cpir
      51.  00:7380  23                          inc hl
      52.  00:7381  23                          inc hl
      53.  00:7382  B6                          or (hl)
      54.  00:7383  20 D6                       jr nz,findStatementName        
      55.  00:7385  37                          scf                             ; not found
      56.  00:7386  C9                          ret
      57.  00:7387                      
      58.  00:7387                      sendRegisters:
      59.  00:7387  F5                          push af
      60.  00:7388  7C                          ld a,h
      61.  00:7389  26 40                       ld h,HIGH usbwr
      62.  00:738B  36 AF                       ld (hl),$af                     ; header
      63.  00:738D  36 05                       ld (hl),$05
      64.  00:738F  71                          ld (hl),c
      65.  00:7390  70                          ld (hl),b
      66.  00:7391  73                          ld (hl),e
      67.  00:7392  72                          ld (hl),d
      68.  00:7393  75                          ld (hl),l
      69.  00:7394  77                          ld (hl),a                       ; register h
      70.  00:7395  D1                          pop de
      71.  00:7396  73                          ld (hl),e                       ; register f
      72.  00:7397  72                          ld (hl),d                       ; register a
      73.  00:7398  C9                          ret
      74.  00:7399                              
      75.  00:7399                      getHeader:
      76.  00:7399  06 FF                       ld b,HIGH 65535                 ; 42000 * 60 states ~ 0,7 sec (time out)
      77.  00:739B  7E                  .loop:  ld a,(hl)
      78.  00:739C  FE AF               .chkaf: cp $af
      79.  00:739E  28 20                       jr z,.chk05
      80.  00:73A0  0B                          dec bc
      81.  00:73A1  78                          ld a,b
      82.  00:73A2  B1                          or c
      83.  00:73A3  20 F6                       jr nz,.loop
      84.  00:73A5                              DEBUGMESSAGE "getHeader Timed out!"
      84.  00:73A5                    >         ifdef DEBUG
      84.  00:73A5  52                >         ld d,d
      84.  00:73A6  18 14             >         jr .skip
      84.  00:73A8                    >         db string
      84.  00:73A8  67 65 74 48 65 61 64 65 72 20 54 69 6D 65 64 20 
      84.  00:73B8  6F 75 74 21 
      84.  00:73BC                    > .skip:
      84.  00:73BC                    >         endif
      85.  00:73BC  3E 02                       ld a,2                          ; not ready
      86.  00:73BE  37                          scf
      87.  00:73BF  C9                          ret
      88.  00:73C0                      
      89.  00:73C0  7E                  .chk05: ld a,(hl)
      90.  00:73C1  FE 05                       cp $05
      91.  00:73C3  20 D7                       jr nz,.chkaf
      92.  00:73C5  7E                          ld a,(hl)
      93.  00:73C6  C9                          ret
      94.  00:73C7                      
      95.  00:73C7                      sendMessage:
      96.  00:73C7                              ;DEBUGMESSAGE "sendMsg"
      97.  00:73C7  E3                          ex (sp),hl
      98.  00:73C8  F5                          push af
      99.  00:73C9  D5                          push de
     100.  00:73CA  E5                          push hl        
     101.  00:73CB  CD 87 73                    call sendRegisters
     102.  00:73CE  36 90                       ld (hl),C_MESSAGE
     103.  00:73D0  E1                          pop hl
     104.  00:73D1  7E                  .loop:  ld a,(hl)
     105.  00:73D2  23                          inc hl
     106.  00:73D3  32 00 40                    ld (usbwr),a
     107.  00:73D6  B7                          or a
     108.  00:73D7  20 F8                       jr nz,.loop
     109.  00:73D9  D1                          pop de
     110.  00:73DA  F1                          pop af
     111.  00:73DB  E3                          ex (sp),hl
     112.  00:73DC  C9                          ret
     113.  00:73DD                              
     114.  00:73DD                      ; AUX device
     115.  00:73DD                              
     116.  00:73DD  C3 E7 73            newAUX: jp AUXin
     117.  00:73E0  00                          nop
     118.  00:73E1  00                          nop
     119.  00:73E2  C3 2C 74                    jp AUXout
     120.  00:73E5  00                          nop
     121.  00:73E6  00                          nop
     122.  00:73E7                      
     123.  00:73E7                      AUXin:  DEBUGMESSAGE "AUX in"
     123.  00:73E7                    >         ifdef DEBUG
     123.  00:73E7  52                >         ld d,d
     123.  00:73E8  18 06             >         jr .skip
     123.  00:73EA  41 55 58 20 69 6E >         db string
     123.  00:73F0                    > .skip:
     123.  00:73F0                    >         endif
     124.  00:73F0  E5                          push hl
     125.  00:73F1  D5                          push de
     126.  00:73F2  C5                          push bc
     127.  00:73F3  CD 87 73                    call sendRegisters
     128.  00:73F6  36 8E                       ld (hl),C_AUXIN
     129.  00:73F8  CD 18 75                    call enableNowindPage0
     130.  00:73FB  26 20                       ld h,HIGH usbrd
     131.  00:73FD  CD 99 73                    call getHeader
     132.  00:7400  D2 1B 74                    jp nc,.getCharacter
     133.  00:7403                              
     134.  00:7403                              DEBUGMESSAGE "not connected"
     134.  00:7403                    >         ifdef DEBUG
     134.  00:7403  52                >         ld d,d
     134.  00:7404  18 0D             >         jr .skip
     134.  00:7406                    >         db string
     134.  00:7406  6E 6F 74 20 63 6F 6E 6E 65 63 74 65 64 
     134.  00:7413                    > .skip:
     134.  00:7413                    >         endif
     135.  00:7413  3E 1A                       ld a,$1a                        ; eof
     136.  00:7415  C1                  .exit:  pop bc
     137.  00:7416  D1                          pop de
     138.  00:7417  E1                          pop hl
     139.  00:7418  C3 23 75                    jp restorePage0        
     140.  00:741B                                    
     141.  00:741B                      .getCharacter:
     142.  00:741B                              DEBUGMESSAGE "getChar"
     142.  00:741B                    >         ifdef DEBUG
     142.  00:741B  52                >         ld d,d
     142.  00:741C  18 07             >         jr .skip
     142.  00:741E                    >         db string
     142.  00:741E  67 65 74 43 68 61 72 
     142.  00:7425                    > .skip:
     142.  00:7425                    >         endif
     143.  00:7425  CD 99 73                    call getHeader
     144.  00:7428  38 F1                       jr c,.getCharacter
     145.  00:742A  18 E9                       jr .exit
     146.  00:742C                      
     147.  00:742C                      
     148.  00:742C                      AUXout: DEBUGMESSAGE "AUX out"
     148.  00:742C                    >         ifdef DEBUG
     148.  00:742C  52                >         ld d,d
     148.  00:742D  18 07             >         jr .skip
     148.  00:742F                    >         db string
     148.  00:742F  41 55 58 20 6F 75 74 
     148.  00:7436                    > .skip:
     148.  00:7436                    >         endif
     149.  00:7436                              DEBUGDUMPREGISTERS
     149.  00:7436                    >         ifdef DEBUG
     149.  00:7436  ED 07             >         db $ed,7
     149.  00:7438                    >         endif
     149.  00:7438                    >         
     149.  00:7438                    >         ifdef USBDEBUG
     149.  00:7438                    ~         assert ($ < $8000)
     149.  00:7438                    ~         call sendCpuInfo
     149.  00:7438                    ~         endif
     150.  00:7438  E5                          push hl
     151.  00:7439  D5                          push de
     152.  00:743A                      ;        push bc
     153.  00:743A                      ;        ld a,(RAMAD1) ; TODO: WTF???
     154.  00:743A                      ;        call RDSLT
     155.  00:743A  F5                          push af        
     156.  00:743B  CD 87 73                    call sendRegisters
     157.  00:743E  36 8F                       ld (hl),C_AUXOUT
     158.  00:7440  F1                          pop af
     159.  00:7441                      ;        pop bc
     160.  00:7441  D1                          pop de
     161.  00:7442  E1                          pop hl
     162.  00:7443  C9                          ret
     163.  00:7444                      
     164.  00:7444                      ;insertBootCode:
     165.  00:7444                      ;        DEBUGMESSAGE "BOOTCODE"
     166.  00:7444                      ;        call sendRegisters
     167.  00:7444                      ;        ld (hl),C_BOOTCODE
     168.  00:7444                      ;        call enableNowindPage0
     169.  00:7444                      ;        call getHeader
     170.  00:7444                      ;        jp c,restorePage0
     171.  00:7444                              
     172.  00:7444                      ;        DEBUGMESSAGE "BOOTCODE"
     173.  00:7444                      ;        jp restorePage0
     174.  00:7444                      
     175.  00:7444                      ; send 32 bytes starting from address specified by DE to the usb
     176.  00:7444                      sdendFCB:
     177.  00:7444  D5                          push de
     178.  00:7445  C5                          push bc
     179.  00:7446                              
     180.  00:7446  06 20                       ld b,32
     181.  00:7448  1A                  .loop:  ld a,(de)
     182.  00:7449  32 00 40                    ld (usbwr),a
     183.  00:744C  13                          inc de
     184.  00:744D  10 F9                       djnz .loop
     185.  00:744F  C1                          pop bc
     186.  00:7450  D1                          pop de
     187.  00:7451  C9                          ret
     188.  00:7452                      
     189.  00:7452                      ; receive 32 bytes and write to the address specified by DE 
     190.  00:7452                      receiveFCB:
     191.  00:7452  D5                          push de
     192.  00:7453  C5                          push bc
     193.  00:7454                              
     194.  00:7454  06 20                       ld b,32
     195.  00:7456  3A 00 20            .loop:  ld a,(usbrd)
     196.  00:7459  32 00 40            	ld (usbwr),a			; loop back
     197.  00:745C  12                          ld (de),a
     198.  00:745D  13                          inc de
     199.  00:745E  10 F6                       djnz .loop
     200.  00:7460  C1                          pop bc
     201.  00:7461  D1                          pop de
     202.  00:7462  C9                          ret
     203.  00:7463                              
      92   00:7463                              include "extendedBios.asm"
       1.  00:7463                      
       2.  00:7463                      installExtendedBios:
       3.  00:7463                      
       4.  00:7463                              ; Called from INIENV, so EXTBIO hook is already initialized
       5.  00:7463                      
       6.  00:7463                              DEBUGMESSAGE "extbio"
       6.  00:7463                    >         ifdef DEBUG
       6.  00:7463  52                >         ld d,d
       6.  00:7464  18 06             >         jr .skip
       6.  00:7466  65 78 74 62 69 6F >         db string
       6.  00:746C                    > .skip:
       6.  00:746C                    >         endif
       7.  00:746C  CD A3 75                    call getEntrySLTWRK             ; save previous EXTBIO hook
       8.  00:746F  23                          inc hl
       9.  00:7470  EB                          ex de,hl        
      10.  00:7471  21 CA FF                    ld hl,EXTBIO
      11.  00:7474  01 05 00                    ld bc,5
      12.  00:7477  ED B0                       ldir
      13.  00:7479                              
      14.  00:7479  E5                          push hl                         ; determine device number
      15.  00:747A  AF                          xor a
      16.  00:747B  11 01 4E                    ld de,$4e01
      17.  00:747E  CD CA FF                    call EXTBIO
      18.  00:7481  E1                          pop hl
      19.  00:7482  77                          ld (hl),a
      20.  00:7483                                      
      21.  00:7483  CD 2D 40                    call GETSLT                     ; install new EXTBIO hook
      22.  00:7486  2E F7                       ld l,$f7
      23.  00:7488  67                          ld h,a
      24.  00:7489  22 CA FF                    ld (EXTBIO),hl
      25.  00:748C  21 98 74                    ld hl,extendedBios
      26.  00:748F  22 CC FF                    ld (EXTBIO+2),hl
      27.  00:7492  3E C9                       ld a,$c9
      28.  00:7494  32 CE FF                    ld (EXTBIO+4),a    
      29.  00:7497  C9                          ret
      30.  00:7498                      
      31.  00:7498                      extendedBios:
      32.  00:7498                              ; broadcast (0x00) not implemented
      33.  00:7498                              ; system exclusive (0xff) not implemented
      34.  00:7498                      
      35.  00:7498  FB                          ei
      36.  00:7499  F5                          push af
      37.  00:749A  7A                          ld a,d
      38.  00:749B  FE 4E                       cp $4e
      39.  00:749D  28 0E                       jr z,determineFunction
      40.  00:749F                      .exit:
      41.  00:749F  E5                          push hl
      42.  00:74A0  C5                          push bc
      43.  00:74A1  CD A3 75                    call getEntrySLTWRK
      44.  00:74A4  2C                          inc l                           ; previous EXTBIO hook 
      45.  00:74A5  E5                          push hl
      46.  00:74A6  DD E1                       pop ix
      47.  00:74A8  C1                          pop bc        
      48.  00:74A9  E1                          pop hl
      49.  00:74AA  F1                          pop af
      50.  00:74AB  DD E9                       jp (ix)                         ; process other EXTBIO handles
      51.  00:74AD                      
      52.  00:74AD                      determineFunction:
      53.  00:74AD  E5                          push hl
      54.  00:74AE  21 B9 D8                    ld hl,functionTable - 2 * $4e00
      55.  00:74B1  19                          add hl,de
      56.  00:74B2  19                          add hl,de
      57.  00:74B3  7E                          ld a,(hl)
      58.  00:74B4  23                          inc hl
      59.  00:74B5  66                          ld h,(hl)
      60.  00:74B6  6F                          ld l,a
      61.  00:74B7  E3                          ex (sp),hl
      62.  00:74B8  C9                          ret
      63.  00:74B9                      
      64.  00:74B9                      functionTable:
      65.  00:74B9  BF 74                       dw getNowindSlot
      66.  00:74BB  DB 74                       dw numberOfDevices
      67.  00:74BD  F2 74                       dw debugMessage
      68.  00:74BF                      
      69.  00:74BF                      getNowindSlot:               
      70.  00:74BF                              DEBUGMESSAGE "getNowindSlot"
      70.  00:74BF                    >         ifdef DEBUG
      70.  00:74BF  52                >         ld d,d
      70.  00:74C0  18 0D             >         jr .skip
      70.  00:74C2                    >         db string
      70.  00:74C2  67 65 74 4E 6F 77 69 6E 64 53 6C 6F 74 
      70.  00:74CF                    > .skip:
      70.  00:74CF                    >         endif
      71.  00:74CF  F1                          pop af
      72.  00:74D0  3D                          dec a
      73.  00:74D1  F5                          push af
      74.  00:74D2  F2 9F 74                    jp p,extendedBios.exit         ; not this device
      75.  00:74D5                              
      76.  00:74D5  F1                          pop af
      77.  00:74D6  CD 73 75                    call getSlotPage1
      78.  00:74D9  37                          scf
      79.  00:74DA  C9                          ret
      80.  00:74DB                              
      81.  00:74DB                      numberOfDevices:
      82.  00:74DB                              DEBUGMESSAGE "numberOfDevices"
      82.  00:74DB                    >         ifdef DEBUG
      82.  00:74DB  52                >         ld d,d
      82.  00:74DC  18 0F             >         jr .skip
      82.  00:74DE                    >         db string
      82.  00:74DE  6E 75 6D 62 65 72 4F 66 44 65 76 69 63 65 73 
      82.  00:74ED                    > .skip:
      82.  00:74ED                    >         endif
      83.  00:74ED  F1                          pop af
      84.  00:74EE  3C                          inc a
      85.  00:74EF  F5                          push af
      86.  00:74F0  18 AD                       jr extendedBios.exit
      87.  00:74F2                              
      88.  00:74F2                      debugMessage:
      89.  00:74F2                              DEBUGMESSAGE "debugMessage"
      89.  00:74F2                    >         ifdef DEBUG
      89.  00:74F2  52                >         ld d,d
      89.  00:74F3  18 0C             >         jr .skip
      89.  00:74F5                    >         db string
      89.  00:74F5  64 65 62 75 67 4D 65 73 73 61 67 65 
      89.  00:7501                    > .skip:
      89.  00:7501                    >         endif
      90.  00:7501  F1                          pop af
      91.  00:7502  3D                          dec a
      92.  00:7503  F5                          push af
      93.  00:7504  F2 9F 74                    jp p,extendedBios.exit
      94.  00:7507                      
      95.  00:7507  E5                          push hl
      96.  00:7508  CD 87 73                    call sendRegisters
      97.  00:750B  36 90                       ld (hl),C_MESSAGE
      98.  00:750D  E1                          pop hl
      99.  00:750E  7E                  .loop:  ld a,(hl)
     100.  00:750F  23                          inc hl
     101.  00:7510  32 00 40                    ld (usbwr),a
     102.  00:7513  B7                          or a
     103.  00:7514  20 F8                       jr nz,.loop
     104.  00:7516                              
     105.  00:7516  F1                          pop af        
     106.  00:7517  C9                          ret
      93   00:7518                              include "slotRoutines.asm"
       1.  00:7518                      ; These routines are used for slot selection
       2.  00:7518                      
       3.  00:7518                      enableNowindPage0:
       4.  00:7518  CD 68 75                    call getSlotPage0
       5.  00:751B  DD 67                       ld ixh,a
       6.  00:751D  CD 73 75                    call getSlotPage1
       7.  00:7520  C3 2C 75                    jp enableSlotPage0       
       8.  00:7523                      
       9.  00:7523                      restorePage0:
      10.  00:7523  F5                          push af
      11.  00:7524  DD 7C                       ld a,ixh
      12.  00:7526  CD 2C 75                    call enableSlotPage0
      13.  00:7529  FB                          ei
      14.  00:752A  F1                          pop af
      15.  00:752B  C9                          ret
      16.  00:752C                      
      17.  00:752C                      enableSlotPage0:
      18.  00:752C                              ; HL and D remain unchanged
      19.  00:752C                              ; enableSlotPage0 can be called in page 1 and 2 (no absolute jumps)
      20.  00:752C                      
      21.  00:752C                              ;DEBUGMESSAGE "enasltP0"
      22.  00:752C  5F                          ld e,a                          ; store slotcode for further use
      23.  00:752D  E6 03                       and 3
      24.  00:752F  4F                          ld c,a                          ; new primary slot in c  
      25.  00:7530  CB 7B                       bit 7,e
      26.  00:7532  F3                          di
      27.  00:7533  20 08                       jr nz,.expanded
      28.  00:7535                      
      29.  00:7535  DB A8                       in a,($a8)
      30.  00:7537  E6 FC                       and %11111100
      31.  00:7539  B1                          or c                            ; enable new primary slot in page 0
      32.  00:753A  D3 A8                       out ($a8),a
      33.  00:753C  C9                          ret
      34.  00:753D                              
      35.  00:753D                      .expanded:
      36.  00:753D  7B                          ld a,e                          ; store secondary slot in e
      37.  00:753E  E6 0C                       and %00001100     
      38.  00:7540  0F                          rrca
      39.  00:7541  0F                          rrca
      40.  00:7542  5F                          ld e,a
      41.  00:7543                      
      42.  00:7543  DB A8                       in a,($a8)
      43.  00:7545  E6 FC                       and %11111100
      44.  00:7547  B1                          or c                            ; new primary slot in page 0
      45.  00:7548  47                          ld b,a                          ; used to restore
      46.  00:7549  17                          rla
      47.  00:754A  A7                          and a                           ; (reset carry)
      48.  00:754B  17                          rla
      49.  00:754C  B1                          or c                            ; new primary slot in page 3
      50.  00:754D  0F                          rrca
      51.  00:754E  0F                          rrca
      52.  00:754F  D3 A8                       out ($a8),a
      53.  00:7551                      
      54.  00:7551  3A FF FF                    ld a,(-1)                       ; write secondary slot register
      55.  00:7554  2F                          cpl
      56.  00:7555  E6 FC                       and %11111100
      57.  00:7557  B3                          or e                            ; apply new secondary slot for page 0
      58.  00:7558  32 FF FF                    ld (-1),a
      59.  00:755B  5F                          ld e,a                          ; store secondary slot register (for SLTTBL)
      60.  00:755C                      
      61.  00:755C  78                          ld a,b                          ; restore primary slot page 3
      62.  00:755D  D3 A8                       out ($a8),a
      63.  00:755F                      
      64.  00:755F  3E C5                       ld a,LOW SLTTBL                 ; update SLTTBL
      65.  00:7561  81                          add c                           ; add primary slot
      66.  00:7562  4F                          ld c,a
      67.  00:7563  06 FC                       ld b,HIGH SLTTBL
      68.  00:7565  7B                          ld a,e                          ; restore secondary slot register
      69.  00:7566  02                          ld (bc),a
      70.  00:7567  C9                          ret
      71.  00:7568                      
      72.  00:7568                      ; These routines determine the current slot and subslot of a page.
      73.  00:7568                      
      74.  00:7568                      getSlotPage0:
      75.  00:7568                              ;DEBUGMESSAGE "getsltP0"
      76.  00:7568  DB A8                       in a,($a8)
      77.  00:756A  CD 8D 75                    call expanded
      78.  00:756D  07                          rlca
      79.  00:756E  07                          rlca
      80.  00:756F  E6 0C                       and %00001100           ; keep subSlot
      81.  00:7571  B1                          or c                    ; add mainSlot and expanded bit
      82.  00:7572  C9                          ret
      83.  00:7573                                      
      84.  00:7573                      getSlotPage1:
      85.  00:7573                      ;        DEBUGMESSAGE "getsltP1"
      86.  00:7573  DB A8                       in a,($a8)
      87.  00:7575  0F                          rrca
      88.  00:7576  0F                          rrca
      89.  00:7577  CD 8D 75                    call expanded
      90.  00:757A  E6 0C                       and %00001100           ; keep subSlot
      91.  00:757C  B1                          or c                    ; add mainSlot and expanded bit
      92.  00:757D  C9                          ret        
      93.  00:757E                                      
      94.  00:757E                      getSlotPage2:
      95.  00:757E                      ;        DEBUGMESSAGE "getsltP2"
      96.  00:757E  DB A8                       in a,($a8)
      97.  00:7580  0F                          rrca
      98.  00:7581  0F                          rrca
      99.  00:7582  0F                          rrca
     100.  00:7583  0F                          rrca
     101.  00:7584  CD 8D 75                    call expanded
     102.  00:7587  0F                          rrca
     103.  00:7588  0F                          rrca
     104.  00:7589  E6 0C                       and %00001100           ; keep subSlot
     105.  00:758B  B1                          or c                    ; add mainSlot and expanded bit
     106.  00:758C  C9                          ret
     107.  00:758D                      
     108.  00:758D                      ;expanded:        
     109.  00:758D                      ;        ld hl,EXPTBL - $0300
     110.  00:758D                      ;        ld b,3
     111.  00:758D                      ;        and b
     112.  00:758D                      ;        ld c,a
     113.  00:758D                      ;        add hl,bc      
     114.  00:758D                      ;        
     115.  00:758D                      ;        or (hl)        ; BUGGIE!!!! (a will be used again!)
     116.  00:758D                      ;        ret p                           ; return when slot is not expanded
     117.  00:758D                      ;        
     118.  00:758D                      ;        ld c,a
     119.  00:758D                      ;        ld a,4
     120.  00:758D                      ;        add a,l
     121.  00:758D                      ;        ld l,a
     122.  00:758D                      ;        ld a,(hl)
     123.  00:758D                      ;        ret
     124.  00:758D                      
     125.  00:758D                      expanded:        
     126.  00:758D  21 C1 F9                    ld hl,EXPTBL - $0300
     127.  00:7590  06 03                       ld b,3
     128.  00:7592  A0                          and b
     129.  00:7593  4F                          ld c,a
     130.  00:7594  09                          add hl,bc
     131.  00:7595  CB 7E                       bit 7,(hl)
     132.  00:7597  28 08                       jr z,notExpanded
     133.  00:7599                      
     134.  00:7599  CB F9                       set 7,c
     135.  00:759B  2C                          inc l
     136.  00:759C  2C                          inc l
     137.  00:759D  2C                          inc l
     138.  00:759E  2C                          inc l
     139.  00:759F  7E                          ld a,(hl)
     140.  00:75A0  C9                          ret        
     141.  00:75A1                      
     142.  00:75A1                      notExpanded:
     143.  00:75A1  C1                          pop bc
     144.  00:75A2  C9                          ret
     145.  00:75A3                      
     146.  00:75A3                      getEntrySLTWRK:
     147.  00:75A3  CD 73 75                    call getSlotPage1
     148.  00:75A6  21 09 FD                    ld hl,SLTWRK
     149.  00:75A9  4F                          ld c,a
     150.  00:75AA  0F                          rrca
     151.  00:75AB  0F                          rrca
     152.  00:75AC  0F                          rrca
     153.  00:75AD  E6 60                       and %01100000           ; main slot x 32
     154.  00:75AF  47                          ld b,a
     155.  00:75B0  79                          ld a,c
     156.  00:75B1  07                          rlca
     157.  00:75B2  E6 18                       and %00011000           ; sub slot x 8
     158.  00:75B4  80                          add b
     159.  00:75B5  85                          add l
     160.  00:75B6  6F                          ld l,a
     161.  00:75B7  C9                          ret
     162.  00:75B8                      
      94   00:75B8                              include "nowindDriver.asm"
       1.  00:75B8  (00:0008)           MYSIZE          equ 8                   ; size of work area (not used, some programs write here to stop drives spinning)
       2.  00:75B8  (00:0200)           SECLEN          equ 512                 ; sector size
       3.  00:75B8                      
       4.  00:75B8                      ; SLTWRK entry
       5.  00:75B8                      ; +0    rom drive number
       6.  00:75B8                      ; +1..5 previous EXTBIO
       7.  00:75B8                      ; +6    not used
       8.  00:75B8                      ; +7    not used
       9.  00:75B8                      
      10.  00:75B8                             
      11.  00:75B8                      ; if this is defined we tell DOS2.3 that we _are DOS2.3 also, so
      12.  00:75B8                      ; it does not try to override our initilazations 
      13.  00:75B8                      
      14.  00:75B8                      define  PRETEND_2B_DOS23
      15.  00:75B8                              
      16.  00:75B8                      INIHRD: 
      17.  00:75B8                              DEBUGMESSAGE "INIHRD"        
      17.  00:75B8                    >         ifdef DEBUG
      17.  00:75B8  52                >         ld d,d
      17.  00:75B9  18 06             >         jr .skip
      17.  00:75BB  49 4E 49 48 52 44 >         db string
      17.  00:75C1                    > .skip:
      17.  00:75C1                    >         endif
      18.  00:75C1                              
      19.  00:75C1                      ;        call getWorkArea
      20.  00:75C1                      ;        DEBUGDUMPREGISTERS
      21.  00:75C1                                                      
      22.  00:75C1  CD 18 75                    call enableNowindPage0                  ; clear hostToMSXFifo by reading 4Kb of random data
      23.  00:75C4  01 00 10                    ld bc,4096
      24.  00:75C7  3A 00 20            .loop:  ld a,(usbrd)
      25.  00:75CA  0B                          dec bc
      26.  00:75CB  78                          ld a,b
      27.  00:75CC  B1                          or c
      28.  00:75CD  20 F8                       jr nz,.loop
      29.  00:75CF  CD 23 75                    call restorePage0
      30.  00:75D2                              
      31.  00:75D2  26 40                       ld h,HIGH usbwr
      32.  00:75D4  36 AF                       ld (hl),$af                     ; INIHRD command
      33.  00:75D6  36 FF                       ld (hl),$ff
      34.  00:75D8  C3 10 73                    jp nowindInit
      35.  00:75DB                      
      36.  00:75DB                      DRIVES:
      37.  00:75DB                              DEBUGMESSAGE "DRIVES"
      37.  00:75DB                    >         ifdef DEBUG
      37.  00:75DB  52                >         ld d,d
      37.  00:75DC  18 06             >         jr .skip
      37.  00:75DE  44 52 49 56 45 53 >         db string
      37.  00:75E4                    > .skip:
      37.  00:75E4                    >         endif
      38.  00:75E4  F5                          push af                         ; A, BC and DE should be preserved!
      39.  00:75E5  C5                          push bc
      40.  00:75E6  D5                          push de
      41.  00:75E7  3A 99 FD                    ld a,(DEVICE)
      42.  00:75EA  CD 87 73                    call sendRegisters
      43.  00:75ED  36 85                       ld (hl),C_DRIVES
      44.  00:75EF  CD 18 75                    call enableNowindPage0
      45.  00:75F2  26 20                       ld h,HIGH usbrd
      46.  00:75F4  CD 99 73                    call getHeader
      47.  00:75F7  2E 02                       ld l,2                          ; default 2 drives
      48.  00:75F9  38 2C                       jr c,.notconnected
      49.  00:75FB                      
      50.  00:75FB                              PRINTVDPTEXT " Host connected."
      50.  00:75FB                    >         
      50.  00:75FB  E5                >         push hl
      50.  00:75FC  21 05 76          >         ld hl,.text
      50.  00:75FF  CD 6F 7B          >         call printVdpText2
      50.  00:7602  E1                >         pop hl
      50.  00:7603  18 11             >         jr .skip
      50.  00:7605                    > .text   db string
      50.  00:7605  20 48 6F 73 74 20 63 6F 6E 6E 65 63 74 65 64 2E 
      50.  00:7615  00                >         db 0
      50.  00:7616                    > .skip:
      51.  00:7616                                                      
      52.  00:7616  32 3F F3                    ld (LASTDRV),a                  ; install phantom drives (CRTL key)?
      53.  00:7619  7E                          ld a,(hl)                       ; allow other drives (SHIFT key)?
      54.  00:761A  32 99 FD                    ld (DEVICE),a
      55.  00:761D  6E                          ld l,(hl)                       ; number of drives
      56.  00:761E  E5                  .exit:  push hl  
      57.  00:761F  CD 23 75                    call restorePage0
      58.  00:7622  E1                          pop hl
      59.  00:7623  D1                          pop de
      60.  00:7624  C1                          pop bc
      61.  00:7625  F1                          pop af
      62.  00:7626  C9                          ret
      63.  00:7627                              
      64.  00:7627                      .notconnected:
      65.  00:7627                              PRINTVDPTEXT " Host timed out!"            
      65.  00:7627                    >         
      65.  00:7627  E5                >         push hl
      65.  00:7628  21 31 76          >         ld hl,.text
      65.  00:762B  CD 6F 7B          >         call printVdpText2
      65.  00:762E  E1                >         pop hl
      65.  00:762F  18 11             >         jr .skip
      65.  00:7631                    > .text   db string
      65.  00:7631  20 48 6F 73 74 20 74 69 6D 65 64 20 6F 75 74 21 
      65.  00:7641  00                >         db 0
      65.  00:7642                    > .skip:
      66.  00:7642  18 DA                       jr .exit
      67.  00:7644                      
      68.  00:7644                      
      69.  00:7644                      INIENV:
      70.  00:7644                      ; Interrupt handler can be installed here and
      71.  00:7644                      ; work area can be initialized when it was requested
      72.  00:7644                              DEBUGMESSAGE "INIENV"
      72.  00:7644                    >         ifdef DEBUG
      72.  00:7644  52                >         ld d,d
      72.  00:7645  18 06             >         jr .skip
      72.  00:7647  49 4E 49 45 4E 56 >         db string
      72.  00:764D                    > .skip:
      72.  00:764D                    >         endif
      73.  00:764D                      
      74.  00:764D                              ifdef PRETEND_2B_DOS23
      75.  00:764D                              DEBUGMESSAGE "Lie about being DOS v2.31"
      75.  00:764D                    >         ifdef DEBUG
      75.  00:764D  52                >         ld d,d
      75.  00:764E  18 19             >         jr .skip
      75.  00:7650                    >         db string
      75.  00:7650  4C 69 65 20 61 62 6F 75 74 20 62 65 69 6E 67 20 
      75.  00:7660  44 4F 53 20 76 32 2E 33 31 
      75.  00:7669                    > .skip:
      75.  00:7669                    >         endif
      76.  00:7669  3E 23                       ld a,$23
      77.  00:766B  32 13 F3                    ld ($f313),a
      78.  00:766E                              endif
      79.  00:766E                              
      80.  00:766E  CD 63 74                    call installExtendedBios
      81.  00:7671  CD 87 73                    call sendRegisters
      82.  00:7674  36 86                       ld (hl),C_INIENV
      83.  00:7676  CD 18 75                    call enableNowindPage0
      84.  00:7679  26 20                       ld h,HIGH usbrd
      85.  00:767B  CD 99 73                    call getHeader
      86.  00:767E  F5                          push af
      87.  00:767F                      ;        push ix
      88.  00:767F                      ;        call GETWRK
      89.  00:767F                      ;        pop ix
      90.  00:767F  CD A3 75                    call getEntrySLTWRK
      91.  00:7682  F1                          pop af
      92.  00:7683  36 00                       ld (hl),0                       ; romdisk in drive A: (default)          
      93.  00:7685  38 01                       jr c,.exit
      94.  00:7687  77                          ld (hl),a                       ; store romdisk drive number (255 = no romdisk)
      95.  00:7688  C3 23 75            .exit:  jp restorePage0
      96.  00:768B                      
      97.  00:768B                      checkWorkArea:
      98.  00:768B  3E 01                       ld a,1
      99.  00:768D  A7                          and a
     100.  00:768E  C9                          ret
     101.  00:768F                              
     102.  00:768F  C5                          push bc
     103.  00:7690  E5                          push hl
     104.  00:7691  F5                          push af
     105.  00:7692                      ;        call GETWRK
     106.  00:7692  CD A3 75                    call getEntrySLTWRK
     107.  00:7695  F1                          pop af
     108.  00:7696  BE                          cp (hl)
     109.  00:7697  E1                          pop hl
     110.  00:7698  C1                          pop bc
     111.  00:7699  C9                          ret        
     112.  00:769A                      
     113.  00:769A                      DSKIO: 
     114.  00:769A                      ; Input     F   Carry for set for write, reset for read
     115.  00:769A                      ;           A   Drive number
     116.  00:769A                      ;           B   Number of sectors to read/write
     117.  00:769A                      ;           C   Media descriptor
     118.  00:769A                      ;           DE  Logical sector number
     119.  00:769A                      ;           HL  Transfer address
     120.  00:769A                      ; Output    F   Carry set when not succesfull
     121.  00:769A                      ;           A   Error code
     122.  00:769A                      ;           B   Number of remaining sectors (TODO: check! even without error?)
     123.  00:769A                      
     124.  00:769A                              DEBUGMESSAGE "DSKIO"
     124.  00:769A                    >         ifdef DEBUG
     124.  00:769A  52                >         ld d,d
     124.  00:769B  18 05             >         jr .skip
     124.  00:769D  44 53 4B 49 4F    >         db string
     124.  00:76A2                    > .skip:
     124.  00:76A2                    >         endif
     125.  00:76A2  F5                          push af
     126.  00:76A3  CD 8B 76                    call checkWorkArea
     127.  00:76A6  CA 09 7C                    jp z,ROMDISK_DSKIO
     128.  00:76A9  F1                          pop af
     129.  00:76AA                      
     130.  00:76AA  CD 87 73                    call sendRegisters
     131.  00:76AD  36 80                       ld (hl),C_DSKIO
     132.  00:76AF  38 58                       jr c,dskioWrite                 ; read or write?
     133.  00:76B1                             
     134.  00:76B1                      dskioRead:
     135.  00:76B1  07                          rlca                            ; < 0x8000 ?
     136.  00:76B2  38 3F                       jr c,.page2and3
     137.  00:76B4                      
     138.  00:76B4                              DEBUGMESSAGE "read01"
     138.  00:76B4                    >         ifdef DEBUG
     138.  00:76B4  52                >         ld d,d
     138.  00:76B5  18 06             >         jr .skip
     138.  00:76B7  72 65 61 64 30 31 >         db string
     138.  00:76BD                    > .skip:
     138.  00:76BD                    >         endif
     139.  00:76BD  CD 7E 75                    call getSlotPage2               ; enable nowind in page 2
     140.  00:76C0  F5                          push af
     141.  00:76C1  CD 73 75                    call getSlotPage1
     142.  00:76C4  DD 67                       ld ixh,a                        ; ixh = current nowind slot
     143.  00:76C6  26 80                       ld h,$80
     144.  00:76C8  CD 24 00                    call ENASLT
     145.  00:76CB  C3 CE B6                    jp .page2
     146.  00:76CE                              
     147.  00:76CE  (B6CE)                      PHASE $ + $4000
     148.  00:B6CE                      .page2:
     149.  00:B6CE  3A 42 F3                    ld a,(RAMAD1)                   ; enable RAM in page 1
     150.  00:B6D1  26 40                       ld h,$40
     151.  00:B6D3  CD 24 00                    call ENASLT
     152.  00:B6D6                              
     153.  00:B6D6  CD 49 B8                    call readSectors01 
     154.  00:B6D9                              ; TODO: carry checken?----------------------------------------------!!!!!!!!!!!!!!!
     155.  00:B6D9                              
     156.  00:B6D9  DD 7C                       ld a,ixh                        ; enable nowind in page 1 
     157.  00:B6DB  26 40                       ld h,$40
     158.  00:B6DD  CD 24 00                    call ENASLT
     159.  00:B6E0  C3 E3 76                    jp .page1        
     160.  00:B6E3                      
     161.  00:B6E3  (76E3)                      DEPHASE
     162.  00:76E3                      .page1:
     163.  00:76E3  3A 00 80                    ld a,(usb2)
     164.  00:76E6  DD 67                       ld ixh,a
     165.  00:76E8  F1                          pop af
     166.  00:76E9  26 80                       ld h,$80
     167.  00:76EB  CD 24 00                    call ENASLT                     ; restore page 2
     168.  00:76EE  DD 7C                       ld a,ixh
     169.  00:76F0  B7                          or a
     170.  00:76F1  FB                          ei
     171.  00:76F2  C8                          ret z                           ; nothing more to read
     172.  00:76F3                                      
     173.  00:76F3                      .page2and3:                     
     174.  00:76F3                              DEBUGMESSAGE "read23"
     174.  00:76F3                    >         ifdef DEBUG
     174.  00:76F3  52                >         ld d,d
     174.  00:76F4  18 06             >         jr .skip
     174.  00:76F6  72 65 61 64 32 33 >         db string
     174.  00:76FC                    > .skip:
     174.  00:76FC                    >         endif
     175.  00:76FC  CD 18 75                    call enableNowindPage0
     176.  00:76FF  FD E5                       push iy
     177.  00:7701  CD 9C 78                    call readSectors23
     178.  00:7704  FD E1                       pop iy
     179.  00:7706  C3 23 75                    jp restorePage0
     180.  00:7709                      
     181.  00:7709                      dskioWrite:
     182.  00:7709                              DEBUGMESSAGE "dskwrite"
     182.  00:7709                    >         ifdef DEBUG
     182.  00:7709  52                >         ld d,d
     182.  00:770A  18 08             >         jr .skip
     182.  00:770C                    >         db string
     182.  00:770C  64 73 6B 77 72 69 74 65 
     182.  00:7714                    > .skip:
     182.  00:7714                    >         endif
     183.  00:7714  07                          rlca
     184.  00:7715  38 3E                       jr c,.page2and3        
     185.  00:7717                              
     186.  00:7717                              ;call enableNowindPage2 (todo: make common routine?) 
     187.  00:7717  CD 7E 75                    call getSlotPage2               ; save current slot page 2
     188.  00:771A  DD 67                       ld ixh,a
     189.  00:771C  CD 73 75                    call getSlotPage1
     190.  00:771F  DD 6F                       ld ixl,a
     191.  00:7721  26 80                       ld h,$80
     192.  00:7723  CD 24 00                    call ENASLT                     ; nowind in page 2
     193.  00:7726  C3 29 B7                    jp .page2
     194.  00:7729                      
     195.  00:7729  (B729)                      PHASE $ + $4000
     196.  00:B729                      .page2:
     197.  00:B729  3A 42 F3                    ld a,(RAMAD1)
     198.  00:B72C  26 40                       ld h,$40
     199.  00:B72E  CD 24 00                    call ENASLT                     ; ram in page 1
     200.  00:B731                              
     201.  00:B731  CD 77 B8                    call writeLoop01
     202.  00:B734  F5                          push af
     203.  00:B735                              
     204.  00:B735  DD 7D                       ld a,ixl
     205.  00:B737  26 40                       ld h,$40
     206.  00:B739  CD 24 00                    call ENASLT                     ; restore nowind in page 1
     207.  00:B73C  C3 3F 77                    jp .page1
     208.  00:B73F                              
     209.  00:B73F  (773F)                      DEPHASE
     210.  00:773F                      .page1:
     211.  00:773F  DD 7C                       ld a,ixh
     212.  00:7741  26 80                       ld h,$80
     213.  00:7743  CD 24 00                    call ENASLT
     214.  00:7746  F1                          pop af
     215.  00:7747  D8                          ret c                           ; return error (error code in a)
     216.  00:7748  E8                          ret pe                          ; host returns 0xfe when data for page 2/3 is available
     217.  00:7749                              DEBUGMESSAGE "doorgaan!"
     217.  00:7749                    >         ifdef DEBUG
     217.  00:7749  52                >         ld d,d
     217.  00:774A  18 09             >         jr .skip
     217.  00:774C                    >         db string
     217.  00:774C  64 6F 6F 72 67 61 61 6E 21 
     217.  00:7755                    > .skip:
     217.  00:7755                    >         endif
     218.  00:7755                              
     219.  00:7755                      .page2and3:
     220.  00:7755                              DEBUGMESSAGE "page2and3"
     220.  00:7755                    >         ifdef DEBUG
     220.  00:7755  52                >         ld d,d
     220.  00:7756  18 09             >         jr .skip
     220.  00:7758                    >         db string
     220.  00:7758  70 61 67 65 32 61 6E 64 33 
     220.  00:7761                    > .skip:
     220.  00:7761                    >         endif
     221.  00:7761  CD 18 75                    call enableNowindPage0
     222.  00:7764  CD 6A 77                    call .writeLoop23
     223.  00:7767  C3 23 75                    jp restorePage0
     224.  00:776A                              
     225.  00:776A                      .writeLoop23:
     226.  00:776A                              DEBUGMESSAGE "writeLoop23"
     226.  00:776A                    >         ifdef DEBUG
     226.  00:776A  52                >         ld d,d
     226.  00:776B  18 0B             >         jr .skip
     226.  00:776D                    >         db string
     226.  00:776D  77 72 69 74 65 4C 6F 6F 70 32 33 
     226.  00:7778                    > .skip:
     226.  00:7778                    >         endif
     227.  00:7778                              
     228.  00:7778  26 20                       ld h,HIGH usbrd
     229.  00:777A  CD 99 73                    call getHeader
     230.  00:777D  D8                          ret c                           ; exit (not ready)
     231.  00:777E  B7                          or a
     232.  00:777F  F8                          ret m                           ; exit (no error)
     233.  00:7780  20 18                       jr nz,.error
     234.  00:7782                      
     235.  00:7782                              DEBUGMESSAGE "send23"
     235.  00:7782                    >         ifdef DEBUG
     235.  00:7782  52                >         ld d,d
     235.  00:7783  18 06             >         jr .skip
     235.  00:7785  73 65 6E 64 32 33 >         db string
     235.  00:778B                    > .skip:
     235.  00:778B                    >         endif
     236.  00:778B  5E                          ld e,(hl)                       ; address
     237.  00:778C  56                          ld d,(hl)
     238.  00:778D  4E                          ld c,(hl)                       ; number of bytes        
     239.  00:778E  46                          ld b,(hl)
     240.  00:778F  7E                          ld a,(hl)                       ; block sequence number
     241.  00:7790                              
     242.  00:7790                              ;DEBUGDUMPREGISTERS
     243.  00:7790  EB                          ex de,hl
     244.  00:7791  11 00 40                    ld de,usbwr
     245.  00:7794  12                          ld (de),a                       ; mark block begin
     246.  00:7795  ED B0                       ldir
     247.  00:7797  12                          ld (de),a                       ; mark block end
     248.  00:7798  18 D0                       jr .writeLoop23
     249.  00:779A                      
     250.  00:779A  37                  .error: scf
     251.  00:779B  7E                          ld a,(hl)                       ; get error code
     252.  00:779C  C9                          ret
     253.  00:779D                      
     254.  00:779D                                     
     255.  00:779D                      DSKCHG:
     256.  00:779D                      ; Input     A   Drive number
     257.  00:779D                      ;           B   0
     258.  00:779D                      ;           C   Media descriptor (previous)
     259.  00:779D                      ;           HL  Base address of DPB
     260.  00:779D                      ; Output    B   1   Disk unchanged
     261.  00:779D                      ;               0   Unknown (DPB is updated)
     262.  00:779D                      ;               -1  Disk changed (DPB is updated)
     263.  00:779D                      ;           F   Carry set when not succesfull
     264.  00:779D                      ;           A   Error code
     265.  00:779D                      
     266.  00:779D                              DEBUGMESSAGE "DSKCHG"
     266.  00:779D                    >         ifdef DEBUG
     266.  00:779D  52                >         ld d,d
     266.  00:779E  18 06             >         jr .skip
     266.  00:77A0  44 53 4B 43 48 47 >         db string
     266.  00:77A6                    > .skip:
     266.  00:77A6                    >         endif
     267.  00:77A6  F5                          push af
     268.  00:77A7  CD 8B 76                    call checkWorkArea
     269.  00:77AA  CA 68 7C                    jp z,ROMDISK_DSKCHG
     270.  00:77AD  F1                          pop af       
     271.  00:77AE                      
     272.  00:77AE  E5                          push hl
     273.  00:77AF  CD 87 73                    call sendRegisters
     274.  00:77B2  36 81                       ld (hl),C_DSKCHG
     275.  00:77B4  CD 18 75                    call enableNowindPage0
     276.  00:77B7  26 20                       ld h,HIGH usbrd
     277.  00:77B9  CD 99 73                    call getHeader
     278.  00:77BC  4E                          ld c,(hl)               ; media descriptor (when disk was changed)
     279.  00:77BD  F5                          push af
     280.  00:77BE  C5                          push bc
     281.  00:77BF  CD 23 75                    call restorePage0
     282.  00:77C2  C1                          pop bc
     283.  00:77C3  F1                          pop af
     284.  00:77C4  E1                          pop hl
     285.  00:77C5  D8                          ret c           ; not ready
     286.  00:77C6  B7                          or a
     287.  00:77C7  06 01                       ld b,1
     288.  00:77C9  C8                          ret z           ; not changed
     289.  00:77CA  41                          ld b,c
     290.  00:77CB  CD D4 77                    call GETDPB
     291.  00:77CE  3E 0A                       ld a,10
     292.  00:77D0  D8                          ret c
     293.  00:77D1  06 FF                       ld b,255
     294.  00:77D3  C9                          ret
     295.  00:77D4                      
     296.  00:77D4                      GETDPB:
     297.  00:77D4                      ; Input     A   Drive number
     298.  00:77D4                      ;           B   Media descriptor (first byte of FAT)
     299.  00:77D4                      ;           C   Previous media descriptor (does not seem to be used in other drivers)
     300.  00:77D4                      ;           HL  Base address of HL
     301.  00:77D4                      ; Output    DPB for specified drive in [HL+1]..[HL+18]
     302.  00:77D4                      
     303.  00:77D4                              DEBUGMESSAGE "GETDPB"
     303.  00:77D4                    >         ifdef DEBUG
     303.  00:77D4  52                >         ld d,d
     303.  00:77D5  18 06             >         jr .skip
     303.  00:77D7  47 45 54 44 50 42 >         db string
     303.  00:77DD                    > .skip:
     303.  00:77DD                    >         endif
     304.  00:77DD  EB                          ex de,hl
     305.  00:77DE  13                          inc de
     306.  00:77DF  67                          ld h,a
     307.  00:77E0  78                          ld a,b
     308.  00:77E1  FE F0                       cp $f0
     309.  00:77E3  7C                          ld a,h
     310.  00:77E4  28 24                       jr z,.hddImage
     311.  00:77E6                              
     312.  00:77E6                              MESSAGE "ROM GETDPB"
     312.  00:77E6  CD C7 73          >         call sendMessage
     312.  00:77E9                    >         db string
     312.  00:77E9  52 4F 4D 20 47 45 54 44 50 42 
     312.  00:77F3  00                > .skip2: nop
     313.  00:77F4                      
     314.  00:77F4  78                          ld a,b
     315.  00:77F5  D6 F8                       sub $f8
     316.  00:77F7  D8                          ret c                           ; not supported in msxdos1
     317.  00:77F8  07                          rlca                            ; 2x
     318.  00:77F9  4F                          ld c,a
     319.  00:77FA  07                          rlca                            ; 4x
     320.  00:77FB  07                          rlca                            ; 8x
     321.  00:77FC  07                          rlca                            ; 16x
     322.  00:77FD  81                          add a,c                         ; 18x
     323.  00:77FE  4F                          ld c,a
     324.  00:77FF  06 00                       ld b,0        
     325.  00:7801  21 79 7B                    ld hl,supportedMedia
     326.  00:7804  09                          add hl,bc
     327.  00:7805  0E 12                       ld c,18
     328.  00:7807  ED B0                       ldir
     329.  00:7809  C9                          ret
     330.  00:780A                      
     331.  00:780A                      .hddImage:
     332.  00:780A                              DEBUGMESSAGE ".hddImage"
     332.  00:780A                    >         ifdef DEBUG
     332.  00:780A  52                >         ld d,d
     332.  00:780B  18 09             >         jr .skip
     332.  00:780D                    >         db string
     332.  00:780D  2E 68 64 64 49 6D 61 67 65 
     332.  00:7816                    > .skip:
     332.  00:7816                    >         endif
     333.  00:7816                                      MESSAGE "HOST GETDPB"
     333.  00:7816  CD C7 73          >         call sendMessage
     333.  00:7819                    >         db string
     333.  00:7819  48 4F 53 54 20 47 45 54 44 50 42 
     333.  00:7824  00                > .skip2: nop
     334.  00:7825  CD 87 73                    call sendRegisters
     335.  00:7828  36 82                       ld (hl),C_GETDPB
     336.  00:782A  CD 18 75                    call enableNowindPage0
     337.  00:782D  26 20                       ld h,HIGH usbrd
     338.  00:782F  CD 99 73                    call getHeader
     339.  00:7832  38 09                       jr c,.exit                      ; not ready
     340.  00:7834  5F                          ld e,a                          ; destination
     341.  00:7835  56                          ld d,(hl)
     342.  00:7836  01 12 00                    ld bc,18
     343.  00:7839                              DEBUGDUMPREGISTERS
     343.  00:7839                    >         ifdef DEBUG
     343.  00:7839  ED 07             >         db $ed,7
     343.  00:783B                    >         endif
     343.  00:783B                    >         
     343.  00:783B                    >         ifdef USBDEBUG
     343.  00:783B                    ~         assert ($ < $8000)
     343.  00:783B                    ~         call sendCpuInfo
     343.  00:783B                    ~         endif
     344.  00:783B  ED B0                       ldir
     345.  00:783D                              ;DB $ed, $0a       
     346.  00:783D  C3 23 75            .exit:  jp restorePage0        
     347.  00:7840                      
     348.  00:7840                      CHOICE:
     349.  00:7840                              ;DEBUGMESSAGE "CHOICE"
     350.  00:7840                              ifdef MSXDOS2
     351.  00:7840                    ~         ld hl,.noFormat
     352.  00:7840                    ~         else
     353.  00:7840  21 00 00                    ld hl,0                         ; no choice
     354.  00:7843                              endif
     355.  00:7843  C9                          ret
     356.  00:7844                      
     357.  00:7844                      .noFormat:
     358.  00:7844  00                          db 0
     359.  00:7845                      
     360.  00:7845                      DSKFMT:
     361.  00:7845  37                          scf
     362.  00:7846  3E 10                       ld a,16                         ; other error
     363.  00:7848  C9                          ret
     364.  00:7849                              
     365.  00:7849  (B849)                      PHASE $ + $4000
     366.  00:B849                              
     367.  00:B849                      readSectors01:
     368.  00:B849                              DEBUGMESSAGE "readSectors01"
     368.  00:B849                    >         ifdef DEBUG
     368.  00:B849  52                >         ld d,d
     368.  00:B84A  18 0D             >         jr .skip
     368.  00:B84C                    >         db string
     368.  00:B84C  72 65 61 64 53 65 63 74 6F 72 73 30 31 
     368.  00:B859                    > .skip:
     368.  00:B859                    >         endif
     369.  00:B859  26 80                       ld h,HIGH usb2
     370.  00:B85B  CD 99 B3                    call getHeader + $4000                                  
     371.  00:B85E  D8                          ret c                           ; carry means timeout, no carry: A == 0 means slow transfer, A == 1 means exit, A == 2 means fast transfer                                      
     372.  00:B85F  3D                          dec a
     373.  00:B860  C8                          ret z
     374.  00:B861  FA 6B B8                    jp m,.slowTransfer                              
     375.  00:B864  CD DD B8                    call reverseTransfer + $4000
     376.  00:B867  70                          ld (hl),b
     377.  00:B868  71                          ld (hl),c
     378.  00:B869  18 DE                       jr readSectors01
     379.  00:B86B                      
     380.  00:B86B                      .slowTransfer:
     381.  00:B86B  5E                          ld e,(hl)                       ; transfer address
     382.  00:B86C  56                          ld d,(hl)
     383.  00:B86D  4E                          ld c,(hl)                       ; transfer amount 
     384.  00:B86E  46                          ld b,(hl)
     385.  00:B86F  ED B0                       ldir        
     386.  00:B871                              
     387.  00:B871  56                          ld d,(hl)                       ; BUG in emulator (byte direct terugschrijven, geeft 'rukkert!')
     388.  00:B872  7E                          ld a,(hl)
     389.  00:B873  72                          ld (hl),d                       ; return end marker ($af, $0f)
     390.  00:B874  77                          ld (hl),a
     391.  00:B875  18 D2                       jr readSectors01
     392.  00:B877                      
     393.  00:B877                      writeLoop01:
     394.  00:B877  26 80                       ld h,HIGH usb2
     395.  00:B879  CD 99 B3                    call getHeader + $4000
     396.  00:B87C  D8                          ret c                           ; exit (not ready)
     397.  00:B87D  B7                          or a
     398.  00:B87E  F8                          ret m                           ; exit (no error)
     399.  00:B87F  20 18                       jr nz,.error
     400.  00:B881                      
     401.  00:B881                              DEBUGMESSAGE "send01"
     401.  00:B881                    >         ifdef DEBUG
     401.  00:B881  52                >         ld d,d
     401.  00:B882  18 06             >         jr .skip
     401.  00:B884  73 65 6E 64 30 31 >         db string
     401.  00:B88A                    > .skip:
     401.  00:B88A                    >         endif
     402.  00:B88A  5E                          ld e,(hl)                       ; address
     403.  00:B88B  56                          ld d,(hl)
     404.  00:B88C  4E                          ld c,(hl)                       ; number of bytes        
     405.  00:B88D  46                          ld b,(hl)
     406.  00:B88E  7E                          ld a,(hl)                       ; block sequence number
     407.  00:B88F                      
     408.  00:B88F  EB                          ex de,hl
     409.  00:B890  11 00 80                    ld de,usb2
     410.  00:B893  12                          ld (de),a                       ; mark block begin
     411.  00:B894  ED B0                       ldir
     412.  00:B896  12                          ld (de),a                       ; mark block end
     413.  00:B897  18 DE                       jr writeLoop01
     414.  00:B899                      
     415.  00:B899  37                  .error: scf
     416.  00:B89A  7E                          ld a,(hl)                       ; get error code
     417.  00:B89B  C9                          ret
     418.  00:B89C                      
     419.  00:B89C  (789C)                      DEPHASE
     420.  00:789C                       
     421.  00:789C                      readSectors23:
     422.  00:789C                              DEBUGMESSAGE "readSectors23"
     422.  00:789C                    >         ifdef DEBUG
     422.  00:789C  52                >         ld d,d
     422.  00:789D  18 0D             >         jr .skip
     422.  00:789F                    >         db string
     422.  00:789F  72 65 61 64 53 65 63 74 6F 72 73 32 33 
     422.  00:78AC                    > .skip:
     422.  00:78AC                    >         endif
     423.  00:78AC  26 20                       ld h,HIGH usbrd
     424.  00:78AE  CD 99 73                    call getHeader
     425.  00:78B1  D8                          ret c
     426.  00:78B2  3D                          dec a
     427.  00:78B3  C8                          ret z                           ; no more data
     428.  00:78B4  FA C0 78                    jp m,.slowTransfer        
     429.  00:78B7  CD DD 78                    call reverseTransfer
     430.  00:78BA  26 40                       ld h,HIGH usbwr 
     431.  00:78BC  70                          ld (hl),b
     432.  00:78BD  71                          ld (hl),c
     433.  00:78BE  18 DC                       jr readSectors23
     434.  00:78C0                      
     435.  00:78C0                      .slowTransfer:
     436.  00:78C0                              DEBUGMESSAGE "slowtransfer"
     436.  00:78C0                    >         ifdef DEBUG
     436.  00:78C0  52                >         ld d,d
     436.  00:78C1  18 0C             >         jr .skip
     436.  00:78C3                    >         db string
     436.  00:78C3  73 6C 6F 77 74 72 61 6E 73 66 65 72 
     436.  00:78CF                    > .skip:
     436.  00:78CF                    >         endif
     437.  00:78CF  5E                          ld e,(hl)                       ; transfer address
     438.  00:78D0  56                          ld d,(hl)
     439.  00:78D1  4E                          ld c,(hl)                       ; transfer amount 
     440.  00:78D2  46                          ld b,(hl)
     441.  00:78D3  ED B0                       ldir
     442.  00:78D5  56                          ld d,(hl)
     443.  00:78D6  7E                          ld a,(hl)
     444.  00:78D7  26 40                       ld h,HIGH usbwr
     445.  00:78D9  72                          ld (hl),d                       ; return end marker ($af, $0f)
     446.  00:78DA  77                          ld (hl),a
     447.  00:78DB  18 BF                       jr readSectors23
     448.  00:78DD                                     
     449.  00:78DD                      reverseTransfer:
     450.  00:78DD  FD 21 00 00                 ld iy,0                         ; save stack pointer
     451.  00:78E1  FD 39                       add iy,sp
     452.  00:78E3  5E                          ld e,(hl)                       ; transfer address
     453.  00:78E4  56                          ld d,(hl)
     454.  00:78E5  EB                          ex de,hl
     455.  00:78E6  F9                          ld sp,hl
     456.  00:78E7  EB                          ex de,hl
     457.  00:78E8  46                          ld b,(hl)                       ; number of loops       
     458.  00:78E9                      .loop:
     459.  00:78E9                              repeat 32                       ; blocks of 64 bytes hardcoded (NowindHost.cpp)
     460.  00:78E9                    <         ld d,(hl)
     461.  00:78E9                    <         ld e,(hl)
     462.  00:78E9                    <         push de
     463.  00:78E9                    <         endrepeat
     463.  00:78E9  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     463.  00:78F9  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     463.  00:7909  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     463.  00:7919  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     463.  00:7929  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     463.  00:7939  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     464.  00:7949  10 9E                       djnz .loop
     465.  00:794B                              
     466.  00:794B  FD F9                       ld sp,iy                        ; restore stack pointer
     467.  00:794D  46                          ld b,(hl)                       ; return end marker
     468.  00:794E  4E                          ld c,(hl)
     469.  00:794F  C9                          ret
     470.  00:7950                            
     471.  00:7950                      OEMSTA:
     472.  00:7950  E5                          push hl
     473.  00:7951  21 5E 79                    ld hl,.statement
     474.  00:7954  CD 5B 73                    call findStatementName
     475.  00:7957  5E                          ld e,(hl)
     476.  00:7958  23                          inc hl
     477.  00:7959  56                          ld d,(hl)
     478.  00:795A  E1                          pop hl        
     479.  00:795B  D8                          ret c
     480.  00:795C  D5                          push de
     481.  00:795D  C9                          ret
     482.  00:795E                      
     483.  00:795E                      .statement:
     484.  00:795E  49 4D 41 47 45 00           db "IMAGE",0
     485.  00:7964  71 79                       dw changeImage
     486.  00:7966                              db "VSTREAM",0
     486.  00:7966  56 53 54 52 45 41 4D 00 
     487.  00:796E  9E 79                       dw videoStream
     488.  00:7970  00                          db 0
     489.  00:7971                      
     490.  00:7971                      ; send arguments, command, filename, end with ":"
     491.  00:7971                      changeImage:
     492.  00:7971                              DEBUGMESSAGE "changeImage"
     492.  00:7971                    >         ifdef DEBUG
     492.  00:7971  52                >         ld d,d
     492.  00:7972  18 0B             >         jr .skip
     492.  00:7974                    >         db string
     492.  00:7974  63 68 61 6E 67 65 49 6D 61 67 65 
     492.  00:797F                    > .skip:
     492.  00:797F                    >         endif
     493.  00:797F  E5                          push hl
     494.  00:7980  CD 87 73                    call sendRegisters
     495.  00:7983  36 91                       ld (hl),C_CHANGEIMAGE
     496.  00:7985  E1                          pop hl
     497.  00:7986                              
     498.  00:7986                      call_exit:
     499.  00:7986                              DEBUGMESSAGE "call_exit"
     499.  00:7986                    >         ifdef DEBUG
     499.  00:7986  52                >         ld d,d
     499.  00:7987  18 09             >         jr .skip
     499.  00:7989                    >         db string
     499.  00:7989  63 61 6C 6C 5F 65 78 69 74 
     499.  00:7992                    > .skip:
     499.  00:7992                    >         endif
     500.  00:7992  7E                  .loop:  ld a,(hl)
     501.  00:7993  32 00 40                    ld (usbwr),a
     502.  00:7996  FE 3A                       cp ":"
     503.  00:7998  C8                          ret z
     504.  00:7999  B7                          or a
     505.  00:799A  C8                          ret z
     506.  00:799B  23                          inc hl
     507.  00:799C  18 F4                       jr .loop
     508.  00:799E                              
     509.  00:799E                      videoStream: 
     510.  00:799E  E5                          push hl
     511.  00:799F                              include "vram.asm"
       1:  00:799F                              
       2:  00:799F                      vramDump:
       3:  00:799F  F3                  	di
       4:  00:79A0  CD 18 75                    call enableNowindPage0
       5:  00:79A3                      
       6:  00:79A3  3E 02                       ld a,2
       7:  00:79A5  D3 99                       out ($99),a
       8:  00:79A7  3E 8F                       ld a,$80+15             ; status register pointer at S#2
       9:  00:79A9  D3 99                       out ($99),a
      10:  00:79AB                      
      11:  00:79AB                      evenFrame:
      12:  00:79AB                              ; vram address 0x0000
      13:  00:79AB                              
      14:  00:79AB                              ;xor a
      15:  00:79AB                              ;out ($99),a
      16:  00:79AB                              ;ld a,$80+2
      17:  00:79AB                              ;out ($99),a
      18:  00:79AB                              
      19:  00:79AB  3E 03                       ld a,%00000011                 ; pattern generator table
      20:  00:79AD  D3 99                       out ($99),a
      21:  00:79AF  3E 84                       ld a,$80+4
      22:  00:79B1  D3 99                       out ($99),a
      23:  00:79B3                      
      24:  00:79B3  AF                          xor a                   ; color table high
      25:  00:79B4  D3 99                       out ($99),a
      26:  00:79B6  3E 8A                       ld a,$80+10
      27:  00:79B8  D3 99                       out ($99),a
      28:  00:79BA                              
      29:  00:79BA  3E 04                       ld a,%00000100          ; vram access at 0x10000
      30:  00:79BC  CD 50 7B                    call setVramAccessPointer
      31:  00:79BF  CD E8 79                    call tranferframe
      32:  00:79C2  CD 5E 7B                    call waitForRetrace
      33:  00:79C5  CD 02 7B                    call changeColors
      34:  00:79C8                      
      35:  00:79C8                      oddFrame:
      36:  00:79C8                              ; vram address 0x10000
      37:  00:79C8                      
      38:  00:79C8                              ;ld a,%01000000
      39:  00:79C8                              ;out ($99),a
      40:  00:79C8                              ;ld a,$80+2
      41:  00:79C8                              ;out ($99),a
      42:  00:79C8                      
      43:  00:79C8  3E 23                       ld a,%00100011          ; pattern generator table
      44:  00:79CA  D3 99                       out ($99),a
      45:  00:79CC  3E 84                       ld a,$80+4
      46:  00:79CE  D3 99                       out ($99),a
      47:  00:79D0                      
      48:  00:79D0  3E 64                       ld a,00000100           ; color table high
      49:  00:79D2  D3 99                       out ($99),a
      50:  00:79D4  3E 8A                       ld a,$80+10
      51:  00:79D6  D3 99                       out ($99),a
      52:  00:79D8                      
      53:  00:79D8  AF                          xor a
      54:  00:79D9  CD 50 7B                    call setVramAccessPointer
      55:  00:79DC  CD E8 79                    call tranferframe
      56:  00:79DF  CD 5E 7B                    call waitForRetrace
      57:  00:79E2  CD 02 7B                    call changeColors
      58:  00:79E5  C3 AB 79                    jp evenFrame
      59:  00:79E8                      
      60:  00:79E8                      tranferframe:
      61:  00:79E8  CD 87 73                    call sendRegisters
      62:  00:79EB  36 FF                       ld (hl),255
      63:  00:79ED                                      
      64:  00:79ED  21 00 20                    ld hl,usbrd
      65:  00:79F0  CD 99 73                    call getHeader
      66:  00:79F3                              
      67:  00:79F3  16 70                       ld d,112			; 224x64 is 1 screen 2 page of data ($3800)
      68:  00:79F5                      write_more:        
      69:  00:79F5  21 00 20            	ld hl,usbrd
      70:  00:79F8  01 98 00                    ld bc,$0098
      71:  00:79FB                              repeat 128
      72:  00:79FB                    <         outi
      73:  00:79FB                    <         endrepeat
      73:  00:79FB  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A0B  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A1B  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A2B  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A3B  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A4B  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A5B  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A6B  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A7B  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A8B  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A9B  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AAB  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7ABB  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7ACB  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7ADB  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AEB  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      74:  00:7AFB                      
      75:  00:7AFB  15                          dec d
      76:  00:7AFC  7A                          ld a,d
      77:  00:7AFD  B7                          or a
      78:  00:7AFE  C2 F5 79                    jp nz,write_more
      79:  00:7B01  C9                          ret		
      80:  00:7B02                      
      81:  00:7B02                      changeColors:
      82:  00:7B02  AF                          xor a			; set color register pointer to zero
      83:  00:7B03  D3 99                       out ($99),a
      84:  00:7B05  3E 90                       ld a,$80+16
      85:  00:7B07  D3 99                       out ($99),a
      86:  00:7B09                              
      87:  00:7B09  21 00 20                    ld hl,usbrd
      88:  00:7B0C  01 9A 00                    ld bc,$009A		; write to color register
      89:  00:7B0F                      
      90:  00:7B0F                              repeat 32
      91:  00:7B0F                    <         outi
      92:  00:7B0F                    <         endrepeat		
      92:  00:7B0F  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B1F  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B2F  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B3F  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      93:  00:7B4F  C9                          ret
      94:  00:7B50                      
      95:  00:7B50                      	
      96:  00:7B50                      setVramAccessPointer:
      97:  00:7B50  D3 99                       out ($99),a
      98:  00:7B52  3E 8E                       ld a,$80+14
      99:  00:7B54  D3 99                       out ($99),a
     100:  00:7B56  AF                          xor a
     101:  00:7B57  D3 99                       out ($99),a
     102:  00:7B59  3E 40                       ld a,%01000000		; vram write
     103:  00:7B5B  D3 99                       out ($99),a
     104:  00:7B5D  C9                          ret
     105:  00:7B5E                      
     106:  00:7B5E                      waitForRetrace:
     107:  00:7B5E  DB 99                       in a,($99)
     108:  00:7B60  CB 77                       bit 6,a
     109:  00:7B62  20 FA                       jr nz,waitForRetrace       
     110:  00:7B64                      .lp2:        
     111:  00:7B64  DB 99                       in a,($99)
     112:  00:7B66  CB 77                       bit 6,a
     113:  00:7B68  28 FA                       jr z,.lp2       
     114:  00:7B6A  C9                          ret
     115:  00:7B6B                              	
     116:  00:7B6B                      	; just let it go... 
     512.  00:7B6B  E1                          pop hl
     513.  00:7B6C  C3 86 79                    jp call_exit
     514.  00:7B6F                              
     515.  00:7B6F                      ; hl points to text
     516.  00:7B6F                      printVdpText2:
     517.  00:7B6F  F5                                                  push af
     518.  00:7B70  7E                  .loop:  ld a,(hl)
     519.  00:7B71  D3 98                                               out ($98),a 
     520.  00:7B73  23                                                  inc hl
     521.  00:7B74  B7                                                  or a
     522.  00:7B75  20 F9                                               jr nz,.loop
     523.  00:7B77  F1                                                  pop af
     524.  00:7B78  C9                                                  ret
     525.  00:7B79                              
     526.  00:7B79                      supportedMedia:
     527.  00:7B79                                      
     528.  00:7B79                      .f8:    MAKEDPB $f8, 512, 2, 112, 1 * 80 * 9, 2, 2      ; 360 kB (1 side * 80 tracks * 9 tracks/sector)
     528.  00:7B79  (00:0001)         > .firfat equ 1
     528.  00:7B79  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     528.  00:7B79  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     528.  00:7B79                    >         if sectorSize = 512
     528.  00:7B79  (00:0004)         > .shft   equ 4
     528.  00:7B79                    >         elseif sectorSize = 256
     528.  00:7B79                    ~ .shft   equ 3
     528.  00:7B79                    ~         endif
     528.  00:7B79                    >         
     528.  00:7B79  F8                >         db media
     528.  00:7B7A  00 02             >         dw sectorSize
     528.  00:7B7C  0F 04             >         db (sectorSize/32)-1, .shft
     528.  00:7B7E  01                >         db sectorsPerCluster-1
     528.  00:7B7F  02                >         db sectorsPerCluster
     528.  00:7B80  01 00             >         dw .firfat
     528.  00:7B82  02 70             >         db fatCount, maxEnt
     528.  00:7B84  0C 00             >         dw .firrec
     528.  00:7B86  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     528.  00:7B88  02                >         db fatSiz
     528.  00:7B89  05 00             >         dw .firdir
     529.  00:7B8B                      .def:   MAKEDPB $f9, 512, 2, 112, 2 * 80 * 9, 3, 2      ; 720 kB
     529.  00:7B8B  (00:0001)         > .firfat equ 1
     529.  00:7B8B  (00:0007)         > .firdir equ .firfat+(fatCount*fatSiz)
     529.  00:7B8B  (00:000E)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     529.  00:7B8B                    >         if sectorSize = 512
     529.  00:7B8B  (00:0004)         > .shft   equ 4
     529.  00:7B8B                    >         elseif sectorSize = 256
     529.  00:7B8B                    ~ .shft   equ 3
     529.  00:7B8B                    ~         endif
     529.  00:7B8B                    >         
     529.  00:7B8B  F9                >         db media
     529.  00:7B8C  00 02             >         dw sectorSize
     529.  00:7B8E  0F 04             >         db (sectorSize/32)-1, .shft
     529.  00:7B90  01                >         db sectorsPerCluster-1
     529.  00:7B91  02                >         db sectorsPerCluster
     529.  00:7B92  01 00             >         dw .firfat
     529.  00:7B94  02 70             >         db fatCount, maxEnt
     529.  00:7B96  0E 00             >         dw .firrec
     529.  00:7B98  CA 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     529.  00:7B9A  03                >         db fatSiz
     529.  00:7B9B  07 00             >         dw .firdir
     530.  00:7B9D                              MAKEDPB $fa, 512, 2, 112, 1 * 80 * 8, 1, 2      ; 320 kB
     530.  00:7B9D  (00:0001)         > .firfat equ 1
     530.  00:7B9D  (00:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     530.  00:7B9D  (00:000A)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     530.  00:7B9D                    >         if sectorSize = 512
     530.  00:7B9D  (00:0004)         > .shft   equ 4
     530.  00:7B9D                    >         elseif sectorSize = 256
     530.  00:7B9D                    ~ .shft   equ 3
     530.  00:7B9D                    ~         endif
     530.  00:7B9D                    >         
     530.  00:7B9D  FA                >         db media
     530.  00:7B9E  00 02             >         dw sectorSize
     530.  00:7BA0  0F 04             >         db (sectorSize/32)-1, .shft
     530.  00:7BA2  01                >         db sectorsPerCluster-1
     530.  00:7BA3  02                >         db sectorsPerCluster
     530.  00:7BA4  01 00             >         dw .firfat
     530.  00:7BA6  02 70             >         db fatCount, maxEnt
     530.  00:7BA8  0A 00             >         dw .firrec
     530.  00:7BAA  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     530.  00:7BAC  01                >         db fatSiz
     530.  00:7BAD  03 00             >         dw .firdir
     531.  00:7BAF                              MAKEDPB $fb, 512, 2, 112, 2 * 80 * 8, 2, 2      ; 640 kB
     531.  00:7BAF  (00:0001)         > .firfat equ 1
     531.  00:7BAF  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     531.  00:7BAF  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     531.  00:7BAF                    >         if sectorSize = 512
     531.  00:7BAF  (00:0004)         > .shft   equ 4
     531.  00:7BAF                    >         elseif sectorSize = 256
     531.  00:7BAF                    ~ .shft   equ 3
     531.  00:7BAF                    ~         endif
     531.  00:7BAF                    >         
     531.  00:7BAF  FB                >         db media
     531.  00:7BB0  00 02             >         dw sectorSize
     531.  00:7BB2  0F 04             >         db (sectorSize/32)-1, .shft
     531.  00:7BB4  01                >         db sectorsPerCluster-1
     531.  00:7BB5  02                >         db sectorsPerCluster
     531.  00:7BB6  01 00             >         dw .firfat
     531.  00:7BB8  02 70             >         db fatCount, maxEnt
     531.  00:7BBA  0C 00             >         dw .firrec
     531.  00:7BBC  7B 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     531.  00:7BBE  02                >         db fatSiz
     531.  00:7BBF  05 00             >         dw .firdir
     532.  00:7BC1                              MAKEDPB $fc, 512, 1, 64,  1 * 40 * 9, 2, 2      ; 180 kB
     532.  00:7BC1  (00:0001)         > .firfat equ 1
     532.  00:7BC1  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     532.  00:7BC1  (00:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     532.  00:7BC1                    >         if sectorSize = 512
     532.  00:7BC1  (00:0004)         > .shft   equ 4
     532.  00:7BC1                    >         elseif sectorSize = 256
     532.  00:7BC1                    ~ .shft   equ 3
     532.  00:7BC1                    ~         endif
     532.  00:7BC1                    >         
     532.  00:7BC1  FC                >         db media
     532.  00:7BC2  00 02             >         dw sectorSize
     532.  00:7BC4  0F 04             >         db (sectorSize/32)-1, .shft
     532.  00:7BC6  00                >         db sectorsPerCluster-1
     532.  00:7BC7  01                >         db sectorsPerCluster
     532.  00:7BC8  01 00             >         dw .firfat
     532.  00:7BCA  02 40             >         db fatCount, maxEnt
     532.  00:7BCC  09 00             >         dw .firrec
     532.  00:7BCE  60 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     532.  00:7BD0  02                >         db fatSiz
     532.  00:7BD1  05 00             >         dw .firdir
     533.  00:7BD3                              MAKEDPB $fd, 512, 2, 112, 2 * 40 * 9, 2, 2      ; 360 kB
     533.  00:7BD3  (00:0001)         > .firfat equ 1
     533.  00:7BD3  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     533.  00:7BD3  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     533.  00:7BD3                    >         if sectorSize = 512
     533.  00:7BD3  (00:0004)         > .shft   equ 4
     533.  00:7BD3                    >         elseif sectorSize = 256
     533.  00:7BD3                    ~ .shft   equ 3
     533.  00:7BD3                    ~         endif
     533.  00:7BD3                    >         
     533.  00:7BD3  FD                >         db media
     533.  00:7BD4  00 02             >         dw sectorSize
     533.  00:7BD6  0F 04             >         db (sectorSize/32)-1, .shft
     533.  00:7BD8  01                >         db sectorsPerCluster-1
     533.  00:7BD9  02                >         db sectorsPerCluster
     533.  00:7BDA  01 00             >         dw .firfat
     533.  00:7BDC  02 70             >         db fatCount, maxEnt
     533.  00:7BDE  0C 00             >         dw .firrec
     533.  00:7BE0  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     533.  00:7BE2  02                >         db fatSiz
     533.  00:7BE3  05 00             >         dw .firdir
     534.  00:7BE5                              MAKEDPB $fe, 512, 1, 64,  1 * 40 * 8, 1, 2      ; 160 kB
     534.  00:7BE5  (00:0001)         > .firfat equ 1
     534.  00:7BE5  (00:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     534.  00:7BE5  (00:0007)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     534.  00:7BE5                    >         if sectorSize = 512
     534.  00:7BE5  (00:0004)         > .shft   equ 4
     534.  00:7BE5                    >         elseif sectorSize = 256
     534.  00:7BE5                    ~ .shft   equ 3
     534.  00:7BE5                    ~         endif
     534.  00:7BE5                    >         
     534.  00:7BE5  FE                >         db media
     534.  00:7BE6  00 02             >         dw sectorSize
     534.  00:7BE8  0F 04             >         db (sectorSize/32)-1, .shft
     534.  00:7BEA  00                >         db sectorsPerCluster-1
     534.  00:7BEB  01                >         db sectorsPerCluster
     534.  00:7BEC  01 00             >         dw .firfat
     534.  00:7BEE  02 40             >         db fatCount, maxEnt
     534.  00:7BF0  07 00             >         dw .firrec
     534.  00:7BF2  3A 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     534.  00:7BF4  01                >         db fatSiz
     534.  00:7BF5  03 00             >         dw .firdir
     535.  00:7BF7                              MAKEDPB $ff, 512, 2, 112, 2 * 40 * 8, 1, 1      ; 320 kB
     535.  00:7BF7  (00:0001)         > .firfat equ 1
     535.  00:7BF7  (00:0002)         > .firdir equ .firfat+(fatCount*fatSiz)
     535.  00:7BF7  (00:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     535.  00:7BF7                    >         if sectorSize = 512
     535.  00:7BF7  (00:0004)         > .shft   equ 4
     535.  00:7BF7                    >         elseif sectorSize = 256
     535.  00:7BF7                    ~ .shft   equ 3
     535.  00:7BF7                    ~         endif
     535.  00:7BF7                    >         
     535.  00:7BF7  FF                >         db media
     535.  00:7BF8  00 02             >         dw sectorSize
     535.  00:7BFA  0F 04             >         db (sectorSize/32)-1, .shft
     535.  00:7BFC  01                >         db sectorsPerCluster-1
     535.  00:7BFD  02                >         db sectorsPerCluster
     535.  00:7BFE  01 00             >         dw .firfat
     535.  00:7C00  01 70             >         db fatCount, maxEnt
     535.  00:7C02  09 00             >         dw .firrec
     535.  00:7C04  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     535.  00:7C06  01                >         db fatSiz
     535.  00:7C07  02 00             >         dw .firdir
     536.  00:7C09                      
     537.  00:7C09                      ; WARNING: in some cases DEFDPB-1 is expected!
     538.  00:7C09  (00:7B8B)           DEFDPB  equ supportedMedia.def
      95   00:7C09                              include "romdisk.asm"
       1.  00:7C09                      		define	ROMDSKBANK 5			; romdisk starts in bank 5
       2.  00:7C09                      		define	ROMDSKLAST (FLASHROMSIZE/16)-1
       3.  00:7C09                      
       4.  00:7C09                      
       5.  00:7C09                      ROMDISK_DSKIO:
       6.  00:7C09                              DEBUGMESSAGE "R_DSKIO"
       6.  00:7C09                    >         ifdef DEBUG
       6.  00:7C09  52                >         ld d,d
       6.  00:7C0A  18 07             >         jr .skip
       6.  00:7C0C                    >         db string
       6.  00:7C0C  52 5F 44 53 4B 49 4F 
       6.  00:7C13                    > .skip:
       6.  00:7C13                    >         endif
       7.  00:7C13  F1                          pop af
       8.  00:7C14  3E 00                       ld a,0
       9.  00:7C16  D8                          ret c                           ; write protected
      10.  00:7C17                              
      11.  00:7C17  EB                          ex de,hl
      12.  00:7C18  C5                  .loop:  push bc
      13.  00:7C19  E5                          push hl        
      14.  00:7C1A                              
      15.  00:7C1A  CB 7A                       bit 7,d
      16.  00:7C1C  20 1C                       jr nz,.directCopy
      17.  00:7C1E  7A                          ld a,d
      18.  00:7C1F  FE 3E                       cp $3e        
      19.  00:7C21  38 17                       jr c,.directCopy
      20.  00:7C23                      
      21.  00:7C23  CD 46 7C                    call .findSector
      22.  00:7C26  D5                          push de
      23.  00:7C27  ED 5B 4D F3                 ld de,($f34d)        
      24.  00:7C2B  CD F4 7F                    call copyFromBank
      25.  00:7C2E  D1                          pop de
      26.  00:7C2F  01 00 02                    ld bc,512
      27.  00:7C32  2A 4D F3                    ld hl,($f34d)
      28.  00:7C35  CD 6E F3                    call XFER
      29.  00:7C38  18 06                       jr .nextSector           
      30.  00:7C3A                                    
      31.  00:7C3A                      .directCopy:                
      32.  00:7C3A  CD 46 7C                    call .findSector  
      33.  00:7C3D  CD F4 7F                    call copyFromBank
      34.  00:7C40                      .nextSector:
      35.  00:7C40  E1                          pop hl
      36.  00:7C41  23                          inc hl
      37.  00:7C42  C1                          pop bc
      38.  00:7C43  10 D3                       djnz .loop
      39.  00:7C45  C9                          ret
      40.  00:7C46                      
      41.  00:7C46                      .findSector:        
      42.  00:7C46  7D                          ld a,l                          ; determine bank
      43.  00:7C47  E6 E0                       and %11100000
      44.  00:7C49  B4                          or h
      45.  00:7C4A  07                          rlca
      46.  00:7C4B  07                          rlca
      47.  00:7C4C  07                          rlca
      48.  00:7C4D  47                          ld b,a
      49.  00:7C4E                      
      50.  00:7C4E  7D                          ld a,l
      51.  00:7C4F  E6 1F                       and 31
      52.  00:7C51  4F                          ld c,a
      53.  00:7C52  3E FF                       ld a,ROMDSKLAST                 ; banks with b0..5=0 reside in the last bank
      54.  00:7C54  28 05                       jr z,.skip
      55.  00:7C56                      
      56.  00:7C56  78                          ld a,b
      57.  00:7C57  C6 05                       add ROMDSKBANK
      58.  00:7C59  41                          ld b,c
      59.  00:7C5A  05                          dec b
      60.  00:7C5B  4F                  .skip:  ld c,a
      61.  00:7C5C  78                          ld a,b
      62.  00:7C5D  07                          rlca
      63.  00:7C5E  C6 41                       add $41                         ; disk images starts at $4100
      64.  00:7C60  67                          ld h,a
      65.  00:7C61  2E 00                       ld l,0
      66.  00:7C63  79                          ld a,c
      67.  00:7C64  01 00 02                    ld bc,512
      68.  00:7C67  C9                          ret
      69.  00:7C68                                                               
      70.  00:7C68                      ROMDISK_DSKCHG:
      71.  00:7C68                              ;DEBUGMESSAGE "ROM_DSKCHG"
      72.  00:7C68  F1                          pop af
      73.  00:7C69  A7                          and a
      74.  00:7C6A  06 01                       ld b,1                          ; not changed
      75.  00:7C6C  C9                          ret
      76.  00:7C6D                      
      77.  00:7C6D                      ROMDISK_GETDPB:
      78.  00:7C6D                              ; not implemented (standard mediadescriptor as used)
      79.  00:7C6D                              
      80.  00:7C6D                      ROMDISK_DSKFMT:
      81.  00:7C6D                              ; not implemented (no disk can be formatted)
      82.  00:7C6D                              
      96   00:7C6D                              include "flashWriter.asm"		; todo: remove load from pc
       1.  00:7C6D                      ; flashWriter.asm
       2.  00:7C6D                      ; Flashes and erases the AMD29F040/M29F032-D
       3.  00:7C6D                           
       4.  00:7C6D                      flashWriter:
       5.  00:7C6D                              ;DEBUGMESSAGE "flashWriter"
       6.  00:7C6D  3E 03                       ld a,3
       7.  00:7C6F  CD 41 01                    call SNSMAT
       8.  00:7C72  E6 08                       and 8
       9.  00:7C74  C0                          ret nz
      10.  00:7C75                              
      11.  00:7C75  CD 8E 72                    call PRINTTEXT
      12.  00:7C78                              db 10,13," FlashROM",10,13," "
      12.  00:7C78  0A 0D 20 46 6C 61 73 68 52 4F 4D 0A 0D 20 
      13.  00:7C86  2E (33)                     ds 33,"."
      14.  00:7CA7  0D 20 00                    db 13," ",0
      15.  00:7CAA                              
      16.  00:7CAA  CD 73 75                    call getSlotPage1
      17.  00:7CAD  CD 2C 75                    call enableSlotPage0
      18.  00:7CB0                      
      19.  00:7CB0  21 BD 7C                    ld hl,.source
      20.  00:7CB3  11 00 C0                    ld de,$c000
      21.  00:7CB6  D5                          push de
      22.  00:7CB7  01 DB 00                    ld bc,flasherEnd - $c000
      23.  00:7CBA  ED B0                       ldir
      24.  00:7CBC  C9                          ret
      25.  00:7CBD                              
      26.  00:7CBD                      .source:     
      27.  00:7CBD  (C000)                      PHASE $c000  
      28.  00:C000                              
      29.  00:C000                      waitForHeader:
      30.  00:C000  26 20                       ld h,HIGH usbrd
      31.  00:C002  7E                          ld a,(hl)
      32.  00:C003  FE BB               .chkbb: cp $bb
      33.  00:C005  20 F9                       jr nz,waitForHeader
      34.  00:C007  7E                          ld a,(hl)
      35.  00:C008  FE 55                       cp $55
      36.  00:C00A  20 F7                       jr nz,.chkbb       
      37.  00:C00C                      
      38.  00:C00C  7E                          ld a,(hl)
      39.  00:C00D  FE A2                       cp $a2
      40.  00:C00F  CA A9 C0                    jp z,verifyFlash
      41.  00:C012  FE A3                       cp $a3
      42.  00:C014  28 6E                       jr z,writeFlash
      43.  00:C016  FE A4                       cp $a4
      44.  00:C018  28 52                       jr z,chipErase
      45.  00:C01A  FE A5                       cp $a5
      46.  00:C01C  28 1C                       jr z,eraseSector
      47.  00:C01E  FE A6                       cp $a6
      48.  00:C020  28 02                       jr z,autoselectMode
      49.  00:C022                      
      50.  00:C022  20 DC                       jr nz,waitForHeader
      51.  00:C024                          
      52.  00:C024                      autoselectMode:
      53.  00:C024  3E 90                       ld a,$90
      54.  00:C026  CD CC C0                    call writeCommandSequence
      55.  00:C029                      
      56.  00:C029  2A 00 40                    ld hl,($4000)
      57.  00:C02C  EB                          ex de,hl
      58.  00:C02D  26 40                       ld h,HIGH usbwr
      59.  00:C02F  36 AA                       ld (hl),$aa
      60.  00:C031  36 55                       ld (hl),$55
      61.  00:C033  73                          ld (hl),e                       ; manufacturer ID (0x01 = AMD)
      62.  00:C034  72                          ld (hl),d                       ; device ID (0xA4 = AM29F040, 0x41 = AM29F032B)
      63.  00:C035                      
      64.  00:C035  CD 66 C0                    call writeResetCommand
      65.  00:C038  18 C6                       jr waitForHeader
      66.  00:C03A                      
      67.  00:C03A                      eraseSector:
      68.  00:C03A                              ;DEBUGMESSAGE "sector erase"
      69.  00:C03A  3E 65               	ld a,"e"
      70.  00:C03C  D3 98               	out ($98),a
      71.  00:C03E                      
      72.  00:C03E  7E                          ld a,(hl)                       ; get sector number 0..63
      73.  00:C03F  CB 27                       sla a
      74.  00:C041  CB 27                       sla a
      75.  00:C043  32 01 60                    ld (mapper),a                   ; select sector
      76.  00:C046                      
      77.  00:C046  3E 80                       ld a,$80
      78.  00:C048  CD CC C0                    call writeCommandSequence
      79.  00:C04B  3E 30                       ld a,$30        
      80.  00:C04D  CD CC C0                    call writeCommandSequence
      81.  00:C050                      
      82.  00:C050  CD 56 C0                    call waitForCommandToComplete
      83.  00:C053  C3 BD C0                    jp acknowledge
      84.  00:C056                              
      85.  00:C056                      waitForCommandToComplete:
      86.  00:C056  7E                          ld a,(hl)
      87.  00:C057  46                          ld b,(hl)
      88.  00:C058  A8                          xor b
      89.  00:C059  E6 40                       and %01000000                   ; check toggle bit I (DQ6)
      90.  00:C05B  C8                          ret z                           ; operation complete
      91.  00:C05C                              
      92.  00:C05C  78                          ld a,b
      93.  00:C05D  E6 20                       and %00100000                   ; timing limits exceeded? (DQ5)
      94.  00:C05F  28 F5                       jr z,waitForCommandToComplete
      95.  00:C061                      
      96.  00:C061  CD 66 C0                    call writeResetCommand
      97.  00:C064  78                          ld a,b
      98.  00:C065  C9                          ret
      99.  00:C066                      
     100.  00:C066                      writeResetCommand:
     101.  00:C066  3E F0                       ld a,$f0                        ; write RESET command
     102.  00:C068  32 00 00                    ld (0),a
     103.  00:C06B  C9                          ret
     104.  00:C06C                      
     105.  00:C06C                      chipErase:
     106.  00:C06C                              ;DEBUGMESSAGE "chip erase"
     107.  00:C06C  3E 45               	ld a,"E"
     108.  00:C06E  D3 98               	out ($98),a
     109.  00:C070                      
     110.  00:C070  3E 80                       ld a,$80
     111.  00:C072  CD CC C0                    call writeCommandSequence
     112.  00:C075  3E 10                       ld a,$10
     113.  00:C077  CD CC C0                    call writeCommandSequence
     114.  00:C07A                      
     115.  00:C07A  3A 00 40            .wait:  ld a,($4000)                    ; read DQ7 (data# polling) 
     116.  00:C07D  07                          rlca
     117.  00:C07E  30 FA                       jr nc,.wait        
     118.  00:C080  3E 01                       ld a,1
     119.  00:C082  18 39                       jr acknowledge
     120.  00:C084                      
     121.  00:C084                      
     122.  00:C084                      writeFlash:
     123.  00:C084                              ;DEBUGMESSAGE "write"
     124.  00:C084  5E                          ld e,(hl)                       ; address
     125.  00:C085  56                          ld d,(hl)
     126.  00:C086                      
     127.  00:C086  7A                          ld a,d
     128.  00:C087  B3                          or e
     129.  00:C088  CC C7 C0                    call z,updateBar
     130.  00:C08B                      
     131.  00:C08B  7E                          ld a,(hl)                       ; bank
     132.  00:C08C  32 01 60                    ld (mapper),a
     133.  00:C08F  26 40                       ld h,$40
     134.  00:C091                              
     135.  00:C091  06 80                       ld b,128                        ; data is written in blocks of 128 bytes
     136.  00:C093  3E A0               .loop:  ld a,$a0
     137.  00:C095  CD CC C0                    call writeCommandSequence
     138.  00:C098  3A 00 20                    ld a,(usbrd)
     139.  00:C09B  12                          ld (de),a                       ; write data to flash
     140.  00:C09C  13                          inc de
     141.  00:C09D                      
     142.  00:C09D  7E                  .wait:  ld  a,(hl)                      ; write complete?
     143.  00:C09E  AE                          xor (hl)
     144.  00:C09F  E6 40                       and %01000000
     145.  00:C0A1  20 FA                       jr  nz,.wait
     146.  00:C0A3  10 EE                       djnz .loop
     147.  00:C0A5                              
     148.  00:C0A5  3E 02                       ld a,2
     149.  00:C0A7  18 14                       jr acknowledge        
     150.  00:C0A9                              
     151.  00:C0A9                      verifyFlash:
     152.  00:C0A9                              ;DEBUGMESSAGE "verify"
     153.  00:C0A9  21 00 20                    ld hl,usbrd
     154.  00:C0AC  5E                          ld e,(hl)                       ; address
     155.  00:C0AD  56                          ld d,(hl)
     156.  00:C0AE  7E                          ld a,(hl)                       ; bank
     157.  00:C0AF  32 01 60                    ld (mapper),a
     158.  00:C0B2                      
     159.  00:C0B2  06 80                       ld b,128
     160.  00:C0B4  1A                  .loop:  ld a,(de)
     161.  00:C0B5  32 00 40                    ld (usbwr),a
     162.  00:C0B8  13                          inc de
     163.  00:C0B9  10 F9                       djnz .loop
     164.  00:C0BB                      
     165.  00:C0BB  3E 03                       ld a,3
     166.  00:C0BD                      acknowledge:        
     167.  00:C0BD  26 40                       ld h,HIGH usbwr
     168.  00:C0BF  36 AA                       ld (hl),$aa
     169.  00:C0C1  36 55                       ld (hl),$55
     170.  00:C0C3  77                          ld (hl),a
     171.  00:C0C4  C3 00 C0                    jp waitForHeader
     172.  00:C0C7                      
     173.  00:C0C7                      updateBar:
     174.  00:C0C7  3E 77                       ld a,"w"  
     175.  00:C0C9  D3 98                       out ($98),a
     176.  00:C0CB  C9                          ret
     177.  00:C0CC                      
     178.  00:C0CC                      writeCommandSequence:
     179.  00:C0CC  F5                          push af
     180.  00:C0CD  3E AA                       ld a,$aa
     181.  00:C0CF  32 55 05                    ld ($0555),a
     182.  00:C0D2  2F                          cpl
     183.  00:C0D3  32 AA 02                    ld ($02aa),a
     184.  00:C0D6  F1                          pop af
     185.  00:C0D7  32 55 05                    ld ($0555),a
     186.  00:C0DA  C9                          ret
     187.  00:C0DB                              
     188.  00:C0DB                      flasherEnd:
     189.  00:C0DB  (7D98)                      DEPHASE
      97   00:7D98                              include "device.asm"
       1.  00:7D98                      ; device.asm
       2.  00:7D98                      ; implements a basic now: device
       3.  00:7D98                          
       4.  00:7D98                      device:
       5.  00:7D98  E5                          push hl
       6.  00:7D99  21 AA 7D                    ld hl,deviceFunctions
       7.  00:7D9C  0F                          rrca
       8.  00:7D9D  3C                          inc a
       9.  00:7D9E  07                          rlca
      10.  00:7D9F  85                          add a,l
      11.  00:7DA0  6F                          ld l,a
      12.  00:7DA1  30 01                       jr nc,.nocy
      13.  00:7DA3  24                          inc h  
      14.  00:7DA4  7E                  .nocy:  ld a,(hl)
      15.  00:7DA5  23                          inc hl
      16.  00:7DA6  66                          ld h,(hl)
      17.  00:7DA7  6F                          ld l,a
      18.  00:7DA8  E3                          ex (sp),hl
      19.  00:7DA9  C9                          ret
      20.  00:7DAA                      
      21.  00:7DAA                      deviceFunctions:
      22.  00:7DAA  C0 7D                       dw identifyDevice               ; 0xff
      23.  00:7DAC  E0 7D                       dw open                         ;  0
      24.  00:7DAE  18 7E                       dw close                        ;  2
      25.  00:7DB0  1E 7E                       dw randomIO                     ;  4
      26.  00:7DB2  22 7E                       dw write                        ;  6
      27.  00:7DB4  28 7E                       dw read                         ;  8
      28.  00:7DB6  7E 7E                       dw loc                          ; 10
      29.  00:7DB8  90 7E                       dw lof                          ; 12
      30.  00:7DBA  5C 7E                       dw eof                          ; 14
      31.  00:7DBC  90 7E                       dw fpos                         ; 16
      32.  00:7DBE  90 7E                       dw putback                      ; 18
      33.  00:7DC0                                
      34.  00:7DC0                      identifyDevice:
      35.  00:7DC0                              DEBUGMESSAGE "identifyDevice"
      35.  00:7DC0                    >         ifdef DEBUG
      35.  00:7DC0  52                >         ld d,d
      35.  00:7DC1  18 0E             >         jr .skip
      35.  00:7DC3                    >         db string
      35.  00:7DC3  69 64 65 6E 74 69 66 79 44 65 76 69 63 65 
      35.  00:7DD1                    > .skip:
      35.  00:7DD1                    >         endif
      36.  00:7DD1  21 D9 7D                    ld hl,deviceNameList
      37.  00:7DD4  CD 5B 73                    call findStatementName
      38.  00:7DD7  7E                          ld a,(hl)                       ; device number
      39.  00:7DD8  C9                          ret                             ; carry is set when invalid device name
      40.  00:7DD9                              
      41.  00:7DD9                      deviceNameList:
      42.  00:7DD9  4E 4F 57 00 00 00           db "NOW",0,0,0                  ; name, end marker, device number, dummy
      43.  00:7DDF                              ;db "STDIN",0,1,0
      44.  00:7DDF  00                          db 0
      45.  00:7DE0                      
      46.  00:7DE0                      ; Input     D   Global device code
      47.  00:7DE0                      ;           E   File mode    
      48.  00:7DE0                      ;           HL  address fcb
      49.  00:7DE0                      open:
      50.  00:7DE0                      ;        DEBUGMESSAGE "open"
      51.  00:7DE0                      ;        DEBUGDUMPMEMHL 9
      52.  00:7DE0  22 64 F8                    ld (PTRFIL),hl
      53.  00:7DE3  CD 87 73                    call sendRegisters
      54.  00:7DE6  36 88                       ld (hl),C_DEVICEOPEN
      55.  00:7DE8  EB                          ex de,hl
      56.  00:7DE9  01 0B 00                    ld bc,11
      57.  00:7DEC  21 66 F8                    ld hl,FILNAM
      58.  00:7DEF  ED B0                       ldir
      59.  00:7DF1                      
      60.  00:7DF1  CD 18 75                    call enableNowindPage0
      61.  00:7DF4  26 20                       ld h,HIGH usbrd
      62.  00:7DF6  CD 99 73                    call getHeader
      63.  00:7DF9  38 0C                       jr c,deviceIoError              ; time out?
      64.  00:7DFB  B7                          or a
      65.  00:7DFC  20 0B                       jr nz,openError
      66.  00:7DFE                      
      67.  00:7DFE  5E                          ld e,(hl)                       ; update fcb (including buffer)
      68.  00:7DFF  56                          ld d,(hl)
      69.  00:7E00  4E                          ld c,(hl)
      70.  00:7E01  46                          ld b,(hl)
      71.  00:7E02  ED B0                       ldir
      72.  00:7E04  C3 23 75                    jp restorePage0        
      73.  00:7E07                      
      74.  00:7E07                      deviceIoError:
      75.  00:7E07  3E 13                       ld a,19
      76.  00:7E09                      
      77.  00:7E09                      openError:
      78.  00:7E09  CD 23 75                    call restorePage0
      79.  00:7E0C  5F                          ld e,a
      80.  00:7E0D                      
      81.  00:7E0D                      basicError:
      82.  00:7E0D  DD 21 6F 40                 ld ix,$406f
      83.  00:7E11  FD 2A C0 FC                 ld iy,(EXPTBL-1)
      84.  00:7E15  C3 1C 00                    jp CALSLT
      85.  00:7E18                                      
      86.  00:7E18                      close:
      87.  00:7E18                      ;        DEBUGMESSAGE "close"
      88.  00:7E18  CD 87 73                    call sendRegisters
      89.  00:7E1B  36 89                       ld (hl),C_DEVICECLOSE
      90.  00:7E1D  C9                          ret
      91.  00:7E1E                              
      92.  00:7E1E                      randomIO:
      93.  00:7E1E                      ;        DEBUGMESSAGE "randomIO"
      94.  00:7E1E  1E 3D                       ld e,61                         ; bad file mode
      95.  00:7E20  18 EB                       jr basicError
      96.  00:7E22                      
      97.  00:7E22                      write:
      98.  00:7E22                      ;        DEBUGMESSAGE "write"
      99.  00:7E22  CD 87 73                    call sendRegisters
     100.  00:7E25  36 8B                       ld (hl),C_DEVICEWRITE
     101.  00:7E27  C9                          ret        
     102.  00:7E28                      
     103.  00:7E28                      read:
     104.  00:7E28                      ;        DEBUGMESSAGE "read"
     105.  00:7E28  11 06 00                    ld de,6
     106.  00:7E2B  19                          add hl,de
     107.  00:7E2C  E5                          push hl
     108.  00:7E2D  5E                          ld e,(hl)
     109.  00:7E2E  23                          inc hl
     110.  00:7E2F  23                          inc hl
     111.  00:7E30  23                          inc hl
     112.  00:7E31  19                          add hl,de
     113.  00:7E32  7E                          ld a,(hl)
     114.  00:7E33  E1                          pop hl
     115.  00:7E34  FE 1A                       cp $1a
     116.  00:7E36  37                          scf
     117.  00:7E37  C8                          ret z                           ; end of file
     118.  00:7E38  3F                          ccf
     119.  00:7E39  34                          inc (hl)                        ; increment position
     120.  00:7E3A  C0                          ret nz                          ; buffer empty?
     121.  00:7E3B                              
     122.  00:7E3B  F5                          push af
     123.  00:7E3C  2B                          dec hl
     124.  00:7E3D  34                          inc (hl)                        ; increment position (high)        
     125.  00:7E3E  11 FB FF                    ld de,-5
     126.  00:7E41  19                          add hl,de
     127.  00:7E42  CD 87 73                    call sendRegisters
     128.  00:7E45  36 8C                       ld (hl),C_DEVICEREAD
     129.  00:7E47  CD 18 75                    call enableNowindPage0
     130.  00:7E4A  26 20                       ld h,HIGH usbrd
     131.  00:7E4C  CD 99 73                    call getHeader
     132.  00:7E4F  38 B6                       jr c,deviceIoError
     133.  00:7E51                      
     134.  00:7E51  5E                          ld e,(hl)
     135.  00:7E52  56                          ld d,(hl)
     136.  00:7E53  4E                          ld c,(hl)
     137.  00:7E54  46                          ld b,(hl)
     138.  00:7E55  ED B0                       ldir                            ; update fcb buffer
     139.  00:7E57  CD 23 75                    call restorePage0
     140.  00:7E5A  F1                          pop af                          ; return last character
     141.  00:7E5B  C9                          ret
     142.  00:7E5C                      
     143.  00:7E5C                      eof:
     144.  00:7E5C                      ;        DEBUGMESSAGE "eof"
     145.  00:7E5C  7E                          ld a,(hl)
     146.  00:7E5D  FE 01                       cp 1                            ; input mode?        
     147.  00:7E5F  1E 3D                       ld e,61                         ; bad file mode
     148.  00:7E61  C2 0D 7E                    jp nz,basicError
     149.  00:7E64                                      
     150.  00:7E64  11 06 00                    ld de,6
     151.  00:7E67  19                          add hl,de
     152.  00:7E68  5E                          ld e,(hl)
     153.  00:7E69  23                          inc hl
     154.  00:7E6A  23                          inc hl
     155.  00:7E6B  23                          inc hl
     156.  00:7E6C  19                          add hl,de
     157.  00:7E6D  7E                          ld a,(hl)
     158.  00:7E6E  ED 62                       sbc hl,hl
     159.  00:7E70  FE 1A                       cp $1a        
     160.  00:7E72  20 01                       jr nz,.skip
     161.  00:7E74  2B                          dec hl
     162.  00:7E75  22 F8 F7            .skip:  ld (DAC+2),hl
     163.  00:7E78  3E 02                       ld a,2
     164.  00:7E7A  32 63 F6                    ld (VALTYP),a
     165.  00:7E7D  C9                          ret
     166.  00:7E7E                      
     167.  00:7E7E                      loc:
     168.  00:7E7E  E5                          push hl
     169.  00:7E7F  FD E1                       pop iy
     170.  00:7E81  FD 6E 06                    ld l,(iy+6)
     171.  00:7E84  FD 66 05                    ld h,(iy+5)
     172.  00:7E87                      ;        DEBUGASSERT
     173.  00:7E87  22 F8 F7                    ld (DAC+2),hl
     174.  00:7E8A  3E 02                       ld a,2
     175.  00:7E8C  32 63 F6                    ld (VALTYP),a
     176.  00:7E8F  C9                          ret
     177.  00:7E90                              
     178.  00:7E90                      putback:
     179.  00:7E90                      ;        DEBUGMESSAGE "putback"
     180.  00:7E90                      ;        push hl
     181.  00:7E90                      ;        pop iy
     182.  00:7E90                      ;        ld (iy+3),c
     183.  00:7E90                      ;        DEBUGASSERT
     184.  00:7E90                      ;        ret
     185.  00:7E90                      
     186.  00:7E90                      lof:
     187.  00:7E90                      fpos:
     188.  00:7E90                              DEBUGMESSAGE "no support!"
     188.  00:7E90                    >         ifdef DEBUG
     188.  00:7E90  52                >         ld d,d
     188.  00:7E91  18 0B             >         jr .skip
     188.  00:7E93                    >         db string
     188.  00:7E93  6E 6F 20 73 75 70 70 6F 72 74 21 
     188.  00:7E9E                    > .skip:
     188.  00:7E9E                    >         endif
     189.  00:7E9E                      
     190.  00:7E9E                      illegalFunctionCall:
     191.  00:7E9E  1E 05                       ld e,5
     192.  00:7EA0  C3 0D 7E                    jp basicError
     193.  00:7EA3                      
     194.  00:7EA3                      ;FCB for DISK BASIC
     195.  00:7EA3                      ; +0 FL.MOD     file mode
     196.  00:7EA3                      ; +1 FL.FCA     Pointer to FCB for BDOS (low)
     197.  00:7EA3                      ; +2 FL.LCA     Pointer to FCB for BDOS (high)
     198.  00:7EA3                      ; +3 FL.LSA     Back up character
     199.  00:7EA3                      ; +4 FL.DSK     device number
     200.  00:7EA3                      ; +5 FL.SLB
     201.  00:7EA3                      ; +6 FL.BPS     Position in FL.BUF
     202.  00:7EA3                      ; +7 FL.FLG     Holds various information
     203.  00:7EA3                      ; +8 FL.OPS     Pseudo head position
     204.  00:7EA3                      ; +9 FL.BUF     256-byte file buffer
     205.  00:7EA3                      
     206.  00:7EA3                      ; device codes
     207.  00:7EA3                      ;          SS0           SS1           SS2           SS3
     208.  00:7EA3                      ;    ---------------------------------------------------------
     209.  00:7EA3                      ;    | 00 04 08 0C | 10 14 18 1C | 20 24 28 2C | 30 34 38 3C | PS0
     210.  00:7EA3                      ;    ---------------------------------------------------------
     211.  00:7EA3                      ;    | 40 44 48 4C | 50 54 58 5C | 60 64 68 6C | 70 74 78 7C | PS1
     212.  00:7EA3                      ;    ---------------------------------------------------------
     213.  00:7EA3                      ;    | 80 84 88 8C | 90 94 98 9C | A0 A4 A8 AC | B0 B4 B8 BC | PS2
     214.  00:7EA3                      ;    ---------------------------------------------------------
     215.  00:7EA3                      ;    | C0 C4 C8 CC | D0 D4 D8 DC | E0 E4 E8 EC | F0 F4 F8 FC | PS3
     216.  00:7EA3                      ;    ---------------------------------------------------------
     217.  00:7EA3                      
     218.  00:7EA3                      ; fileModes
     219.  00:7EA3                      ; FOR INPUT (01H)
     220.  00:7EA3                      ; FOR OUTPUT (02H)
     221.  00:7EA3                      ; FOR APPEND (08H)
     222.  00:7EA3                      ; random mode (04H)
     223.  00:7EA3                      
     224.  00:7EA3                      ; maximum number of files open: MAXFILES=15
     225.  00:7EA3                              
     226.  00:7EA3                      ; File Control Block
     227.  00:7EA3                      ;       0     1     2     3     4     5     6     7     8
     228.  00:7EA3                      ;    -------------------------------------------------------
     229.  00:7EA3                      ;    | Mod | 00H | 00H | 00H | DEV | 00H | POS | 00H | PPS |
     230.  00:7EA3                      ;    -------------------------------------------------------
     231.  00:7EA3                      ;                  err? bckup       posHi 
     232.  00:7EA3                      ; followed by a 256 byte buffer
      98   00:7EA3                      
      99   00:7EA3  FF (337)                    ds $8000-(endCopyFromBank-copyFromBank)-$, $ff
     100   00:7FF4                      
     101   00:7FF4                      ; bank switching and data transfer
     102   00:7FF4                      copyFromBank:
     103   00:7FF4  32 01 60                    ld (mapper),a
     104   00:7FF7  ED B0                       ldir
     105   00:7FF9                      enableBank0:
     106   00:7FF9  AF                          xor a
     107   00:7FFA                      switchBank:
     108   00:7FFA  F5                          push af
     109   00:7FFB  32 01 60                    ld (mapper),a
     110   00:7FFE  F1                          pop af
     111   00:7FFF  C9                          ret
     112   00:8000                      endCopyFromBank:
     113   00:8000                      
     114   00:8000  (01)                        page 1
     115   01:4000  (C000)                      incbin "..\roms\MSXDOS22.ROM", $4000, 3 * $4000
     116   01!0000                              PATCH $4093, mapper
     116   01!0000                    >         code ! address
     116   01:4093  01 60             >         dw word
     117   01:4095                              PATCH $8093, mapper
     117   01:4095                    >         code ! address
     117   01:8093  01 60             >         dw word
     118   01:8095                              PATCH $C093, mapper
     118   01:8095                    >         code ! address
     118   01:C093  01 60             >         dw word
     119   01:C095                      
     120   01:C095                              ; areas not used in MSXDOS22.ROM
     121   01:C095                              ; bank 1: 0x5CA0 - 0x7FFF (9056 bytes)
     122   01:C095                              ; bank 2: 0x7F30 - 0x7FFF (208 bytes)
     123   01:C095                              ; bank 3: 0x7E70 - 0x7FFF (400 bytes)
     124   01:C095                      
     125   01:C095                      ; insert MSXDOS1
     126   01:C095  (02)                	page 2
     127   02:4000                      	module	MSXDOS1_PART
     128   02:4000                      
     129   02:4000                      	define 	MSXDOSVER 1
     130   02:4000                      ;	define	ROMINIT $576f
     131   02:4000                      	define	PRINTTEXT $5f86
     132   02:4000                      
     133   02:4000  (3405)                      incbin "..\roms\DISK.ROM", 0, $7405-$4000
     134   02:7405                                      
     135   02:7405                              PATCH $4006, device
     135   02:7405                    >         code ! address
     135   02:4006  8D 7E             >         dw word
     136   02:4008                      
     137   02:4008                              code ! $4010
     138   02:4010  C3 8F 77                    jp DSKIO
     139   02:4013  C3 92 78                    jp DSKCHG
     140   02:4016  C3 C9 78                    jp GETDPB
     141   02:4019  C3 35 79                    jp CHOICE
     142   02:401C  C3 3A 79                    jp DSKFMT
     143   02:401F  00 00 00                    db 0,0,0                        ; no DRVOFF
     144   02:4022                              
     145   02:4022                              PATCH $5770, INIHRD
     145   02:4022                    >         code ! address
     145   02:5770  AD 76             >         dw word
     146   02:5772                              PATCH $57aa, $f380 + MYSIZE
     146   02:5772                    >         code ! address
     146   02:57AA  88 F3             >         dw word
     147   02:57AC                              PATCH $581e, MYSIZE
     147   02:57AC                    >         code ! address
     147   02:581E  08 00             >         dw word
     148   02:5820                              PATCH $582f, SECLEN
     148   02:5820                    >         code ! address
     148   02:582F  00 02             >         dw word
     149   02:5831                              PATCH $5851, DRIVES
     149   02:5831                    >         code ! address
     149   02:5851  D0 76             >         dw word
     150   02:5853                              PATCH $5884, DEFDPB - 1
     150   02:5853                    >         code ! address
     150   02:5884  7F 7C             >         dw word
     151   02:5886                              PATCH $5890, INIENV
     151   02:5886                    >         code ! address
     151   02:5890  39 77             >         dw word
     152   02:5892                              PATCH $5ae8, DEFDPB             ; different address in some roms
     152   02:5892                    >         code ! address
     152   02:5AE8  80 7C             >         dw word
     153   02:5AEA                              PATCH $65af, OEMSTA
     153   02:5AEA                    >         code ! address
     153   02:65AF  45 7A             >         dw word
     154   02:65B1                      	PATCH $5809, initDiskBasic      ; HRUNC
     154   02:65B1                    >         code ! address
     154   02:5809  38 74             >         dw word
     155   02:580B                              
     156   02:580B                              ;PATCH $5b9a, getHostDate        ; get date from host when no clockchip found (different 5b95)
     157   02:580B                      
     158   02:580B                      		ifdef BDOS_NOWIND
     159   02:580B                    ~ 	
     160   02:580B                    ~ 		; just patching the BDOS hook will not work; not everybody uses the hook
     161   02:580B                    ~         ;PATCH $5d20, BDOSNW						  ; overwrite the standard BDOS hook "DW $56D3" with BDOSNW
     162   02:580B                    ~         	
     163   02:580B                    ~         ; even patching the BDOS jump table will not work; internal calls (even in command.com) bypass it
     164   02:580B                    ~         ; jump table patches
     165   02:580B                    ~         ;PATCH $572b, BDOS_0FH_J				  ; overwrite specific function 0Fh in jump table
     166   02:580B                    ~         ;PATCH $572f, BDOS_11H_J				  ; overwrite specific function 11h in jump table
     167   02:580B                    ~         ;PATCH $5731, BDOS_12H_J				  ; overwrite specific function 12h in jump table
     168   02:580B                    ~         	
     169   02:580B                    ~         ; these patches are at the start of the routine themselves, the addresses are more or less "standardized" 
     170   02:580B                    ~         ; over several brands of diskroms	
     171   02:580B                    ~         ; in-routine patches
     172   02:580B                    ~         PATCH $4463, BDOS_0FH					  ; overwrite function 0Fh itself!
     173   02:580B                    ~         PATCH $4fb9, BDOS_11H 				  ; overwrite function 11h itself!
     174   02:580B                    ~         PATCH $5007, BDOS_12H 				  ; overwrite function 12h itself!
     175   02:580B                    ~         	
     176   02:580B                    ~        	endif
     177   02:580B                      				
     178   02:580B                              code ! $595d
     179   02:595D  21 D2 74                    ld hl,newAUX                    ; redirect AUX to host  
     180   02:5960  11 27 F3                    ld de,$f327
     181   02:5963  01 0A 00                    ld bc,10
     182   02:5966  ED B0                       ldir
     183   02:5968  00                          nop
     184   02:5969  00                          nop
     185   02:596A  00                          nop
     186   02:596B  00                          nop                             ; do not remove!
     187   02:596C                              
     188   02:596C                              code @ $7405
     189   02:7405                      
     190   02:7405                              include "common.asm"
       1.  02:7405                      ; Nowind specific
       2.  02:7405                      
       3.  02:7405                      nowindInit:
       4.  02:7405                              ;DEBUGMESSAGE "nowindInit"
       5.  02:7405  3A F8 FA                    ld a,($faf8)										; moet volgens bifi ld a,($2d) zijn, $faf8 is op msx1 deel van de rs232 area?
       6.  02:7408  B7                          or a 
       7.  02:7409  F5                          push af
       8.  02:740A  CC 5F 00                    call z,CHGMOD                   ; SCREEN 0 for MSX1
       9.  02:740D  F1                          pop af
      10.  02:740E  DD 21 85 01                 ld ix,SDFSCR                    ; restore screen mode from clockchip
      11.  02:7412  C4 5F 01                    call nz,EXTROM
      12.  02:7415                                      
      13.  02:7415  CD 86 5F                    call PRINTTEXT
      14.  02:7418                              ifndef DEBUG
      15.  02:7418                    ~         db "Nowind USB Diskrom!",0
      16.  02:7418                    ~         else
      17.  02:7418                              db "Nowind USB Diskrom! [debug]",0
      17.  02:7418  4E 6F 77 69 6E 64 20 55 53 42 20 44 69 73 6B 72 
      17.  02:7428  6F 6D 21 20 5B 64 65 62 75 67 5D 00 
      18.  02:7434                              endif
      19.  02:7434                      
      20.  02:7434                              ; call insertBootCode
      21.  02:7434  CD 62 7D                    call flashWriter
      22.  02:7437  C9                          ret
      23.  02:7438                      
      24.  02:7438                      initDiskBasic:
      25.  02:7438                              DEBUGMESSAGE "initDiskBasic"
      25.  02:7438                    >         ifdef DEBUG
      25.  02:7438  52                >         ld d,d
      25.  02:7439  18 0D             >         jr .skip
      25.  02:743B                    >         db string
      25.  02:743B  69 6E 69 74 44 69 73 6B 42 61 73 69 63 
      25.  02:7448                    > .skip:
      25.  02:7448                    >         endif
      26.  02:7448  21 99 FD                    ld hl,DEVICE
      27.  02:744B  CB BE                       res 7,(hl)
      28.  02:744D                              
      29.  02:744D                              if MSXDOSVER = 1 
      30.  02:744D  C3 97 58                    jp $5897
      31.  02:7450                              else
      32.  02:7450                    ~         jp $495b
      33.  02:7450                    ~         endif
      34.  02:7450                      
      35.  02:7450                      ; search call statement or device name
      36.  02:7450                      findStatementName:
      37.  02:7450                              DEBUGMESSAGE "findStatementName"
      37.  02:7450                    >         ifdef DEBUG
      37.  02:7450  52                >         ld d,d
      37.  02:7451  18 11             >         jr .skip
      37.  02:7453                    >         db string
      37.  02:7453  66 69 6E 64 53 74 61 74 65 6D 65 6E 74 4E 61 6D 
      37.  02:7463  65 
      37.  02:7464                    > .skip:
      37.  02:7464                    >         endif
      38.  02:7464  11 89 FD                    ld de,PROCNM
      39.  02:7467  1A                  .loop:  ld a,(de)
      40.  02:7468  BE                          cp (hl)
      41.  02:7469  20 06                       jr nz,.nextStatement
      42.  02:746B  23                          inc hl
      43.  02:746C  B7                          or a
      44.  02:746D  C8                          ret z                           ; name found
      45.  02:746E  13                          inc de
      46.  02:746F  18 F6                       jr .loop        
      47.  02:7471                      .nextStatement:
      48.  02:7471  AF                          xor a
      49.  02:7472  4F                          ld c,a
      50.  02:7473  ED B1                       cpir
      51.  02:7475  23                          inc hl
      52.  02:7476  23                          inc hl
      53.  02:7477  B6                          or (hl)
      54.  02:7478  20 D6                       jr nz,findStatementName        
      55.  02:747A  37                          scf                             ; not found
      56.  02:747B  C9                          ret
      57.  02:747C                      
      58.  02:747C                      sendRegisters:
      59.  02:747C  F5                          push af
      60.  02:747D  7C                          ld a,h
      61.  02:747E  26 40                       ld h,HIGH usbwr
      62.  02:7480  36 AF                       ld (hl),$af                     ; header
      63.  02:7482  36 05                       ld (hl),$05
      64.  02:7484  71                          ld (hl),c
      65.  02:7485  70                          ld (hl),b
      66.  02:7486  73                          ld (hl),e
      67.  02:7487  72                          ld (hl),d
      68.  02:7488  75                          ld (hl),l
      69.  02:7489  77                          ld (hl),a                       ; register h
      70.  02:748A  D1                          pop de
      71.  02:748B  73                          ld (hl),e                       ; register f
      72.  02:748C  72                          ld (hl),d                       ; register a
      73.  02:748D  C9                          ret
      74.  02:748E                              
      75.  02:748E                      getHeader:
      76.  02:748E  06 FF                       ld b,HIGH 65535                 ; 42000 * 60 states ~ 0,7 sec (time out)
      77.  02:7490  7E                  .loop:  ld a,(hl)
      78.  02:7491  FE AF               .chkaf: cp $af
      79.  02:7493  28 20                       jr z,.chk05
      80.  02:7495  0B                          dec bc
      81.  02:7496  78                          ld a,b
      82.  02:7497  B1                          or c
      83.  02:7498  20 F6                       jr nz,.loop
      84.  02:749A                              DEBUGMESSAGE "getHeader Timed out!"
      84.  02:749A                    >         ifdef DEBUG
      84.  02:749A  52                >         ld d,d
      84.  02:749B  18 14             >         jr .skip
      84.  02:749D                    >         db string
      84.  02:749D  67 65 74 48 65 61 64 65 72 20 54 69 6D 65 64 20 
      84.  02:74AD  6F 75 74 21 
      84.  02:74B1                    > .skip:
      84.  02:74B1                    >         endif
      85.  02:74B1  3E 02                       ld a,2                          ; not ready
      86.  02:74B3  37                          scf
      87.  02:74B4  C9                          ret
      88.  02:74B5                      
      89.  02:74B5  7E                  .chk05: ld a,(hl)
      90.  02:74B6  FE 05                       cp $05
      91.  02:74B8  20 D7                       jr nz,.chkaf
      92.  02:74BA  7E                          ld a,(hl)
      93.  02:74BB  C9                          ret
      94.  02:74BC                      
      95.  02:74BC                      sendMessage:
      96.  02:74BC                              ;DEBUGMESSAGE "sendMsg"
      97.  02:74BC  E3                          ex (sp),hl
      98.  02:74BD  F5                          push af
      99.  02:74BE  D5                          push de
     100.  02:74BF  E5                          push hl        
     101.  02:74C0  CD 7C 74                    call sendRegisters
     102.  02:74C3  36 90                       ld (hl),C_MESSAGE
     103.  02:74C5  E1                          pop hl
     104.  02:74C6  7E                  .loop:  ld a,(hl)
     105.  02:74C7  23                          inc hl
     106.  02:74C8  32 00 40                    ld (usbwr),a
     107.  02:74CB  B7                          or a
     108.  02:74CC  20 F8                       jr nz,.loop
     109.  02:74CE  D1                          pop de
     110.  02:74CF  F1                          pop af
     111.  02:74D0  E3                          ex (sp),hl
     112.  02:74D1  C9                          ret
     113.  02:74D2                              
     114.  02:74D2                      ; AUX device
     115.  02:74D2                              
     116.  02:74D2  C3 DC 74            newAUX: jp AUXin
     117.  02:74D5  00                          nop
     118.  02:74D6  00                          nop
     119.  02:74D7  C3 21 75                    jp AUXout
     120.  02:74DA  00                          nop
     121.  02:74DB  00                          nop
     122.  02:74DC                      
     123.  02:74DC                      AUXin:  DEBUGMESSAGE "AUX in"
     123.  02:74DC                    >         ifdef DEBUG
     123.  02:74DC  52                >         ld d,d
     123.  02:74DD  18 06             >         jr .skip
     123.  02:74DF  41 55 58 20 69 6E >         db string
     123.  02:74E5                    > .skip:
     123.  02:74E5                    >         endif
     124.  02:74E5  E5                          push hl
     125.  02:74E6  D5                          push de
     126.  02:74E7  C5                          push bc
     127.  02:74E8  CD 7C 74                    call sendRegisters
     128.  02:74EB  36 8E                       ld (hl),C_AUXIN
     129.  02:74ED  CD 0D 76                    call enableNowindPage0
     130.  02:74F0  26 20                       ld h,HIGH usbrd
     131.  02:74F2  CD 8E 74                    call getHeader
     132.  02:74F5  D2 10 75                    jp nc,.getCharacter
     133.  02:74F8                              
     134.  02:74F8                              DEBUGMESSAGE "not connected"
     134.  02:74F8                    >         ifdef DEBUG
     134.  02:74F8  52                >         ld d,d
     134.  02:74F9  18 0D             >         jr .skip
     134.  02:74FB                    >         db string
     134.  02:74FB  6E 6F 74 20 63 6F 6E 6E 65 63 74 65 64 
     134.  02:7508                    > .skip:
     134.  02:7508                    >         endif
     135.  02:7508  3E 1A                       ld a,$1a                        ; eof
     136.  02:750A  C1                  .exit:  pop bc
     137.  02:750B  D1                          pop de
     138.  02:750C  E1                          pop hl
     139.  02:750D  C3 18 76                    jp restorePage0        
     140.  02:7510                                    
     141.  02:7510                      .getCharacter:
     142.  02:7510                              DEBUGMESSAGE "getChar"
     142.  02:7510                    >         ifdef DEBUG
     142.  02:7510  52                >         ld d,d
     142.  02:7511  18 07             >         jr .skip
     142.  02:7513                    >         db string
     142.  02:7513  67 65 74 43 68 61 72 
     142.  02:751A                    > .skip:
     142.  02:751A                    >         endif
     143.  02:751A  CD 8E 74                    call getHeader
     144.  02:751D  38 F1                       jr c,.getCharacter
     145.  02:751F  18 E9                       jr .exit
     146.  02:7521                      
     147.  02:7521                      
     148.  02:7521                      AUXout: DEBUGMESSAGE "AUX out"
     148.  02:7521                    >         ifdef DEBUG
     148.  02:7521  52                >         ld d,d
     148.  02:7522  18 07             >         jr .skip
     148.  02:7524                    >         db string
     148.  02:7524  41 55 58 20 6F 75 74 
     148.  02:752B                    > .skip:
     148.  02:752B                    >         endif
     149.  02:752B                              DEBUGDUMPREGISTERS
     149.  02:752B                    >         ifdef DEBUG
     149.  02:752B  ED 07             >         db $ed,7
     149.  02:752D                    >         endif
     149.  02:752D                    >         
     149.  02:752D                    >         ifdef USBDEBUG
     149.  02:752D                    ~         assert ($ < $8000)
     149.  02:752D                    ~         call sendCpuInfo
     149.  02:752D                    ~         endif
     150.  02:752D  E5                          push hl
     151.  02:752E  D5                          push de
     152.  02:752F                      ;        push bc
     153.  02:752F                      ;        ld a,(RAMAD1) ; TODO: WTF???
     154.  02:752F                      ;        call RDSLT
     155.  02:752F  F5                          push af        
     156.  02:7530  CD 7C 74                    call sendRegisters
     157.  02:7533  36 8F                       ld (hl),C_AUXOUT
     158.  02:7535  F1                          pop af
     159.  02:7536                      ;        pop bc
     160.  02:7536  D1                          pop de
     161.  02:7537  E1                          pop hl
     162.  02:7538  C9                          ret
     163.  02:7539                      
     164.  02:7539                      ;insertBootCode:
     165.  02:7539                      ;        DEBUGMESSAGE "BOOTCODE"
     166.  02:7539                      ;        call sendRegisters
     167.  02:7539                      ;        ld (hl),C_BOOTCODE
     168.  02:7539                      ;        call enableNowindPage0
     169.  02:7539                      ;        call getHeader
     170.  02:7539                      ;        jp c,restorePage0
     171.  02:7539                              
     172.  02:7539                      ;        DEBUGMESSAGE "BOOTCODE"
     173.  02:7539                      ;        jp restorePage0
     174.  02:7539                      
     175.  02:7539                      ; send 32 bytes starting from address specified by DE to the usb
     176.  02:7539                      sdendFCB:
     177.  02:7539  D5                          push de
     178.  02:753A  C5                          push bc
     179.  02:753B                              
     180.  02:753B  06 20                       ld b,32
     181.  02:753D  1A                  .loop:  ld a,(de)
     182.  02:753E  32 00 40                    ld (usbwr),a
     183.  02:7541  13                          inc de
     184.  02:7542  10 F9                       djnz .loop
     185.  02:7544  C1                          pop bc
     186.  02:7545  D1                          pop de
     187.  02:7546  C9                          ret
     188.  02:7547                      
     189.  02:7547                      ; receive 32 bytes and write to the address specified by DE 
     190.  02:7547                      receiveFCB:
     191.  02:7547  D5                          push de
     192.  02:7548  C5                          push bc
     193.  02:7549                              
     194.  02:7549  06 20                       ld b,32
     195.  02:754B  3A 00 20            .loop:  ld a,(usbrd)
     196.  02:754E  32 00 40            	ld (usbwr),a			; loop back
     197.  02:7551  12                          ld (de),a
     198.  02:7552  13                          inc de
     199.  02:7553  10 F6                       djnz .loop
     200.  02:7555  C1                          pop bc
     201.  02:7556  D1                          pop de
     202.  02:7557  C9                          ret
     203.  02:7558                              
     191   02:7558                              include "extendedBios.asm"
       1.  02:7558                      
       2.  02:7558                      installExtendedBios:
       3.  02:7558                      
       4.  02:7558                              ; Called from INIENV, so EXTBIO hook is already initialized
       5.  02:7558                      
       6.  02:7558                              DEBUGMESSAGE "extbio"
       6.  02:7558                    >         ifdef DEBUG
       6.  02:7558  52                >         ld d,d
       6.  02:7559  18 06             >         jr .skip
       6.  02:755B  65 78 74 62 69 6F >         db string
       6.  02:7561                    > .skip:
       6.  02:7561                    >         endif
       7.  02:7561  CD 98 76                    call getEntrySLTWRK             ; save previous EXTBIO hook
       8.  02:7564  23                          inc hl
       9.  02:7565  EB                          ex de,hl        
      10.  02:7566  21 CA FF                    ld hl,EXTBIO
      11.  02:7569  01 05 00                    ld bc,5
      12.  02:756C  ED B0                       ldir
      13.  02:756E                              
      14.  02:756E  E5                          push hl                         ; determine device number
      15.  02:756F  AF                          xor a
      16.  02:7570  11 01 4E                    ld de,$4e01
      17.  02:7573  CD CA FF                    call EXTBIO
      18.  02:7576  E1                          pop hl
      19.  02:7577  77                          ld (hl),a
      20.  02:7578                                      
      21.  02:7578  CD 2D 40                    call GETSLT                     ; install new EXTBIO hook
      22.  02:757B  2E F7                       ld l,$f7
      23.  02:757D  67                          ld h,a
      24.  02:757E  22 CA FF                    ld (EXTBIO),hl
      25.  02:7581  21 8D 75                    ld hl,extendedBios
      26.  02:7584  22 CC FF                    ld (EXTBIO+2),hl
      27.  02:7587  3E C9                       ld a,$c9
      28.  02:7589  32 CE FF                    ld (EXTBIO+4),a    
      29.  02:758C  C9                          ret
      30.  02:758D                      
      31.  02:758D                      extendedBios:
      32.  02:758D                              ; broadcast (0x00) not implemented
      33.  02:758D                              ; system exclusive (0xff) not implemented
      34.  02:758D                      
      35.  02:758D  FB                          ei
      36.  02:758E  F5                          push af
      37.  02:758F  7A                          ld a,d
      38.  02:7590  FE 4E                       cp $4e
      39.  02:7592  28 0E                       jr z,determineFunction
      40.  02:7594                      .exit:
      41.  02:7594  E5                          push hl
      42.  02:7595  C5                          push bc
      43.  02:7596  CD 98 76                    call getEntrySLTWRK
      44.  02:7599  2C                          inc l                           ; previous EXTBIO hook 
      45.  02:759A  E5                          push hl
      46.  02:759B  DD E1                       pop ix
      47.  02:759D  C1                          pop bc        
      48.  02:759E  E1                          pop hl
      49.  02:759F  F1                          pop af
      50.  02:75A0  DD E9                       jp (ix)                         ; process other EXTBIO handles
      51.  02:75A2                      
      52.  02:75A2                      determineFunction:
      53.  02:75A2  E5                          push hl
      54.  02:75A3  21 AE D9                    ld hl,functionTable - 2 * $4e00
      55.  02:75A6  19                          add hl,de
      56.  02:75A7  19                          add hl,de
      57.  02:75A8  7E                          ld a,(hl)
      58.  02:75A9  23                          inc hl
      59.  02:75AA  66                          ld h,(hl)
      60.  02:75AB  6F                          ld l,a
      61.  02:75AC  E3                          ex (sp),hl
      62.  02:75AD  C9                          ret
      63.  02:75AE                      
      64.  02:75AE                      functionTable:
      65.  02:75AE  B4 75                       dw getNowindSlot
      66.  02:75B0  D0 75                       dw numberOfDevices
      67.  02:75B2  E7 75                       dw debugMessage
      68.  02:75B4                      
      69.  02:75B4                      getNowindSlot:               
      70.  02:75B4                              DEBUGMESSAGE "getNowindSlot"
      70.  02:75B4                    >         ifdef DEBUG
      70.  02:75B4  52                >         ld d,d
      70.  02:75B5  18 0D             >         jr .skip
      70.  02:75B7                    >         db string
      70.  02:75B7  67 65 74 4E 6F 77 69 6E 64 53 6C 6F 74 
      70.  02:75C4                    > .skip:
      70.  02:75C4                    >         endif
      71.  02:75C4  F1                          pop af
      72.  02:75C5  3D                          dec a
      73.  02:75C6  F5                          push af
      74.  02:75C7  F2 94 75                    jp p,extendedBios.exit         ; not this device
      75.  02:75CA                              
      76.  02:75CA  F1                          pop af
      77.  02:75CB  CD 68 76                    call getSlotPage1
      78.  02:75CE  37                          scf
      79.  02:75CF  C9                          ret
      80.  02:75D0                              
      81.  02:75D0                      numberOfDevices:
      82.  02:75D0                              DEBUGMESSAGE "numberOfDevices"
      82.  02:75D0                    >         ifdef DEBUG
      82.  02:75D0  52                >         ld d,d
      82.  02:75D1  18 0F             >         jr .skip
      82.  02:75D3                    >         db string
      82.  02:75D3  6E 75 6D 62 65 72 4F 66 44 65 76 69 63 65 73 
      82.  02:75E2                    > .skip:
      82.  02:75E2                    >         endif
      83.  02:75E2  F1                          pop af
      84.  02:75E3  3C                          inc a
      85.  02:75E4  F5                          push af
      86.  02:75E5  18 AD                       jr extendedBios.exit
      87.  02:75E7                              
      88.  02:75E7                      debugMessage:
      89.  02:75E7                              DEBUGMESSAGE "debugMessage"
      89.  02:75E7                    >         ifdef DEBUG
      89.  02:75E7  52                >         ld d,d
      89.  02:75E8  18 0C             >         jr .skip
      89.  02:75EA                    >         db string
      89.  02:75EA  64 65 62 75 67 4D 65 73 73 61 67 65 
      89.  02:75F6                    > .skip:
      89.  02:75F6                    >         endif
      90.  02:75F6  F1                          pop af
      91.  02:75F7  3D                          dec a
      92.  02:75F8  F5                          push af
      93.  02:75F9  F2 94 75                    jp p,extendedBios.exit
      94.  02:75FC                      
      95.  02:75FC  E5                          push hl
      96.  02:75FD  CD 7C 74                    call sendRegisters
      97.  02:7600  36 90                       ld (hl),C_MESSAGE
      98.  02:7602  E1                          pop hl
      99.  02:7603  7E                  .loop:  ld a,(hl)
     100.  02:7604  23                          inc hl
     101.  02:7605  32 00 40                    ld (usbwr),a
     102.  02:7608  B7                          or a
     103.  02:7609  20 F8                       jr nz,.loop
     104.  02:760B                              
     105.  02:760B  F1                          pop af        
     106.  02:760C  C9                          ret
     192   02:760D                              include "slotRoutines.asm"
       1.  02:760D                      ; These routines are used for slot selection
       2.  02:760D                      
       3.  02:760D                      enableNowindPage0:
       4.  02:760D  CD 5D 76                    call getSlotPage0
       5.  02:7610  DD 67                       ld ixh,a
       6.  02:7612  CD 68 76                    call getSlotPage1
       7.  02:7615  C3 21 76                    jp enableSlotPage0       
       8.  02:7618                      
       9.  02:7618                      restorePage0:
      10.  02:7618  F5                          push af
      11.  02:7619  DD 7C                       ld a,ixh
      12.  02:761B  CD 21 76                    call enableSlotPage0
      13.  02:761E  FB                          ei
      14.  02:761F  F1                          pop af
      15.  02:7620  C9                          ret
      16.  02:7621                      
      17.  02:7621                      enableSlotPage0:
      18.  02:7621                              ; HL and D remain unchanged
      19.  02:7621                              ; enableSlotPage0 can be called in page 1 and 2 (no absolute jumps)
      20.  02:7621                      
      21.  02:7621                              ;DEBUGMESSAGE "enasltP0"
      22.  02:7621  5F                          ld e,a                          ; store slotcode for further use
      23.  02:7622  E6 03                       and 3
      24.  02:7624  4F                          ld c,a                          ; new primary slot in c  
      25.  02:7625  CB 7B                       bit 7,e
      26.  02:7627  F3                          di
      27.  02:7628  20 08                       jr nz,.expanded
      28.  02:762A                      
      29.  02:762A  DB A8                       in a,($a8)
      30.  02:762C  E6 FC                       and %11111100
      31.  02:762E  B1                          or c                            ; enable new primary slot in page 0
      32.  02:762F  D3 A8                       out ($a8),a
      33.  02:7631  C9                          ret
      34.  02:7632                              
      35.  02:7632                      .expanded:
      36.  02:7632  7B                          ld a,e                          ; store secondary slot in e
      37.  02:7633  E6 0C                       and %00001100     
      38.  02:7635  0F                          rrca
      39.  02:7636  0F                          rrca
      40.  02:7637  5F                          ld e,a
      41.  02:7638                      
      42.  02:7638  DB A8                       in a,($a8)
      43.  02:763A  E6 FC                       and %11111100
      44.  02:763C  B1                          or c                            ; new primary slot in page 0
      45.  02:763D  47                          ld b,a                          ; used to restore
      46.  02:763E  17                          rla
      47.  02:763F  A7                          and a                           ; (reset carry)
      48.  02:7640  17                          rla
      49.  02:7641  B1                          or c                            ; new primary slot in page 3
      50.  02:7642  0F                          rrca
      51.  02:7643  0F                          rrca
      52.  02:7644  D3 A8                       out ($a8),a
      53.  02:7646                      
      54.  02:7646  3A FF FF                    ld a,(-1)                       ; write secondary slot register
      55.  02:7649  2F                          cpl
      56.  02:764A  E6 FC                       and %11111100
      57.  02:764C  B3                          or e                            ; apply new secondary slot for page 0
      58.  02:764D  32 FF FF                    ld (-1),a
      59.  02:7650  5F                          ld e,a                          ; store secondary slot register (for SLTTBL)
      60.  02:7651                      
      61.  02:7651  78                          ld a,b                          ; restore primary slot page 3
      62.  02:7652  D3 A8                       out ($a8),a
      63.  02:7654                      
      64.  02:7654  3E C5                       ld a,LOW SLTTBL                 ; update SLTTBL
      65.  02:7656  81                          add c                           ; add primary slot
      66.  02:7657  4F                          ld c,a
      67.  02:7658  06 FC                       ld b,HIGH SLTTBL
      68.  02:765A  7B                          ld a,e                          ; restore secondary slot register
      69.  02:765B  02                          ld (bc),a
      70.  02:765C  C9                          ret
      71.  02:765D                      
      72.  02:765D                      ; These routines determine the current slot and subslot of a page.
      73.  02:765D                      
      74.  02:765D                      getSlotPage0:
      75.  02:765D                              ;DEBUGMESSAGE "getsltP0"
      76.  02:765D  DB A8                       in a,($a8)
      77.  02:765F  CD 82 76                    call expanded
      78.  02:7662  07                          rlca
      79.  02:7663  07                          rlca
      80.  02:7664  E6 0C                       and %00001100           ; keep subSlot
      81.  02:7666  B1                          or c                    ; add mainSlot and expanded bit
      82.  02:7667  C9                          ret
      83.  02:7668                                      
      84.  02:7668                      getSlotPage1:
      85.  02:7668                      ;        DEBUGMESSAGE "getsltP1"
      86.  02:7668  DB A8                       in a,($a8)
      87.  02:766A  0F                          rrca
      88.  02:766B  0F                          rrca
      89.  02:766C  CD 82 76                    call expanded
      90.  02:766F  E6 0C                       and %00001100           ; keep subSlot
      91.  02:7671  B1                          or c                    ; add mainSlot and expanded bit
      92.  02:7672  C9                          ret        
      93.  02:7673                                      
      94.  02:7673                      getSlotPage2:
      95.  02:7673                      ;        DEBUGMESSAGE "getsltP2"
      96.  02:7673  DB A8                       in a,($a8)
      97.  02:7675  0F                          rrca
      98.  02:7676  0F                          rrca
      99.  02:7677  0F                          rrca
     100.  02:7678  0F                          rrca
     101.  02:7679  CD 82 76                    call expanded
     102.  02:767C  0F                          rrca
     103.  02:767D  0F                          rrca
     104.  02:767E  E6 0C                       and %00001100           ; keep subSlot
     105.  02:7680  B1                          or c                    ; add mainSlot and expanded bit
     106.  02:7681  C9                          ret
     107.  02:7682                      
     108.  02:7682                      ;expanded:        
     109.  02:7682                      ;        ld hl,EXPTBL - $0300
     110.  02:7682                      ;        ld b,3
     111.  02:7682                      ;        and b
     112.  02:7682                      ;        ld c,a
     113.  02:7682                      ;        add hl,bc      
     114.  02:7682                      ;        
     115.  02:7682                      ;        or (hl)        ; BUGGIE!!!! (a will be used again!)
     116.  02:7682                      ;        ret p                           ; return when slot is not expanded
     117.  02:7682                      ;        
     118.  02:7682                      ;        ld c,a
     119.  02:7682                      ;        ld a,4
     120.  02:7682                      ;        add a,l
     121.  02:7682                      ;        ld l,a
     122.  02:7682                      ;        ld a,(hl)
     123.  02:7682                      ;        ret
     124.  02:7682                      
     125.  02:7682                      expanded:        
     126.  02:7682  21 C1 F9                    ld hl,EXPTBL - $0300
     127.  02:7685  06 03                       ld b,3
     128.  02:7687  A0                          and b
     129.  02:7688  4F                          ld c,a
     130.  02:7689  09                          add hl,bc
     131.  02:768A  CB 7E                       bit 7,(hl)
     132.  02:768C  28 08                       jr z,notExpanded
     133.  02:768E                      
     134.  02:768E  CB F9                       set 7,c
     135.  02:7690  2C                          inc l
     136.  02:7691  2C                          inc l
     137.  02:7692  2C                          inc l
     138.  02:7693  2C                          inc l
     139.  02:7694  7E                          ld a,(hl)
     140.  02:7695  C9                          ret        
     141.  02:7696                      
     142.  02:7696                      notExpanded:
     143.  02:7696  C1                          pop bc
     144.  02:7697  C9                          ret
     145.  02:7698                      
     146.  02:7698                      getEntrySLTWRK:
     147.  02:7698  CD 68 76                    call getSlotPage1
     148.  02:769B  21 09 FD                    ld hl,SLTWRK
     149.  02:769E  4F                          ld c,a
     150.  02:769F  0F                          rrca
     151.  02:76A0  0F                          rrca
     152.  02:76A1  0F                          rrca
     153.  02:76A2  E6 60                       and %01100000           ; main slot x 32
     154.  02:76A4  47                          ld b,a
     155.  02:76A5  79                          ld a,c
     156.  02:76A6  07                          rlca
     157.  02:76A7  E6 18                       and %00011000           ; sub slot x 8
     158.  02:76A9  80                          add b
     159.  02:76AA  85                          add l
     160.  02:76AB  6F                          ld l,a
     161.  02:76AC  C9                          ret
     162.  02:76AD                      
     193   02:76AD                              include "nowindDriver.asm"
       1.  02:76AD  (02:0008)           MYSIZE          equ 8                   ; size of work area (not used, some programs write here to stop drives spinning)
       2.  02:76AD  (02:0200)           SECLEN          equ 512                 ; sector size
       3.  02:76AD                      
       4.  02:76AD                      ; SLTWRK entry
       5.  02:76AD                      ; +0    rom drive number
       6.  02:76AD                      ; +1..5 previous EXTBIO
       7.  02:76AD                      ; +6    not used
       8.  02:76AD                      ; +7    not used
       9.  02:76AD                      
      10.  02:76AD                             
      11.  02:76AD                      ; if this is defined we tell DOS2.3 that we _are DOS2.3 also, so
      12.  02:76AD                      ; it does not try to override our initilazations 
      13.  02:76AD                      
      14.  02:76AD                      define  PRETEND_2B_DOS23
      15.  02:76AD                              
      16.  02:76AD                      INIHRD: 
      17.  02:76AD                              DEBUGMESSAGE "INIHRD"        
      17.  02:76AD                    >         ifdef DEBUG
      17.  02:76AD  52                >         ld d,d
      17.  02:76AE  18 06             >         jr .skip
      17.  02:76B0  49 4E 49 48 52 44 >         db string
      17.  02:76B6                    > .skip:
      17.  02:76B6                    >         endif
      18.  02:76B6                              
      19.  02:76B6                      ;        call getWorkArea
      20.  02:76B6                      ;        DEBUGDUMPREGISTERS
      21.  02:76B6                                                      
      22.  02:76B6  CD 0D 76                    call enableNowindPage0                  ; clear hostToMSXFifo by reading 4Kb of random data
      23.  02:76B9  01 00 10                    ld bc,4096
      24.  02:76BC  3A 00 20            .loop:  ld a,(usbrd)
      25.  02:76BF  0B                          dec bc
      26.  02:76C0  78                          ld a,b
      27.  02:76C1  B1                          or c
      28.  02:76C2  20 F8                       jr nz,.loop
      29.  02:76C4  CD 18 76                    call restorePage0
      30.  02:76C7                              
      31.  02:76C7  26 40                       ld h,HIGH usbwr
      32.  02:76C9  36 AF                       ld (hl),$af                     ; INIHRD command
      33.  02:76CB  36 FF                       ld (hl),$ff
      34.  02:76CD  C3 05 74                    jp nowindInit
      35.  02:76D0                      
      36.  02:76D0                      DRIVES:
      37.  02:76D0                              DEBUGMESSAGE "DRIVES"
      37.  02:76D0                    >         ifdef DEBUG
      37.  02:76D0  52                >         ld d,d
      37.  02:76D1  18 06             >         jr .skip
      37.  02:76D3  44 52 49 56 45 53 >         db string
      37.  02:76D9                    > .skip:
      37.  02:76D9                    >         endif
      38.  02:76D9  F5                          push af                         ; A, BC and DE should be preserved!
      39.  02:76DA  C5                          push bc
      40.  02:76DB  D5                          push de
      41.  02:76DC  3A 99 FD                    ld a,(DEVICE)
      42.  02:76DF  CD 7C 74                    call sendRegisters
      43.  02:76E2  36 85                       ld (hl),C_DRIVES
      44.  02:76E4  CD 0D 76                    call enableNowindPage0
      45.  02:76E7  26 20                       ld h,HIGH usbrd
      46.  02:76E9  CD 8E 74                    call getHeader
      47.  02:76EC  2E 02                       ld l,2                          ; default 2 drives
      48.  02:76EE  38 2C                       jr c,.notconnected
      49.  02:76F0                      
      50.  02:76F0                              PRINTVDPTEXT " Host connected."
      50.  02:76F0                    >         
      50.  02:76F0  E5                >         push hl
      50.  02:76F1  21 FA 76          >         ld hl,.text
      50.  02:76F4  CD 64 7C          >         call printVdpText2
      50.  02:76F7  E1                >         pop hl
      50.  02:76F8  18 11             >         jr .skip
      50.  02:76FA                    > .text   db string
      50.  02:76FA  20 48 6F 73 74 20 63 6F 6E 6E 65 63 74 65 64 2E 
      50.  02:770A  00                >         db 0
      50.  02:770B                    > .skip:
      51.  02:770B                                                      
      52.  02:770B  32 3F F3                    ld (LASTDRV),a                  ; install phantom drives (CRTL key)?
      53.  02:770E  7E                          ld a,(hl)                       ; allow other drives (SHIFT key)?
      54.  02:770F  32 99 FD                    ld (DEVICE),a
      55.  02:7712  6E                          ld l,(hl)                       ; number of drives
      56.  02:7713  E5                  .exit:  push hl  
      57.  02:7714  CD 18 76                    call restorePage0
      58.  02:7717  E1                          pop hl
      59.  02:7718  D1                          pop de
      60.  02:7719  C1                          pop bc
      61.  02:771A  F1                          pop af
      62.  02:771B  C9                          ret
      63.  02:771C                              
      64.  02:771C                      .notconnected:
      65.  02:771C                              PRINTVDPTEXT " Host timed out!"            
      65.  02:771C                    >         
      65.  02:771C  E5                >         push hl
      65.  02:771D  21 26 77          >         ld hl,.text
      65.  02:7720  CD 64 7C          >         call printVdpText2
      65.  02:7723  E1                >         pop hl
      65.  02:7724  18 11             >         jr .skip
      65.  02:7726                    > .text   db string
      65.  02:7726  20 48 6F 73 74 20 74 69 6D 65 64 20 6F 75 74 21 
      65.  02:7736  00                >         db 0
      65.  02:7737                    > .skip:
      66.  02:7737  18 DA                       jr .exit
      67.  02:7739                      
      68.  02:7739                      
      69.  02:7739                      INIENV:
      70.  02:7739                      ; Interrupt handler can be installed here and
      71.  02:7739                      ; work area can be initialized when it was requested
      72.  02:7739                              DEBUGMESSAGE "INIENV"
      72.  02:7739                    >         ifdef DEBUG
      72.  02:7739  52                >         ld d,d
      72.  02:773A  18 06             >         jr .skip
      72.  02:773C  49 4E 49 45 4E 56 >         db string
      72.  02:7742                    > .skip:
      72.  02:7742                    >         endif
      73.  02:7742                      
      74.  02:7742                              ifdef PRETEND_2B_DOS23
      75.  02:7742                              DEBUGMESSAGE "Lie about being DOS v2.31"
      75.  02:7742                    >         ifdef DEBUG
      75.  02:7742  52                >         ld d,d
      75.  02:7743  18 19             >         jr .skip
      75.  02:7745                    >         db string
      75.  02:7745  4C 69 65 20 61 62 6F 75 74 20 62 65 69 6E 67 20 
      75.  02:7755  44 4F 53 20 76 32 2E 33 31 
      75.  02:775E                    > .skip:
      75.  02:775E                    >         endif
      76.  02:775E  3E 23                       ld a,$23
      77.  02:7760  32 13 F3                    ld ($f313),a
      78.  02:7763                              endif
      79.  02:7763                              
      80.  02:7763  CD 58 75                    call installExtendedBios
      81.  02:7766  CD 7C 74                    call sendRegisters
      82.  02:7769  36 86                       ld (hl),C_INIENV
      83.  02:776B  CD 0D 76                    call enableNowindPage0
      84.  02:776E  26 20                       ld h,HIGH usbrd
      85.  02:7770  CD 8E 74                    call getHeader
      86.  02:7773  F5                          push af
      87.  02:7774                      ;        push ix
      88.  02:7774                      ;        call GETWRK
      89.  02:7774                      ;        pop ix
      90.  02:7774  CD 98 76                    call getEntrySLTWRK
      91.  02:7777  F1                          pop af
      92.  02:7778  36 00                       ld (hl),0                       ; romdisk in drive A: (default)          
      93.  02:777A  38 01                       jr c,.exit
      94.  02:777C  77                          ld (hl),a                       ; store romdisk drive number (255 = no romdisk)
      95.  02:777D  C3 18 76            .exit:  jp restorePage0
      96.  02:7780                      
      97.  02:7780                      checkWorkArea:
      98.  02:7780  3E 01                       ld a,1
      99.  02:7782  A7                          and a
     100.  02:7783  C9                          ret
     101.  02:7784                              
     102.  02:7784  C5                          push bc
     103.  02:7785  E5                          push hl
     104.  02:7786  F5                          push af
     105.  02:7787                      ;        call GETWRK
     106.  02:7787  CD 98 76                    call getEntrySLTWRK
     107.  02:778A  F1                          pop af
     108.  02:778B  BE                          cp (hl)
     109.  02:778C  E1                          pop hl
     110.  02:778D  C1                          pop bc
     111.  02:778E  C9                          ret        
     112.  02:778F                      
     113.  02:778F                      DSKIO: 
     114.  02:778F                      ; Input     F   Carry for set for write, reset for read
     115.  02:778F                      ;           A   Drive number
     116.  02:778F                      ;           B   Number of sectors to read/write
     117.  02:778F                      ;           C   Media descriptor
     118.  02:778F                      ;           DE  Logical sector number
     119.  02:778F                      ;           HL  Transfer address
     120.  02:778F                      ; Output    F   Carry set when not succesfull
     121.  02:778F                      ;           A   Error code
     122.  02:778F                      ;           B   Number of remaining sectors (TODO: check! even without error?)
     123.  02:778F                      
     124.  02:778F                              DEBUGMESSAGE "DSKIO"
     124.  02:778F                    >         ifdef DEBUG
     124.  02:778F  52                >         ld d,d
     124.  02:7790  18 05             >         jr .skip
     124.  02:7792  44 53 4B 49 4F    >         db string
     124.  02:7797                    > .skip:
     124.  02:7797                    >         endif
     125.  02:7797  F5                          push af
     126.  02:7798  CD 80 77                    call checkWorkArea
     127.  02:779B  CA FE 7C                    jp z,ROMDISK_DSKIO
     128.  02:779E  F1                          pop af
     129.  02:779F                      
     130.  02:779F  CD 7C 74                    call sendRegisters
     131.  02:77A2  36 80                       ld (hl),C_DSKIO
     132.  02:77A4  38 58                       jr c,dskioWrite                 ; read or write?
     133.  02:77A6                             
     134.  02:77A6                      dskioRead:
     135.  02:77A6  07                          rlca                            ; < 0x8000 ?
     136.  02:77A7  38 3F                       jr c,.page2and3
     137.  02:77A9                      
     138.  02:77A9                              DEBUGMESSAGE "read01"
     138.  02:77A9                    >         ifdef DEBUG
     138.  02:77A9  52                >         ld d,d
     138.  02:77AA  18 06             >         jr .skip
     138.  02:77AC  72 65 61 64 30 31 >         db string
     138.  02:77B2                    > .skip:
     138.  02:77B2                    >         endif
     139.  02:77B2  CD 73 76                    call getSlotPage2               ; enable nowind in page 2
     140.  02:77B5  F5                          push af
     141.  02:77B6  CD 68 76                    call getSlotPage1
     142.  02:77B9  DD 67                       ld ixh,a                        ; ixh = current nowind slot
     143.  02:77BB  26 80                       ld h,$80
     144.  02:77BD  CD 24 00                    call ENASLT
     145.  02:77C0  C3 C3 B7                    jp .page2
     146.  02:77C3                              
     147.  02:77C3  (B7C3)                      PHASE $ + $4000
     148.  02:B7C3                      .page2:
     149.  02:B7C3  3A 42 F3                    ld a,(RAMAD1)                   ; enable RAM in page 1
     150.  02:B7C6  26 40                       ld h,$40
     151.  02:B7C8  CD 24 00                    call ENASLT
     152.  02:B7CB                              
     153.  02:B7CB  CD 3E B9                    call readSectors01 
     154.  02:B7CE                              ; TODO: carry checken?----------------------------------------------!!!!!!!!!!!!!!!
     155.  02:B7CE                              
     156.  02:B7CE  DD 7C                       ld a,ixh                        ; enable nowind in page 1 
     157.  02:B7D0  26 40                       ld h,$40
     158.  02:B7D2  CD 24 00                    call ENASLT
     159.  02:B7D5  C3 D8 77                    jp .page1        
     160.  02:B7D8                      
     161.  02:B7D8  (77D8)                      DEPHASE
     162.  02:77D8                      .page1:
     163.  02:77D8  3A 00 80                    ld a,(usb2)
     164.  02:77DB  DD 67                       ld ixh,a
     165.  02:77DD  F1                          pop af
     166.  02:77DE  26 80                       ld h,$80
     167.  02:77E0  CD 24 00                    call ENASLT                     ; restore page 2
     168.  02:77E3  DD 7C                       ld a,ixh
     169.  02:77E5  B7                          or a
     170.  02:77E6  FB                          ei
     171.  02:77E7  C8                          ret z                           ; nothing more to read
     172.  02:77E8                                      
     173.  02:77E8                      .page2and3:                     
     174.  02:77E8                              DEBUGMESSAGE "read23"
     174.  02:77E8                    >         ifdef DEBUG
     174.  02:77E8  52                >         ld d,d
     174.  02:77E9  18 06             >         jr .skip
     174.  02:77EB  72 65 61 64 32 33 >         db string
     174.  02:77F1                    > .skip:
     174.  02:77F1                    >         endif
     175.  02:77F1  CD 0D 76                    call enableNowindPage0
     176.  02:77F4  FD E5                       push iy
     177.  02:77F6  CD 91 79                    call readSectors23
     178.  02:77F9  FD E1                       pop iy
     179.  02:77FB  C3 18 76                    jp restorePage0
     180.  02:77FE                      
     181.  02:77FE                      dskioWrite:
     182.  02:77FE                              DEBUGMESSAGE "dskwrite"
     182.  02:77FE                    >         ifdef DEBUG
     182.  02:77FE  52                >         ld d,d
     182.  02:77FF  18 08             >         jr .skip
     182.  02:7801                    >         db string
     182.  02:7801  64 73 6B 77 72 69 74 65 
     182.  02:7809                    > .skip:
     182.  02:7809                    >         endif
     183.  02:7809  07                          rlca
     184.  02:780A  38 3E                       jr c,.page2and3        
     185.  02:780C                              
     186.  02:780C                              ;call enableNowindPage2 (todo: make common routine?) 
     187.  02:780C  CD 73 76                    call getSlotPage2               ; save current slot page 2
     188.  02:780F  DD 67                       ld ixh,a
     189.  02:7811  CD 68 76                    call getSlotPage1
     190.  02:7814  DD 6F                       ld ixl,a
     191.  02:7816  26 80                       ld h,$80
     192.  02:7818  CD 24 00                    call ENASLT                     ; nowind in page 2
     193.  02:781B  C3 1E B8                    jp .page2
     194.  02:781E                      
     195.  02:781E  (B81E)                      PHASE $ + $4000
     196.  02:B81E                      .page2:
     197.  02:B81E  3A 42 F3                    ld a,(RAMAD1)
     198.  02:B821  26 40                       ld h,$40
     199.  02:B823  CD 24 00                    call ENASLT                     ; ram in page 1
     200.  02:B826                              
     201.  02:B826  CD 6C B9                    call writeLoop01
     202.  02:B829  F5                          push af
     203.  02:B82A                              
     204.  02:B82A  DD 7D                       ld a,ixl
     205.  02:B82C  26 40                       ld h,$40
     206.  02:B82E  CD 24 00                    call ENASLT                     ; restore nowind in page 1
     207.  02:B831  C3 34 78                    jp .page1
     208.  02:B834                              
     209.  02:B834  (7834)                      DEPHASE
     210.  02:7834                      .page1:
     211.  02:7834  DD 7C                       ld a,ixh
     212.  02:7836  26 80                       ld h,$80
     213.  02:7838  CD 24 00                    call ENASLT
     214.  02:783B  F1                          pop af
     215.  02:783C  D8                          ret c                           ; return error (error code in a)
     216.  02:783D  E8                          ret pe                          ; host returns 0xfe when data for page 2/3 is available
     217.  02:783E                              DEBUGMESSAGE "doorgaan!"
     217.  02:783E                    >         ifdef DEBUG
     217.  02:783E  52                >         ld d,d
     217.  02:783F  18 09             >         jr .skip
     217.  02:7841                    >         db string
     217.  02:7841  64 6F 6F 72 67 61 61 6E 21 
     217.  02:784A                    > .skip:
     217.  02:784A                    >         endif
     218.  02:784A                              
     219.  02:784A                      .page2and3:
     220.  02:784A                              DEBUGMESSAGE "page2and3"
     220.  02:784A                    >         ifdef DEBUG
     220.  02:784A  52                >         ld d,d
     220.  02:784B  18 09             >         jr .skip
     220.  02:784D                    >         db string
     220.  02:784D  70 61 67 65 32 61 6E 64 33 
     220.  02:7856                    > .skip:
     220.  02:7856                    >         endif
     221.  02:7856  CD 0D 76                    call enableNowindPage0
     222.  02:7859  CD 5F 78                    call .writeLoop23
     223.  02:785C  C3 18 76                    jp restorePage0
     224.  02:785F                              
     225.  02:785F                      .writeLoop23:
     226.  02:785F                              DEBUGMESSAGE "writeLoop23"
     226.  02:785F                    >         ifdef DEBUG
     226.  02:785F  52                >         ld d,d
     226.  02:7860  18 0B             >         jr .skip
     226.  02:7862                    >         db string
     226.  02:7862  77 72 69 74 65 4C 6F 6F 70 32 33 
     226.  02:786D                    > .skip:
     226.  02:786D                    >         endif
     227.  02:786D                              
     228.  02:786D  26 20                       ld h,HIGH usbrd
     229.  02:786F  CD 8E 74                    call getHeader
     230.  02:7872  D8                          ret c                           ; exit (not ready)
     231.  02:7873  B7                          or a
     232.  02:7874  F8                          ret m                           ; exit (no error)
     233.  02:7875  20 18                       jr nz,.error
     234.  02:7877                      
     235.  02:7877                              DEBUGMESSAGE "send23"
     235.  02:7877                    >         ifdef DEBUG
     235.  02:7877  52                >         ld d,d
     235.  02:7878  18 06             >         jr .skip
     235.  02:787A  73 65 6E 64 32 33 >         db string
     235.  02:7880                    > .skip:
     235.  02:7880                    >         endif
     236.  02:7880  5E                          ld e,(hl)                       ; address
     237.  02:7881  56                          ld d,(hl)
     238.  02:7882  4E                          ld c,(hl)                       ; number of bytes        
     239.  02:7883  46                          ld b,(hl)
     240.  02:7884  7E                          ld a,(hl)                       ; block sequence number
     241.  02:7885                              
     242.  02:7885                              ;DEBUGDUMPREGISTERS
     243.  02:7885  EB                          ex de,hl
     244.  02:7886  11 00 40                    ld de,usbwr
     245.  02:7889  12                          ld (de),a                       ; mark block begin
     246.  02:788A  ED B0                       ldir
     247.  02:788C  12                          ld (de),a                       ; mark block end
     248.  02:788D  18 D0                       jr .writeLoop23
     249.  02:788F                      
     250.  02:788F  37                  .error: scf
     251.  02:7890  7E                          ld a,(hl)                       ; get error code
     252.  02:7891  C9                          ret
     253.  02:7892                      
     254.  02:7892                                     
     255.  02:7892                      DSKCHG:
     256.  02:7892                      ; Input     A   Drive number
     257.  02:7892                      ;           B   0
     258.  02:7892                      ;           C   Media descriptor (previous)
     259.  02:7892                      ;           HL  Base address of DPB
     260.  02:7892                      ; Output    B   1   Disk unchanged
     261.  02:7892                      ;               0   Unknown (DPB is updated)
     262.  02:7892                      ;               -1  Disk changed (DPB is updated)
     263.  02:7892                      ;           F   Carry set when not succesfull
     264.  02:7892                      ;           A   Error code
     265.  02:7892                      
     266.  02:7892                              DEBUGMESSAGE "DSKCHG"
     266.  02:7892                    >         ifdef DEBUG
     266.  02:7892  52                >         ld d,d
     266.  02:7893  18 06             >         jr .skip
     266.  02:7895  44 53 4B 43 48 47 >         db string
     266.  02:789B                    > .skip:
     266.  02:789B                    >         endif
     267.  02:789B  F5                          push af
     268.  02:789C  CD 80 77                    call checkWorkArea
     269.  02:789F  CA 5D 7D                    jp z,ROMDISK_DSKCHG
     270.  02:78A2  F1                          pop af       
     271.  02:78A3                      
     272.  02:78A3  E5                          push hl
     273.  02:78A4  CD 7C 74                    call sendRegisters
     274.  02:78A7  36 81                       ld (hl),C_DSKCHG
     275.  02:78A9  CD 0D 76                    call enableNowindPage0
     276.  02:78AC  26 20                       ld h,HIGH usbrd
     277.  02:78AE  CD 8E 74                    call getHeader
     278.  02:78B1  4E                          ld c,(hl)               ; media descriptor (when disk was changed)
     279.  02:78B2  F5                          push af
     280.  02:78B3  C5                          push bc
     281.  02:78B4  CD 18 76                    call restorePage0
     282.  02:78B7  C1                          pop bc
     283.  02:78B8  F1                          pop af
     284.  02:78B9  E1                          pop hl
     285.  02:78BA  D8                          ret c           ; not ready
     286.  02:78BB  B7                          or a
     287.  02:78BC  06 01                       ld b,1
     288.  02:78BE  C8                          ret z           ; not changed
     289.  02:78BF  41                          ld b,c
     290.  02:78C0  CD C9 78                    call GETDPB
     291.  02:78C3  3E 0A                       ld a,10
     292.  02:78C5  D8                          ret c
     293.  02:78C6  06 FF                       ld b,255
     294.  02:78C8  C9                          ret
     295.  02:78C9                      
     296.  02:78C9                      GETDPB:
     297.  02:78C9                      ; Input     A   Drive number
     298.  02:78C9                      ;           B   Media descriptor (first byte of FAT)
     299.  02:78C9                      ;           C   Previous media descriptor (does not seem to be used in other drivers)
     300.  02:78C9                      ;           HL  Base address of HL
     301.  02:78C9                      ; Output    DPB for specified drive in [HL+1]..[HL+18]
     302.  02:78C9                      
     303.  02:78C9                              DEBUGMESSAGE "GETDPB"
     303.  02:78C9                    >         ifdef DEBUG
     303.  02:78C9  52                >         ld d,d
     303.  02:78CA  18 06             >         jr .skip
     303.  02:78CC  47 45 54 44 50 42 >         db string
     303.  02:78D2                    > .skip:
     303.  02:78D2                    >         endif
     304.  02:78D2  EB                          ex de,hl
     305.  02:78D3  13                          inc de
     306.  02:78D4  67                          ld h,a
     307.  02:78D5  78                          ld a,b
     308.  02:78D6  FE F0                       cp $f0
     309.  02:78D8  7C                          ld a,h
     310.  02:78D9  28 24                       jr z,.hddImage
     311.  02:78DB                              
     312.  02:78DB                              MESSAGE "ROM GETDPB"
     312.  02:78DB  CD BC 74          >         call sendMessage
     312.  02:78DE                    >         db string
     312.  02:78DE  52 4F 4D 20 47 45 54 44 50 42 
     312.  02:78E8  00                > .skip2: nop
     313.  02:78E9                      
     314.  02:78E9  78                          ld a,b
     315.  02:78EA  D6 F8                       sub $f8
     316.  02:78EC  D8                          ret c                           ; not supported in msxdos1
     317.  02:78ED  07                          rlca                            ; 2x
     318.  02:78EE  4F                          ld c,a
     319.  02:78EF  07                          rlca                            ; 4x
     320.  02:78F0  07                          rlca                            ; 8x
     321.  02:78F1  07                          rlca                            ; 16x
     322.  02:78F2  81                          add a,c                         ; 18x
     323.  02:78F3  4F                          ld c,a
     324.  02:78F4  06 00                       ld b,0        
     325.  02:78F6  21 6E 7C                    ld hl,supportedMedia
     326.  02:78F9  09                          add hl,bc
     327.  02:78FA  0E 12                       ld c,18
     328.  02:78FC  ED B0                       ldir
     329.  02:78FE  C9                          ret
     330.  02:78FF                      
     331.  02:78FF                      .hddImage:
     332.  02:78FF                              DEBUGMESSAGE ".hddImage"
     332.  02:78FF                    >         ifdef DEBUG
     332.  02:78FF  52                >         ld d,d
     332.  02:7900  18 09             >         jr .skip
     332.  02:7902                    >         db string
     332.  02:7902  2E 68 64 64 49 6D 61 67 65 
     332.  02:790B                    > .skip:
     332.  02:790B                    >         endif
     333.  02:790B                                      MESSAGE "HOST GETDPB"
     333.  02:790B  CD BC 74          >         call sendMessage
     333.  02:790E                    >         db string
     333.  02:790E  48 4F 53 54 20 47 45 54 44 50 42 
     333.  02:7919  00                > .skip2: nop
     334.  02:791A  CD 7C 74                    call sendRegisters
     335.  02:791D  36 82                       ld (hl),C_GETDPB
     336.  02:791F  CD 0D 76                    call enableNowindPage0
     337.  02:7922  26 20                       ld h,HIGH usbrd
     338.  02:7924  CD 8E 74                    call getHeader
     339.  02:7927  38 09                       jr c,.exit                      ; not ready
     340.  02:7929  5F                          ld e,a                          ; destination
     341.  02:792A  56                          ld d,(hl)
     342.  02:792B  01 12 00                    ld bc,18
     343.  02:792E                              DEBUGDUMPREGISTERS
     343.  02:792E                    >         ifdef DEBUG
     343.  02:792E  ED 07             >         db $ed,7
     343.  02:7930                    >         endif
     343.  02:7930                    >         
     343.  02:7930                    >         ifdef USBDEBUG
     343.  02:7930                    ~         assert ($ < $8000)
     343.  02:7930                    ~         call sendCpuInfo
     343.  02:7930                    ~         endif
     344.  02:7930  ED B0                       ldir
     345.  02:7932                              ;DB $ed, $0a       
     346.  02:7932  C3 18 76            .exit:  jp restorePage0        
     347.  02:7935                      
     348.  02:7935                      CHOICE:
     349.  02:7935                              ;DEBUGMESSAGE "CHOICE"
     350.  02:7935                              ifdef MSXDOS2
     351.  02:7935                    ~         ld hl,.noFormat
     352.  02:7935                    ~         else
     353.  02:7935  21 00 00                    ld hl,0                         ; no choice
     354.  02:7938                              endif
     355.  02:7938  C9                          ret
     356.  02:7939                      
     357.  02:7939                      .noFormat:
     358.  02:7939  00                          db 0
     359.  02:793A                      
     360.  02:793A                      DSKFMT:
     361.  02:793A  37                          scf
     362.  02:793B  3E 10                       ld a,16                         ; other error
     363.  02:793D  C9                          ret
     364.  02:793E                              
     365.  02:793E  (B93E)                      PHASE $ + $4000
     366.  02:B93E                              
     367.  02:B93E                      readSectors01:
     368.  02:B93E                              DEBUGMESSAGE "readSectors01"
     368.  02:B93E                    >         ifdef DEBUG
     368.  02:B93E  52                >         ld d,d
     368.  02:B93F  18 0D             >         jr .skip
     368.  02:B941                    >         db string
     368.  02:B941  72 65 61 64 53 65 63 74 6F 72 73 30 31 
     368.  02:B94E                    > .skip:
     368.  02:B94E                    >         endif
     369.  02:B94E  26 80                       ld h,HIGH usb2
     370.  02:B950  CD 8E B4                    call getHeader + $4000                                  
     371.  02:B953  D8                          ret c                           ; carry means timeout, no carry: A == 0 means slow transfer, A == 1 means exit, A == 2 means fast transfer                                      
     372.  02:B954  3D                          dec a
     373.  02:B955  C8                          ret z
     374.  02:B956  FA 60 B9                    jp m,.slowTransfer                              
     375.  02:B959  CD D2 B9                    call reverseTransfer + $4000
     376.  02:B95C  70                          ld (hl),b
     377.  02:B95D  71                          ld (hl),c
     378.  02:B95E  18 DE                       jr readSectors01
     379.  02:B960                      
     380.  02:B960                      .slowTransfer:
     381.  02:B960  5E                          ld e,(hl)                       ; transfer address
     382.  02:B961  56                          ld d,(hl)
     383.  02:B962  4E                          ld c,(hl)                       ; transfer amount 
     384.  02:B963  46                          ld b,(hl)
     385.  02:B964  ED B0                       ldir        
     386.  02:B966                              
     387.  02:B966  56                          ld d,(hl)                       ; BUG in emulator (byte direct terugschrijven, geeft 'rukkert!')
     388.  02:B967  7E                          ld a,(hl)
     389.  02:B968  72                          ld (hl),d                       ; return end marker ($af, $0f)
     390.  02:B969  77                          ld (hl),a
     391.  02:B96A  18 D2                       jr readSectors01
     392.  02:B96C                      
     393.  02:B96C                      writeLoop01:
     394.  02:B96C  26 80                       ld h,HIGH usb2
     395.  02:B96E  CD 8E B4                    call getHeader + $4000
     396.  02:B971  D8                          ret c                           ; exit (not ready)
     397.  02:B972  B7                          or a
     398.  02:B973  F8                          ret m                           ; exit (no error)
     399.  02:B974  20 18                       jr nz,.error
     400.  02:B976                      
     401.  02:B976                              DEBUGMESSAGE "send01"
     401.  02:B976                    >         ifdef DEBUG
     401.  02:B976  52                >         ld d,d
     401.  02:B977  18 06             >         jr .skip
     401.  02:B979  73 65 6E 64 30 31 >         db string
     401.  02:B97F                    > .skip:
     401.  02:B97F                    >         endif
     402.  02:B97F  5E                          ld e,(hl)                       ; address
     403.  02:B980  56                          ld d,(hl)
     404.  02:B981  4E                          ld c,(hl)                       ; number of bytes        
     405.  02:B982  46                          ld b,(hl)
     406.  02:B983  7E                          ld a,(hl)                       ; block sequence number
     407.  02:B984                      
     408.  02:B984  EB                          ex de,hl
     409.  02:B985  11 00 80                    ld de,usb2
     410.  02:B988  12                          ld (de),a                       ; mark block begin
     411.  02:B989  ED B0                       ldir
     412.  02:B98B  12                          ld (de),a                       ; mark block end
     413.  02:B98C  18 DE                       jr writeLoop01
     414.  02:B98E                      
     415.  02:B98E  37                  .error: scf
     416.  02:B98F  7E                          ld a,(hl)                       ; get error code
     417.  02:B990  C9                          ret
     418.  02:B991                      
     419.  02:B991  (7991)                      DEPHASE
     420.  02:7991                       
     421.  02:7991                      readSectors23:
     422.  02:7991                              DEBUGMESSAGE "readSectors23"
     422.  02:7991                    >         ifdef DEBUG
     422.  02:7991  52                >         ld d,d
     422.  02:7992  18 0D             >         jr .skip
     422.  02:7994                    >         db string
     422.  02:7994  72 65 61 64 53 65 63 74 6F 72 73 32 33 
     422.  02:79A1                    > .skip:
     422.  02:79A1                    >         endif
     423.  02:79A1  26 20                       ld h,HIGH usbrd
     424.  02:79A3  CD 8E 74                    call getHeader
     425.  02:79A6  D8                          ret c
     426.  02:79A7  3D                          dec a
     427.  02:79A8  C8                          ret z                           ; no more data
     428.  02:79A9  FA B5 79                    jp m,.slowTransfer        
     429.  02:79AC  CD D2 79                    call reverseTransfer
     430.  02:79AF  26 40                       ld h,HIGH usbwr 
     431.  02:79B1  70                          ld (hl),b
     432.  02:79B2  71                          ld (hl),c
     433.  02:79B3  18 DC                       jr readSectors23
     434.  02:79B5                      
     435.  02:79B5                      .slowTransfer:
     436.  02:79B5                              DEBUGMESSAGE "slowtransfer"
     436.  02:79B5                    >         ifdef DEBUG
     436.  02:79B5  52                >         ld d,d
     436.  02:79B6  18 0C             >         jr .skip
     436.  02:79B8                    >         db string
     436.  02:79B8  73 6C 6F 77 74 72 61 6E 73 66 65 72 
     436.  02:79C4                    > .skip:
     436.  02:79C4                    >         endif
     437.  02:79C4  5E                          ld e,(hl)                       ; transfer address
     438.  02:79C5  56                          ld d,(hl)
     439.  02:79C6  4E                          ld c,(hl)                       ; transfer amount 
     440.  02:79C7  46                          ld b,(hl)
     441.  02:79C8  ED B0                       ldir
     442.  02:79CA  56                          ld d,(hl)
     443.  02:79CB  7E                          ld a,(hl)
     444.  02:79CC  26 40                       ld h,HIGH usbwr
     445.  02:79CE  72                          ld (hl),d                       ; return end marker ($af, $0f)
     446.  02:79CF  77                          ld (hl),a
     447.  02:79D0  18 BF                       jr readSectors23
     448.  02:79D2                                     
     449.  02:79D2                      reverseTransfer:
     450.  02:79D2  FD 21 00 00                 ld iy,0                         ; save stack pointer
     451.  02:79D6  FD 39                       add iy,sp
     452.  02:79D8  5E                          ld e,(hl)                       ; transfer address
     453.  02:79D9  56                          ld d,(hl)
     454.  02:79DA  EB                          ex de,hl
     455.  02:79DB  F9                          ld sp,hl
     456.  02:79DC  EB                          ex de,hl
     457.  02:79DD  46                          ld b,(hl)                       ; number of loops       
     458.  02:79DE                      .loop:
     459.  02:79DE                              repeat 32                       ; blocks of 64 bytes hardcoded (NowindHost.cpp)
     460.  02:79DE                    <         ld d,(hl)
     461.  02:79DE                    <         ld e,(hl)
     462.  02:79DE                    <         push de
     463.  02:79DE                    <         endrepeat
     463.  02:79DE  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     463.  02:79EE  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     463.  02:79FE  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     463.  02:7A0E  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     463.  02:7A1E  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     463.  02:7A2E  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     464.  02:7A3E  10 9E                       djnz .loop
     465.  02:7A40                              
     466.  02:7A40  FD F9                       ld sp,iy                        ; restore stack pointer
     467.  02:7A42  46                          ld b,(hl)                       ; return end marker
     468.  02:7A43  4E                          ld c,(hl)
     469.  02:7A44  C9                          ret
     470.  02:7A45                            
     471.  02:7A45                      OEMSTA:
     472.  02:7A45  E5                          push hl
     473.  02:7A46  21 53 7A                    ld hl,.statement
     474.  02:7A49  CD 50 74                    call findStatementName
     475.  02:7A4C  5E                          ld e,(hl)
     476.  02:7A4D  23                          inc hl
     477.  02:7A4E  56                          ld d,(hl)
     478.  02:7A4F  E1                          pop hl        
     479.  02:7A50  D8                          ret c
     480.  02:7A51  D5                          push de
     481.  02:7A52  C9                          ret
     482.  02:7A53                      
     483.  02:7A53                      .statement:
     484.  02:7A53  49 4D 41 47 45 00           db "IMAGE",0
     485.  02:7A59  66 7A                       dw changeImage
     486.  02:7A5B                              db "VSTREAM",0
     486.  02:7A5B  56 53 54 52 45 41 4D 00 
     487.  02:7A63  93 7A                       dw videoStream
     488.  02:7A65  00                          db 0
     489.  02:7A66                      
     490.  02:7A66                      ; send arguments, command, filename, end with ":"
     491.  02:7A66                      changeImage:
     492.  02:7A66                              DEBUGMESSAGE "changeImage"
     492.  02:7A66                    >         ifdef DEBUG
     492.  02:7A66  52                >         ld d,d
     492.  02:7A67  18 0B             >         jr .skip
     492.  02:7A69                    >         db string
     492.  02:7A69  63 68 61 6E 67 65 49 6D 61 67 65 
     492.  02:7A74                    > .skip:
     492.  02:7A74                    >         endif
     493.  02:7A74  E5                          push hl
     494.  02:7A75  CD 7C 74                    call sendRegisters
     495.  02:7A78  36 91                       ld (hl),C_CHANGEIMAGE
     496.  02:7A7A  E1                          pop hl
     497.  02:7A7B                              
     498.  02:7A7B                      call_exit:
     499.  02:7A7B                              DEBUGMESSAGE "call_exit"
     499.  02:7A7B                    >         ifdef DEBUG
     499.  02:7A7B  52                >         ld d,d
     499.  02:7A7C  18 09             >         jr .skip
     499.  02:7A7E                    >         db string
     499.  02:7A7E  63 61 6C 6C 5F 65 78 69 74 
     499.  02:7A87                    > .skip:
     499.  02:7A87                    >         endif
     500.  02:7A87  7E                  .loop:  ld a,(hl)
     501.  02:7A88  32 00 40                    ld (usbwr),a
     502.  02:7A8B  FE 3A                       cp ":"
     503.  02:7A8D  C8                          ret z
     504.  02:7A8E  B7                          or a
     505.  02:7A8F  C8                          ret z
     506.  02:7A90  23                          inc hl
     507.  02:7A91  18 F4                       jr .loop
     508.  02:7A93                              
     509.  02:7A93                      videoStream: 
     510.  02:7A93  E5                          push hl
     511.  02:7A94                              include "vram.asm"
       1:  02:7A94                              
       2:  02:7A94                      vramDump:
       3:  02:7A94  F3                  	di
       4:  02:7A95  CD 0D 76                    call enableNowindPage0
       5:  02:7A98                      
       6:  02:7A98  3E 02                       ld a,2
       7:  02:7A9A  D3 99                       out ($99),a
       8:  02:7A9C  3E 8F                       ld a,$80+15             ; status register pointer at S#2
       9:  02:7A9E  D3 99                       out ($99),a
      10:  02:7AA0                      
      11:  02:7AA0                      evenFrame:
      12:  02:7AA0                              ; vram address 0x0000
      13:  02:7AA0                              
      14:  02:7AA0                              ;xor a
      15:  02:7AA0                              ;out ($99),a
      16:  02:7AA0                              ;ld a,$80+2
      17:  02:7AA0                              ;out ($99),a
      18:  02:7AA0                              
      19:  02:7AA0  3E 03                       ld a,%00000011                 ; pattern generator table
      20:  02:7AA2  D3 99                       out ($99),a
      21:  02:7AA4  3E 84                       ld a,$80+4
      22:  02:7AA6  D3 99                       out ($99),a
      23:  02:7AA8                      
      24:  02:7AA8  AF                          xor a                   ; color table high
      25:  02:7AA9  D3 99                       out ($99),a
      26:  02:7AAB  3E 8A                       ld a,$80+10
      27:  02:7AAD  D3 99                       out ($99),a
      28:  02:7AAF                              
      29:  02:7AAF  3E 04                       ld a,%00000100          ; vram access at 0x10000
      30:  02:7AB1  CD 45 7C                    call setVramAccessPointer
      31:  02:7AB4  CD DD 7A                    call tranferframe
      32:  02:7AB7  CD 53 7C                    call waitForRetrace
      33:  02:7ABA  CD F7 7B                    call changeColors
      34:  02:7ABD                      
      35:  02:7ABD                      oddFrame:
      36:  02:7ABD                              ; vram address 0x10000
      37:  02:7ABD                      
      38:  02:7ABD                              ;ld a,%01000000
      39:  02:7ABD                              ;out ($99),a
      40:  02:7ABD                              ;ld a,$80+2
      41:  02:7ABD                              ;out ($99),a
      42:  02:7ABD                      
      43:  02:7ABD  3E 23                       ld a,%00100011          ; pattern generator table
      44:  02:7ABF  D3 99                       out ($99),a
      45:  02:7AC1  3E 84                       ld a,$80+4
      46:  02:7AC3  D3 99                       out ($99),a
      47:  02:7AC5                      
      48:  02:7AC5  3E 64                       ld a,00000100           ; color table high
      49:  02:7AC7  D3 99                       out ($99),a
      50:  02:7AC9  3E 8A                       ld a,$80+10
      51:  02:7ACB  D3 99                       out ($99),a
      52:  02:7ACD                      
      53:  02:7ACD  AF                          xor a
      54:  02:7ACE  CD 45 7C                    call setVramAccessPointer
      55:  02:7AD1  CD DD 7A                    call tranferframe
      56:  02:7AD4  CD 53 7C                    call waitForRetrace
      57:  02:7AD7  CD F7 7B                    call changeColors
      58:  02:7ADA  C3 A0 7A                    jp evenFrame
      59:  02:7ADD                      
      60:  02:7ADD                      tranferframe:
      61:  02:7ADD  CD 7C 74                    call sendRegisters
      62:  02:7AE0  36 FF                       ld (hl),255
      63:  02:7AE2                                      
      64:  02:7AE2  21 00 20                    ld hl,usbrd
      65:  02:7AE5  CD 8E 74                    call getHeader
      66:  02:7AE8                              
      67:  02:7AE8  16 70                       ld d,112			; 224x64 is 1 screen 2 page of data ($3800)
      68:  02:7AEA                      write_more:        
      69:  02:7AEA  21 00 20            	ld hl,usbrd
      70:  02:7AED  01 98 00                    ld bc,$0098
      71:  02:7AF0                              repeat 128
      72:  02:7AF0                    <         outi
      73:  02:7AF0                    <         endrepeat
      73:  02:7AF0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B00  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B10  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B20  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B30  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B40  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B50  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B60  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B70  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B80  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B90  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BA0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BB0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BC0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BD0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BE0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      74:  02:7BF0                      
      75:  02:7BF0  15                          dec d
      76:  02:7BF1  7A                          ld a,d
      77:  02:7BF2  B7                          or a
      78:  02:7BF3  C2 EA 7A                    jp nz,write_more
      79:  02:7BF6  C9                          ret		
      80:  02:7BF7                      
      81:  02:7BF7                      changeColors:
      82:  02:7BF7  AF                          xor a			; set color register pointer to zero
      83:  02:7BF8  D3 99                       out ($99),a
      84:  02:7BFA  3E 90                       ld a,$80+16
      85:  02:7BFC  D3 99                       out ($99),a
      86:  02:7BFE                              
      87:  02:7BFE  21 00 20                    ld hl,usbrd
      88:  02:7C01  01 9A 00                    ld bc,$009A		; write to color register
      89:  02:7C04                      
      90:  02:7C04                              repeat 32
      91:  02:7C04                    <         outi
      92:  02:7C04                    <         endrepeat		
      92:  02:7C04  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  02:7C14  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  02:7C24  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  02:7C34  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      93:  02:7C44  C9                          ret
      94:  02:7C45                      
      95:  02:7C45                      	
      96:  02:7C45                      setVramAccessPointer:
      97:  02:7C45  D3 99                       out ($99),a
      98:  02:7C47  3E 8E                       ld a,$80+14
      99:  02:7C49  D3 99                       out ($99),a
     100:  02:7C4B  AF                          xor a
     101:  02:7C4C  D3 99                       out ($99),a
     102:  02:7C4E  3E 40                       ld a,%01000000		; vram write
     103:  02:7C50  D3 99                       out ($99),a
     104:  02:7C52  C9                          ret
     105:  02:7C53                      
     106:  02:7C53                      waitForRetrace:
     107:  02:7C53  DB 99                       in a,($99)
     108:  02:7C55  CB 77                       bit 6,a
     109:  02:7C57  20 FA                       jr nz,waitForRetrace       
     110:  02:7C59                      .lp2:        
     111:  02:7C59  DB 99                       in a,($99)
     112:  02:7C5B  CB 77                       bit 6,a
     113:  02:7C5D  28 FA                       jr z,.lp2       
     114:  02:7C5F  C9                          ret
     115:  02:7C60                              	
     116:  02:7C60                      	; just let it go... 
     512.  02:7C60  E1                          pop hl
     513.  02:7C61  C3 7B 7A                    jp call_exit
     514.  02:7C64                              
     515.  02:7C64                      ; hl points to text
     516.  02:7C64                      printVdpText2:
     517.  02:7C64  F5                                                  push af
     518.  02:7C65  7E                  .loop:  ld a,(hl)
     519.  02:7C66  D3 98                                               out ($98),a 
     520.  02:7C68  23                                                  inc hl
     521.  02:7C69  B7                                                  or a
     522.  02:7C6A  20 F9                                               jr nz,.loop
     523.  02:7C6C  F1                                                  pop af
     524.  02:7C6D  C9                                                  ret
     525.  02:7C6E                              
     526.  02:7C6E                      supportedMedia:
     527.  02:7C6E                                      
     528.  02:7C6E                      .f8:    MAKEDPB $f8, 512, 2, 112, 1 * 80 * 9, 2, 2      ; 360 kB (1 side * 80 tracks * 9 tracks/sector)
     528.  02:7C6E  (02:0001)         > .firfat equ 1
     528.  02:7C6E  (02:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     528.  02:7C6E  (02:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     528.  02:7C6E                    >         if sectorSize = 512
     528.  02:7C6E  (02:0004)         > .shft   equ 4
     528.  02:7C6E                    >         elseif sectorSize = 256
     528.  02:7C6E                    ~ .shft   equ 3
     528.  02:7C6E                    ~         endif
     528.  02:7C6E                    >         
     528.  02:7C6E  F8                >         db media
     528.  02:7C6F  00 02             >         dw sectorSize
     528.  02:7C71  0F 04             >         db (sectorSize/32)-1, .shft
     528.  02:7C73  01                >         db sectorsPerCluster-1
     528.  02:7C74  02                >         db sectorsPerCluster
     528.  02:7C75  01 00             >         dw .firfat
     528.  02:7C77  02 70             >         db fatCount, maxEnt
     528.  02:7C79  0C 00             >         dw .firrec
     528.  02:7C7B  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     528.  02:7C7D  02                >         db fatSiz
     528.  02:7C7E  05 00             >         dw .firdir
     529.  02:7C80                      .def:   MAKEDPB $f9, 512, 2, 112, 2 * 80 * 9, 3, 2      ; 720 kB
     529.  02:7C80  (02:0001)         > .firfat equ 1
     529.  02:7C80  (02:0007)         > .firdir equ .firfat+(fatCount*fatSiz)
     529.  02:7C80  (02:000E)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     529.  02:7C80                    >         if sectorSize = 512
     529.  02:7C80  (02:0004)         > .shft   equ 4
     529.  02:7C80                    >         elseif sectorSize = 256
     529.  02:7C80                    ~ .shft   equ 3
     529.  02:7C80                    ~         endif
     529.  02:7C80                    >         
     529.  02:7C80  F9                >         db media
     529.  02:7C81  00 02             >         dw sectorSize
     529.  02:7C83  0F 04             >         db (sectorSize/32)-1, .shft
     529.  02:7C85  01                >         db sectorsPerCluster-1
     529.  02:7C86  02                >         db sectorsPerCluster
     529.  02:7C87  01 00             >         dw .firfat
     529.  02:7C89  02 70             >         db fatCount, maxEnt
     529.  02:7C8B  0E 00             >         dw .firrec
     529.  02:7C8D  CA 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     529.  02:7C8F  03                >         db fatSiz
     529.  02:7C90  07 00             >         dw .firdir
     530.  02:7C92                              MAKEDPB $fa, 512, 2, 112, 1 * 80 * 8, 1, 2      ; 320 kB
     530.  02:7C92  (02:0001)         > .firfat equ 1
     530.  02:7C92  (02:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     530.  02:7C92  (02:000A)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     530.  02:7C92                    >         if sectorSize = 512
     530.  02:7C92  (02:0004)         > .shft   equ 4
     530.  02:7C92                    >         elseif sectorSize = 256
     530.  02:7C92                    ~ .shft   equ 3
     530.  02:7C92                    ~         endif
     530.  02:7C92                    >         
     530.  02:7C92  FA                >         db media
     530.  02:7C93  00 02             >         dw sectorSize
     530.  02:7C95  0F 04             >         db (sectorSize/32)-1, .shft
     530.  02:7C97  01                >         db sectorsPerCluster-1
     530.  02:7C98  02                >         db sectorsPerCluster
     530.  02:7C99  01 00             >         dw .firfat
     530.  02:7C9B  02 70             >         db fatCount, maxEnt
     530.  02:7C9D  0A 00             >         dw .firrec
     530.  02:7C9F  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     530.  02:7CA1  01                >         db fatSiz
     530.  02:7CA2  03 00             >         dw .firdir
     531.  02:7CA4                              MAKEDPB $fb, 512, 2, 112, 2 * 80 * 8, 2, 2      ; 640 kB
     531.  02:7CA4  (02:0001)         > .firfat equ 1
     531.  02:7CA4  (02:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     531.  02:7CA4  (02:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     531.  02:7CA4                    >         if sectorSize = 512
     531.  02:7CA4  (02:0004)         > .shft   equ 4
     531.  02:7CA4                    >         elseif sectorSize = 256
     531.  02:7CA4                    ~ .shft   equ 3
     531.  02:7CA4                    ~         endif
     531.  02:7CA4                    >         
     531.  02:7CA4  FB                >         db media
     531.  02:7CA5  00 02             >         dw sectorSize
     531.  02:7CA7  0F 04             >         db (sectorSize/32)-1, .shft
     531.  02:7CA9  01                >         db sectorsPerCluster-1
     531.  02:7CAA  02                >         db sectorsPerCluster
     531.  02:7CAB  01 00             >         dw .firfat
     531.  02:7CAD  02 70             >         db fatCount, maxEnt
     531.  02:7CAF  0C 00             >         dw .firrec
     531.  02:7CB1  7B 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     531.  02:7CB3  02                >         db fatSiz
     531.  02:7CB4  05 00             >         dw .firdir
     532.  02:7CB6                              MAKEDPB $fc, 512, 1, 64,  1 * 40 * 9, 2, 2      ; 180 kB
     532.  02:7CB6  (02:0001)         > .firfat equ 1
     532.  02:7CB6  (02:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     532.  02:7CB6  (02:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     532.  02:7CB6                    >         if sectorSize = 512
     532.  02:7CB6  (02:0004)         > .shft   equ 4
     532.  02:7CB6                    >         elseif sectorSize = 256
     532.  02:7CB6                    ~ .shft   equ 3
     532.  02:7CB6                    ~         endif
     532.  02:7CB6                    >         
     532.  02:7CB6  FC                >         db media
     532.  02:7CB7  00 02             >         dw sectorSize
     532.  02:7CB9  0F 04             >         db (sectorSize/32)-1, .shft
     532.  02:7CBB  00                >         db sectorsPerCluster-1
     532.  02:7CBC  01                >         db sectorsPerCluster
     532.  02:7CBD  01 00             >         dw .firfat
     532.  02:7CBF  02 40             >         db fatCount, maxEnt
     532.  02:7CC1  09 00             >         dw .firrec
     532.  02:7CC3  60 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     532.  02:7CC5  02                >         db fatSiz
     532.  02:7CC6  05 00             >         dw .firdir
     533.  02:7CC8                              MAKEDPB $fd, 512, 2, 112, 2 * 40 * 9, 2, 2      ; 360 kB
     533.  02:7CC8  (02:0001)         > .firfat equ 1
     533.  02:7CC8  (02:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     533.  02:7CC8  (02:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     533.  02:7CC8                    >         if sectorSize = 512
     533.  02:7CC8  (02:0004)         > .shft   equ 4
     533.  02:7CC8                    >         elseif sectorSize = 256
     533.  02:7CC8                    ~ .shft   equ 3
     533.  02:7CC8                    ~         endif
     533.  02:7CC8                    >         
     533.  02:7CC8  FD                >         db media
     533.  02:7CC9  00 02             >         dw sectorSize
     533.  02:7CCB  0F 04             >         db (sectorSize/32)-1, .shft
     533.  02:7CCD  01                >         db sectorsPerCluster-1
     533.  02:7CCE  02                >         db sectorsPerCluster
     533.  02:7CCF  01 00             >         dw .firfat
     533.  02:7CD1  02 70             >         db fatCount, maxEnt
     533.  02:7CD3  0C 00             >         dw .firrec
     533.  02:7CD5  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     533.  02:7CD7  02                >         db fatSiz
     533.  02:7CD8  05 00             >         dw .firdir
     534.  02:7CDA                              MAKEDPB $fe, 512, 1, 64,  1 * 40 * 8, 1, 2      ; 160 kB
     534.  02:7CDA  (02:0001)         > .firfat equ 1
     534.  02:7CDA  (02:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     534.  02:7CDA  (02:0007)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     534.  02:7CDA                    >         if sectorSize = 512
     534.  02:7CDA  (02:0004)         > .shft   equ 4
     534.  02:7CDA                    >         elseif sectorSize = 256
     534.  02:7CDA                    ~ .shft   equ 3
     534.  02:7CDA                    ~         endif
     534.  02:7CDA                    >         
     534.  02:7CDA  FE                >         db media
     534.  02:7CDB  00 02             >         dw sectorSize
     534.  02:7CDD  0F 04             >         db (sectorSize/32)-1, .shft
     534.  02:7CDF  00                >         db sectorsPerCluster-1
     534.  02:7CE0  01                >         db sectorsPerCluster
     534.  02:7CE1  01 00             >         dw .firfat
     534.  02:7CE3  02 40             >         db fatCount, maxEnt
     534.  02:7CE5  07 00             >         dw .firrec
     534.  02:7CE7  3A 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     534.  02:7CE9  01                >         db fatSiz
     534.  02:7CEA  03 00             >         dw .firdir
     535.  02:7CEC                              MAKEDPB $ff, 512, 2, 112, 2 * 40 * 8, 1, 1      ; 320 kB
     535.  02:7CEC  (02:0001)         > .firfat equ 1
     535.  02:7CEC  (02:0002)         > .firdir equ .firfat+(fatCount*fatSiz)
     535.  02:7CEC  (02:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     535.  02:7CEC                    >         if sectorSize = 512
     535.  02:7CEC  (02:0004)         > .shft   equ 4
     535.  02:7CEC                    >         elseif sectorSize = 256
     535.  02:7CEC                    ~ .shft   equ 3
     535.  02:7CEC                    ~         endif
     535.  02:7CEC                    >         
     535.  02:7CEC  FF                >         db media
     535.  02:7CED  00 02             >         dw sectorSize
     535.  02:7CEF  0F 04             >         db (sectorSize/32)-1, .shft
     535.  02:7CF1  01                >         db sectorsPerCluster-1
     535.  02:7CF2  02                >         db sectorsPerCluster
     535.  02:7CF3  01 00             >         dw .firfat
     535.  02:7CF5  01 70             >         db fatCount, maxEnt
     535.  02:7CF7  09 00             >         dw .firrec
     535.  02:7CF9  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     535.  02:7CFB  01                >         db fatSiz
     535.  02:7CFC  02 00             >         dw .firdir
     536.  02:7CFE                      
     537.  02:7CFE                      ; WARNING: in some cases DEFDPB-1 is expected!
     538.  02:7CFE  (02:7C80)           DEFDPB  equ supportedMedia.def
     194   02:7CFE                              include "romdisk.asm"
       1.  02:7CFE                      		define	ROMDSKBANK 5			; romdisk starts in bank 5
       2.  02:7CFE                      		define	ROMDSKLAST (FLASHROMSIZE/16)-1
       3.  02:7CFE                      
       4.  02:7CFE                      
       5.  02:7CFE                      ROMDISK_DSKIO:
       6.  02:7CFE                              DEBUGMESSAGE "R_DSKIO"
       6.  02:7CFE                    >         ifdef DEBUG
       6.  02:7CFE  52                >         ld d,d
       6.  02:7CFF  18 07             >         jr .skip
       6.  02:7D01                    >         db string
       6.  02:7D01  52 5F 44 53 4B 49 4F 
       6.  02:7D08                    > .skip:
       6.  02:7D08                    >         endif
       7.  02:7D08  F1                          pop af
       8.  02:7D09  3E 00                       ld a,0
       9.  02:7D0B  D8                          ret c                           ; write protected
      10.  02:7D0C                              
      11.  02:7D0C  EB                          ex de,hl
      12.  02:7D0D  C5                  .loop:  push bc
      13.  02:7D0E  E5                          push hl        
      14.  02:7D0F                              
      15.  02:7D0F  CB 7A                       bit 7,d
      16.  02:7D11  20 1C                       jr nz,.directCopy
      17.  02:7D13  7A                          ld a,d
      18.  02:7D14  FE 3E                       cp $3e        
      19.  02:7D16  38 17                       jr c,.directCopy
      20.  02:7D18                      
      21.  02:7D18  CD 3B 7D                    call .findSector
      22.  02:7D1B  D5                          push de
      23.  02:7D1C  ED 5B 4D F3                 ld de,($f34d)        
      24.  02:7D20  CD F4 7F                    call copyFromBank
      25.  02:7D23  D1                          pop de
      26.  02:7D24  01 00 02                    ld bc,512
      27.  02:7D27  2A 4D F3                    ld hl,($f34d)
      28.  02:7D2A  CD 6E F3                    call XFER
      29.  02:7D2D  18 06                       jr .nextSector           
      30.  02:7D2F                                    
      31.  02:7D2F                      .directCopy:                
      32.  02:7D2F  CD 3B 7D                    call .findSector  
      33.  02:7D32  CD F4 7F                    call copyFromBank
      34.  02:7D35                      .nextSector:
      35.  02:7D35  E1                          pop hl
      36.  02:7D36  23                          inc hl
      37.  02:7D37  C1                          pop bc
      38.  02:7D38  10 D3                       djnz .loop
      39.  02:7D3A  C9                          ret
      40.  02:7D3B                      
      41.  02:7D3B                      .findSector:        
      42.  02:7D3B  7D                          ld a,l                          ; determine bank
      43.  02:7D3C  E6 E0                       and %11100000
      44.  02:7D3E  B4                          or h
      45.  02:7D3F  07                          rlca
      46.  02:7D40  07                          rlca
      47.  02:7D41  07                          rlca
      48.  02:7D42  47                          ld b,a
      49.  02:7D43                      
      50.  02:7D43  7D                          ld a,l
      51.  02:7D44  E6 1F                       and 31
      52.  02:7D46  4F                          ld c,a
      53.  02:7D47  3E FF                       ld a,ROMDSKLAST                 ; banks with b0..5=0 reside in the last bank
      54.  02:7D49  28 05                       jr z,.skip
      55.  02:7D4B                      
      56.  02:7D4B  78                          ld a,b
      57.  02:7D4C  C6 05                       add ROMDSKBANK
      58.  02:7D4E  41                          ld b,c
      59.  02:7D4F  05                          dec b
      60.  02:7D50  4F                  .skip:  ld c,a
      61.  02:7D51  78                          ld a,b
      62.  02:7D52  07                          rlca
      63.  02:7D53  C6 41                       add $41                         ; disk images starts at $4100
      64.  02:7D55  67                          ld h,a
      65.  02:7D56  2E 00                       ld l,0
      66.  02:7D58  79                          ld a,c
      67.  02:7D59  01 00 02                    ld bc,512
      68.  02:7D5C  C9                          ret
      69.  02:7D5D                                                               
      70.  02:7D5D                      ROMDISK_DSKCHG:
      71.  02:7D5D                              ;DEBUGMESSAGE "ROM_DSKCHG"
      72.  02:7D5D  F1                          pop af
      73.  02:7D5E  A7                          and a
      74.  02:7D5F  06 01                       ld b,1                          ; not changed
      75.  02:7D61  C9                          ret
      76.  02:7D62                      
      77.  02:7D62                      ROMDISK_GETDPB:
      78.  02:7D62                              ; not implemented (standard mediadescriptor as used)
      79.  02:7D62                              
      80.  02:7D62                      ROMDISK_DSKFMT:
      81.  02:7D62                              ; not implemented (no disk can be formatted)
      82.  02:7D62                              
     195   02:7D62                              include "flashWriter.asm"
       1.  02:7D62                      ; flashWriter.asm
       2.  02:7D62                      ; Flashes and erases the AMD29F040/M29F032-D
       3.  02:7D62                           
       4.  02:7D62                      flashWriter:
       5.  02:7D62                              ;DEBUGMESSAGE "flashWriter"
       6.  02:7D62  3E 03                       ld a,3
       7.  02:7D64  CD 41 01                    call SNSMAT
       8.  02:7D67  E6 08                       and 8
       9.  02:7D69  C0                          ret nz
      10.  02:7D6A                              
      11.  02:7D6A  CD 86 5F                    call PRINTTEXT
      12.  02:7D6D                              db 10,13," FlashROM",10,13," "
      12.  02:7D6D  0A 0D 20 46 6C 61 73 68 52 4F 4D 0A 0D 20 
      13.  02:7D7B  2E (33)                     ds 33,"."
      14.  02:7D9C  0D 20 00                    db 13," ",0
      15.  02:7D9F                              
      16.  02:7D9F  CD 68 76                    call getSlotPage1
      17.  02:7DA2  CD 21 76                    call enableSlotPage0
      18.  02:7DA5                      
      19.  02:7DA5  21 B2 7D                    ld hl,.source
      20.  02:7DA8  11 00 C0                    ld de,$c000
      21.  02:7DAB  D5                          push de
      22.  02:7DAC  01 DB 00                    ld bc,flasherEnd - $c000
      23.  02:7DAF  ED B0                       ldir
      24.  02:7DB1  C9                          ret
      25.  02:7DB2                              
      26.  02:7DB2                      .source:     
      27.  02:7DB2  (C000)                      PHASE $c000  
      28.  02:C000                              
      29.  02:C000                      waitForHeader:
      30.  02:C000  26 20                       ld h,HIGH usbrd
      31.  02:C002  7E                          ld a,(hl)
      32.  02:C003  FE BB               .chkbb: cp $bb
      33.  02:C005  20 F9                       jr nz,waitForHeader
      34.  02:C007  7E                          ld a,(hl)
      35.  02:C008  FE 55                       cp $55
      36.  02:C00A  20 F7                       jr nz,.chkbb       
      37.  02:C00C                      
      38.  02:C00C  7E                          ld a,(hl)
      39.  02:C00D  FE A2                       cp $a2
      40.  02:C00F  CA A9 C0                    jp z,verifyFlash
      41.  02:C012  FE A3                       cp $a3
      42.  02:C014  28 6E                       jr z,writeFlash
      43.  02:C016  FE A4                       cp $a4
      44.  02:C018  28 52                       jr z,chipErase
      45.  02:C01A  FE A5                       cp $a5
      46.  02:C01C  28 1C                       jr z,eraseSector
      47.  02:C01E  FE A6                       cp $a6
      48.  02:C020  28 02                       jr z,autoselectMode
      49.  02:C022                      
      50.  02:C022  20 DC                       jr nz,waitForHeader
      51.  02:C024                          
      52.  02:C024                      autoselectMode:
      53.  02:C024  3E 90                       ld a,$90
      54.  02:C026  CD CC C0                    call writeCommandSequence
      55.  02:C029                      
      56.  02:C029  2A 00 40                    ld hl,($4000)
      57.  02:C02C  EB                          ex de,hl
      58.  02:C02D  26 40                       ld h,HIGH usbwr
      59.  02:C02F  36 AA                       ld (hl),$aa
      60.  02:C031  36 55                       ld (hl),$55
      61.  02:C033  73                          ld (hl),e                       ; manufacturer ID (0x01 = AMD)
      62.  02:C034  72                          ld (hl),d                       ; device ID (0xA4 = AM29F040, 0x41 = AM29F032B)
      63.  02:C035                      
      64.  02:C035  CD 66 C0                    call writeResetCommand
      65.  02:C038  18 C6                       jr waitForHeader
      66.  02:C03A                      
      67.  02:C03A                      eraseSector:
      68.  02:C03A                              ;DEBUGMESSAGE "sector erase"
      69.  02:C03A  3E 65               	ld a,"e"
      70.  02:C03C  D3 98               	out ($98),a
      71.  02:C03E                      
      72.  02:C03E  7E                          ld a,(hl)                       ; get sector number 0..63
      73.  02:C03F  CB 27                       sla a
      74.  02:C041  CB 27                       sla a
      75.  02:C043  32 01 60                    ld (mapper),a                   ; select sector
      76.  02:C046                      
      77.  02:C046  3E 80                       ld a,$80
      78.  02:C048  CD CC C0                    call writeCommandSequence
      79.  02:C04B  3E 30                       ld a,$30        
      80.  02:C04D  CD CC C0                    call writeCommandSequence
      81.  02:C050                      
      82.  02:C050  CD 56 C0                    call waitForCommandToComplete
      83.  02:C053  C3 BD C0                    jp acknowledge
      84.  02:C056                              
      85.  02:C056                      waitForCommandToComplete:
      86.  02:C056  7E                          ld a,(hl)
      87.  02:C057  46                          ld b,(hl)
      88.  02:C058  A8                          xor b
      89.  02:C059  E6 40                       and %01000000                   ; check toggle bit I (DQ6)
      90.  02:C05B  C8                          ret z                           ; operation complete
      91.  02:C05C                              
      92.  02:C05C  78                          ld a,b
      93.  02:C05D  E6 20                       and %00100000                   ; timing limits exceeded? (DQ5)
      94.  02:C05F  28 F5                       jr z,waitForCommandToComplete
      95.  02:C061                      
      96.  02:C061  CD 66 C0                    call writeResetCommand
      97.  02:C064  78                          ld a,b
      98.  02:C065  C9                          ret
      99.  02:C066                      
     100.  02:C066                      writeResetCommand:
     101.  02:C066  3E F0                       ld a,$f0                        ; write RESET command
     102.  02:C068  32 00 00                    ld (0),a
     103.  02:C06B  C9                          ret
     104.  02:C06C                      
     105.  02:C06C                      chipErase:
     106.  02:C06C                              ;DEBUGMESSAGE "chip erase"
     107.  02:C06C  3E 45               	ld a,"E"
     108.  02:C06E  D3 98               	out ($98),a
     109.  02:C070                      
     110.  02:C070  3E 80                       ld a,$80
     111.  02:C072  CD CC C0                    call writeCommandSequence
     112.  02:C075  3E 10                       ld a,$10
     113.  02:C077  CD CC C0                    call writeCommandSequence
     114.  02:C07A                      
     115.  02:C07A  3A 00 40            .wait:  ld a,($4000)                    ; read DQ7 (data# polling) 
     116.  02:C07D  07                          rlca
     117.  02:C07E  30 FA                       jr nc,.wait        
     118.  02:C080  3E 01                       ld a,1
     119.  02:C082  18 39                       jr acknowledge
     120.  02:C084                      
     121.  02:C084                      
     122.  02:C084                      writeFlash:
     123.  02:C084                              ;DEBUGMESSAGE "write"
     124.  02:C084  5E                          ld e,(hl)                       ; address
     125.  02:C085  56                          ld d,(hl)
     126.  02:C086                      
     127.  02:C086  7A                          ld a,d
     128.  02:C087  B3                          or e
     129.  02:C088  CC C7 C0                    call z,updateBar
     130.  02:C08B                      
     131.  02:C08B  7E                          ld a,(hl)                       ; bank
     132.  02:C08C  32 01 60                    ld (mapper),a
     133.  02:C08F  26 40                       ld h,$40
     134.  02:C091                              
     135.  02:C091  06 80                       ld b,128                        ; data is written in blocks of 128 bytes
     136.  02:C093  3E A0               .loop:  ld a,$a0
     137.  02:C095  CD CC C0                    call writeCommandSequence
     138.  02:C098  3A 00 20                    ld a,(usbrd)
     139.  02:C09B  12                          ld (de),a                       ; write data to flash
     140.  02:C09C  13                          inc de
     141.  02:C09D                      
     142.  02:C09D  7E                  .wait:  ld  a,(hl)                      ; write complete?
     143.  02:C09E  AE                          xor (hl)
     144.  02:C09F  E6 40                       and %01000000
     145.  02:C0A1  20 FA                       jr  nz,.wait
     146.  02:C0A3  10 EE                       djnz .loop
     147.  02:C0A5                              
     148.  02:C0A5  3E 02                       ld a,2
     149.  02:C0A7  18 14                       jr acknowledge        
     150.  02:C0A9                              
     151.  02:C0A9                      verifyFlash:
     152.  02:C0A9                              ;DEBUGMESSAGE "verify"
     153.  02:C0A9  21 00 20                    ld hl,usbrd
     154.  02:C0AC  5E                          ld e,(hl)                       ; address
     155.  02:C0AD  56                          ld d,(hl)
     156.  02:C0AE  7E                          ld a,(hl)                       ; bank
     157.  02:C0AF  32 01 60                    ld (mapper),a
     158.  02:C0B2                      
     159.  02:C0B2  06 80                       ld b,128
     160.  02:C0B4  1A                  .loop:  ld a,(de)
     161.  02:C0B5  32 00 40                    ld (usbwr),a
     162.  02:C0B8  13                          inc de
     163.  02:C0B9  10 F9                       djnz .loop
     164.  02:C0BB                      
     165.  02:C0BB  3E 03                       ld a,3
     166.  02:C0BD                      acknowledge:        
     167.  02:C0BD  26 40                       ld h,HIGH usbwr
     168.  02:C0BF  36 AA                       ld (hl),$aa
     169.  02:C0C1  36 55                       ld (hl),$55
     170.  02:C0C3  77                          ld (hl),a
     171.  02:C0C4  C3 00 C0                    jp waitForHeader
     172.  02:C0C7                      
     173.  02:C0C7                      updateBar:
     174.  02:C0C7  3E 77                       ld a,"w"  
     175.  02:C0C9  D3 98                       out ($98),a
     176.  02:C0CB  C9                          ret
     177.  02:C0CC                      
     178.  02:C0CC                      writeCommandSequence:
     179.  02:C0CC  F5                          push af
     180.  02:C0CD  3E AA                       ld a,$aa
     181.  02:C0CF  32 55 05                    ld ($0555),a
     182.  02:C0D2  2F                          cpl
     183.  02:C0D3  32 AA 02                    ld ($02aa),a
     184.  02:C0D6  F1                          pop af
     185.  02:C0D7  32 55 05                    ld ($0555),a
     186.  02:C0DA  C9                          ret
     187.  02:C0DB                              
     188.  02:C0DB                      flasherEnd:
     189.  02:C0DB  (7E8D)                      DEPHASE
     196   02:7E8D                              include "device.asm"
       1.  02:7E8D                      ; device.asm
       2.  02:7E8D                      ; implements a basic now: device
       3.  02:7E8D                          
       4.  02:7E8D                      device:
       5.  02:7E8D  E5                          push hl
       6.  02:7E8E  21 9F 7E                    ld hl,deviceFunctions
       7.  02:7E91  0F                          rrca
       8.  02:7E92  3C                          inc a
       9.  02:7E93  07                          rlca
      10.  02:7E94  85                          add a,l
      11.  02:7E95  6F                          ld l,a
      12.  02:7E96  30 01                       jr nc,.nocy
      13.  02:7E98  24                          inc h  
      14.  02:7E99  7E                  .nocy:  ld a,(hl)
      15.  02:7E9A  23                          inc hl
      16.  02:7E9B  66                          ld h,(hl)
      17.  02:7E9C  6F                          ld l,a
      18.  02:7E9D  E3                          ex (sp),hl
      19.  02:7E9E  C9                          ret
      20.  02:7E9F                      
      21.  02:7E9F                      deviceFunctions:
      22.  02:7E9F  B5 7E                       dw identifyDevice               ; 0xff
      23.  02:7EA1  D5 7E                       dw open                         ;  0
      24.  02:7EA3  0D 7F                       dw close                        ;  2
      25.  02:7EA5  13 7F                       dw randomIO                     ;  4
      26.  02:7EA7  17 7F                       dw write                        ;  6
      27.  02:7EA9  1D 7F                       dw read                         ;  8
      28.  02:7EAB  73 7F                       dw loc                          ; 10
      29.  02:7EAD  85 7F                       dw lof                          ; 12
      30.  02:7EAF  51 7F                       dw eof                          ; 14
      31.  02:7EB1  85 7F                       dw fpos                         ; 16
      32.  02:7EB3  85 7F                       dw putback                      ; 18
      33.  02:7EB5                                
      34.  02:7EB5                      identifyDevice:
      35.  02:7EB5                              DEBUGMESSAGE "identifyDevice"
      35.  02:7EB5                    >         ifdef DEBUG
      35.  02:7EB5  52                >         ld d,d
      35.  02:7EB6  18 0E             >         jr .skip
      35.  02:7EB8                    >         db string
      35.  02:7EB8  69 64 65 6E 74 69 66 79 44 65 76 69 63 65 
      35.  02:7EC6                    > .skip:
      35.  02:7EC6                    >         endif
      36.  02:7EC6  21 CE 7E                    ld hl,deviceNameList
      37.  02:7EC9  CD 50 74                    call findStatementName
      38.  02:7ECC  7E                          ld a,(hl)                       ; device number
      39.  02:7ECD  C9                          ret                             ; carry is set when invalid device name
      40.  02:7ECE                              
      41.  02:7ECE                      deviceNameList:
      42.  02:7ECE  4E 4F 57 00 00 00           db "NOW",0,0,0                  ; name, end marker, device number, dummy
      43.  02:7ED4                              ;db "STDIN",0,1,0
      44.  02:7ED4  00                          db 0
      45.  02:7ED5                      
      46.  02:7ED5                      ; Input     D   Global device code
      47.  02:7ED5                      ;           E   File mode    
      48.  02:7ED5                      ;           HL  address fcb
      49.  02:7ED5                      open:
      50.  02:7ED5                      ;        DEBUGMESSAGE "open"
      51.  02:7ED5                      ;        DEBUGDUMPMEMHL 9
      52.  02:7ED5  22 64 F8                    ld (PTRFIL),hl
      53.  02:7ED8  CD 7C 74                    call sendRegisters
      54.  02:7EDB  36 88                       ld (hl),C_DEVICEOPEN
      55.  02:7EDD  EB                          ex de,hl
      56.  02:7EDE  01 0B 00                    ld bc,11
      57.  02:7EE1  21 66 F8                    ld hl,FILNAM
      58.  02:7EE4  ED B0                       ldir
      59.  02:7EE6                      
      60.  02:7EE6  CD 0D 76                    call enableNowindPage0
      61.  02:7EE9  26 20                       ld h,HIGH usbrd
      62.  02:7EEB  CD 8E 74                    call getHeader
      63.  02:7EEE  38 0C                       jr c,deviceIoError              ; time out?
      64.  02:7EF0  B7                          or a
      65.  02:7EF1  20 0B                       jr nz,openError
      66.  02:7EF3                      
      67.  02:7EF3  5E                          ld e,(hl)                       ; update fcb (including buffer)
      68.  02:7EF4  56                          ld d,(hl)
      69.  02:7EF5  4E                          ld c,(hl)
      70.  02:7EF6  46                          ld b,(hl)
      71.  02:7EF7  ED B0                       ldir
      72.  02:7EF9  C3 18 76                    jp restorePage0        
      73.  02:7EFC                      
      74.  02:7EFC                      deviceIoError:
      75.  02:7EFC  3E 13                       ld a,19
      76.  02:7EFE                      
      77.  02:7EFE                      openError:
      78.  02:7EFE  CD 18 76                    call restorePage0
      79.  02:7F01  5F                          ld e,a
      80.  02:7F02                      
      81.  02:7F02                      basicError:
      82.  02:7F02  DD 21 6F 40                 ld ix,$406f
      83.  02:7F06  FD 2A C0 FC                 ld iy,(EXPTBL-1)
      84.  02:7F0A  C3 1C 00                    jp CALSLT
      85.  02:7F0D                                      
      86.  02:7F0D                      close:
      87.  02:7F0D                      ;        DEBUGMESSAGE "close"
      88.  02:7F0D  CD 7C 74                    call sendRegisters
      89.  02:7F10  36 89                       ld (hl),C_DEVICECLOSE
      90.  02:7F12  C9                          ret
      91.  02:7F13                              
      92.  02:7F13                      randomIO:
      93.  02:7F13                      ;        DEBUGMESSAGE "randomIO"
      94.  02:7F13  1E 3D                       ld e,61                         ; bad file mode
      95.  02:7F15  18 EB                       jr basicError
      96.  02:7F17                      
      97.  02:7F17                      write:
      98.  02:7F17                      ;        DEBUGMESSAGE "write"
      99.  02:7F17  CD 7C 74                    call sendRegisters
     100.  02:7F1A  36 8B                       ld (hl),C_DEVICEWRITE
     101.  02:7F1C  C9                          ret        
     102.  02:7F1D                      
     103.  02:7F1D                      read:
     104.  02:7F1D                      ;        DEBUGMESSAGE "read"
     105.  02:7F1D  11 06 00                    ld de,6
     106.  02:7F20  19                          add hl,de
     107.  02:7F21  E5                          push hl
     108.  02:7F22  5E                          ld e,(hl)
     109.  02:7F23  23                          inc hl
     110.  02:7F24  23                          inc hl
     111.  02:7F25  23                          inc hl
     112.  02:7F26  19                          add hl,de
     113.  02:7F27  7E                          ld a,(hl)
     114.  02:7F28  E1                          pop hl
     115.  02:7F29  FE 1A                       cp $1a
     116.  02:7F2B  37                          scf
     117.  02:7F2C  C8                          ret z                           ; end of file
     118.  02:7F2D  3F                          ccf
     119.  02:7F2E  34                          inc (hl)                        ; increment position
     120.  02:7F2F  C0                          ret nz                          ; buffer empty?
     121.  02:7F30                              
     122.  02:7F30  F5                          push af
     123.  02:7F31  2B                          dec hl
     124.  02:7F32  34                          inc (hl)                        ; increment position (high)        
     125.  02:7F33  11 FB FF                    ld de,-5
     126.  02:7F36  19                          add hl,de
     127.  02:7F37  CD 7C 74                    call sendRegisters
     128.  02:7F3A  36 8C                       ld (hl),C_DEVICEREAD
     129.  02:7F3C  CD 0D 76                    call enableNowindPage0
     130.  02:7F3F  26 20                       ld h,HIGH usbrd
     131.  02:7F41  CD 8E 74                    call getHeader
     132.  02:7F44  38 B6                       jr c,deviceIoError
     133.  02:7F46                      
     134.  02:7F46  5E                          ld e,(hl)
     135.  02:7F47  56                          ld d,(hl)
     136.  02:7F48  4E                          ld c,(hl)
     137.  02:7F49  46                          ld b,(hl)
     138.  02:7F4A  ED B0                       ldir                            ; update fcb buffer
     139.  02:7F4C  CD 18 76                    call restorePage0
     140.  02:7F4F  F1                          pop af                          ; return last character
     141.  02:7F50  C9                          ret
     142.  02:7F51                      
     143.  02:7F51                      eof:
     144.  02:7F51                      ;        DEBUGMESSAGE "eof"
     145.  02:7F51  7E                          ld a,(hl)
     146.  02:7F52  FE 01                       cp 1                            ; input mode?        
     147.  02:7F54  1E 3D                       ld e,61                         ; bad file mode
     148.  02:7F56  C2 02 7F                    jp nz,basicError
     149.  02:7F59                                      
     150.  02:7F59  11 06 00                    ld de,6
     151.  02:7F5C  19                          add hl,de
     152.  02:7F5D  5E                          ld e,(hl)
     153.  02:7F5E  23                          inc hl
     154.  02:7F5F  23                          inc hl
     155.  02:7F60  23                          inc hl
     156.  02:7F61  19                          add hl,de
     157.  02:7F62  7E                          ld a,(hl)
     158.  02:7F63  ED 62                       sbc hl,hl
     159.  02:7F65  FE 1A                       cp $1a        
     160.  02:7F67  20 01                       jr nz,.skip
     161.  02:7F69  2B                          dec hl
     162.  02:7F6A  22 F8 F7            .skip:  ld (DAC+2),hl
     163.  02:7F6D  3E 02                       ld a,2
     164.  02:7F6F  32 63 F6                    ld (VALTYP),a
     165.  02:7F72  C9                          ret
     166.  02:7F73                      
     167.  02:7F73                      loc:
     168.  02:7F73  E5                          push hl
     169.  02:7F74  FD E1                       pop iy
     170.  02:7F76  FD 6E 06                    ld l,(iy+6)
     171.  02:7F79  FD 66 05                    ld h,(iy+5)
     172.  02:7F7C                      ;        DEBUGASSERT
     173.  02:7F7C  22 F8 F7                    ld (DAC+2),hl
     174.  02:7F7F  3E 02                       ld a,2
     175.  02:7F81  32 63 F6                    ld (VALTYP),a
     176.  02:7F84  C9                          ret
     177.  02:7F85                              
     178.  02:7F85                      putback:
     179.  02:7F85                      ;        DEBUGMESSAGE "putback"
     180.  02:7F85                      ;        push hl
     181.  02:7F85                      ;        pop iy
     182.  02:7F85                      ;        ld (iy+3),c
     183.  02:7F85                      ;        DEBUGASSERT
     184.  02:7F85                      ;        ret
     185.  02:7F85                      
     186.  02:7F85                      lof:
     187.  02:7F85                      fpos:
     188.  02:7F85                              DEBUGMESSAGE "no support!"
     188.  02:7F85                    >         ifdef DEBUG
     188.  02:7F85  52                >         ld d,d
     188.  02:7F86  18 0B             >         jr .skip
     188.  02:7F88                    >         db string
     188.  02:7F88  6E 6F 20 73 75 70 70 6F 72 74 21 
     188.  02:7F93                    > .skip:
     188.  02:7F93                    >         endif
     189.  02:7F93                      
     190.  02:7F93                      illegalFunctionCall:
     191.  02:7F93  1E 05                       ld e,5
     192.  02:7F95  C3 02 7F                    jp basicError
     193.  02:7F98                      
     194.  02:7F98                      ;FCB for DISK BASIC
     195.  02:7F98                      ; +0 FL.MOD     file mode
     196.  02:7F98                      ; +1 FL.FCA     Pointer to FCB for BDOS (low)
     197.  02:7F98                      ; +2 FL.LCA     Pointer to FCB for BDOS (high)
     198.  02:7F98                      ; +3 FL.LSA     Back up character
     199.  02:7F98                      ; +4 FL.DSK     device number
     200.  02:7F98                      ; +5 FL.SLB
     201.  02:7F98                      ; +6 FL.BPS     Position in FL.BUF
     202.  02:7F98                      ; +7 FL.FLG     Holds various information
     203.  02:7F98                      ; +8 FL.OPS     Pseudo head position
     204.  02:7F98                      ; +9 FL.BUF     256-byte file buffer
     205.  02:7F98                      
     206.  02:7F98                      ; device codes
     207.  02:7F98                      ;          SS0           SS1           SS2           SS3
     208.  02:7F98                      ;    ---------------------------------------------------------
     209.  02:7F98                      ;    | 00 04 08 0C | 10 14 18 1C | 20 24 28 2C | 30 34 38 3C | PS0
     210.  02:7F98                      ;    ---------------------------------------------------------
     211.  02:7F98                      ;    | 40 44 48 4C | 50 54 58 5C | 60 64 68 6C | 70 74 78 7C | PS1
     212.  02:7F98                      ;    ---------------------------------------------------------
     213.  02:7F98                      ;    | 80 84 88 8C | 90 94 98 9C | A0 A4 A8 AC | B0 B4 B8 BC | PS2
     214.  02:7F98                      ;    ---------------------------------------------------------
     215.  02:7F98                      ;    | C0 C4 C8 CC | D0 D4 D8 DC | E0 E4 E8 EC | F0 F4 F8 FC | PS3
     216.  02:7F98                      ;    ---------------------------------------------------------
     217.  02:7F98                      
     218.  02:7F98                      ; fileModes
     219.  02:7F98                      ; FOR INPUT (01H)
     220.  02:7F98                      ; FOR OUTPUT (02H)
     221.  02:7F98                      ; FOR APPEND (08H)
     222.  02:7F98                      ; random mode (04H)
     223.  02:7F98                      
     224.  02:7F98                      ; maximum number of files open: MAXFILES=15
     225.  02:7F98                              
     226.  02:7F98                      ; File Control Block
     227.  02:7F98                      ;       0     1     2     3     4     5     6     7     8
     228.  02:7F98                      ;    -------------------------------------------------------
     229.  02:7F98                      ;    | Mod | 00H | 00H | 00H | DEV | 00H | POS | 00H | PPS |
     230.  02:7F98                      ;    -------------------------------------------------------
     231.  02:7F98                      ;                  err? bckup       posHi 
     232.  02:7F98                      ; followed by a 256 byte buffer
     197   02:7F98                              
     198   02:7F98                              ifdef BDOS_NOWIND
     199   02:7F98                    ~         include "nowindbdos.asm"
     200   02:7F98                    ~         endif
     201   02:7F98                              
     202   02:7F98  FF (92)                    ds $8000-(endCopyFromBank-copyFromBank)-$, $ff
     203   02:7FF4                      
     204   02:7FF4                      ; bank switching and data transfer
     205   02:7FF4                      copyFromBank:
     206   02:7FF4  32 01 60                    ld (mapper),a
     207   02:7FF7  ED B0                       ldir
     208   02:7FF9                      enableBank0:
     209   02:7FF9  AF                          xor a
     210   02:7FFA  F5                          push af
     211   02:7FFB  32 01 60                    ld (mapper),a
     212   02:7FFE  F1                          pop af
     213   02:7FFF  C9                          ret
     214   02:8000                      endCopyFromBank:
     215   02:8000                      
     216   02:8000  (03)                        page 3
     217   03:0000  BA (442368)                 ds (512-80)*1024, $ba

    LABELS
---------------------------------------
00:0000000C X RDSLT
00:00000014 X WRSLT
00:0000001C   CALSLT
00:00000024   ENASLT
00:0000005F   CHGMOD
00:00000141   SNSMAT
00:0000015F   EXTROM
00:00000185   SDFSCR
00:0000F33F   LASTDRV
00:0000F342   RAMAD1
00:0000F36E   XFER
00:0000F663   VALTYP
00:0000F7F6   DAC
00:0000F864   PTRFIL
00:0000F866   FILNAM
00:0000FCC1   EXPTBL
00:0000FCC5   SLTTBL
00:0000FCC9 X SLTATR
00:0000FD09   SLTWRK
00:0000FD89   PROCNM
00:0000FD99   DEVICE
00:0000FFCA   EXTBIO
00:0000402D   GETSLT
00:0000FECB X H.RUNC
00:00004000   usbwr
00:00002000   usbrd
00:00008000   usb2
00:00006001   mapper
00:00000080   C_DSKIO
00:00000081   C_DSKCHG
00:00000082   C_GETDPB
00:00000083 X C_CHOICE
00:00000084 X C_DSKFMT
00:00000085   C_DRIVES
00:00000086   C_INIENV
00:00000087 X C_SETDATE
00:00000088   C_DEVICEOPEN
00:00000089   C_DEVICECLOSE
00:0000008A X C_DEVICERNDIO
00:0000008B   C_DEVICEWRITE
00:0000008C   C_DEVICEREAD
00:0000008D X C_DEVICEEOF
00:0000008E   C_AUXIN
00:0000008F   C_AUXOUT
00:00000090   C_MESSAGE
00:00000091   C_CHANGEIMAGE
00:00000092   C_BOOTARGS
00:00000093 X C_CMDREQUEST
00:000072F0   MSXDOS2_PART.getBootArgs
00:00007307   MSXDOS2_PART.bootMSXDOS1
00:00007310   MSXDOS2_PART.nowindInit
00:00007343   MSXDOS2_PART.initDiskBasic
00:0000735B   MSXDOS2_PART.findStatementName
00:00007372   MSXDOS2_PART.findStatementName.loop
00:0000737C   MSXDOS2_PART.findStatementName.nextStatement
00:00007387   MSXDOS2_PART.sendRegisters
00:00007399   MSXDOS2_PART.getHeader
00:0000739B   MSXDOS2_PART.getHeader.loop
00:0000739C   MSXDOS2_PART.getHeader.chkaf
00:000073C0   MSXDOS2_PART.getHeader.chk05
00:000073C7   MSXDOS2_PART.sendMessage
00:000073D1   MSXDOS2_PART.sendMessage.loop
00:000073DD   MSXDOS2_PART.newAUX
00:000073E7   MSXDOS2_PART.AUXin
00:00007415   MSXDOS2_PART.AUXin.exit
00:0000741B   MSXDOS2_PART.AUXin.getCharacter
00:0000742C   MSXDOS2_PART.AUXout
00:00007444 X MSXDOS2_PART.sdendFCB
00:00007448   MSXDOS2_PART.sdendFCB.loop
00:00007452 X MSXDOS2_PART.receiveFCB
00:00007456   MSXDOS2_PART.receiveFCB.loop
00:00007463   MSXDOS2_PART.installExtendedBios
00:00007498   MSXDOS2_PART.extendedBios
00:0000749F   MSXDOS2_PART.extendedBios.exit
00:000074AD   MSXDOS2_PART.determineFunction
00:000074B9   MSXDOS2_PART.functionTable
00:000074BF   MSXDOS2_PART.getNowindSlot
00:000074DB   MSXDOS2_PART.numberOfDevices
00:000074F2   MSXDOS2_PART.debugMessage
00:0000750E   MSXDOS2_PART.debugMessage.loop
00:00007518   MSXDOS2_PART.enableNowindPage0
00:00007523   MSXDOS2_PART.restorePage0
00:0000752C   MSXDOS2_PART.enableSlotPage0
00:0000753D   MSXDOS2_PART.enableSlotPage0.expanded
00:00007568   MSXDOS2_PART.getSlotPage0
00:00007573   MSXDOS2_PART.getSlotPage1
00:0000757E   MSXDOS2_PART.getSlotPage2
00:0000758D   MSXDOS2_PART.expanded
00:000075A1   MSXDOS2_PART.notExpanded
00:000075A3   MSXDOS2_PART.getEntrySLTWRK
00:00000008   MSXDOS2_PART.MYSIZE
00:00000200   MSXDOS2_PART.SECLEN
00:000075B8   MSXDOS2_PART.INIHRD
00:000075C7   MSXDOS2_PART.INIHRD.loop
00:000075DB   MSXDOS2_PART.DRIVES
00:0000761E   MSXDOS2_PART.DRIVES.exit
00:00007627   MSXDOS2_PART.DRIVES.notconnected
00:00007644   MSXDOS2_PART.INIENV
00:00007688   MSXDOS2_PART.INIENV.exit
00:0000768B   MSXDOS2_PART.checkWorkArea
00:0000769A   MSXDOS2_PART.DSKIO
00:000076B1 X MSXDOS2_PART.dskioRead
00:0000B6CE   MSXDOS2_PART.dskioRead.page2
00:000076E3   MSXDOS2_PART.dskioRead.page1
00:000076F3   MSXDOS2_PART.dskioRead.page2and3
00:00007709   MSXDOS2_PART.dskioWrite
00:0000B729   MSXDOS2_PART.dskioWrite.page2
00:0000773F   MSXDOS2_PART.dskioWrite.page1
00:00007755   MSXDOS2_PART.dskioWrite.page2and3
00:0000776A   MSXDOS2_PART.dskioWrite.writeLoop23
00:0000779A   MSXDOS2_PART.dskioWrite.error
00:0000779D   MSXDOS2_PART.DSKCHG
00:000077D4   MSXDOS2_PART.GETDPB
00:0000780A   MSXDOS2_PART.GETDPB.hddImage
00:0000783D   MSXDOS2_PART.GETDPB.exit
00:00007840   MSXDOS2_PART.CHOICE
00:00007844 X MSXDOS2_PART.CHOICE.noFormat
00:00007845   MSXDOS2_PART.DSKFMT
00:0000B849   MSXDOS2_PART.readSectors01
00:0000B86B   MSXDOS2_PART.readSectors01.slowTransfer
00:0000B877   MSXDOS2_PART.writeLoop01
00:0000B899   MSXDOS2_PART.writeLoop01.error
00:0000789C   MSXDOS2_PART.readSectors23
00:000078C0   MSXDOS2_PART.readSectors23.slowTransfer
00:000078DD   MSXDOS2_PART.reverseTransfer
00:000078E9   MSXDOS2_PART.reverseTransfer.loop
00:00007950   MSXDOS2_PART.OEMSTA
00:0000795E   MSXDOS2_PART.OEMSTA.statement
00:00007971   MSXDOS2_PART.changeImage
00:00007986   MSXDOS2_PART.call_exit
00:00007992   MSXDOS2_PART.call_exit.loop
00:0000799E   MSXDOS2_PART.videoStream
00:0000799F X MSXDOS2_PART.vramDump
00:000079AB   MSXDOS2_PART.evenFrame
00:000079C8 X MSXDOS2_PART.oddFrame
00:000079E8   MSXDOS2_PART.tranferframe
00:000079F5   MSXDOS2_PART.write_more
00:00007B02   MSXDOS2_PART.changeColors
00:00007B50   MSXDOS2_PART.setVramAccessPointer
00:00007B5E   MSXDOS2_PART.waitForRetrace
00:00007B64   MSXDOS2_PART.waitForRetrace.lp2
00:00007B6F   MSXDOS2_PART.printVdpText2
00:00007B70   MSXDOS2_PART.printVdpText2.loop
00:00007B79   MSXDOS2_PART.supportedMedia
00:00007B79 X MSXDOS2_PART.supportedMedia.f8
00:00007B8B   MSXDOS2_PART.supportedMedia.def
00:00007B8B   MSXDOS2_PART.DEFDPB
00:00007C09   MSXDOS2_PART.ROMDISK_DSKIO
00:00007C18   MSXDOS2_PART.ROMDISK_DSKIO.loop
00:00007C3A   MSXDOS2_PART.ROMDISK_DSKIO.directCopy
00:00007C40   MSXDOS2_PART.ROMDISK_DSKIO.nextSector
00:00007C46   MSXDOS2_PART.ROMDISK_DSKIO.findSector
00:00007C5B   MSXDOS2_PART.ROMDISK_DSKIO.skip
00:00007C68   MSXDOS2_PART.ROMDISK_DSKCHG
00:00007C6D X MSXDOS2_PART.ROMDISK_GETDPB
00:00007C6D X MSXDOS2_PART.ROMDISK_DSKFMT
00:00007C6D   MSXDOS2_PART.flashWriter
00:00007CBD   MSXDOS2_PART.flashWriter.source
00:0000C000   MSXDOS2_PART.waitForHeader
00:0000C003   MSXDOS2_PART.waitForHeader.chkbb
00:0000C024   MSXDOS2_PART.autoselectMode
00:0000C03A   MSXDOS2_PART.eraseSector
00:0000C056   MSXDOS2_PART.waitForCommandToComplete
00:0000C066   MSXDOS2_PART.writeResetCommand
00:0000C06C   MSXDOS2_PART.chipErase
00:0000C07A   MSXDOS2_PART.chipErase.wait
00:0000C084   MSXDOS2_PART.writeFlash
00:0000C093   MSXDOS2_PART.writeFlash.loop
00:0000C09D   MSXDOS2_PART.writeFlash.wait
00:0000C0A9   MSXDOS2_PART.verifyFlash
00:0000C0B4   MSXDOS2_PART.verifyFlash.loop
00:0000C0BD   MSXDOS2_PART.acknowledge
00:0000C0C7   MSXDOS2_PART.updateBar
00:0000C0CC   MSXDOS2_PART.writeCommandSequence
00:0000C0DB   MSXDOS2_PART.flasherEnd
00:00007D98   MSXDOS2_PART.device
00:00007DA4   MSXDOS2_PART.device.nocy
00:00007DAA   MSXDOS2_PART.deviceFunctions
00:00007DC0   MSXDOS2_PART.identifyDevice
00:00007DD9   MSXDOS2_PART.deviceNameList
00:00007DE0   MSXDOS2_PART.open
00:00007E07   MSXDOS2_PART.deviceIoError
00:00007E09   MSXDOS2_PART.openError
00:00007E0D   MSXDOS2_PART.basicError
00:00007E18   MSXDOS2_PART.close
00:00007E1E   MSXDOS2_PART.randomIO
00:00007E22   MSXDOS2_PART.write
00:00007E28   MSXDOS2_PART.read
00:00007E5C   MSXDOS2_PART.eof
00:00007E75   MSXDOS2_PART.eof.skip
00:00007E7E   MSXDOS2_PART.loc
00:00007E90   MSXDOS2_PART.putback
00:00007E90   MSXDOS2_PART.lof
00:00007E90   MSXDOS2_PART.fpos
00:00007E9E X MSXDOS2_PART.illegalFunctionCall
00:00007FF4   MSXDOS2_PART.copyFromBank
00:00007FF9 X MSXDOS2_PART.enableBank0
00:00007FFA   MSXDOS2_PART.switchBank
00:00008000   MSXDOS2_PART.endCopyFromBank
02:00007405   MSXDOS1_PART.nowindInit
02:00007438   MSXDOS1_PART.initDiskBasic
02:00007450   MSXDOS1_PART.findStatementName
02:00007467   MSXDOS1_PART.findStatementName.loop
02:00007471   MSXDOS1_PART.findStatementName.nextStatement
02:0000747C   MSXDOS1_PART.sendRegisters
02:0000748E   MSXDOS1_PART.getHeader
02:00007490   MSXDOS1_PART.getHeader.loop
02:00007491   MSXDOS1_PART.getHeader.chkaf
02:000074B5   MSXDOS1_PART.getHeader.chk05
02:000074BC   MSXDOS1_PART.sendMessage
02:000074C6   MSXDOS1_PART.sendMessage.loop
02:000074D2   MSXDOS1_PART.newAUX
02:000074DC   MSXDOS1_PART.AUXin
02:0000750A   MSXDOS1_PART.AUXin.exit
02:00007510   MSXDOS1_PART.AUXin.getCharacter
02:00007521   MSXDOS1_PART.AUXout
02:00007539 X MSXDOS1_PART.sdendFCB
02:0000753D   MSXDOS1_PART.sdendFCB.loop
02:00007547 X MSXDOS1_PART.receiveFCB
02:0000754B   MSXDOS1_PART.receiveFCB.loop
02:00007558   MSXDOS1_PART.installExtendedBios
02:0000758D   MSXDOS1_PART.extendedBios
02:00007594   MSXDOS1_PART.extendedBios.exit
02:000075A2   MSXDOS1_PART.determineFunction
02:000075AE   MSXDOS1_PART.functionTable
02:000075B4   MSXDOS1_PART.getNowindSlot
02:000075D0   MSXDOS1_PART.numberOfDevices
02:000075E7   MSXDOS1_PART.debugMessage
02:00007603   MSXDOS1_PART.debugMessage.loop
02:0000760D   MSXDOS1_PART.enableNowindPage0
02:00007618   MSXDOS1_PART.restorePage0
02:00007621   MSXDOS1_PART.enableSlotPage0
02:00007632   MSXDOS1_PART.enableSlotPage0.expanded
02:0000765D   MSXDOS1_PART.getSlotPage0
02:00007668   MSXDOS1_PART.getSlotPage1
02:00007673   MSXDOS1_PART.getSlotPage2
02:00007682   MSXDOS1_PART.expanded
02:00007696   MSXDOS1_PART.notExpanded
02:00007698   MSXDOS1_PART.getEntrySLTWRK
02:00000008   MSXDOS1_PART.MYSIZE
02:00000200   MSXDOS1_PART.SECLEN
02:000076AD   MSXDOS1_PART.INIHRD
02:000076BC   MSXDOS1_PART.INIHRD.loop
02:000076D0   MSXDOS1_PART.DRIVES
02:00007713   MSXDOS1_PART.DRIVES.exit
02:0000771C   MSXDOS1_PART.DRIVES.notconnected
02:00007739   MSXDOS1_PART.INIENV
02:0000777D   MSXDOS1_PART.INIENV.exit
02:00007780   MSXDOS1_PART.checkWorkArea
02:0000778F   MSXDOS1_PART.DSKIO
02:000077A6 X MSXDOS1_PART.dskioRead
02:0000B7C3   MSXDOS1_PART.dskioRead.page2
02:000077D8   MSXDOS1_PART.dskioRead.page1
02:000077E8   MSXDOS1_PART.dskioRead.page2and3
02:000077FE   MSXDOS1_PART.dskioWrite
02:0000B81E   MSXDOS1_PART.dskioWrite.page2
02:00007834   MSXDOS1_PART.dskioWrite.page1
02:0000784A   MSXDOS1_PART.dskioWrite.page2and3
02:0000785F   MSXDOS1_PART.dskioWrite.writeLoop23
02:0000788F   MSXDOS1_PART.dskioWrite.error
02:00007892   MSXDOS1_PART.DSKCHG
02:000078C9   MSXDOS1_PART.GETDPB
02:000078FF   MSXDOS1_PART.GETDPB.hddImage
02:00007932   MSXDOS1_PART.GETDPB.exit
02:00007935   MSXDOS1_PART.CHOICE
02:00007939 X MSXDOS1_PART.CHOICE.noFormat
02:0000793A   MSXDOS1_PART.DSKFMT
02:0000B93E   MSXDOS1_PART.readSectors01
02:0000B960   MSXDOS1_PART.readSectors01.slowTransfer
02:0000B96C   MSXDOS1_PART.writeLoop01
02:0000B98E   MSXDOS1_PART.writeLoop01.error
02:00007991   MSXDOS1_PART.readSectors23
02:000079B5   MSXDOS1_PART.readSectors23.slowTransfer
02:000079D2   MSXDOS1_PART.reverseTransfer
02:000079DE   MSXDOS1_PART.reverseTransfer.loop
02:00007A45   MSXDOS1_PART.OEMSTA
02:00007A53   MSXDOS1_PART.OEMSTA.statement
02:00007A66   MSXDOS1_PART.changeImage
02:00007A7B   MSXDOS1_PART.call_exit
02:00007A87   MSXDOS1_PART.call_exit.loop
02:00007A93   MSXDOS1_PART.videoStream
02:00007A94 X MSXDOS1_PART.vramDump
02:00007AA0   MSXDOS1_PART.evenFrame
02:00007ABD X MSXDOS1_PART.oddFrame
02:00007ADD   MSXDOS1_PART.tranferframe
02:00007AEA   MSXDOS1_PART.write_more
02:00007BF7   MSXDOS1_PART.changeColors
02:00007C45   MSXDOS1_PART.setVramAccessPointer
02:00007C53   MSXDOS1_PART.waitForRetrace
02:00007C59   MSXDOS1_PART.waitForRetrace.lp2
02:00007C64   MSXDOS1_PART.printVdpText2
02:00007C65   MSXDOS1_PART.printVdpText2.loop
02:00007C6E   MSXDOS1_PART.supportedMedia
02:00007C6E X MSXDOS1_PART.supportedMedia.f8
02:00007C80   MSXDOS1_PART.supportedMedia.def
02:00007C80   MSXDOS1_PART.DEFDPB
02:00007CFE   MSXDOS1_PART.ROMDISK_DSKIO
02:00007D0D   MSXDOS1_PART.ROMDISK_DSKIO.loop
02:00007D2F   MSXDOS1_PART.ROMDISK_DSKIO.directCopy
02:00007D35   MSXDOS1_PART.ROMDISK_DSKIO.nextSector
02:00007D3B   MSXDOS1_PART.ROMDISK_DSKIO.findSector
02:00007D50   MSXDOS1_PART.ROMDISK_DSKIO.skip
02:00007D5D   MSXDOS1_PART.ROMDISK_DSKCHG
02:00007D62 X MSXDOS1_PART.ROMDISK_GETDPB
02:00007D62 X MSXDOS1_PART.ROMDISK_DSKFMT
02:00007D62   MSXDOS1_PART.flashWriter
02:00007DB2   MSXDOS1_PART.flashWriter.source
02:0000C000   MSXDOS1_PART.waitForHeader
02:0000C003   MSXDOS1_PART.waitForHeader.chkbb
02:0000C024   MSXDOS1_PART.autoselectMode
02:0000C03A   MSXDOS1_PART.eraseSector
02:0000C056   MSXDOS1_PART.waitForCommandToComplete
02:0000C066   MSXDOS1_PART.writeResetCommand
02:0000C06C   MSXDOS1_PART.chipErase
02:0000C07A   MSXDOS1_PART.chipErase.wait
02:0000C084   MSXDOS1_PART.writeFlash
02:0000C093   MSXDOS1_PART.writeFlash.loop
02:0000C09D   MSXDOS1_PART.writeFlash.wait
02:0000C0A9   MSXDOS1_PART.verifyFlash
02:0000C0B4   MSXDOS1_PART.verifyFlash.loop
02:0000C0BD   MSXDOS1_PART.acknowledge
02:0000C0C7   MSXDOS1_PART.updateBar
02:0000C0CC   MSXDOS1_PART.writeCommandSequence
02:0000C0DB   MSXDOS1_PART.flasherEnd
02:00007E8D   MSXDOS1_PART.device
02:00007E99   MSXDOS1_PART.device.nocy
02:00007E9F   MSXDOS1_PART.deviceFunctions
02:00007EB5   MSXDOS1_PART.identifyDevice
02:00007ECE   MSXDOS1_PART.deviceNameList
02:00007ED5   MSXDOS1_PART.open
02:00007EFC   MSXDOS1_PART.deviceIoError
02:00007EFE   MSXDOS1_PART.openError
02:00007F02   MSXDOS1_PART.basicError
02:00007F0D   MSXDOS1_PART.close
02:00007F13   MSXDOS1_PART.randomIO
02:00007F17   MSXDOS1_PART.write
02:00007F1D   MSXDOS1_PART.read
02:00007F51   MSXDOS1_PART.eof
02:00007F6A   MSXDOS1_PART.eof.skip
02:00007F73   MSXDOS1_PART.loc
02:00007F85   MSXDOS1_PART.putback
02:00007F85   MSXDOS1_PART.lof
02:00007F85   MSXDOS1_PART.fpos
02:00007F93 X MSXDOS1_PART.illegalFunctionCall
02:00007FF4   MSXDOS1_PART.copyFromBank
02:00007FF9 X MSXDOS1_PART.enableBank0
02:00008000   MSXDOS1_PART.endCopyFromBank


Output: nowind.out
--------------------------------------

 Page: 00
  Org: 00000000  Size: *  Used: 00000000

    No output

Output: nowind.rom
--------------------------------------

 Page: 00
  Org: 00004000  Size: 00004000  Used: 00004000

   Address   Length Align  Label
   00004000   13040        
   000072F0    3344     @  MSXDOS2_PART.getBootArgs

  Overlay parts:
   Address   Length Align  Label
   00004006       2     @  
   00004010      18     @  
   00004093       2     @  
   000047D7       2     @  
   00004881       1     @  
   00004884       1     @  
   0000488D       2     @  
   0000489F       2     @  
   000048B9       2     @  
   000048EB       2     @  
   000048F7       2     @  
   000049A3      16     @  
   00005797       2     @  

 Page: 01
  Org: 00004000  Size: 0000C000  Used: 0000C000

   Address   Length Align  Label
   00004000   49152        

  Overlay parts:
   Address   Length Align  Label
   00004093       2     @  
   00008093       2     @  
   0000C093       2     @  

 Page: 02
  Org: 00004000  Size: 00004000  Used: 00004000

   Address   Length Align  Label
   00004000   13317        
   00007405    3067     @  MSXDOS1_PART.nowindInit

  Overlay parts:
   Address   Length Align  Label
   00004006       2     @  
   00004010      18     @  
   00005770       2     @  
   000057AA       2     @  
   00005809       2     @  
   0000581E       2     @  
   0000582F       2     @  
   00005851       2     @  
   00005884       2     @  
   00005890       2     @  
   0000595D      15     @  
   00005AE8       2     @  
   000065AF       2     @  

 Page: 03
  Org: 00000000  Size: 0006C000  Used: 0006C000

   Address   Length Align  Label
   00000000  442368        

Sjasm Z80 Assembler v0.4 BETA 6 - www.xl2s.tk             [2010.02.07 - 21:54:51]

d:\project\nowindlibraries\msxsrc\nowind.asm
Errors: 0

       1   00:0000                              define  DEBUG
       2   00:0000                              
       3   00:0000                      	;define	NOWINDVERSION_FIRSTBATCH			; our handmade first batch
       4   00:0000                      	define	NOWINDVERSION_SUNRISE				; sunrise first batch
       5   00:0000                      		        
       6   00:0000                      	ifdef	NOWINDVERSION_FIRSTBATCH
       7   00:0000                    ~ 	define	FLASHROMSIZE 512
       8   00:0000                    ~ 	endif
       9   00:0000                      		
      10   00:0000                      	ifdef	NOWINDVERSION_SUNRISE
      11   00:0000                      	define	FLASHROMSIZE 4096
      12   00:0000                      	endif
      13   00:0000                      		
      14   00:0000                      	output	"nowind.rom"
      15   00:0000                      	include "labels.asm"
       1.  00:0000                      ; BIOS routines
       2.  00:0000  (00:000C)           RDSLT           equ $000c
       3.  00:0000  (00:0014)           WRSLT           equ $0014
       4.  00:0000  (00:001C)           CALSLT          equ $001c
       5.  00:0000  (00:0024)           ENASLT          equ $0024
       6.  00:0000  (00:005F)           CHGMOD          equ $005f
       7.  00:0000  (00:0141)           SNSMAT          equ $0141
       8.  00:0000  (00:015F)           EXTROM          equ $015f
       9.  00:0000  (00:0185)           SDFSCR          equ $0185               ; restore screen parameters from clockchip (in SUBROM)
      10.  00:0000                      
      11.  00:0000                      ; BIOS variables (really?)
      12.  00:0000  (00:F33F)           LASTDRV         equ $f33f               ; stores CTRL-key status during boot
      13.  00:0000  (00:F342)           RAMAD1          equ $f342
      14.  00:0000  (00:F36E)           XFER            equ $f36e
      15.  00:0000                       
      16.  00:0000  (00:F663)           VALTYP          equ $f663
      17.  00:0000  (00:F7F6)           DAC             equ $f7f6
      18.  00:0000  (00:F864)           PTRFIL          equ $f864
      19.  00:0000  (00:F866)           FILNAM          equ $f866
      20.  00:0000                      
      21.  00:0000  (00:FCC1)           EXPTBL          equ $fcc1
      22.  00:0000  (00:FCC5)           SLTTBL          equ $fcc5
      23.  00:0000  (00:FCC9)           SLTATR          equ $fcc9
      24.  00:0000  (00:FD09)           SLTWRK          equ $fd09
      25.  00:0000  (00:FD89)           PROCNM          equ $fd89
      26.  00:0000  (00:FD99)           DEVICE          equ $fd99
      27.  00:0000  (00:FFCA)           EXTBIO          equ $ffca
      28.  00:0000                      
      29.  00:0000                      ; Diskrom routines
      30.  00:0000  (00:402D)           GETSLT          equ $402d
      31.  00:0000                               
      32.  00:0000                      ; Hooks
      33.  00:0000  (00:FECB)           H.RUNC          equ $fecb               ; Intercepted by diskrom
      34.  00:0000                      
      35.  00:0000                      ; Nowind hardware addresses
      36.  00:0000  (00:4000)           usbwr           equ $4000               ; 0x4000..0x5fff
      37.  00:0000  (00:2000)           usbrd           equ $2000               ; 0x2000..0x3fff
      38.  00:0000  (00:8000)           usb2            equ $8000               ; 0x8000..0x9fff (read and write)
      39.  00:0000  (00:6001)           mapper          equ $6001               ; 0x6001..0x7fff (odd numbers only)
      40.  00:0000                      
      41.  00:0000                      ; Host commands
      42.  00:0000  (00:0080)           C_DSKIO         equ $80
      43.  00:0000  (00:0081)           C_DSKCHG        equ $81
      44.  00:0000  (00:0082)           C_GETDPB        equ $82
      45.  00:0000  (00:0083)           C_CHOICE        equ $83
      46.  00:0000  (00:0084)           C_DSKFMT        equ $84
      47.  00:0000  (00:0085)           C_DRIVES        equ $85
      48.  00:0000  (00:0086)           C_INIENV        equ $86
      49.  00:0000  (00:0087)           C_SETDATE       equ $87
      50.  00:0000  (00:0088)           C_DEVICEOPEN    equ $88
      51.  00:0000  (00:0089)           C_DEVICECLOSE   equ $89
      52.  00:0000  (00:008A)           C_DEVICERNDIO   equ $8a
      53.  00:0000  (00:008B)           C_DEVICEWRITE   equ $8b
      54.  00:0000  (00:008C)           C_DEVICEREAD    equ $8c
      55.  00:0000  (00:008D)           C_DEVICEEOF     equ $8d
      56.  00:0000  (00:008E)           C_AUXIN         equ $8e
      57.  00:0000  (00:008F)           C_AUXOUT        equ $8f
      58.  00:0000  (00:0090)           C_MESSAGE       equ $90
      59.  00:0000  (00:0091)           C_CHANGEIMAGE   equ $91
      60.  00:0000  (00:0092)           C_GETDOSVERSION equ $92
      61.  00:0000  (00:0093)           C_CMDREQUEST    equ $93
      62.  00:0000                      
      63.  00:0000                      ; BDOS commands 0x0F- 0x37 can just use their original command code in register C
      64.  00:0000                      
      65.  00:0000                      ; PATCH       
      66.  00:0000                              macro PATCH address, word
      67.  00:0000                    <         code ! address
      68.  00:0000                    <         dw word
      69.  00:0000                    <         endmacro
      70.  00:0000                      
      71.  00:0000                      ; DEBUGMESSAGE
      72.  00:0000                              macro DEBUGMESSAGE string
      73.  00:0000                    <         ifdef DEBUG
      74.  00:0000                    <         ld d,d
      75.  00:0000                    <         jr .skip
      76.  00:0000                    <         db string
      77.  00:0000                    < .skip:  
      78.  00:0000                    <         endif
      79.  00:0000                    <         endmacro
      80.  00:0000                      
      81.  00:0000                      ; MESSAGE
      82.  00:0000                              macro MESSAGE string
      83.  00:0000                    <         call sendMessage
      84.  00:0000                    <         db string
      85.  00:0000                    < .skip2: nop
      86.  00:0000                    <         endmacro
      87.  00:0000                      
      88.  00:0000                      ; DEBUGDUMPREGISTERS
      89.  00:0000                              macro DEBUGDUMPREGISTERS
      90.  00:0000                    <         ifdef DEBUG
      91.  00:0000                    <         db $ed,7
      92.  00:0000                    <         endif
      93.  00:0000                    <         
      94.  00:0000                    <         ifdef USBDEBUG
      95.  00:0000                    <         assert ($ < $8000)
      96.  00:0000                    <         call sendCpuInfo
      97.  00:0000                    <         endif
      98.  00:0000                    <         endmacro
      99.  00:0000                      
     100.  00:0000                      ; MAKEDPB macro
     101.  00:0000                              macro MAKEDPB media, sectorSize, sectorsPerCluster, maxEnt, maxSector, fatSiz, fatCount
     102.  00:0000                    < .firfat equ 1
     103.  00:0000                    < .firdir equ .firfat+(fatCount*fatSiz)
     104.  00:0000                    < .firrec equ .firdir+(maxEnt/(sectorSize/32))
     105.  00:0000                    <         if sectorSize = 512
     106.  00:0000                    < .shft   equ 4
     107.  00:0000                    <         elseif sectorSize = 256
     108.  00:0000                    < .shft   equ 3
     109.  00:0000                    <         endif
     110.  00:0000                    <         
     111.  00:0000                    <         db media                                        ; media descriptor
     112.  00:0000                    <         dw sectorSize                                   ; sector size
     113.  00:0000                    <         db (sectorSize/32)-1, .shft                     ; dirmsk
     114.  00:0000                    <         db sectorsPerCluster-1                          ; clusmsk 
     115.  00:0000                    <         db sectorsPerCluster                            ; clusshft (TODO: only correct for 1 and 2 sec/clus)         
     116.  00:0000                    <         dw .firfat
     117.  00:0000                    <         db fatCount, maxEnt
     118.  00:0000                    <         dw .firrec
     119.  00:0000                    <         dw (maxSector-.firrec)/sectorsPerCluster+1      ; maxclus
     120.  00:0000                    <         db fatSiz
     121.  00:0000                    <         dw .firdir
     122.  00:0000                    <         endmacro
     123.  00:0000                      
     124.  00:0000                      
     125.  00:0000                      ; ROMHEADER macro
     126.  00:0000                              macro romheader r   
     127.  00:0000                    < .addr := $4000        
     128.  00:0000                    <         repeat r
     129.  00:0000                    <         code ! .addr
     130.  00:0000                    < 
     131.  00:0000                    <         org $4000
     132.  00:0000                    <         db "AB"
     133.  00:0000                    <         dw .init
     134.  00:0000                    <         ds 12,0
     135.  00:0000                    < 
     136.  00:0000                    <         call .redir                     ; DSKIO
     137.  00:0000                    <         call .redir                     ; DSKCHG
     138.  00:0000                    <         call .redir                     ; GETDPB
     139.  00:0000                    <         call .redir                     ; CHOICE
     140.  00:0000                    <         call .redir                     ; DSKFMT
     141.  00:0000                    <         ds 3,0                          ; DRVOFF
     142.  00:0000                    < 
     143.  00:0000                    <         code ! .addr + $3fe7
     144.  00:0000                    <         org $7fe7
     145.  00:0000                    <         
     146.  00:0000                    < .init:  ld hl,romInit
     147.  00:0000                    <         push hl
     148.  00:0000                    <         jr .enableBank0        
     149.  00:0000                    < 
     150.  00:0000                    < .redir: ex (sp),hl
     151.  00:0000                    <         dec hl
     152.  00:0000                    <         dec hl
     153.  00:0000                    <         dec hl
     154.  00:0000                    <         ex (sp),hl
     155.  00:0000                    <         jr .enableBank0
     156.  00:0000                    < 
     157.  00:0000                    <         ld (mapper),a                   ; copyFromBank
     158.  00:0000                    <         ldir
     159.  00:0000                    < .enableBank0:
     160.  00:0000                    <         push af                         ; enable bank 0 (no registers changed)
     161.  00:0000                    <         xor a
     162.  00:0000                    <         ld (mapper),a
     163.  00:0000                    <         pop af
     164.  00:0000                    <         ret
     165.  00:0000                    <         
     166.  00:0000                    < .@addr := .addr + $4000
     167.  00:0000                    <         endrepeat
     168.  00:0000                    <         endmacro
     169.  00:0000                      
     170.  00:0000                      ; MACRO debugdisasm
     171.  00:0000                              macro DEBUGDISASM
     172.  00:0000                    <         db $ed, $0b
     173.  00:0000                    <         endmacro
     174.  00:0000                              
     175.  00:0000                      ; MACRO debugdisasmoff
     176.  00:0000                              macro DEBUGDISASMOFF
     177.  00:0000                    <         db $ed, $0c
     178.  00:0000                    <         endmacro        
     179.  00:0000                      
     180.  00:0000                      ; MACRO breakpoint
     181.  00:0000                              macro BREAKPOINT
     182.  00:0000                    <         ld b,b
     183.  00:0000                    <         jr $+2
     184.  00:0000                    <         endmacro
     185.  00:0000                      
     186.  00:0000                              
     187.  00:0000                              macro PRINTVDPTEXT string
     188.  00:0000                    <         
     189.  00:0000                    <         push hl
     190.  00:0000                    <         ld hl,.text 
     191.  00:0000                    <         call printVdpText2
     192.  00:0000                    <         pop hl
     193.  00:0000                    <         jr .skip
     194.  00:0000                    < .text   db string
     195.  00:0000                    <         db 0
     196.  00:0000                    < .skip:
     197.  00:0000                    <         endmacro
      16   00:0000                      
      17   00:0000                              defpage 0, $4000, $4000						; MSXDOS2 bank 0
      18   00:0000                              defpage 1, $4000, 3 * $4000					; MSXDOS2 bank 1..3
      19   00:0000                              defpage 2, $4000, $4000						; MSXDOS1
      20   00:0000                              defpage 3, 0, (512-80)*1024
      21   00:0000                      		
      22   00:0000                      ; insert MSXDOS2
      23   00:0000  (00)                        page 0
      24   00:4000                      	module	MSXDOS2_PART
      25   00:4000                      		
      26   00:4000                      	define 	MSXDOSVER 2
      27   00:4000                      ;	define	ROMINIT $47d6
      28   00:4000                      	define	PRINTTEXT $728e
      29   00:4000                      		
      30   00:4000  (32F0)                      incbin "..\roms\MSXDOS22.ROM", 0, $72f0-$4000
      31   00:72F0                                      
      32   00:72F0                              PATCH $4006, device
      32   00:72F0                    >         code ! address
      32   00:4006  DC 7D             >         dw word
      33   00:4008                      
      34   00:4008                              code ! $4010
      35   00:4010  C3 DE 76                    jp DSKIO
      36   00:4013  C3 E1 77                    jp DSKCHG
      37   00:4016  C3 18 78                    jp GETDPB
      38   00:4019  C3 84 78                    jp CHOICE
      39   00:401C  C3 89 78                    jp DSKFMT
      40   00:401F  00 00 00                    db 0,0,0                        ; no DRVOFF
      41   00:4022                              
      42   00:4022                              PATCH $47d7, getBootArgs        ; INIHDR
      42   00:4022                    >         code ! address
      42   00:47D7  F0 72             >         dw word
      43   00:47D9                      ;        PATCH $47dd, 0                  ; do not check for MSX1
      44   00:47D9                              PATCH $488d, MYSIZE
      44   00:47D9                    >         code ! address
      44   00:488D  08 00             >         dw word
      45   00:488F                              PATCH $489f, SECLEN
      45   00:488F                    >         code ! address
      45   00:489F  00 02             >         dw word
      46   00:48A1                              PATCH $48b9, DRIVES
      46   00:48A1                    >         code ! address
      46   00:48B9  1F 76             >         dw word
      47   00:48BB                              PATCH $48eb, DEFDPB - 1
      47   00:48BB                    >         code ! address
      47   00:48EB  CE 7B             >         dw word
      48   00:48ED                              PATCH $48f7, INIENV
      48   00:48ED                    >         code ! address
      48   00:48F7  88 76             >         dw word
      49   00:48F9                              PATCH $5797, OEMSTA
      49   00:48F9                    >         code ! address
      49   00:5797  94 79             >         dw word
      50   00:5799                      
      51   00:5799                              PATCH $4093, mapper
      51   00:5799                    >         code ! address
      51   00:4093  01 60             >         dw word
      52   00:4095                      
      53   00:4095                              code ! $4881
      54   00:4881  87                          db LOW initDiskBasic
      55   00:4882                              code ! $4884
      56   00:4884  73                          db HIGH initDiskBasic
      57   00:4885                       
      58   00:4885                              code ! $49a3
      59   00:49A3  21 21 74                    ld hl,newAUX                    ; redirect AUX to host  
      60   00:49A6  11 27 F3                    ld de,$f327
      61   00:49A9  01 0A 00                    ld bc,10
      62   00:49AC  ED B0                       ldir
      63   00:49AE  00                          nop
      64   00:49AF  00                          nop
      65   00:49B0  00                          nop
      66   00:49B1  00                          nop
      67   00:49B2  00                          nop                             ; nops needed to override existing code!
      68   00:49B3                              
      69   00:49B3                              code @ $72f0
      70   00:72F0                                      
      71   00:72F0                      getBootArgs:              
      72   00:72F0  06 00                       ld b,0                      ; b=0 means request startup command
      73   00:72F2  0E 00                       ld c,0                      ; c=0 means reset startup queue index 
      74   00:72F4  CD CB 73            next:   call sendRegisters
      75   00:72F7  36 93                       ld (hl),C_CMDREQUEST
      76   00:72F9  CD 5C 75                    call enableNowindPage0
      77   00:72FC  26 20                       ld h,HIGH usbrd
      78   00:72FE  CD DD 73                    call getHeader
      79   00:7301                              ; todo: read command here
      80   00:7301  CD 67 75                    call restorePage0
      81   00:7304  A7                          and a
      82   00:7305  28 13                       jr z,noNextCommand
      83   00:7307                              DEBUGMESSAGE "Got command!"   
      83   00:7307                    >         ifdef DEBUG
      83   00:7307  52                >         ld d,d
      83   00:7308  18 0C             >         jr .skip
      83   00:730A                    >         db string
      83   00:730A  47 6F 74 20 63 6F 6D 6D 61 6E 64 21 
      83   00:7316                    > .skip:
      83   00:7316                    >         endif
      84   00:7316  0E 01                       ld c,1
      85   00:7318  18 DA                       jr next
      86   00:731A                      noNextCommand:
      87   00:731A                              DEBUGMESSAGE "End of startup commands"   
      87   00:731A                    >         ifdef DEBUG
      87   00:731A  52                >         ld d,d
      87   00:731B  18 17             >         jr .skip
      87   00:731D                    >         db string
      87   00:731D  45 6E 64 20 6F 66 20 73 74 61 72 74 75 70 20 63 
      87   00:732D  6F 6D 6D 61 6E 64 73 
      87   00:7334                    > .skip:
      87   00:7334                    >         endif
      88   00:7334                      
      89   00:7334  CD CB 73                    call sendRegisters
      90   00:7337  36 92                       ld (hl),C_GETDOSVERSION
      91   00:7339  CD 5C 75                    call enableNowindPage0
      92   00:733C  26 20                       ld h,HIGH usbrd
      93   00:733E  CD DD 73                    call getHeader
      94   00:7341                      
      95   00:7341  CD 67 75                    call restorePage0
      96   00:7344  DA 4B 73                    jp c,bootMSXDOS1                ; no reply (host not connected?)
      97   00:7347                              
      98   00:7347  A7                          and a
      99   00:7348  C2 FC 75                    jp nz,INIHRD                    ; boot MSXDOS2
     100   00:734B                      
     101   00:734B                      bootMSXDOS1:
     102   00:734B  21 6F 57                    ld hl,$576f                     ; boot MSXDOS1
     103   00:734E  E5                          push hl
     104   00:734F  3E 04                       ld a,4
     105   00:7351  C3 FA 7F                    jp switchBank
     106   00:7354                                              
     107   00:7354                              include "common.asm"
       1.  00:7354                      ; Nowind specific
       2.  00:7354                      
       3.  00:7354                      nowindInit:
       4.  00:7354                              ;DEBUGMESSAGE "nowindInit"
       5.  00:7354  3A F8 FA                    ld a,($faf8)										; moet volgens bifi ld a,($2d) zijn, $faf8 is op msx1 deel van de rs232 area?
       6.  00:7357  B7                          or a 
       7.  00:7358  F5                          push af
       8.  00:7359  CC 5F 00                    call z,CHGMOD                   ; SCREEN 0 for MSX1
       9.  00:735C  F1                          pop af
      10.  00:735D  DD 21 85 01                 ld ix,SDFSCR                    ; restore screen mode from clockchip
      11.  00:7361  C4 5F 01                    call nz,EXTROM
      12.  00:7364                                      
      13.  00:7364  CD 8E 72                    call PRINTTEXT
      14.  00:7367                              ifndef DEBUG
      15.  00:7367                    ~         db "Nowind USB Diskrom!",0
      16.  00:7367                    ~         else
      17.  00:7367                              db "Nowind USB Diskrom! [debug]",0
      17.  00:7367  4E 6F 77 69 6E 64 20 55 53 42 20 44 69 73 6B 72 
      17.  00:7377  6F 6D 21 20 5B 64 65 62 75 67 5D 00 
      18.  00:7383                              endif
      19.  00:7383                      
      20.  00:7383                              ; call insertBootCode
      21.  00:7383  CD B1 7C                    call flashWriter
      22.  00:7386  C9                          ret
      23.  00:7387                      
      24.  00:7387                      initDiskBasic:
      25.  00:7387                              DEBUGMESSAGE "initDiskBasic"
      25.  00:7387                    >         ifdef DEBUG
      25.  00:7387  52                >         ld d,d
      25.  00:7388  18 0D             >         jr .skip
      25.  00:738A                    >         db string
      25.  00:738A  69 6E 69 74 44 69 73 6B 42 61 73 69 63 
      25.  00:7397                    > .skip:
      25.  00:7397                    >         endif
      26.  00:7397  21 99 FD                    ld hl,DEVICE
      27.  00:739A  CB BE                       res 7,(hl)
      28.  00:739C                              
      29.  00:739C                              if MSXDOSVER = 1 
      30.  00:739C                    ~         jp $5897
      31.  00:739C                    ~         else
      32.  00:739C  C3 5B 49                    jp $495b
      33.  00:739F                              endif
      34.  00:739F                      
      35.  00:739F                      ; search call statement or device name
      36.  00:739F                      findStatementName:
      37.  00:739F                              DEBUGMESSAGE "findStatementName"
      37.  00:739F                    >         ifdef DEBUG
      37.  00:739F  52                >         ld d,d
      37.  00:73A0  18 11             >         jr .skip
      37.  00:73A2                    >         db string
      37.  00:73A2  66 69 6E 64 53 74 61 74 65 6D 65 6E 74 4E 61 6D 
      37.  00:73B2  65 
      37.  00:73B3                    > .skip:
      37.  00:73B3                    >         endif
      38.  00:73B3  11 89 FD                    ld de,PROCNM
      39.  00:73B6  1A                  .loop:  ld a,(de)
      40.  00:73B7  BE                          cp (hl)
      41.  00:73B8  20 06                       jr nz,.nextStatement
      42.  00:73BA  23                          inc hl
      43.  00:73BB  B7                          or a
      44.  00:73BC  C8                          ret z                           ; name found
      45.  00:73BD  13                          inc de
      46.  00:73BE  18 F6                       jr .loop        
      47.  00:73C0                      .nextStatement:
      48.  00:73C0  AF                          xor a
      49.  00:73C1  4F                          ld c,a
      50.  00:73C2  ED B1                       cpir
      51.  00:73C4  23                          inc hl
      52.  00:73C5  23                          inc hl
      53.  00:73C6  B6                          or (hl)
      54.  00:73C7  20 D6                       jr nz,findStatementName        
      55.  00:73C9  37                          scf                             ; not found
      56.  00:73CA  C9                          ret
      57.  00:73CB                      
      58.  00:73CB                      sendRegisters:
      59.  00:73CB  F5                          push af
      60.  00:73CC  7C                          ld a,h
      61.  00:73CD  26 40                       ld h,HIGH usbwr
      62.  00:73CF  36 AF                       ld (hl),$af                     ; header
      63.  00:73D1  36 05                       ld (hl),$05
      64.  00:73D3  71                          ld (hl),c
      65.  00:73D4  70                          ld (hl),b
      66.  00:73D5  73                          ld (hl),e
      67.  00:73D6  72                          ld (hl),d
      68.  00:73D7  75                          ld (hl),l
      69.  00:73D8  77                          ld (hl),a                       ; register h
      70.  00:73D9  D1                          pop de
      71.  00:73DA  73                          ld (hl),e                       ; register f
      72.  00:73DB  72                          ld (hl),d                       ; register a
      73.  00:73DC  C9                          ret
      74.  00:73DD                              
      75.  00:73DD                      getHeader:
      76.  00:73DD  06 FF                       ld b,HIGH 65535                 ; 42000 * 60 states ~ 0,7 sec (time out)
      77.  00:73DF  7E                  .loop:  ld a,(hl)
      78.  00:73E0  FE AF               .chkaf: cp $af
      79.  00:73E2  28 20                       jr z,.chk05
      80.  00:73E4  0B                          dec bc
      81.  00:73E5  78                          ld a,b
      82.  00:73E6  B1                          or c
      83.  00:73E7  20 F6                       jr nz,.loop
      84.  00:73E9                              DEBUGMESSAGE "getHeader Timed out!"
      84.  00:73E9                    >         ifdef DEBUG
      84.  00:73E9  52                >         ld d,d
      84.  00:73EA  18 14             >         jr .skip
      84.  00:73EC                    >         db string
      84.  00:73EC  67 65 74 48 65 61 64 65 72 20 54 69 6D 65 64 20 
      84.  00:73FC  6F 75 74 21 
      84.  00:7400                    > .skip:
      84.  00:7400                    >         endif
      85.  00:7400  3E 02                       ld a,2                          ; not ready
      86.  00:7402  37                          scf
      87.  00:7403  C9                          ret
      88.  00:7404                      
      89.  00:7404  7E                  .chk05: ld a,(hl)
      90.  00:7405  FE 05                       cp $05
      91.  00:7407  20 D7                       jr nz,.chkaf
      92.  00:7409  7E                          ld a,(hl)
      93.  00:740A  C9                          ret
      94.  00:740B                      
      95.  00:740B                      sendMessage:
      96.  00:740B                              ;DEBUGMESSAGE "sendMsg"
      97.  00:740B  E3                          ex (sp),hl
      98.  00:740C  F5                          push af
      99.  00:740D  D5                          push de
     100.  00:740E  E5                          push hl        
     101.  00:740F  CD CB 73                    call sendRegisters
     102.  00:7412  36 90                       ld (hl),C_MESSAGE
     103.  00:7414  E1                          pop hl
     104.  00:7415  7E                  .loop:  ld a,(hl)
     105.  00:7416  23                          inc hl
     106.  00:7417  32 00 40                    ld (usbwr),a
     107.  00:741A  B7                          or a
     108.  00:741B  20 F8                       jr nz,.loop
     109.  00:741D  D1                          pop de
     110.  00:741E  F1                          pop af
     111.  00:741F  E3                          ex (sp),hl
     112.  00:7420  C9                          ret
     113.  00:7421                              
     114.  00:7421                      ; AUX device
     115.  00:7421                              
     116.  00:7421  C3 2B 74            newAUX: jp AUXin
     117.  00:7424  00                          nop
     118.  00:7425  00                          nop
     119.  00:7426  C3 70 74                    jp AUXout
     120.  00:7429  00                          nop
     121.  00:742A  00                          nop
     122.  00:742B                      
     123.  00:742B                      AUXin:  DEBUGMESSAGE "AUX in"
     123.  00:742B                    >         ifdef DEBUG
     123.  00:742B  52                >         ld d,d
     123.  00:742C  18 06             >         jr .skip
     123.  00:742E  41 55 58 20 69 6E >         db string
     123.  00:7434                    > .skip:
     123.  00:7434                    >         endif
     124.  00:7434  E5                          push hl
     125.  00:7435  D5                          push de
     126.  00:7436  C5                          push bc
     127.  00:7437  CD CB 73                    call sendRegisters
     128.  00:743A  36 8E                       ld (hl),C_AUXIN
     129.  00:743C  CD 5C 75                    call enableNowindPage0
     130.  00:743F  26 20                       ld h,HIGH usbrd
     131.  00:7441  CD DD 73                    call getHeader
     132.  00:7444  D2 5F 74                    jp nc,.getCharacter
     133.  00:7447                              
     134.  00:7447                              DEBUGMESSAGE "not connected"
     134.  00:7447                    >         ifdef DEBUG
     134.  00:7447  52                >         ld d,d
     134.  00:7448  18 0D             >         jr .skip
     134.  00:744A                    >         db string
     134.  00:744A  6E 6F 74 20 63 6F 6E 6E 65 63 74 65 64 
     134.  00:7457                    > .skip:
     134.  00:7457                    >         endif
     135.  00:7457  3E 1A                       ld a,$1a                        ; eof
     136.  00:7459  C1                  .exit:  pop bc
     137.  00:745A  D1                          pop de
     138.  00:745B  E1                          pop hl
     139.  00:745C  C3 67 75                    jp restorePage0        
     140.  00:745F                                    
     141.  00:745F                      .getCharacter:
     142.  00:745F                              DEBUGMESSAGE "getChar"
     142.  00:745F                    >         ifdef DEBUG
     142.  00:745F  52                >         ld d,d
     142.  00:7460  18 07             >         jr .skip
     142.  00:7462                    >         db string
     142.  00:7462  67 65 74 43 68 61 72 
     142.  00:7469                    > .skip:
     142.  00:7469                    >         endif
     143.  00:7469  CD DD 73                    call getHeader
     144.  00:746C  38 F1                       jr c,.getCharacter
     145.  00:746E  18 E9                       jr .exit
     146.  00:7470                      
     147.  00:7470                      
     148.  00:7470                      AUXout: DEBUGMESSAGE "AUX out"
     148.  00:7470                    >         ifdef DEBUG
     148.  00:7470  52                >         ld d,d
     148.  00:7471  18 07             >         jr .skip
     148.  00:7473                    >         db string
     148.  00:7473  41 55 58 20 6F 75 74 
     148.  00:747A                    > .skip:
     148.  00:747A                    >         endif
     149.  00:747A                              DEBUGDUMPREGISTERS
     149.  00:747A                    >         ifdef DEBUG
     149.  00:747A  ED 07             >         db $ed,7
     149.  00:747C                    >         endif
     149.  00:747C                    >         
     149.  00:747C                    >         ifdef USBDEBUG
     149.  00:747C                    ~         assert ($ < $8000)
     149.  00:747C                    ~         call sendCpuInfo
     149.  00:747C                    ~         endif
     150.  00:747C  E5                          push hl
     151.  00:747D  D5                          push de
     152.  00:747E                      ;        push bc
     153.  00:747E                      ;        ld a,(RAMAD1) ; TODO: WTF???
     154.  00:747E                      ;        call RDSLT
     155.  00:747E  F5                          push af        
     156.  00:747F  CD CB 73                    call sendRegisters
     157.  00:7482  36 8F                       ld (hl),C_AUXOUT
     158.  00:7484  F1                          pop af
     159.  00:7485                      ;        pop bc
     160.  00:7485  D1                          pop de
     161.  00:7486  E1                          pop hl
     162.  00:7487  C9                          ret
     163.  00:7488                      
     164.  00:7488                      ;insertBootCode:
     165.  00:7488                      ;        DEBUGMESSAGE "BOOTCODE"
     166.  00:7488                      ;        call sendRegisters
     167.  00:7488                      ;        ld (hl),C_BOOTCODE
     168.  00:7488                      ;        call enableNowindPage0
     169.  00:7488                      ;        call getHeader
     170.  00:7488                      ;        jp c,restorePage0
     171.  00:7488                              
     172.  00:7488                      ;        DEBUGMESSAGE "BOOTCODE"
     173.  00:7488                      ;        jp restorePage0
     174.  00:7488                      
     175.  00:7488                      ; send 32 bytes starting from address specified by DE to the usb
     176.  00:7488                      sdendFCB:
     177.  00:7488  D5                          push de
     178.  00:7489  C5                          push bc
     179.  00:748A                              
     180.  00:748A  06 20                       ld b,32
     181.  00:748C  1A                  .loop:  ld a,(de)
     182.  00:748D  32 00 40                    ld (usbwr),a
     183.  00:7490  13                          inc de
     184.  00:7491  10 F9                       djnz .loop
     185.  00:7493  C1                          pop bc
     186.  00:7494  D1                          pop de
     187.  00:7495  C9                          ret
     188.  00:7496                      
     189.  00:7496                      ; receive 32 bytes and write to the address specified by DE 
     190.  00:7496                      receiveFCB:
     191.  00:7496  D5                          push de
     192.  00:7497  C5                          push bc
     193.  00:7498                              
     194.  00:7498  06 20                       ld b,32
     195.  00:749A  3A 00 20            .loop:  ld a,(usbrd)
     196.  00:749D  32 00 40            	ld (usbwr),a			; loop back
     197.  00:74A0  12                          ld (de),a
     198.  00:74A1  13                          inc de
     199.  00:74A2  10 F6                       djnz .loop
     200.  00:74A4  C1                          pop bc
     201.  00:74A5  D1                          pop de
     202.  00:74A6  C9                          ret
     203.  00:74A7                              
     108   00:74A7                              include "extendedBios.asm"
       1.  00:74A7                      
       2.  00:74A7                      installExtendedBios:
       3.  00:74A7                      
       4.  00:74A7                              ; Called from INIENV, so EXTBIO hook is already initialized
       5.  00:74A7                      
       6.  00:74A7                              DEBUGMESSAGE "extbio"
       6.  00:74A7                    >         ifdef DEBUG
       6.  00:74A7  52                >         ld d,d
       6.  00:74A8  18 06             >         jr .skip
       6.  00:74AA  65 78 74 62 69 6F >         db string
       6.  00:74B0                    > .skip:
       6.  00:74B0                    >         endif
       7.  00:74B0  CD E7 75                    call getEntrySLTWRK             ; save previous EXTBIO hook
       8.  00:74B3  23                          inc hl
       9.  00:74B4  EB                          ex de,hl        
      10.  00:74B5  21 CA FF                    ld hl,EXTBIO
      11.  00:74B8  01 05 00                    ld bc,5
      12.  00:74BB  ED B0                       ldir
      13.  00:74BD                              
      14.  00:74BD  E5                          push hl                         ; determine device number
      15.  00:74BE  AF                          xor a
      16.  00:74BF  11 01 4E                    ld de,$4e01
      17.  00:74C2  CD CA FF                    call EXTBIO
      18.  00:74C5  E1                          pop hl
      19.  00:74C6  77                          ld (hl),a
      20.  00:74C7                                      
      21.  00:74C7  CD 2D 40                    call GETSLT                     ; install new EXTBIO hook
      22.  00:74CA  2E F7                       ld l,$f7
      23.  00:74CC  67                          ld h,a
      24.  00:74CD  22 CA FF                    ld (EXTBIO),hl
      25.  00:74D0  21 DC 74                    ld hl,extendedBios
      26.  00:74D3  22 CC FF                    ld (EXTBIO+2),hl
      27.  00:74D6  3E C9                       ld a,$c9
      28.  00:74D8  32 CE FF                    ld (EXTBIO+4),a    
      29.  00:74DB  C9                          ret
      30.  00:74DC                      
      31.  00:74DC                      extendedBios:
      32.  00:74DC                              ; broadcast (0x00) not implemented
      33.  00:74DC                              ; system exclusive (0xff) not implemented
      34.  00:74DC                      
      35.  00:74DC  FB                          ei
      36.  00:74DD  F5                          push af
      37.  00:74DE  7A                          ld a,d
      38.  00:74DF  FE 4E                       cp $4e
      39.  00:74E1  28 0E                       jr z,determineFunction
      40.  00:74E3                      .exit:
      41.  00:74E3  E5                          push hl
      42.  00:74E4  C5                          push bc
      43.  00:74E5  CD E7 75                    call getEntrySLTWRK
      44.  00:74E8  2C                          inc l                           ; previous EXTBIO hook 
      45.  00:74E9  E5                          push hl
      46.  00:74EA  DD E1                       pop ix
      47.  00:74EC  C1                          pop bc        
      48.  00:74ED  E1                          pop hl
      49.  00:74EE  F1                          pop af
      50.  00:74EF  DD E9                       jp (ix)                         ; process other EXTBIO handles
      51.  00:74F1                      
      52.  00:74F1                      determineFunction:
      53.  00:74F1  E5                          push hl
      54.  00:74F2  21 FD D8                    ld hl,functionTable - 2 * $4e00
      55.  00:74F5  19                          add hl,de
      56.  00:74F6  19                          add hl,de
      57.  00:74F7  7E                          ld a,(hl)
      58.  00:74F8  23                          inc hl
      59.  00:74F9  66                          ld h,(hl)
      60.  00:74FA  6F                          ld l,a
      61.  00:74FB  E3                          ex (sp),hl
      62.  00:74FC  C9                          ret
      63.  00:74FD                      
      64.  00:74FD                      functionTable:
      65.  00:74FD  03 75                       dw getNowindSlot
      66.  00:74FF  1F 75                       dw numberOfDevices
      67.  00:7501  36 75                       dw debugMessage
      68.  00:7503                      
      69.  00:7503                      getNowindSlot:               
      70.  00:7503                              DEBUGMESSAGE "getNowindSlot"
      70.  00:7503                    >         ifdef DEBUG
      70.  00:7503  52                >         ld d,d
      70.  00:7504  18 0D             >         jr .skip
      70.  00:7506                    >         db string
      70.  00:7506  67 65 74 4E 6F 77 69 6E 64 53 6C 6F 74 
      70.  00:7513                    > .skip:
      70.  00:7513                    >         endif
      71.  00:7513  F1                          pop af
      72.  00:7514  3D                          dec a
      73.  00:7515  F5                          push af
      74.  00:7516  F2 E3 74                    jp p,extendedBios.exit         ; not this device
      75.  00:7519                              
      76.  00:7519  F1                          pop af
      77.  00:751A  CD B7 75                    call getSlotPage1
      78.  00:751D  37                          scf
      79.  00:751E  C9                          ret
      80.  00:751F                              
      81.  00:751F                      numberOfDevices:
      82.  00:751F                              DEBUGMESSAGE "numberOfDevices"
      82.  00:751F                    >         ifdef DEBUG
      82.  00:751F  52                >         ld d,d
      82.  00:7520  18 0F             >         jr .skip
      82.  00:7522                    >         db string
      82.  00:7522  6E 75 6D 62 65 72 4F 66 44 65 76 69 63 65 73 
      82.  00:7531                    > .skip:
      82.  00:7531                    >         endif
      83.  00:7531  F1                          pop af
      84.  00:7532  3C                          inc a
      85.  00:7533  F5                          push af
      86.  00:7534  18 AD                       jr extendedBios.exit
      87.  00:7536                              
      88.  00:7536                      debugMessage:
      89.  00:7536                              DEBUGMESSAGE "debugMessage"
      89.  00:7536                    >         ifdef DEBUG
      89.  00:7536  52                >         ld d,d
      89.  00:7537  18 0C             >         jr .skip
      89.  00:7539                    >         db string
      89.  00:7539  64 65 62 75 67 4D 65 73 73 61 67 65 
      89.  00:7545                    > .skip:
      89.  00:7545                    >         endif
      90.  00:7545  F1                          pop af
      91.  00:7546  3D                          dec a
      92.  00:7547  F5                          push af
      93.  00:7548  F2 E3 74                    jp p,extendedBios.exit
      94.  00:754B                      
      95.  00:754B  E5                          push hl
      96.  00:754C  CD CB 73                    call sendRegisters
      97.  00:754F  36 90                       ld (hl),C_MESSAGE
      98.  00:7551  E1                          pop hl
      99.  00:7552  7E                  .loop:  ld a,(hl)
     100.  00:7553  23                          inc hl
     101.  00:7554  32 00 40                    ld (usbwr),a
     102.  00:7557  B7                          or a
     103.  00:7558  20 F8                       jr nz,.loop
     104.  00:755A                              
     105.  00:755A  F1                          pop af        
     106.  00:755B  C9                          ret
     109   00:755C                              include "slotRoutines.asm"
       1.  00:755C                      ; These routines are used for slot selection
       2.  00:755C                      
       3.  00:755C                      enableNowindPage0:
       4.  00:755C  CD AC 75                    call getSlotPage0
       5.  00:755F  DD 67                       ld ixh,a
       6.  00:7561  CD B7 75                    call getSlotPage1
       7.  00:7564  C3 70 75                    jp enableSlotPage0       
       8.  00:7567                      
       9.  00:7567                      restorePage0:
      10.  00:7567  F5                          push af
      11.  00:7568  DD 7C                       ld a,ixh
      12.  00:756A  CD 70 75                    call enableSlotPage0
      13.  00:756D  FB                          ei
      14.  00:756E  F1                          pop af
      15.  00:756F  C9                          ret
      16.  00:7570                      
      17.  00:7570                      enableSlotPage0:
      18.  00:7570                              ; HL and D remain unchanged
      19.  00:7570                              ; enableSlotPage0 can be called in page 1 and 2 (no absolute jumps)
      20.  00:7570                      
      21.  00:7570                              ;DEBUGMESSAGE "enasltP0"
      22.  00:7570  5F                          ld e,a                          ; store slotcode for further use
      23.  00:7571  E6 03                       and 3
      24.  00:7573  4F                          ld c,a                          ; new primary slot in c  
      25.  00:7574  CB 7B                       bit 7,e
      26.  00:7576  F3                          di
      27.  00:7577  20 08                       jr nz,.expanded
      28.  00:7579                      
      29.  00:7579  DB A8                       in a,($a8)
      30.  00:757B  E6 FC                       and %11111100
      31.  00:757D  B1                          or c                            ; enable new primary slot in page 0
      32.  00:757E  D3 A8                       out ($a8),a
      33.  00:7580  C9                          ret
      34.  00:7581                              
      35.  00:7581                      .expanded:
      36.  00:7581  7B                          ld a,e                          ; store secondary slot in e
      37.  00:7582  E6 0C                       and %00001100     
      38.  00:7584  0F                          rrca
      39.  00:7585  0F                          rrca
      40.  00:7586  5F                          ld e,a
      41.  00:7587                      
      42.  00:7587  DB A8                       in a,($a8)
      43.  00:7589  E6 FC                       and %11111100
      44.  00:758B  B1                          or c                            ; new primary slot in page 0
      45.  00:758C  47                          ld b,a                          ; used to restore
      46.  00:758D  17                          rla
      47.  00:758E  A7                          and a                           ; (reset carry)
      48.  00:758F  17                          rla
      49.  00:7590  B1                          or c                            ; new primary slot in page 3
      50.  00:7591  0F                          rrca
      51.  00:7592  0F                          rrca
      52.  00:7593  D3 A8                       out ($a8),a
      53.  00:7595                      
      54.  00:7595  3A FF FF                    ld a,(-1)                       ; write secondary slot register
      55.  00:7598  2F                          cpl
      56.  00:7599  E6 FC                       and %11111100
      57.  00:759B  B3                          or e                            ; apply new secondary slot for page 0
      58.  00:759C  32 FF FF                    ld (-1),a
      59.  00:759F  5F                          ld e,a                          ; store secondary slot register (for SLTTBL)
      60.  00:75A0                      
      61.  00:75A0  78                          ld a,b                          ; restore primary slot page 3
      62.  00:75A1  D3 A8                       out ($a8),a
      63.  00:75A3                      
      64.  00:75A3  3E C5                       ld a,LOW SLTTBL                 ; update SLTTBL
      65.  00:75A5  81                          add c                           ; add primary slot
      66.  00:75A6  4F                          ld c,a
      67.  00:75A7  06 FC                       ld b,HIGH SLTTBL
      68.  00:75A9  7B                          ld a,e                          ; restore secondary slot register
      69.  00:75AA  02                          ld (bc),a
      70.  00:75AB  C9                          ret
      71.  00:75AC                      
      72.  00:75AC                      ; These routines determine the current slot and subslot of a page.
      73.  00:75AC                      
      74.  00:75AC                      getSlotPage0:
      75.  00:75AC                              ;DEBUGMESSAGE "getsltP0"
      76.  00:75AC  DB A8                       in a,($a8)
      77.  00:75AE  CD D1 75                    call expanded
      78.  00:75B1  07                          rlca
      79.  00:75B2  07                          rlca
      80.  00:75B3  E6 0C                       and %00001100           ; keep subSlot
      81.  00:75B5  B1                          or c                    ; add mainSlot and expanded bit
      82.  00:75B6  C9                          ret
      83.  00:75B7                                      
      84.  00:75B7                      getSlotPage1:
      85.  00:75B7                      ;        DEBUGMESSAGE "getsltP1"
      86.  00:75B7  DB A8                       in a,($a8)
      87.  00:75B9  0F                          rrca
      88.  00:75BA  0F                          rrca
      89.  00:75BB  CD D1 75                    call expanded
      90.  00:75BE  E6 0C                       and %00001100           ; keep subSlot
      91.  00:75C0  B1                          or c                    ; add mainSlot and expanded bit
      92.  00:75C1  C9                          ret        
      93.  00:75C2                                      
      94.  00:75C2                      getSlotPage2:
      95.  00:75C2                      ;        DEBUGMESSAGE "getsltP2"
      96.  00:75C2  DB A8                       in a,($a8)
      97.  00:75C4  0F                          rrca
      98.  00:75C5  0F                          rrca
      99.  00:75C6  0F                          rrca
     100.  00:75C7  0F                          rrca
     101.  00:75C8  CD D1 75                    call expanded
     102.  00:75CB  0F                          rrca
     103.  00:75CC  0F                          rrca
     104.  00:75CD  E6 0C                       and %00001100           ; keep subSlot
     105.  00:75CF  B1                          or c                    ; add mainSlot and expanded bit
     106.  00:75D0  C9                          ret
     107.  00:75D1                      
     108.  00:75D1                      ;expanded:        
     109.  00:75D1                      ;        ld hl,EXPTBL - $0300
     110.  00:75D1                      ;        ld b,3
     111.  00:75D1                      ;        and b
     112.  00:75D1                      ;        ld c,a
     113.  00:75D1                      ;        add hl,bc      
     114.  00:75D1                      ;        
     115.  00:75D1                      ;        or (hl)        ; BUGGIE!!!! (a will be used again!)
     116.  00:75D1                      ;        ret p                           ; return when slot is not expanded
     117.  00:75D1                      ;        
     118.  00:75D1                      ;        ld c,a
     119.  00:75D1                      ;        ld a,4
     120.  00:75D1                      ;        add a,l
     121.  00:75D1                      ;        ld l,a
     122.  00:75D1                      ;        ld a,(hl)
     123.  00:75D1                      ;        ret
     124.  00:75D1                      
     125.  00:75D1                      expanded:        
     126.  00:75D1  21 C1 F9                    ld hl,EXPTBL - $0300
     127.  00:75D4  06 03                       ld b,3
     128.  00:75D6  A0                          and b
     129.  00:75D7  4F                          ld c,a
     130.  00:75D8  09                          add hl,bc
     131.  00:75D9  CB 7E                       bit 7,(hl)
     132.  00:75DB  28 08                       jr z,notExpanded
     133.  00:75DD                      
     134.  00:75DD  CB F9                       set 7,c
     135.  00:75DF  2C                          inc l
     136.  00:75E0  2C                          inc l
     137.  00:75E1  2C                          inc l
     138.  00:75E2  2C                          inc l
     139.  00:75E3  7E                          ld a,(hl)
     140.  00:75E4  C9                          ret        
     141.  00:75E5                      
     142.  00:75E5                      notExpanded:
     143.  00:75E5  C1                          pop bc
     144.  00:75E6  C9                          ret
     145.  00:75E7                      
     146.  00:75E7                      getEntrySLTWRK:
     147.  00:75E7  CD B7 75                    call getSlotPage1
     148.  00:75EA  21 09 FD                    ld hl,SLTWRK
     149.  00:75ED  4F                          ld c,a
     150.  00:75EE  0F                          rrca
     151.  00:75EF  0F                          rrca
     152.  00:75F0  0F                          rrca
     153.  00:75F1  E6 60                       and %01100000           ; main slot x 32
     154.  00:75F3  47                          ld b,a
     155.  00:75F4  79                          ld a,c
     156.  00:75F5  07                          rlca
     157.  00:75F6  E6 18                       and %00011000           ; sub slot x 8
     158.  00:75F8  80                          add b
     159.  00:75F9  85                          add l
     160.  00:75FA  6F                          ld l,a
     161.  00:75FB  C9                          ret
     162.  00:75FC                      
     110   00:75FC                              include "nowindDriver.asm"
       1.  00:75FC  (00:0008)           MYSIZE          equ 8                   ; size of work area (not used, some programs write here to stop drives spinning)
       2.  00:75FC  (00:0200)           SECLEN          equ 512                 ; sector size
       3.  00:75FC                      
       4.  00:75FC                      ; SLTWRK entry
       5.  00:75FC                      ; +0    rom drive number
       6.  00:75FC                      ; +1..5 previous EXTBIO
       7.  00:75FC                      ; +6    not used
       8.  00:75FC                      ; +7    not used
       9.  00:75FC                      
      10.  00:75FC                             
      11.  00:75FC                      ; if this is defined we tell DOS2.3 that we _are DOS2.3 also, so
      12.  00:75FC                      ; it does not try to override our initilazations 
      13.  00:75FC                      
      14.  00:75FC                      define  PRETEND_2B_DOS23
      15.  00:75FC                              
      16.  00:75FC                      INIHRD: 
      17.  00:75FC                              DEBUGMESSAGE "INIHRD"        
      17.  00:75FC                    >         ifdef DEBUG
      17.  00:75FC  52                >         ld d,d
      17.  00:75FD  18 06             >         jr .skip
      17.  00:75FF  49 4E 49 48 52 44 >         db string
      17.  00:7605                    > .skip:
      17.  00:7605                    >         endif
      18.  00:7605                              
      19.  00:7605                      ;        call getWorkArea
      20.  00:7605                      ;        DEBUGDUMPREGISTERS
      21.  00:7605                                                      
      22.  00:7605  CD 5C 75                    call enableNowindPage0                  ; clear hostToMSXFifo by reading 4Kb of random data
      23.  00:7608  01 00 10                    ld bc,4096
      24.  00:760B  3A 00 20            .loop:  ld a,(usbrd)
      25.  00:760E  0B                          dec bc
      26.  00:760F  78                          ld a,b
      27.  00:7610  B1                          or c
      28.  00:7611  20 F8                       jr nz,.loop
      29.  00:7613  CD 67 75                    call restorePage0
      30.  00:7616                              
      31.  00:7616  26 40                       ld h,HIGH usbwr
      32.  00:7618  36 AF                       ld (hl),$af                     ; INIHRD command
      33.  00:761A  36 FF                       ld (hl),$ff
      34.  00:761C  C3 54 73                    jp nowindInit
      35.  00:761F                      
      36.  00:761F                      DRIVES:
      37.  00:761F                              DEBUGMESSAGE "DRIVES"
      37.  00:761F                    >         ifdef DEBUG
      37.  00:761F  52                >         ld d,d
      37.  00:7620  18 06             >         jr .skip
      37.  00:7622  44 52 49 56 45 53 >         db string
      37.  00:7628                    > .skip:
      37.  00:7628                    >         endif
      38.  00:7628  F5                          push af                         ; A, BC and DE should be preserved!
      39.  00:7629  C5                          push bc
      40.  00:762A  D5                          push de
      41.  00:762B  3A 99 FD                    ld a,(DEVICE)
      42.  00:762E  CD CB 73                    call sendRegisters
      43.  00:7631  36 85                       ld (hl),C_DRIVES
      44.  00:7633  CD 5C 75                    call enableNowindPage0
      45.  00:7636  26 20                       ld h,HIGH usbrd
      46.  00:7638  CD DD 73                    call getHeader
      47.  00:763B  2E 02                       ld l,2                          ; default 2 drives
      48.  00:763D  38 2C                       jr c,.notconnected
      49.  00:763F                      
      50.  00:763F                              PRINTVDPTEXT " Host connected."
      50.  00:763F                    >         
      50.  00:763F  E5                >         push hl
      50.  00:7640  21 49 76          >         ld hl,.text
      50.  00:7643  CD B3 7B          >         call printVdpText2
      50.  00:7646  E1                >         pop hl
      50.  00:7647  18 11             >         jr .skip
      50.  00:7649                    > .text   db string
      50.  00:7649  20 48 6F 73 74 20 63 6F 6E 6E 65 63 74 65 64 2E 
      50.  00:7659  00                >         db 0
      50.  00:765A                    > .skip:
      51.  00:765A                                                      
      52.  00:765A  32 3F F3                    ld (LASTDRV),a                  ; install phantom drives (CRTL key)?
      53.  00:765D  7E                          ld a,(hl)                       ; allow other drives (SHIFT key)?
      54.  00:765E  32 99 FD                    ld (DEVICE),a
      55.  00:7661  6E                          ld l,(hl)                       ; number of drives
      56.  00:7662  E5                  .exit:  push hl  
      57.  00:7663  CD 67 75                    call restorePage0
      58.  00:7666  E1                          pop hl
      59.  00:7667  D1                          pop de
      60.  00:7668  C1                          pop bc
      61.  00:7669  F1                          pop af
      62.  00:766A  C9                          ret
      63.  00:766B                              
      64.  00:766B                      .notconnected:
      65.  00:766B                              PRINTVDPTEXT " Host timed out!"            
      65.  00:766B                    >         
      65.  00:766B  E5                >         push hl
      65.  00:766C  21 75 76          >         ld hl,.text
      65.  00:766F  CD B3 7B          >         call printVdpText2
      65.  00:7672  E1                >         pop hl
      65.  00:7673  18 11             >         jr .skip
      65.  00:7675                    > .text   db string
      65.  00:7675  20 48 6F 73 74 20 74 69 6D 65 64 20 6F 75 74 21 
      65.  00:7685  00                >         db 0
      65.  00:7686                    > .skip:
      66.  00:7686  18 DA                       jr .exit
      67.  00:7688                      
      68.  00:7688                      
      69.  00:7688                      INIENV:
      70.  00:7688                      ; Interrupt handler can be installed here and
      71.  00:7688                      ; work area can be initialized when it was requested
      72.  00:7688                              DEBUGMESSAGE "INIENV"
      72.  00:7688                    >         ifdef DEBUG
      72.  00:7688  52                >         ld d,d
      72.  00:7689  18 06             >         jr .skip
      72.  00:768B  49 4E 49 45 4E 56 >         db string
      72.  00:7691                    > .skip:
      72.  00:7691                    >         endif
      73.  00:7691                      
      74.  00:7691                              ifdef PRETEND_2B_DOS23
      75.  00:7691                              DEBUGMESSAGE "Lie about being DOS v2.31"
      75.  00:7691                    >         ifdef DEBUG
      75.  00:7691  52                >         ld d,d
      75.  00:7692  18 19             >         jr .skip
      75.  00:7694                    >         db string
      75.  00:7694  4C 69 65 20 61 62 6F 75 74 20 62 65 69 6E 67 20 
      75.  00:76A4  44 4F 53 20 76 32 2E 33 31 
      75.  00:76AD                    > .skip:
      75.  00:76AD                    >         endif
      76.  00:76AD  3E 23                       ld a,$23
      77.  00:76AF  32 13 F3                    ld ($f313),a
      78.  00:76B2                              endif
      79.  00:76B2                              
      80.  00:76B2  CD A7 74                    call installExtendedBios
      81.  00:76B5  CD CB 73                    call sendRegisters
      82.  00:76B8  36 86                       ld (hl),C_INIENV
      83.  00:76BA  CD 5C 75                    call enableNowindPage0
      84.  00:76BD  26 20                       ld h,HIGH usbrd
      85.  00:76BF  CD DD 73                    call getHeader
      86.  00:76C2  F5                          push af
      87.  00:76C3                      ;        push ix
      88.  00:76C3                      ;        call GETWRK
      89.  00:76C3                      ;        pop ix
      90.  00:76C3  CD E7 75                    call getEntrySLTWRK
      91.  00:76C6  F1                          pop af
      92.  00:76C7  36 00                       ld (hl),0                       ; romdisk in drive A: (default)          
      93.  00:76C9  38 01                       jr c,.exit
      94.  00:76CB  77                          ld (hl),a                       ; store romdisk drive number (255 = no romdisk)
      95.  00:76CC  C3 67 75            .exit:  jp restorePage0
      96.  00:76CF                      
      97.  00:76CF                      checkWorkArea:
      98.  00:76CF  3E 01                       ld a,1
      99.  00:76D1  A7                          and a
     100.  00:76D2  C9                          ret
     101.  00:76D3                              
     102.  00:76D3  C5                          push bc
     103.  00:76D4  E5                          push hl
     104.  00:76D5  F5                          push af
     105.  00:76D6                      ;        call GETWRK
     106.  00:76D6  CD E7 75                    call getEntrySLTWRK
     107.  00:76D9  F1                          pop af
     108.  00:76DA  BE                          cp (hl)
     109.  00:76DB  E1                          pop hl
     110.  00:76DC  C1                          pop bc
     111.  00:76DD  C9                          ret        
     112.  00:76DE                      
     113.  00:76DE                      DSKIO: 
     114.  00:76DE                      ; Input     F   Carry for set for write, reset for read
     115.  00:76DE                      ;           A   Drive number
     116.  00:76DE                      ;           B   Number of sectors to read/write
     117.  00:76DE                      ;           C   Media descriptor
     118.  00:76DE                      ;           DE  Logical sector number
     119.  00:76DE                      ;           HL  Transfer address
     120.  00:76DE                      ; Output    F   Carry set when not succesfull
     121.  00:76DE                      ;           A   Error code
     122.  00:76DE                      ;           B   Number of remaining sectors (TODO: check! even without error?)
     123.  00:76DE                      
     124.  00:76DE                              DEBUGMESSAGE "DSKIO"
     124.  00:76DE                    >         ifdef DEBUG
     124.  00:76DE  52                >         ld d,d
     124.  00:76DF  18 05             >         jr .skip
     124.  00:76E1  44 53 4B 49 4F    >         db string
     124.  00:76E6                    > .skip:
     124.  00:76E6                    >         endif
     125.  00:76E6  F5                          push af
     126.  00:76E7  CD CF 76                    call checkWorkArea
     127.  00:76EA  CA 4D 7C                    jp z,ROMDISK_DSKIO
     128.  00:76ED  F1                          pop af
     129.  00:76EE                      
     130.  00:76EE  CD CB 73                    call sendRegisters
     131.  00:76F1  36 80                       ld (hl),C_DSKIO
     132.  00:76F3  38 58                       jr c,dskioWrite                 ; read or write?
     133.  00:76F5                             
     134.  00:76F5                      dskioRead:
     135.  00:76F5  07                          rlca                            ; < 0x8000 ?
     136.  00:76F6  38 3F                       jr c,.page2and3
     137.  00:76F8                      
     138.  00:76F8                              DEBUGMESSAGE "read01"
     138.  00:76F8                    >         ifdef DEBUG
     138.  00:76F8  52                >         ld d,d
     138.  00:76F9  18 06             >         jr .skip
     138.  00:76FB  72 65 61 64 30 31 >         db string
     138.  00:7701                    > .skip:
     138.  00:7701                    >         endif
     139.  00:7701  CD C2 75                    call getSlotPage2               ; enable nowind in page 2
     140.  00:7704  F5                          push af
     141.  00:7705  CD B7 75                    call getSlotPage1
     142.  00:7708  DD 67                       ld ixh,a                        ; ixh = current nowind slot
     143.  00:770A  26 80                       ld h,$80
     144.  00:770C  CD 24 00                    call ENASLT
     145.  00:770F  C3 12 B7                    jp .page2
     146.  00:7712                              
     147.  00:7712  (B712)                      PHASE $ + $4000
     148.  00:B712                      .page2:
     149.  00:B712  3A 42 F3                    ld a,(RAMAD1)                   ; enable RAM in page 1
     150.  00:B715  26 40                       ld h,$40
     151.  00:B717  CD 24 00                    call ENASLT
     152.  00:B71A                              
     153.  00:B71A  CD 8D B8                    call readSectors01 
     154.  00:B71D                              ; TODO: carry checken?----------------------------------------------!!!!!!!!!!!!!!!
     155.  00:B71D                              
     156.  00:B71D  DD 7C                       ld a,ixh                        ; enable nowind in page 1 
     157.  00:B71F  26 40                       ld h,$40
     158.  00:B721  CD 24 00                    call ENASLT
     159.  00:B724  C3 27 77                    jp .page1        
     160.  00:B727                      
     161.  00:B727  (7727)                      DEPHASE
     162.  00:7727                      .page1:
     163.  00:7727  3A 00 80                    ld a,(usb2)
     164.  00:772A  DD 67                       ld ixh,a
     165.  00:772C  F1                          pop af
     166.  00:772D  26 80                       ld h,$80
     167.  00:772F  CD 24 00                    call ENASLT                     ; restore page 2
     168.  00:7732  DD 7C                       ld a,ixh
     169.  00:7734  B7                          or a
     170.  00:7735  FB                          ei
     171.  00:7736  C8                          ret z                           ; nothing more to read
     172.  00:7737                                      
     173.  00:7737                      .page2and3:                     
     174.  00:7737                              DEBUGMESSAGE "read23"
     174.  00:7737                    >         ifdef DEBUG
     174.  00:7737  52                >         ld d,d
     174.  00:7738  18 06             >         jr .skip
     174.  00:773A  72 65 61 64 32 33 >         db string
     174.  00:7740                    > .skip:
     174.  00:7740                    >         endif
     175.  00:7740  CD 5C 75                    call enableNowindPage0
     176.  00:7743  FD E5                       push iy
     177.  00:7745  CD E0 78                    call readSectors23
     178.  00:7748  FD E1                       pop iy
     179.  00:774A  C3 67 75                    jp restorePage0
     180.  00:774D                      
     181.  00:774D                      dskioWrite:
     182.  00:774D                              DEBUGMESSAGE "dskwrite"
     182.  00:774D                    >         ifdef DEBUG
     182.  00:774D  52                >         ld d,d
     182.  00:774E  18 08             >         jr .skip
     182.  00:7750                    >         db string
     182.  00:7750  64 73 6B 77 72 69 74 65 
     182.  00:7758                    > .skip:
     182.  00:7758                    >         endif
     183.  00:7758  07                          rlca
     184.  00:7759  38 3E                       jr c,.page2and3        
     185.  00:775B                              
     186.  00:775B                              ;call enableNowindPage2 (todo: make common routine?) 
     187.  00:775B  CD C2 75                    call getSlotPage2               ; save current slot page 2
     188.  00:775E  DD 67                       ld ixh,a
     189.  00:7760  CD B7 75                    call getSlotPage1
     190.  00:7763  DD 6F                       ld ixl,a
     191.  00:7765  26 80                       ld h,$80
     192.  00:7767  CD 24 00                    call ENASLT                     ; nowind in page 2
     193.  00:776A  C3 6D B7                    jp .page2
     194.  00:776D                      
     195.  00:776D  (B76D)                      PHASE $ + $4000
     196.  00:B76D                      .page2:
     197.  00:B76D  3A 42 F3                    ld a,(RAMAD1)
     198.  00:B770  26 40                       ld h,$40
     199.  00:B772  CD 24 00                    call ENASLT                     ; ram in page 1
     200.  00:B775                              
     201.  00:B775  CD BB B8                    call writeLoop01
     202.  00:B778  F5                          push af
     203.  00:B779                              
     204.  00:B779  DD 7D                       ld a,ixl
     205.  00:B77B  26 40                       ld h,$40
     206.  00:B77D  CD 24 00                    call ENASLT                     ; restore nowind in page 1
     207.  00:B780  C3 83 77                    jp .page1
     208.  00:B783                              
     209.  00:B783  (7783)                      DEPHASE
     210.  00:7783                      .page1:
     211.  00:7783  DD 7C                       ld a,ixh
     212.  00:7785  26 80                       ld h,$80
     213.  00:7787  CD 24 00                    call ENASLT
     214.  00:778A  F1                          pop af
     215.  00:778B  D8                          ret c                           ; return error (error code in a)
     216.  00:778C  E8                          ret pe                          ; host returns 0xfe when data for page 2/3 is available
     217.  00:778D                              DEBUGMESSAGE "doorgaan!"
     217.  00:778D                    >         ifdef DEBUG
     217.  00:778D  52                >         ld d,d
     217.  00:778E  18 09             >         jr .skip
     217.  00:7790                    >         db string
     217.  00:7790  64 6F 6F 72 67 61 61 6E 21 
     217.  00:7799                    > .skip:
     217.  00:7799                    >         endif
     218.  00:7799                              
     219.  00:7799                      .page2and3:
     220.  00:7799                              DEBUGMESSAGE "page2and3"
     220.  00:7799                    >         ifdef DEBUG
     220.  00:7799  52                >         ld d,d
     220.  00:779A  18 09             >         jr .skip
     220.  00:779C                    >         db string
     220.  00:779C  70 61 67 65 32 61 6E 64 33 
     220.  00:77A5                    > .skip:
     220.  00:77A5                    >         endif
     221.  00:77A5  CD 5C 75                    call enableNowindPage0
     222.  00:77A8  CD AE 77                    call .writeLoop23
     223.  00:77AB  C3 67 75                    jp restorePage0
     224.  00:77AE                              
     225.  00:77AE                      .writeLoop23:
     226.  00:77AE                              DEBUGMESSAGE "writeLoop23"
     226.  00:77AE                    >         ifdef DEBUG
     226.  00:77AE  52                >         ld d,d
     226.  00:77AF  18 0B             >         jr .skip
     226.  00:77B1                    >         db string
     226.  00:77B1  77 72 69 74 65 4C 6F 6F 70 32 33 
     226.  00:77BC                    > .skip:
     226.  00:77BC                    >         endif
     227.  00:77BC                              
     228.  00:77BC  26 20                       ld h,HIGH usbrd
     229.  00:77BE  CD DD 73                    call getHeader
     230.  00:77C1  D8                          ret c                           ; exit (not ready)
     231.  00:77C2  B7                          or a
     232.  00:77C3  F8                          ret m                           ; exit (no error)
     233.  00:77C4  20 18                       jr nz,.error
     234.  00:77C6                      
     235.  00:77C6                              DEBUGMESSAGE "send23"
     235.  00:77C6                    >         ifdef DEBUG
     235.  00:77C6  52                >         ld d,d
     235.  00:77C7  18 06             >         jr .skip
     235.  00:77C9  73 65 6E 64 32 33 >         db string
     235.  00:77CF                    > .skip:
     235.  00:77CF                    >         endif
     236.  00:77CF  5E                          ld e,(hl)                       ; address
     237.  00:77D0  56                          ld d,(hl)
     238.  00:77D1  4E                          ld c,(hl)                       ; number of bytes        
     239.  00:77D2  46                          ld b,(hl)
     240.  00:77D3  7E                          ld a,(hl)                       ; block sequence number
     241.  00:77D4                              
     242.  00:77D4                              ;DEBUGDUMPREGISTERS
     243.  00:77D4  EB                          ex de,hl
     244.  00:77D5  11 00 40                    ld de,usbwr
     245.  00:77D8  12                          ld (de),a                       ; mark block begin
     246.  00:77D9  ED B0                       ldir
     247.  00:77DB  12                          ld (de),a                       ; mark block end
     248.  00:77DC  18 D0                       jr .writeLoop23
     249.  00:77DE                      
     250.  00:77DE  37                  .error: scf
     251.  00:77DF  7E                          ld a,(hl)                       ; get error code
     252.  00:77E0  C9                          ret
     253.  00:77E1                      
     254.  00:77E1                                     
     255.  00:77E1                      DSKCHG:
     256.  00:77E1                      ; Input     A   Drive number
     257.  00:77E1                      ;           B   0
     258.  00:77E1                      ;           C   Media descriptor (previous)
     259.  00:77E1                      ;           HL  Base address of DPB
     260.  00:77E1                      ; Output    B   1   Disk unchanged
     261.  00:77E1                      ;               0   Unknown (DPB is updated)
     262.  00:77E1                      ;               -1  Disk changed (DPB is updated)
     263.  00:77E1                      ;           F   Carry set when not succesfull
     264.  00:77E1                      ;           A   Error code
     265.  00:77E1                      
     266.  00:77E1                              DEBUGMESSAGE "DSKCHG"
     266.  00:77E1                    >         ifdef DEBUG
     266.  00:77E1  52                >         ld d,d
     266.  00:77E2  18 06             >         jr .skip
     266.  00:77E4  44 53 4B 43 48 47 >         db string
     266.  00:77EA                    > .skip:
     266.  00:77EA                    >         endif
     267.  00:77EA  F5                          push af
     268.  00:77EB  CD CF 76                    call checkWorkArea
     269.  00:77EE  CA AC 7C                    jp z,ROMDISK_DSKCHG
     270.  00:77F1  F1                          pop af       
     271.  00:77F2                      
     272.  00:77F2  E5                          push hl
     273.  00:77F3  CD CB 73                    call sendRegisters
     274.  00:77F6  36 81                       ld (hl),C_DSKCHG
     275.  00:77F8  CD 5C 75                    call enableNowindPage0
     276.  00:77FB  26 20                       ld h,HIGH usbrd
     277.  00:77FD  CD DD 73                    call getHeader
     278.  00:7800  4E                          ld c,(hl)               ; media descriptor (when disk was changed)
     279.  00:7801  F5                          push af
     280.  00:7802  C5                          push bc
     281.  00:7803  CD 67 75                    call restorePage0
     282.  00:7806  C1                          pop bc
     283.  00:7807  F1                          pop af
     284.  00:7808  E1                          pop hl
     285.  00:7809  D8                          ret c           ; not ready
     286.  00:780A  B7                          or a
     287.  00:780B  06 01                       ld b,1
     288.  00:780D  C8                          ret z           ; not changed
     289.  00:780E  41                          ld b,c
     290.  00:780F  CD 18 78                    call GETDPB
     291.  00:7812  3E 0A                       ld a,10
     292.  00:7814  D8                          ret c
     293.  00:7815  06 FF                       ld b,255
     294.  00:7817  C9                          ret
     295.  00:7818                      
     296.  00:7818                      GETDPB:
     297.  00:7818                      ; Input     A   Drive number
     298.  00:7818                      ;           B   Media descriptor (first byte of FAT)
     299.  00:7818                      ;           C   Previous media descriptor (does not seem to be used in other drivers)
     300.  00:7818                      ;           HL  Base address of HL
     301.  00:7818                      ; Output    DPB for specified drive in [HL+1]..[HL+18]
     302.  00:7818                      
     303.  00:7818                              DEBUGMESSAGE "GETDPB"
     303.  00:7818                    >         ifdef DEBUG
     303.  00:7818  52                >         ld d,d
     303.  00:7819  18 06             >         jr .skip
     303.  00:781B  47 45 54 44 50 42 >         db string
     303.  00:7821                    > .skip:
     303.  00:7821                    >         endif
     304.  00:7821  EB                          ex de,hl
     305.  00:7822  13                          inc de
     306.  00:7823  67                          ld h,a
     307.  00:7824  78                          ld a,b
     308.  00:7825  FE F0                       cp $f0
     309.  00:7827  7C                          ld a,h
     310.  00:7828  28 24                       jr z,.hddImage
     311.  00:782A                              
     312.  00:782A                              MESSAGE "ROM GETDPB"
     312.  00:782A  CD 0B 74          >         call sendMessage
     312.  00:782D                    >         db string
     312.  00:782D  52 4F 4D 20 47 45 54 44 50 42 
     312.  00:7837  00                > .skip2: nop
     313.  00:7838                      
     314.  00:7838  78                          ld a,b
     315.  00:7839  D6 F8                       sub $f8
     316.  00:783B  D8                          ret c                           ; not supported in msxdos1
     317.  00:783C  07                          rlca                            ; 2x
     318.  00:783D  4F                          ld c,a
     319.  00:783E  07                          rlca                            ; 4x
     320.  00:783F  07                          rlca                            ; 8x
     321.  00:7840  07                          rlca                            ; 16x
     322.  00:7841  81                          add a,c                         ; 18x
     323.  00:7842  4F                          ld c,a
     324.  00:7843  06 00                       ld b,0        
     325.  00:7845  21 BD 7B                    ld hl,supportedMedia
     326.  00:7848  09                          add hl,bc
     327.  00:7849  0E 12                       ld c,18
     328.  00:784B  ED B0                       ldir
     329.  00:784D  C9                          ret
     330.  00:784E                      
     331.  00:784E                      .hddImage:
     332.  00:784E                              DEBUGMESSAGE ".hddImage"
     332.  00:784E                    >         ifdef DEBUG
     332.  00:784E  52                >         ld d,d
     332.  00:784F  18 09             >         jr .skip
     332.  00:7851                    >         db string
     332.  00:7851  2E 68 64 64 49 6D 61 67 65 
     332.  00:785A                    > .skip:
     332.  00:785A                    >         endif
     333.  00:785A                                      MESSAGE "HOST GETDPB"
     333.  00:785A  CD 0B 74          >         call sendMessage
     333.  00:785D                    >         db string
     333.  00:785D  48 4F 53 54 20 47 45 54 44 50 42 
     333.  00:7868  00                > .skip2: nop
     334.  00:7869  CD CB 73                    call sendRegisters
     335.  00:786C  36 82                       ld (hl),C_GETDPB
     336.  00:786E  CD 5C 75                    call enableNowindPage0
     337.  00:7871  26 20                       ld h,HIGH usbrd
     338.  00:7873  CD DD 73                    call getHeader
     339.  00:7876  38 09                       jr c,.exit                      ; not ready
     340.  00:7878  5F                          ld e,a                          ; destination
     341.  00:7879  56                          ld d,(hl)
     342.  00:787A  01 12 00                    ld bc,18
     343.  00:787D                              DEBUGDUMPREGISTERS
     343.  00:787D                    >         ifdef DEBUG
     343.  00:787D  ED 07             >         db $ed,7
     343.  00:787F                    >         endif
     343.  00:787F                    >         
     343.  00:787F                    >         ifdef USBDEBUG
     343.  00:787F                    ~         assert ($ < $8000)
     343.  00:787F                    ~         call sendCpuInfo
     343.  00:787F                    ~         endif
     344.  00:787F  ED B0                       ldir
     345.  00:7881                              ;DB $ed, $0a       
     346.  00:7881  C3 67 75            .exit:  jp restorePage0        
     347.  00:7884                      
     348.  00:7884                      CHOICE:
     349.  00:7884                              ;DEBUGMESSAGE "CHOICE"
     350.  00:7884                              ifdef MSXDOS2
     351.  00:7884                    ~         ld hl,.noFormat
     352.  00:7884                    ~         else
     353.  00:7884  21 00 00                    ld hl,0                         ; no choice
     354.  00:7887                              endif
     355.  00:7887  C9                          ret
     356.  00:7888                      
     357.  00:7888                      .noFormat:
     358.  00:7888  00                          db 0
     359.  00:7889                      
     360.  00:7889                      DSKFMT:
     361.  00:7889  37                          scf
     362.  00:788A  3E 10                       ld a,16                         ; other error
     363.  00:788C  C9                          ret
     364.  00:788D                              
     365.  00:788D  (B88D)                      PHASE $ + $4000
     366.  00:B88D                              
     367.  00:B88D                      readSectors01:
     368.  00:B88D                              DEBUGMESSAGE "readSectors01"
     368.  00:B88D                    >         ifdef DEBUG
     368.  00:B88D  52                >         ld d,d
     368.  00:B88E  18 0D             >         jr .skip
     368.  00:B890                    >         db string
     368.  00:B890  72 65 61 64 53 65 63 74 6F 72 73 30 31 
     368.  00:B89D                    > .skip:
     368.  00:B89D                    >         endif
     369.  00:B89D  26 80                       ld h,HIGH usb2
     370.  00:B89F  CD DD B3                    call getHeader + $4000                                  
     371.  00:B8A2  D8                          ret c                           ; carry means timeout, no carry: A == 0 means slow transfer, A == 1 means exit, A == 2 means fast transfer                                      
     372.  00:B8A3  3D                          dec a
     373.  00:B8A4  C8                          ret z
     374.  00:B8A5  FA AF B8                    jp m,.slowTransfer                              
     375.  00:B8A8  CD 21 B9                    call reverseTransfer + $4000
     376.  00:B8AB  70                          ld (hl),b
     377.  00:B8AC  71                          ld (hl),c
     378.  00:B8AD  18 DE                       jr readSectors01
     379.  00:B8AF                      
     380.  00:B8AF                      .slowTransfer:
     381.  00:B8AF  5E                          ld e,(hl)                       ; transfer address
     382.  00:B8B0  56                          ld d,(hl)
     383.  00:B8B1  4E                          ld c,(hl)                       ; transfer amount 
     384.  00:B8B2  46                          ld b,(hl)
     385.  00:B8B3  ED B0                       ldir        
     386.  00:B8B5                              
     387.  00:B8B5  56                          ld d,(hl)                       ; BUG in emulator (byte direct terugschrijven, geeft 'rukkert!')
     388.  00:B8B6  7E                          ld a,(hl)
     389.  00:B8B7  72                          ld (hl),d                       ; return end marker ($af, $0f)
     390.  00:B8B8  77                          ld (hl),a
     391.  00:B8B9  18 D2                       jr readSectors01
     392.  00:B8BB                      
     393.  00:B8BB                      writeLoop01:
     394.  00:B8BB  26 80                       ld h,HIGH usb2
     395.  00:B8BD  CD DD B3                    call getHeader + $4000
     396.  00:B8C0  D8                          ret c                           ; exit (not ready)
     397.  00:B8C1  B7                          or a
     398.  00:B8C2  F8                          ret m                           ; exit (no error)
     399.  00:B8C3  20 18                       jr nz,.error
     400.  00:B8C5                      
     401.  00:B8C5                              DEBUGMESSAGE "send01"
     401.  00:B8C5                    >         ifdef DEBUG
     401.  00:B8C5  52                >         ld d,d
     401.  00:B8C6  18 06             >         jr .skip
     401.  00:B8C8  73 65 6E 64 30 31 >         db string
     401.  00:B8CE                    > .skip:
     401.  00:B8CE                    >         endif
     402.  00:B8CE  5E                          ld e,(hl)                       ; address
     403.  00:B8CF  56                          ld d,(hl)
     404.  00:B8D0  4E                          ld c,(hl)                       ; number of bytes        
     405.  00:B8D1  46                          ld b,(hl)
     406.  00:B8D2  7E                          ld a,(hl)                       ; block sequence number
     407.  00:B8D3                      
     408.  00:B8D3  EB                          ex de,hl
     409.  00:B8D4  11 00 80                    ld de,usb2
     410.  00:B8D7  12                          ld (de),a                       ; mark block begin
     411.  00:B8D8  ED B0                       ldir
     412.  00:B8DA  12                          ld (de),a                       ; mark block end
     413.  00:B8DB  18 DE                       jr writeLoop01
     414.  00:B8DD                      
     415.  00:B8DD  37                  .error: scf
     416.  00:B8DE  7E                          ld a,(hl)                       ; get error code
     417.  00:B8DF  C9                          ret
     418.  00:B8E0                      
     419.  00:B8E0  (78E0)                      DEPHASE
     420.  00:78E0                       
     421.  00:78E0                      readSectors23:
     422.  00:78E0                              DEBUGMESSAGE "readSectors23"
     422.  00:78E0                    >         ifdef DEBUG
     422.  00:78E0  52                >         ld d,d
     422.  00:78E1  18 0D             >         jr .skip
     422.  00:78E3                    >         db string
     422.  00:78E3  72 65 61 64 53 65 63 74 6F 72 73 32 33 
     422.  00:78F0                    > .skip:
     422.  00:78F0                    >         endif
     423.  00:78F0  26 20                       ld h,HIGH usbrd
     424.  00:78F2  CD DD 73                    call getHeader
     425.  00:78F5  D8                          ret c
     426.  00:78F6  3D                          dec a
     427.  00:78F7  C8                          ret z                           ; no more data
     428.  00:78F8  FA 04 79                    jp m,.slowTransfer        
     429.  00:78FB  CD 21 79                    call reverseTransfer
     430.  00:78FE  26 40                       ld h,HIGH usbwr 
     431.  00:7900  70                          ld (hl),b
     432.  00:7901  71                          ld (hl),c
     433.  00:7902  18 DC                       jr readSectors23
     434.  00:7904                      
     435.  00:7904                      .slowTransfer:
     436.  00:7904                              DEBUGMESSAGE "slowtransfer"
     436.  00:7904                    >         ifdef DEBUG
     436.  00:7904  52                >         ld d,d
     436.  00:7905  18 0C             >         jr .skip
     436.  00:7907                    >         db string
     436.  00:7907  73 6C 6F 77 74 72 61 6E 73 66 65 72 
     436.  00:7913                    > .skip:
     436.  00:7913                    >         endif
     437.  00:7913  5E                          ld e,(hl)                       ; transfer address
     438.  00:7914  56                          ld d,(hl)
     439.  00:7915  4E                          ld c,(hl)                       ; transfer amount 
     440.  00:7916  46                          ld b,(hl)
     441.  00:7917  ED B0                       ldir
     442.  00:7919  56                          ld d,(hl)
     443.  00:791A  7E                          ld a,(hl)
     444.  00:791B  26 40                       ld h,HIGH usbwr
     445.  00:791D  72                          ld (hl),d                       ; return end marker ($af, $0f)
     446.  00:791E  77                          ld (hl),a
     447.  00:791F  18 BF                       jr readSectors23
     448.  00:7921                                     
     449.  00:7921                      reverseTransfer:
     450.  00:7921  FD 21 00 00                 ld iy,0                         ; save stack pointer
     451.  00:7925  FD 39                       add iy,sp
     452.  00:7927  5E                          ld e,(hl)                       ; transfer address
     453.  00:7928  56                          ld d,(hl)
     454.  00:7929  EB                          ex de,hl
     455.  00:792A  F9                          ld sp,hl
     456.  00:792B  EB                          ex de,hl
     457.  00:792C  46                          ld b,(hl)                       ; number of loops       
     458.  00:792D                      .loop:
     459.  00:792D                              repeat 32                       ; blocks of 64 bytes hardcoded (NowindHost.cpp)
     460.  00:792D                    <         ld d,(hl)
     461.  00:792D                    <         ld e,(hl)
     462.  00:792D                    <         push de
     463.  00:792D                    <         endrepeat
     463.  00:792D  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     463.  00:793D  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     463.  00:794D  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     463.  00:795D  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     463.  00:796D  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     463.  00:797D  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     464.  00:798D  10 9E                       djnz .loop
     465.  00:798F                              
     466.  00:798F  FD F9                       ld sp,iy                        ; restore stack pointer
     467.  00:7991  46                          ld b,(hl)                       ; return end marker
     468.  00:7992  4E                          ld c,(hl)
     469.  00:7993  C9                          ret
     470.  00:7994                            
     471.  00:7994                      OEMSTA:
     472.  00:7994  E5                          push hl
     473.  00:7995  21 A2 79                    ld hl,.statement
     474.  00:7998  CD 9F 73                    call findStatementName
     475.  00:799B  5E                          ld e,(hl)
     476.  00:799C  23                          inc hl
     477.  00:799D  56                          ld d,(hl)
     478.  00:799E  E1                          pop hl        
     479.  00:799F  D8                          ret c
     480.  00:79A0  D5                          push de
     481.  00:79A1  C9                          ret
     482.  00:79A2                      
     483.  00:79A2                      .statement:
     484.  00:79A2  49 4D 41 47 45 00           db "IMAGE",0
     485.  00:79A8  B5 79                       dw changeImage
     486.  00:79AA                              db "VSTREAM",0
     486.  00:79AA  56 53 54 52 45 41 4D 00 
     487.  00:79B2  E2 79                       dw videoStream
     488.  00:79B4  00                          db 0
     489.  00:79B5                      
     490.  00:79B5                      ; send arguments, command, filename, end with ":"
     491.  00:79B5                      changeImage:
     492.  00:79B5                              DEBUGMESSAGE "changeImage"
     492.  00:79B5                    >         ifdef DEBUG
     492.  00:79B5  52                >         ld d,d
     492.  00:79B6  18 0B             >         jr .skip
     492.  00:79B8                    >         db string
     492.  00:79B8  63 68 61 6E 67 65 49 6D 61 67 65 
     492.  00:79C3                    > .skip:
     492.  00:79C3                    >         endif
     493.  00:79C3  E5                          push hl
     494.  00:79C4  CD CB 73                    call sendRegisters
     495.  00:79C7  36 91                       ld (hl),C_CHANGEIMAGE
     496.  00:79C9  E1                          pop hl
     497.  00:79CA                              
     498.  00:79CA                      call_exit:
     499.  00:79CA                              DEBUGMESSAGE "call_exit"
     499.  00:79CA                    >         ifdef DEBUG
     499.  00:79CA  52                >         ld d,d
     499.  00:79CB  18 09             >         jr .skip
     499.  00:79CD                    >         db string
     499.  00:79CD  63 61 6C 6C 5F 65 78 69 74 
     499.  00:79D6                    > .skip:
     499.  00:79D6                    >         endif
     500.  00:79D6  7E                  .loop:  ld a,(hl)
     501.  00:79D7  32 00 40                    ld (usbwr),a
     502.  00:79DA  FE 3A                       cp ":"
     503.  00:79DC  C8                          ret z
     504.  00:79DD  B7                          or a
     505.  00:79DE  C8                          ret z
     506.  00:79DF  23                          inc hl
     507.  00:79E0  18 F4                       jr .loop
     508.  00:79E2                              
     509.  00:79E2                      videoStream: 
     510.  00:79E2  E5                          push hl
     511.  00:79E3                              include "vram.asm"
       1:  00:79E3                              
       2:  00:79E3                      vramDump:
       3:  00:79E3  F3                  	di
       4:  00:79E4  CD 5C 75                    call enableNowindPage0
       5:  00:79E7                      
       6:  00:79E7  3E 02                       ld a,2
       7:  00:79E9  D3 99                       out ($99),a
       8:  00:79EB  3E 8F                       ld a,$80+15             ; status register pointer at S#2
       9:  00:79ED  D3 99                       out ($99),a
      10:  00:79EF                      
      11:  00:79EF                      evenFrame:
      12:  00:79EF                              ; vram address 0x0000
      13:  00:79EF                              
      14:  00:79EF                              ;xor a
      15:  00:79EF                              ;out ($99),a
      16:  00:79EF                              ;ld a,$80+2
      17:  00:79EF                              ;out ($99),a
      18:  00:79EF                              
      19:  00:79EF  3E 03                       ld a,%00000011                 ; pattern generator table
      20:  00:79F1  D3 99                       out ($99),a
      21:  00:79F3  3E 84                       ld a,$80+4
      22:  00:79F5  D3 99                       out ($99),a
      23:  00:79F7                      
      24:  00:79F7  AF                          xor a                   ; color table high
      25:  00:79F8  D3 99                       out ($99),a
      26:  00:79FA  3E 8A                       ld a,$80+10
      27:  00:79FC  D3 99                       out ($99),a
      28:  00:79FE                              
      29:  00:79FE  3E 04                       ld a,%00000100          ; vram access at 0x10000
      30:  00:7A00  CD 94 7B                    call setVramAccessPointer
      31:  00:7A03  CD 2C 7A                    call tranferframe
      32:  00:7A06  CD A2 7B                    call waitForRetrace
      33:  00:7A09  CD 46 7B                    call changeColors
      34:  00:7A0C                      
      35:  00:7A0C                      oddFrame:
      36:  00:7A0C                              ; vram address 0x10000
      37:  00:7A0C                      
      38:  00:7A0C                              ;ld a,%01000000
      39:  00:7A0C                              ;out ($99),a
      40:  00:7A0C                              ;ld a,$80+2
      41:  00:7A0C                              ;out ($99),a
      42:  00:7A0C                      
      43:  00:7A0C  3E 23                       ld a,%00100011          ; pattern generator table
      44:  00:7A0E  D3 99                       out ($99),a
      45:  00:7A10  3E 84                       ld a,$80+4
      46:  00:7A12  D3 99                       out ($99),a
      47:  00:7A14                      
      48:  00:7A14  3E 64                       ld a,00000100           ; color table high
      49:  00:7A16  D3 99                       out ($99),a
      50:  00:7A18  3E 8A                       ld a,$80+10
      51:  00:7A1A  D3 99                       out ($99),a
      52:  00:7A1C                      
      53:  00:7A1C  AF                          xor a
      54:  00:7A1D  CD 94 7B                    call setVramAccessPointer
      55:  00:7A20  CD 2C 7A                    call tranferframe
      56:  00:7A23  CD A2 7B                    call waitForRetrace
      57:  00:7A26  CD 46 7B                    call changeColors
      58:  00:7A29  C3 EF 79                    jp evenFrame
      59:  00:7A2C                      
      60:  00:7A2C                      tranferframe:
      61:  00:7A2C  CD CB 73                    call sendRegisters
      62:  00:7A2F  36 FF                       ld (hl),255
      63:  00:7A31                                      
      64:  00:7A31  21 00 20                    ld hl,usbrd
      65:  00:7A34  CD DD 73                    call getHeader
      66:  00:7A37                              
      67:  00:7A37  16 70                       ld d,112			; 224x64 is 1 screen 2 page of data ($3800)
      68:  00:7A39                      write_more:        
      69:  00:7A39  21 00 20            	ld hl,usbrd
      70:  00:7A3C  01 98 00                    ld bc,$0098
      71:  00:7A3F                              repeat 128
      72:  00:7A3F                    <         outi
      73:  00:7A3F                    <         endrepeat
      73:  00:7A3F  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A4F  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A5F  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A6F  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A7F  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A8F  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A9F  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AAF  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7ABF  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7ACF  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7ADF  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AEF  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AFF  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7B0F  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7B1F  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7B2F  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      74:  00:7B3F                      
      75:  00:7B3F  15                          dec d
      76:  00:7B40  7A                          ld a,d
      77:  00:7B41  B7                          or a
      78:  00:7B42  C2 39 7A                    jp nz,write_more
      79:  00:7B45  C9                          ret		
      80:  00:7B46                      
      81:  00:7B46                      changeColors:
      82:  00:7B46  AF                          xor a			; set color register pointer to zero
      83:  00:7B47  D3 99                       out ($99),a
      84:  00:7B49  3E 90                       ld a,$80+16
      85:  00:7B4B  D3 99                       out ($99),a
      86:  00:7B4D                              
      87:  00:7B4D  21 00 20                    ld hl,usbrd
      88:  00:7B50  01 9A 00                    ld bc,$009A		; write to color register
      89:  00:7B53                      
      90:  00:7B53                              repeat 32
      91:  00:7B53                    <         outi
      92:  00:7B53                    <         endrepeat		
      92:  00:7B53  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B63  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B73  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B83  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      93:  00:7B93  C9                          ret
      94:  00:7B94                      
      95:  00:7B94                      	
      96:  00:7B94                      setVramAccessPointer:
      97:  00:7B94  D3 99                       out ($99),a
      98:  00:7B96  3E 8E                       ld a,$80+14
      99:  00:7B98  D3 99                       out ($99),a
     100:  00:7B9A  AF                          xor a
     101:  00:7B9B  D3 99                       out ($99),a
     102:  00:7B9D  3E 40                       ld a,%01000000		; vram write
     103:  00:7B9F  D3 99                       out ($99),a
     104:  00:7BA1  C9                          ret
     105:  00:7BA2                      
     106:  00:7BA2                      waitForRetrace:
     107:  00:7BA2  DB 99                       in a,($99)
     108:  00:7BA4  CB 77                       bit 6,a
     109:  00:7BA6  20 FA                       jr nz,waitForRetrace       
     110:  00:7BA8                      .lp2:        
     111:  00:7BA8  DB 99                       in a,($99)
     112:  00:7BAA  CB 77                       bit 6,a
     113:  00:7BAC  28 FA                       jr z,.lp2       
     114:  00:7BAE  C9                          ret
     115:  00:7BAF                              	
     116:  00:7BAF                      	; just let it go... 
     512.  00:7BAF  E1                          pop hl
     513.  00:7BB0  C3 CA 79                    jp call_exit
     514.  00:7BB3                              
     515.  00:7BB3                      ; hl points to text
     516.  00:7BB3                      printVdpText2:
     517.  00:7BB3  F5                                                  push af
     518.  00:7BB4  7E                  .loop:  ld a,(hl)
     519.  00:7BB5  D3 98                                               out ($98),a 
     520.  00:7BB7  23                                                  inc hl
     521.  00:7BB8  B7                                                  or a
     522.  00:7BB9  20 F9                                               jr nz,.loop
     523.  00:7BBB  F1                                                  pop af
     524.  00:7BBC  C9                                                  ret
     525.  00:7BBD                              
     526.  00:7BBD                      supportedMedia:
     527.  00:7BBD                                      
     528.  00:7BBD                      .f8:    MAKEDPB $f8, 512, 2, 112, 1 * 80 * 9, 2, 2      ; 360 kB (1 side * 80 tracks * 9 tracks/sector)
     528.  00:7BBD  (00:0001)         > .firfat equ 1
     528.  00:7BBD  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     528.  00:7BBD  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     528.  00:7BBD                    >         if sectorSize = 512
     528.  00:7BBD  (00:0004)         > .shft   equ 4
     528.  00:7BBD                    >         elseif sectorSize = 256
     528.  00:7BBD                    ~ .shft   equ 3
     528.  00:7BBD                    ~         endif
     528.  00:7BBD                    >         
     528.  00:7BBD  F8                >         db media
     528.  00:7BBE  00 02             >         dw sectorSize
     528.  00:7BC0  0F 04             >         db (sectorSize/32)-1, .shft
     528.  00:7BC2  01                >         db sectorsPerCluster-1
     528.  00:7BC3  02                >         db sectorsPerCluster
     528.  00:7BC4  01 00             >         dw .firfat
     528.  00:7BC6  02 70             >         db fatCount, maxEnt
     528.  00:7BC8  0C 00             >         dw .firrec
     528.  00:7BCA  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     528.  00:7BCC  02                >         db fatSiz
     528.  00:7BCD  05 00             >         dw .firdir
     529.  00:7BCF                      .def:   MAKEDPB $f9, 512, 2, 112, 2 * 80 * 9, 3, 2      ; 720 kB
     529.  00:7BCF  (00:0001)         > .firfat equ 1
     529.  00:7BCF  (00:0007)         > .firdir equ .firfat+(fatCount*fatSiz)
     529.  00:7BCF  (00:000E)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     529.  00:7BCF                    >         if sectorSize = 512
     529.  00:7BCF  (00:0004)         > .shft   equ 4
     529.  00:7BCF                    >         elseif sectorSize = 256
     529.  00:7BCF                    ~ .shft   equ 3
     529.  00:7BCF                    ~         endif
     529.  00:7BCF                    >         
     529.  00:7BCF  F9                >         db media
     529.  00:7BD0  00 02             >         dw sectorSize
     529.  00:7BD2  0F 04             >         db (sectorSize/32)-1, .shft
     529.  00:7BD4  01                >         db sectorsPerCluster-1
     529.  00:7BD5  02                >         db sectorsPerCluster
     529.  00:7BD6  01 00             >         dw .firfat
     529.  00:7BD8  02 70             >         db fatCount, maxEnt
     529.  00:7BDA  0E 00             >         dw .firrec
     529.  00:7BDC  CA 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     529.  00:7BDE  03                >         db fatSiz
     529.  00:7BDF  07 00             >         dw .firdir
     530.  00:7BE1                              MAKEDPB $fa, 512, 2, 112, 1 * 80 * 8, 1, 2      ; 320 kB
     530.  00:7BE1  (00:0001)         > .firfat equ 1
     530.  00:7BE1  (00:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     530.  00:7BE1  (00:000A)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     530.  00:7BE1                    >         if sectorSize = 512
     530.  00:7BE1  (00:0004)         > .shft   equ 4
     530.  00:7BE1                    >         elseif sectorSize = 256
     530.  00:7BE1                    ~ .shft   equ 3
     530.  00:7BE1                    ~         endif
     530.  00:7BE1                    >         
     530.  00:7BE1  FA                >         db media
     530.  00:7BE2  00 02             >         dw sectorSize
     530.  00:7BE4  0F 04             >         db (sectorSize/32)-1, .shft
     530.  00:7BE6  01                >         db sectorsPerCluster-1
     530.  00:7BE7  02                >         db sectorsPerCluster
     530.  00:7BE8  01 00             >         dw .firfat
     530.  00:7BEA  02 70             >         db fatCount, maxEnt
     530.  00:7BEC  0A 00             >         dw .firrec
     530.  00:7BEE  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     530.  00:7BF0  01                >         db fatSiz
     530.  00:7BF1  03 00             >         dw .firdir
     531.  00:7BF3                              MAKEDPB $fb, 512, 2, 112, 2 * 80 * 8, 2, 2      ; 640 kB
     531.  00:7BF3  (00:0001)         > .firfat equ 1
     531.  00:7BF3  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     531.  00:7BF3  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     531.  00:7BF3                    >         if sectorSize = 512
     531.  00:7BF3  (00:0004)         > .shft   equ 4
     531.  00:7BF3                    >         elseif sectorSize = 256
     531.  00:7BF3                    ~ .shft   equ 3
     531.  00:7BF3                    ~         endif
     531.  00:7BF3                    >         
     531.  00:7BF3  FB                >         db media
     531.  00:7BF4  00 02             >         dw sectorSize
     531.  00:7BF6  0F 04             >         db (sectorSize/32)-1, .shft
     531.  00:7BF8  01                >         db sectorsPerCluster-1
     531.  00:7BF9  02                >         db sectorsPerCluster
     531.  00:7BFA  01 00             >         dw .firfat
     531.  00:7BFC  02 70             >         db fatCount, maxEnt
     531.  00:7BFE  0C 00             >         dw .firrec
     531.  00:7C00  7B 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     531.  00:7C02  02                >         db fatSiz
     531.  00:7C03  05 00             >         dw .firdir
     532.  00:7C05                              MAKEDPB $fc, 512, 1, 64,  1 * 40 * 9, 2, 2      ; 180 kB
     532.  00:7C05  (00:0001)         > .firfat equ 1
     532.  00:7C05  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     532.  00:7C05  (00:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     532.  00:7C05                    >         if sectorSize = 512
     532.  00:7C05  (00:0004)         > .shft   equ 4
     532.  00:7C05                    >         elseif sectorSize = 256
     532.  00:7C05                    ~ .shft   equ 3
     532.  00:7C05                    ~         endif
     532.  00:7C05                    >         
     532.  00:7C05  FC                >         db media
     532.  00:7C06  00 02             >         dw sectorSize
     532.  00:7C08  0F 04             >         db (sectorSize/32)-1, .shft
     532.  00:7C0A  00                >         db sectorsPerCluster-1
     532.  00:7C0B  01                >         db sectorsPerCluster
     532.  00:7C0C  01 00             >         dw .firfat
     532.  00:7C0E  02 40             >         db fatCount, maxEnt
     532.  00:7C10  09 00             >         dw .firrec
     532.  00:7C12  60 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     532.  00:7C14  02                >         db fatSiz
     532.  00:7C15  05 00             >         dw .firdir
     533.  00:7C17                              MAKEDPB $fd, 512, 2, 112, 2 * 40 * 9, 2, 2      ; 360 kB
     533.  00:7C17  (00:0001)         > .firfat equ 1
     533.  00:7C17  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     533.  00:7C17  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     533.  00:7C17                    >         if sectorSize = 512
     533.  00:7C17  (00:0004)         > .shft   equ 4
     533.  00:7C17                    >         elseif sectorSize = 256
     533.  00:7C17                    ~ .shft   equ 3
     533.  00:7C17                    ~         endif
     533.  00:7C17                    >         
     533.  00:7C17  FD                >         db media
     533.  00:7C18  00 02             >         dw sectorSize
     533.  00:7C1A  0F 04             >         db (sectorSize/32)-1, .shft
     533.  00:7C1C  01                >         db sectorsPerCluster-1
     533.  00:7C1D  02                >         db sectorsPerCluster
     533.  00:7C1E  01 00             >         dw .firfat
     533.  00:7C20  02 70             >         db fatCount, maxEnt
     533.  00:7C22  0C 00             >         dw .firrec
     533.  00:7C24  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     533.  00:7C26  02                >         db fatSiz
     533.  00:7C27  05 00             >         dw .firdir
     534.  00:7C29                              MAKEDPB $fe, 512, 1, 64,  1 * 40 * 8, 1, 2      ; 160 kB
     534.  00:7C29  (00:0001)         > .firfat equ 1
     534.  00:7C29  (00:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     534.  00:7C29  (00:0007)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     534.  00:7C29                    >         if sectorSize = 512
     534.  00:7C29  (00:0004)         > .shft   equ 4
     534.  00:7C29                    >         elseif sectorSize = 256
     534.  00:7C29                    ~ .shft   equ 3
     534.  00:7C29                    ~         endif
     534.  00:7C29                    >         
     534.  00:7C29  FE                >         db media
     534.  00:7C2A  00 02             >         dw sectorSize
     534.  00:7C2C  0F 04             >         db (sectorSize/32)-1, .shft
     534.  00:7C2E  00                >         db sectorsPerCluster-1
     534.  00:7C2F  01                >         db sectorsPerCluster
     534.  00:7C30  01 00             >         dw .firfat
     534.  00:7C32  02 40             >         db fatCount, maxEnt
     534.  00:7C34  07 00             >         dw .firrec
     534.  00:7C36  3A 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     534.  00:7C38  01                >         db fatSiz
     534.  00:7C39  03 00             >         dw .firdir
     535.  00:7C3B                              MAKEDPB $ff, 512, 2, 112, 2 * 40 * 8, 1, 1      ; 320 kB
     535.  00:7C3B  (00:0001)         > .firfat equ 1
     535.  00:7C3B  (00:0002)         > .firdir equ .firfat+(fatCount*fatSiz)
     535.  00:7C3B  (00:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     535.  00:7C3B                    >         if sectorSize = 512
     535.  00:7C3B  (00:0004)         > .shft   equ 4
     535.  00:7C3B                    >         elseif sectorSize = 256
     535.  00:7C3B                    ~ .shft   equ 3
     535.  00:7C3B                    ~         endif
     535.  00:7C3B                    >         
     535.  00:7C3B  FF                >         db media
     535.  00:7C3C  00 02             >         dw sectorSize
     535.  00:7C3E  0F 04             >         db (sectorSize/32)-1, .shft
     535.  00:7C40  01                >         db sectorsPerCluster-1
     535.  00:7C41  02                >         db sectorsPerCluster
     535.  00:7C42  01 00             >         dw .firfat
     535.  00:7C44  01 70             >         db fatCount, maxEnt
     535.  00:7C46  09 00             >         dw .firrec
     535.  00:7C48  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     535.  00:7C4A  01                >         db fatSiz
     535.  00:7C4B  02 00             >         dw .firdir
     536.  00:7C4D                      
     537.  00:7C4D                      ; WARNING: in some cases DEFDPB-1 is expected!
     538.  00:7C4D  (00:7BCF)           DEFDPB  equ supportedMedia.def
     111   00:7C4D                              include "romdisk.asm"
       1.  00:7C4D                      		define	ROMDSKBANK 5			; romdisk starts in bank 5
       2.  00:7C4D                      		define	ROMDSKLAST (FLASHROMSIZE/16)-1
       3.  00:7C4D                      
       4.  00:7C4D                      
       5.  00:7C4D                      ROMDISK_DSKIO:
       6.  00:7C4D                              DEBUGMESSAGE "R_DSKIO"
       6.  00:7C4D                    >         ifdef DEBUG
       6.  00:7C4D  52                >         ld d,d
       6.  00:7C4E  18 07             >         jr .skip
       6.  00:7C50                    >         db string
       6.  00:7C50  52 5F 44 53 4B 49 4F 
       6.  00:7C57                    > .skip:
       6.  00:7C57                    >         endif
       7.  00:7C57  F1                          pop af
       8.  00:7C58  3E 00                       ld a,0
       9.  00:7C5A  D8                          ret c                           ; write protected
      10.  00:7C5B                              
      11.  00:7C5B  EB                          ex de,hl
      12.  00:7C5C  C5                  .loop:  push bc
      13.  00:7C5D  E5                          push hl        
      14.  00:7C5E                              
      15.  00:7C5E  CB 7A                       bit 7,d
      16.  00:7C60  20 1C                       jr nz,.directCopy
      17.  00:7C62  7A                          ld a,d
      18.  00:7C63  FE 3E                       cp $3e        
      19.  00:7C65  38 17                       jr c,.directCopy
      20.  00:7C67                      
      21.  00:7C67  CD 8A 7C                    call .findSector
      22.  00:7C6A  D5                          push de
      23.  00:7C6B  ED 5B 4D F3                 ld de,($f34d)        
      24.  00:7C6F  CD F4 7F                    call copyFromBank
      25.  00:7C72  D1                          pop de
      26.  00:7C73  01 00 02                    ld bc,512
      27.  00:7C76  2A 4D F3                    ld hl,($f34d)
      28.  00:7C79  CD 6E F3                    call XFER
      29.  00:7C7C  18 06                       jr .nextSector           
      30.  00:7C7E                                    
      31.  00:7C7E                      .directCopy:                
      32.  00:7C7E  CD 8A 7C                    call .findSector  
      33.  00:7C81  CD F4 7F                    call copyFromBank
      34.  00:7C84                      .nextSector:
      35.  00:7C84  E1                          pop hl
      36.  00:7C85  23                          inc hl
      37.  00:7C86  C1                          pop bc
      38.  00:7C87  10 D3                       djnz .loop
      39.  00:7C89  C9                          ret
      40.  00:7C8A                      
      41.  00:7C8A                      .findSector:        
      42.  00:7C8A  7D                          ld a,l                          ; determine bank
      43.  00:7C8B  E6 E0                       and %11100000
      44.  00:7C8D  B4                          or h
      45.  00:7C8E  07                          rlca
      46.  00:7C8F  07                          rlca
      47.  00:7C90  07                          rlca
      48.  00:7C91  47                          ld b,a
      49.  00:7C92                      
      50.  00:7C92  7D                          ld a,l
      51.  00:7C93  E6 1F                       and 31
      52.  00:7C95  4F                          ld c,a
      53.  00:7C96  3E FF                       ld a,ROMDSKLAST                 ; banks with b0..5=0 reside in the last bank
      54.  00:7C98  28 05                       jr z,.skip
      55.  00:7C9A                      
      56.  00:7C9A  78                          ld a,b
      57.  00:7C9B  C6 05                       add ROMDSKBANK
      58.  00:7C9D  41                          ld b,c
      59.  00:7C9E  05                          dec b
      60.  00:7C9F  4F                  .skip:  ld c,a
      61.  00:7CA0  78                          ld a,b
      62.  00:7CA1  07                          rlca
      63.  00:7CA2  C6 41                       add $41                         ; disk images starts at $4100
      64.  00:7CA4  67                          ld h,a
      65.  00:7CA5  2E 00                       ld l,0
      66.  00:7CA7  79                          ld a,c
      67.  00:7CA8  01 00 02                    ld bc,512
      68.  00:7CAB  C9                          ret
      69.  00:7CAC                                                               
      70.  00:7CAC                      ROMDISK_DSKCHG:
      71.  00:7CAC                              ;DEBUGMESSAGE "ROM_DSKCHG"
      72.  00:7CAC  F1                          pop af
      73.  00:7CAD  A7                          and a
      74.  00:7CAE  06 01                       ld b,1                          ; not changed
      75.  00:7CB0  C9                          ret
      76.  00:7CB1                      
      77.  00:7CB1                      ROMDISK_GETDPB:
      78.  00:7CB1                              ; not implemented (standard mediadescriptor as used)
      79.  00:7CB1                              
      80.  00:7CB1                      ROMDISK_DSKFMT:
      81.  00:7CB1                              ; not implemented (no disk can be formatted)
      82.  00:7CB1                              
     112   00:7CB1                              include "flashWriter.asm"		; todo: remove load from pc
       1.  00:7CB1                      ; flashWriter.asm
       2.  00:7CB1                      ; Flashes and erases the AMD29F040/M29F032-D
       3.  00:7CB1                           
       4.  00:7CB1                      flashWriter:
       5.  00:7CB1                              ;DEBUGMESSAGE "flashWriter"
       6.  00:7CB1  3E 03                       ld a,3
       7.  00:7CB3  CD 41 01                    call SNSMAT
       8.  00:7CB6  E6 08                       and 8
       9.  00:7CB8  C0                          ret nz
      10.  00:7CB9                              
      11.  00:7CB9  CD 8E 72                    call PRINTTEXT
      12.  00:7CBC                              db 10,13," FlashROM",10,13," "
      12.  00:7CBC  0A 0D 20 46 6C 61 73 68 52 4F 4D 0A 0D 20 
      13.  00:7CCA  2E (33)                     ds 33,"."
      14.  00:7CEB  0D 20 00                    db 13," ",0
      15.  00:7CEE                              
      16.  00:7CEE  CD B7 75                    call getSlotPage1
      17.  00:7CF1  CD 70 75                    call enableSlotPage0
      18.  00:7CF4                      
      19.  00:7CF4  21 01 7D                    ld hl,.source
      20.  00:7CF7  11 00 C0                    ld de,$c000
      21.  00:7CFA  D5                          push de
      22.  00:7CFB  01 DB 00                    ld bc,flasherEnd - $c000
      23.  00:7CFE  ED B0                       ldir
      24.  00:7D00  C9                          ret
      25.  00:7D01                              
      26.  00:7D01                      .source:     
      27.  00:7D01  (C000)                      PHASE $c000  
      28.  00:C000                              
      29.  00:C000                      waitForHeader:
      30.  00:C000  26 20                       ld h,HIGH usbrd
      31.  00:C002  7E                          ld a,(hl)
      32.  00:C003  FE BB               .chkbb: cp $bb
      33.  00:C005  20 F9                       jr nz,waitForHeader
      34.  00:C007  7E                          ld a,(hl)
      35.  00:C008  FE 55                       cp $55
      36.  00:C00A  20 F7                       jr nz,.chkbb       
      37.  00:C00C                      
      38.  00:C00C  7E                          ld a,(hl)
      39.  00:C00D  FE A2                       cp $a2
      40.  00:C00F  CA A9 C0                    jp z,verifyFlash
      41.  00:C012  FE A3                       cp $a3
      42.  00:C014  28 6E                       jr z,writeFlash
      43.  00:C016  FE A4                       cp $a4
      44.  00:C018  28 52                       jr z,chipErase
      45.  00:C01A  FE A5                       cp $a5
      46.  00:C01C  28 1C                       jr z,eraseSector
      47.  00:C01E  FE A6                       cp $a6
      48.  00:C020  28 02                       jr z,autoselectMode
      49.  00:C022                      
      50.  00:C022  20 DC                       jr nz,waitForHeader
      51.  00:C024                          
      52.  00:C024                      autoselectMode:
      53.  00:C024  3E 90                       ld a,$90
      54.  00:C026  CD CC C0                    call writeCommandSequence
      55.  00:C029                      
      56.  00:C029  2A 00 40                    ld hl,($4000)
      57.  00:C02C  EB                          ex de,hl
      58.  00:C02D  26 40                       ld h,HIGH usbwr
      59.  00:C02F  36 AA                       ld (hl),$aa
      60.  00:C031  36 55                       ld (hl),$55
      61.  00:C033  73                          ld (hl),e                       ; manufacturer ID (0x01 = AMD)
      62.  00:C034  72                          ld (hl),d                       ; device ID (0xA4 = AM29F040, 0x41 = AM29F032B)
      63.  00:C035                      
      64.  00:C035  CD 66 C0                    call writeResetCommand
      65.  00:C038  18 C6                       jr waitForHeader
      66.  00:C03A                      
      67.  00:C03A                      eraseSector:
      68.  00:C03A                              ;DEBUGMESSAGE "sector erase"
      69.  00:C03A  3E 65               	ld a,"e"
      70.  00:C03C  D3 98               	out ($98),a
      71.  00:C03E                      
      72.  00:C03E  7E                          ld a,(hl)                       ; get sector number 0..63
      73.  00:C03F  CB 27                       sla a
      74.  00:C041  CB 27                       sla a
      75.  00:C043  32 01 60                    ld (mapper),a                   ; select sector
      76.  00:C046                      
      77.  00:C046  3E 80                       ld a,$80
      78.  00:C048  CD CC C0                    call writeCommandSequence
      79.  00:C04B  3E 30                       ld a,$30        
      80.  00:C04D  CD CC C0                    call writeCommandSequence
      81.  00:C050                      
      82.  00:C050  CD 56 C0                    call waitForCommandToComplete
      83.  00:C053  C3 BD C0                    jp acknowledge
      84.  00:C056                              
      85.  00:C056                      waitForCommandToComplete:
      86.  00:C056  7E                          ld a,(hl)
      87.  00:C057  46                          ld b,(hl)
      88.  00:C058  A8                          xor b
      89.  00:C059  E6 40                       and %01000000                   ; check toggle bit I (DQ6)
      90.  00:C05B  C8                          ret z                           ; operation complete
      91.  00:C05C                              
      92.  00:C05C  78                          ld a,b
      93.  00:C05D  E6 20                       and %00100000                   ; timing limits exceeded? (DQ5)
      94.  00:C05F  28 F5                       jr z,waitForCommandToComplete
      95.  00:C061                      
      96.  00:C061  CD 66 C0                    call writeResetCommand
      97.  00:C064  78                          ld a,b
      98.  00:C065  C9                          ret
      99.  00:C066                      
     100.  00:C066                      writeResetCommand:
     101.  00:C066  3E F0                       ld a,$f0                        ; write RESET command
     102.  00:C068  32 00 00                    ld (0),a
     103.  00:C06B  C9                          ret
     104.  00:C06C                      
     105.  00:C06C                      chipErase:
     106.  00:C06C                              ;DEBUGMESSAGE "chip erase"
     107.  00:C06C  3E 45               	ld a,"E"
     108.  00:C06E  D3 98               	out ($98),a
     109.  00:C070                      
     110.  00:C070  3E 80                       ld a,$80
     111.  00:C072  CD CC C0                    call writeCommandSequence
     112.  00:C075  3E 10                       ld a,$10
     113.  00:C077  CD CC C0                    call writeCommandSequence
     114.  00:C07A                      
     115.  00:C07A  3A 00 40            .wait:  ld a,($4000)                    ; read DQ7 (data# polling) 
     116.  00:C07D  07                          rlca
     117.  00:C07E  30 FA                       jr nc,.wait        
     118.  00:C080  3E 01                       ld a,1
     119.  00:C082  18 39                       jr acknowledge
     120.  00:C084                      
     121.  00:C084                      
     122.  00:C084                      writeFlash:
     123.  00:C084                              ;DEBUGMESSAGE "write"
     124.  00:C084  5E                          ld e,(hl)                       ; address
     125.  00:C085  56                          ld d,(hl)
     126.  00:C086                      
     127.  00:C086  7A                          ld a,d
     128.  00:C087  B3                          or e
     129.  00:C088  CC C7 C0                    call z,updateBar
     130.  00:C08B                      
     131.  00:C08B  7E                          ld a,(hl)                       ; bank
     132.  00:C08C  32 01 60                    ld (mapper),a
     133.  00:C08F  26 40                       ld h,$40
     134.  00:C091                              
     135.  00:C091  06 80                       ld b,128                        ; data is written in blocks of 128 bytes
     136.  00:C093  3E A0               .loop:  ld a,$a0
     137.  00:C095  CD CC C0                    call writeCommandSequence
     138.  00:C098  3A 00 20                    ld a,(usbrd)
     139.  00:C09B  12                          ld (de),a                       ; write data to flash
     140.  00:C09C  13                          inc de
     141.  00:C09D                      
     142.  00:C09D  7E                  .wait:  ld  a,(hl)                      ; write complete?
     143.  00:C09E  AE                          xor (hl)
     144.  00:C09F  E6 40                       and %01000000
     145.  00:C0A1  20 FA                       jr  nz,.wait
     146.  00:C0A3  10 EE                       djnz .loop
     147.  00:C0A5                              
     148.  00:C0A5  3E 02                       ld a,2
     149.  00:C0A7  18 14                       jr acknowledge        
     150.  00:C0A9                              
     151.  00:C0A9                      verifyFlash:
     152.  00:C0A9                              ;DEBUGMESSAGE "verify"
     153.  00:C0A9  21 00 20                    ld hl,usbrd
     154.  00:C0AC  5E                          ld e,(hl)                       ; address
     155.  00:C0AD  56                          ld d,(hl)
     156.  00:C0AE  7E                          ld a,(hl)                       ; bank
     157.  00:C0AF  32 01 60                    ld (mapper),a
     158.  00:C0B2                      
     159.  00:C0B2  06 80                       ld b,128
     160.  00:C0B4  1A                  .loop:  ld a,(de)
     161.  00:C0B5  32 00 40                    ld (usbwr),a
     162.  00:C0B8  13                          inc de
     163.  00:C0B9  10 F9                       djnz .loop
     164.  00:C0BB                      
     165.  00:C0BB  3E 03                       ld a,3
     166.  00:C0BD                      acknowledge:        
     167.  00:C0BD  26 40                       ld h,HIGH usbwr
     168.  00:C0BF  36 AA                       ld (hl),$aa
     169.  00:C0C1  36 55                       ld (hl),$55
     170.  00:C0C3  77                          ld (hl),a
     171.  00:C0C4  C3 00 C0                    jp waitForHeader
     172.  00:C0C7                      
     173.  00:C0C7                      updateBar:
     174.  00:C0C7  3E 77                       ld a,"w"  
     175.  00:C0C9  D3 98                       out ($98),a
     176.  00:C0CB  C9                          ret
     177.  00:C0CC                      
     178.  00:C0CC                      writeCommandSequence:
     179.  00:C0CC  F5                          push af
     180.  00:C0CD  3E AA                       ld a,$aa
     181.  00:C0CF  32 55 05                    ld ($0555),a
     182.  00:C0D2  2F                          cpl
     183.  00:C0D3  32 AA 02                    ld ($02aa),a
     184.  00:C0D6  F1                          pop af
     185.  00:C0D7  32 55 05                    ld ($0555),a
     186.  00:C0DA  C9                          ret
     187.  00:C0DB                              
     188.  00:C0DB                      flasherEnd:
     189.  00:C0DB  (7DDC)                      DEPHASE
     113   00:7DDC                              include "device.asm"
       1.  00:7DDC                      ; device.asm
       2.  00:7DDC                      ; implements a basic now: device
       3.  00:7DDC                          
       4.  00:7DDC                      device:
       5.  00:7DDC  E5                          push hl
       6.  00:7DDD  21 EE 7D                    ld hl,deviceFunctions
       7.  00:7DE0  0F                          rrca
       8.  00:7DE1  3C                          inc a
       9.  00:7DE2  07                          rlca
      10.  00:7DE3  85                          add a,l
      11.  00:7DE4  6F                          ld l,a
      12.  00:7DE5  30 01                       jr nc,.nocy
      13.  00:7DE7  24                          inc h  
      14.  00:7DE8  7E                  .nocy:  ld a,(hl)
      15.  00:7DE9  23                          inc hl
      16.  00:7DEA  66                          ld h,(hl)
      17.  00:7DEB  6F                          ld l,a
      18.  00:7DEC  E3                          ex (sp),hl
      19.  00:7DED  C9                          ret
      20.  00:7DEE                      
      21.  00:7DEE                      deviceFunctions:
      22.  00:7DEE  04 7E                       dw identifyDevice               ; 0xff
      23.  00:7DF0  24 7E                       dw open                         ;  0
      24.  00:7DF2  5C 7E                       dw close                        ;  2
      25.  00:7DF4  62 7E                       dw randomIO                     ;  4
      26.  00:7DF6  66 7E                       dw write                        ;  6
      27.  00:7DF8  6C 7E                       dw read                         ;  8
      28.  00:7DFA  C2 7E                       dw loc                          ; 10
      29.  00:7DFC  D4 7E                       dw lof                          ; 12
      30.  00:7DFE  A0 7E                       dw eof                          ; 14
      31.  00:7E00  D4 7E                       dw fpos                         ; 16
      32.  00:7E02  D4 7E                       dw putback                      ; 18
      33.  00:7E04                                
      34.  00:7E04                      identifyDevice:
      35.  00:7E04                              DEBUGMESSAGE "identifyDevice"
      35.  00:7E04                    >         ifdef DEBUG
      35.  00:7E04  52                >         ld d,d
      35.  00:7E05  18 0E             >         jr .skip
      35.  00:7E07                    >         db string
      35.  00:7E07  69 64 65 6E 74 69 66 79 44 65 76 69 63 65 
      35.  00:7E15                    > .skip:
      35.  00:7E15                    >         endif
      36.  00:7E15  21 1D 7E                    ld hl,deviceNameList
      37.  00:7E18  CD 9F 73                    call findStatementName
      38.  00:7E1B  7E                          ld a,(hl)                       ; device number
      39.  00:7E1C  C9                          ret                             ; carry is set when invalid device name
      40.  00:7E1D                              
      41.  00:7E1D                      deviceNameList:
      42.  00:7E1D  4E 4F 57 00 00 00           db "NOW",0,0,0                  ; name, end marker, device number, dummy
      43.  00:7E23                              ;db "STDIN",0,1,0
      44.  00:7E23  00                          db 0
      45.  00:7E24                      
      46.  00:7E24                      ; Input     D   Global device code
      47.  00:7E24                      ;           E   File mode    
      48.  00:7E24                      ;           HL  address fcb
      49.  00:7E24                      open:
      50.  00:7E24                      ;        DEBUGMESSAGE "open"
      51.  00:7E24                      ;        DEBUGDUMPMEMHL 9
      52.  00:7E24  22 64 F8                    ld (PTRFIL),hl
      53.  00:7E27  CD CB 73                    call sendRegisters
      54.  00:7E2A  36 88                       ld (hl),C_DEVICEOPEN
      55.  00:7E2C  EB                          ex de,hl
      56.  00:7E2D  01 0B 00                    ld bc,11
      57.  00:7E30  21 66 F8                    ld hl,FILNAM
      58.  00:7E33  ED B0                       ldir
      59.  00:7E35                      
      60.  00:7E35  CD 5C 75                    call enableNowindPage0
      61.  00:7E38  26 20                       ld h,HIGH usbrd
      62.  00:7E3A  CD DD 73                    call getHeader
      63.  00:7E3D  38 0C                       jr c,deviceIoError              ; time out?
      64.  00:7E3F  B7                          or a
      65.  00:7E40  20 0B                       jr nz,openError
      66.  00:7E42                      
      67.  00:7E42  5E                          ld e,(hl)                       ; update fcb (including buffer)
      68.  00:7E43  56                          ld d,(hl)
      69.  00:7E44  4E                          ld c,(hl)
      70.  00:7E45  46                          ld b,(hl)
      71.  00:7E46  ED B0                       ldir
      72.  00:7E48  C3 67 75                    jp restorePage0        
      73.  00:7E4B                      
      74.  00:7E4B                      deviceIoError:
      75.  00:7E4B  3E 13                       ld a,19
      76.  00:7E4D                      
      77.  00:7E4D                      openError:
      78.  00:7E4D  CD 67 75                    call restorePage0
      79.  00:7E50  5F                          ld e,a
      80.  00:7E51                      
      81.  00:7E51                      basicError:
      82.  00:7E51  DD 21 6F 40                 ld ix,$406f
      83.  00:7E55  FD 2A C0 FC                 ld iy,(EXPTBL-1)
      84.  00:7E59  C3 1C 00                    jp CALSLT
      85.  00:7E5C                                      
      86.  00:7E5C                      close:
      87.  00:7E5C                      ;        DEBUGMESSAGE "close"
      88.  00:7E5C  CD CB 73                    call sendRegisters
      89.  00:7E5F  36 89                       ld (hl),C_DEVICECLOSE
      90.  00:7E61  C9                          ret
      91.  00:7E62                              
      92.  00:7E62                      randomIO:
      93.  00:7E62                      ;        DEBUGMESSAGE "randomIO"
      94.  00:7E62  1E 3D                       ld e,61                         ; bad file mode
      95.  00:7E64  18 EB                       jr basicError
      96.  00:7E66                      
      97.  00:7E66                      write:
      98.  00:7E66                      ;        DEBUGMESSAGE "write"
      99.  00:7E66  CD CB 73                    call sendRegisters
     100.  00:7E69  36 8B                       ld (hl),C_DEVICEWRITE
     101.  00:7E6B  C9                          ret        
     102.  00:7E6C                      
     103.  00:7E6C                      read:
     104.  00:7E6C                      ;        DEBUGMESSAGE "read"
     105.  00:7E6C  11 06 00                    ld de,6
     106.  00:7E6F  19                          add hl,de
     107.  00:7E70  E5                          push hl
     108.  00:7E71  5E                          ld e,(hl)
     109.  00:7E72  23                          inc hl
     110.  00:7E73  23                          inc hl
     111.  00:7E74  23                          inc hl
     112.  00:7E75  19                          add hl,de
     113.  00:7E76  7E                          ld a,(hl)
     114.  00:7E77  E1                          pop hl
     115.  00:7E78  FE 1A                       cp $1a
     116.  00:7E7A  37                          scf
     117.  00:7E7B  C8                          ret z                           ; end of file
     118.  00:7E7C  3F                          ccf
     119.  00:7E7D  34                          inc (hl)                        ; increment position
     120.  00:7E7E  C0                          ret nz                          ; buffer empty?
     121.  00:7E7F                              
     122.  00:7E7F  F5                          push af
     123.  00:7E80  2B                          dec hl
     124.  00:7E81  34                          inc (hl)                        ; increment position (high)        
     125.  00:7E82  11 FB FF                    ld de,-5
     126.  00:7E85  19                          add hl,de
     127.  00:7E86  CD CB 73                    call sendRegisters
     128.  00:7E89  36 8C                       ld (hl),C_DEVICEREAD
     129.  00:7E8B  CD 5C 75                    call enableNowindPage0
     130.  00:7E8E  26 20                       ld h,HIGH usbrd
     131.  00:7E90  CD DD 73                    call getHeader
     132.  00:7E93  38 B6                       jr c,deviceIoError
     133.  00:7E95                      
     134.  00:7E95  5E                          ld e,(hl)
     135.  00:7E96  56                          ld d,(hl)
     136.  00:7E97  4E                          ld c,(hl)
     137.  00:7E98  46                          ld b,(hl)
     138.  00:7E99  ED B0                       ldir                            ; update fcb buffer
     139.  00:7E9B  CD 67 75                    call restorePage0
     140.  00:7E9E  F1                          pop af                          ; return last character
     141.  00:7E9F  C9                          ret
     142.  00:7EA0                      
     143.  00:7EA0                      eof:
     144.  00:7EA0                      ;        DEBUGMESSAGE "eof"
     145.  00:7EA0  7E                          ld a,(hl)
     146.  00:7EA1  FE 01                       cp 1                            ; input mode?        
     147.  00:7EA3  1E 3D                       ld e,61                         ; bad file mode
     148.  00:7EA5  C2 51 7E                    jp nz,basicError
     149.  00:7EA8                                      
     150.  00:7EA8  11 06 00                    ld de,6
     151.  00:7EAB  19                          add hl,de
     152.  00:7EAC  5E                          ld e,(hl)
     153.  00:7EAD  23                          inc hl
     154.  00:7EAE  23                          inc hl
     155.  00:7EAF  23                          inc hl
     156.  00:7EB0  19                          add hl,de
     157.  00:7EB1  7E                          ld a,(hl)
     158.  00:7EB2  ED 62                       sbc hl,hl
     159.  00:7EB4  FE 1A                       cp $1a        
     160.  00:7EB6  20 01                       jr nz,.skip
     161.  00:7EB8  2B                          dec hl
     162.  00:7EB9  22 F8 F7            .skip:  ld (DAC+2),hl
     163.  00:7EBC  3E 02                       ld a,2
     164.  00:7EBE  32 63 F6                    ld (VALTYP),a
     165.  00:7EC1  C9                          ret
     166.  00:7EC2                      
     167.  00:7EC2                      loc:
     168.  00:7EC2  E5                          push hl
     169.  00:7EC3  FD E1                       pop iy
     170.  00:7EC5  FD 6E 06                    ld l,(iy+6)
     171.  00:7EC8  FD 66 05                    ld h,(iy+5)
     172.  00:7ECB                      ;        DEBUGASSERT
     173.  00:7ECB  22 F8 F7                    ld (DAC+2),hl
     174.  00:7ECE  3E 02                       ld a,2
     175.  00:7ED0  32 63 F6                    ld (VALTYP),a
     176.  00:7ED3  C9                          ret
     177.  00:7ED4                              
     178.  00:7ED4                      putback:
     179.  00:7ED4                      ;        DEBUGMESSAGE "putback"
     180.  00:7ED4                      ;        push hl
     181.  00:7ED4                      ;        pop iy
     182.  00:7ED4                      ;        ld (iy+3),c
     183.  00:7ED4                      ;        DEBUGASSERT
     184.  00:7ED4                      ;        ret
     185.  00:7ED4                      
     186.  00:7ED4                      lof:
     187.  00:7ED4                      fpos:
     188.  00:7ED4                              DEBUGMESSAGE "no support!"
     188.  00:7ED4                    >         ifdef DEBUG
     188.  00:7ED4  52                >         ld d,d
     188.  00:7ED5  18 0B             >         jr .skip
     188.  00:7ED7                    >         db string
     188.  00:7ED7  6E 6F 20 73 75 70 70 6F 72 74 21 
     188.  00:7EE2                    > .skip:
     188.  00:7EE2                    >         endif
     189.  00:7EE2                      
     190.  00:7EE2                      illegalFunctionCall:
     191.  00:7EE2  1E 05                       ld e,5
     192.  00:7EE4  C3 51 7E                    jp basicError
     193.  00:7EE7                      
     194.  00:7EE7                      ;FCB for DISK BASIC
     195.  00:7EE7                      ; +0 FL.MOD     file mode
     196.  00:7EE7                      ; +1 FL.FCA     Pointer to FCB for BDOS (low)
     197.  00:7EE7                      ; +2 FL.LCA     Pointer to FCB for BDOS (high)
     198.  00:7EE7                      ; +3 FL.LSA     Back up character
     199.  00:7EE7                      ; +4 FL.DSK     device number
     200.  00:7EE7                      ; +5 FL.SLB
     201.  00:7EE7                      ; +6 FL.BPS     Position in FL.BUF
     202.  00:7EE7                      ; +7 FL.FLG     Holds various information
     203.  00:7EE7                      ; +8 FL.OPS     Pseudo head position
     204.  00:7EE7                      ; +9 FL.BUF     256-byte file buffer
     205.  00:7EE7                      
     206.  00:7EE7                      ; device codes
     207.  00:7EE7                      ;          SS0           SS1           SS2           SS3
     208.  00:7EE7                      ;    ---------------------------------------------------------
     209.  00:7EE7                      ;    | 00 04 08 0C | 10 14 18 1C | 20 24 28 2C | 30 34 38 3C | PS0
     210.  00:7EE7                      ;    ---------------------------------------------------------
     211.  00:7EE7                      ;    | 40 44 48 4C | 50 54 58 5C | 60 64 68 6C | 70 74 78 7C | PS1
     212.  00:7EE7                      ;    ---------------------------------------------------------
     213.  00:7EE7                      ;    | 80 84 88 8C | 90 94 98 9C | A0 A4 A8 AC | B0 B4 B8 BC | PS2
     214.  00:7EE7                      ;    ---------------------------------------------------------
     215.  00:7EE7                      ;    | C0 C4 C8 CC | D0 D4 D8 DC | E0 E4 E8 EC | F0 F4 F8 FC | PS3
     216.  00:7EE7                      ;    ---------------------------------------------------------
     217.  00:7EE7                      
     218.  00:7EE7                      ; fileModes
     219.  00:7EE7                      ; FOR INPUT (01H)
     220.  00:7EE7                      ; FOR OUTPUT (02H)
     221.  00:7EE7                      ; FOR APPEND (08H)
     222.  00:7EE7                      ; random mode (04H)
     223.  00:7EE7                      
     224.  00:7EE7                      ; maximum number of files open: MAXFILES=15
     225.  00:7EE7                              
     226.  00:7EE7                      ; File Control Block
     227.  00:7EE7                      ;       0     1     2     3     4     5     6     7     8
     228.  00:7EE7                      ;    -------------------------------------------------------
     229.  00:7EE7                      ;    | Mod | 00H | 00H | 00H | DEV | 00H | POS | 00H | PPS |
     230.  00:7EE7                      ;    -------------------------------------------------------
     231.  00:7EE7                      ;                  err? bckup       posHi 
     232.  00:7EE7                      ; followed by a 256 byte buffer
     114   00:7EE7                      
     115   00:7EE7  FF (269)                    ds $8000-(endCopyFromBank-copyFromBank)-$, $ff
     116   00:7FF4                      
     117   00:7FF4                      ; bank switching and data transfer
     118   00:7FF4                      copyFromBank:
     119   00:7FF4  32 01 60                    ld (mapper),a
     120   00:7FF7  ED B0                       ldir
     121   00:7FF9                      enableBank0:
     122   00:7FF9  AF                          xor a
     123   00:7FFA                      switchBank:
     124   00:7FFA  F5                          push af
     125   00:7FFB  32 01 60                    ld (mapper),a
     126   00:7FFE  F1                          pop af
     127   00:7FFF  C9                          ret
     128   00:8000                      endCopyFromBank:
     129   00:8000                      
     130   00:8000  (01)                        page 1
     131   01:4000  (C000)                      incbin "..\roms\MSXDOS22.ROM", $4000, 3 * $4000
     132   01!0000                              PATCH $4093, mapper
     132   01!0000                    >         code ! address
     132   01:4093  01 60             >         dw word
     133   01:4095                              PATCH $8093, mapper
     133   01:4095                    >         code ! address
     133   01:8093  01 60             >         dw word
     134   01:8095                              PATCH $C093, mapper
     134   01:8095                    >         code ! address
     134   01:C093  01 60             >         dw word
     135   01:C095                      
     136   01:C095                              ; areas not used in MSXDOS22.ROM
     137   01:C095                              ; bank 1: 0x5CA0 - 0x7FFF (9056 bytes)
     138   01:C095                              ; bank 2: 0x7F30 - 0x7FFF (208 bytes)
     139   01:C095                              ; bank 3: 0x7E70 - 0x7FFF (400 bytes)
     140   01:C095                      
     141   01:C095                      ; insert MSXDOS1
     142   01:C095  (02)                	page 2
     143   02:4000                      	module	MSXDOS1_PART
     144   02:4000                      
     145   02:4000                      	define 	MSXDOSVER 1
     146   02:4000                      ;	define	ROMINIT $576f
     147   02:4000                      	define	PRINTTEXT $5f86
     148   02:4000                      
     149   02:4000  (3405)                      incbin "..\roms\DISK.ROM", 0, $7405-$4000
     150   02:7405                                      
     151   02:7405                              PATCH $4006, device
     151   02:7405                    >         code ! address
     151   02:4006  8D 7E             >         dw word
     152   02:4008                      
     153   02:4008                              code ! $4010
     154   02:4010  C3 8F 77                    jp DSKIO
     155   02:4013  C3 92 78                    jp DSKCHG
     156   02:4016  C3 C9 78                    jp GETDPB
     157   02:4019  C3 35 79                    jp CHOICE
     158   02:401C  C3 3A 79                    jp DSKFMT
     159   02:401F  00 00 00                    db 0,0,0                        ; no DRVOFF
     160   02:4022                              
     161   02:4022                              PATCH $5770, INIHRD
     161   02:4022                    >         code ! address
     161   02:5770  AD 76             >         dw word
     162   02:5772                              PATCH $57aa, $f380 + MYSIZE
     162   02:5772                    >         code ! address
     162   02:57AA  88 F3             >         dw word
     163   02:57AC                              PATCH $581e, MYSIZE
     163   02:57AC                    >         code ! address
     163   02:581E  08 00             >         dw word
     164   02:5820                              PATCH $582f, SECLEN
     164   02:5820                    >         code ! address
     164   02:582F  00 02             >         dw word
     165   02:5831                              PATCH $5851, DRIVES
     165   02:5831                    >         code ! address
     165   02:5851  D0 76             >         dw word
     166   02:5853                              PATCH $5884, DEFDPB - 1
     166   02:5853                    >         code ! address
     166   02:5884  7F 7C             >         dw word
     167   02:5886                              PATCH $5890, INIENV
     167   02:5886                    >         code ! address
     167   02:5890  39 77             >         dw word
     168   02:5892                              PATCH $5ae8, DEFDPB             ; different address in some roms
     168   02:5892                    >         code ! address
     168   02:5AE8  80 7C             >         dw word
     169   02:5AEA                              PATCH $65af, OEMSTA
     169   02:5AEA                    >         code ! address
     169   02:65AF  45 7A             >         dw word
     170   02:65B1                      	PATCH $5809, initDiskBasic      ; HRUNC
     170   02:65B1                    >         code ! address
     170   02:5809  38 74             >         dw word
     171   02:580B                              
     172   02:580B                              ;PATCH $5b9a, getHostDate        ; get date from host when no clockchip found (different 5b95)
     173   02:580B                      
     174   02:580B                      		ifdef BDOS_NOWIND
     175   02:580B                    ~ 	
     176   02:580B                    ~ 		; just patching the BDOS hook will not work; not everybody uses the hook
     177   02:580B                    ~         ;PATCH $5d20, BDOSNW						  ; overwrite the standard BDOS hook "DW $56D3" with BDOSNW
     178   02:580B                    ~         	
     179   02:580B                    ~         ; even patching the BDOS jump table will not work; internal calls (even in command.com) bypass it
     180   02:580B                    ~         ; jump table patches
     181   02:580B                    ~         ;PATCH $572b, BDOS_0FH_J				  ; overwrite specific function 0Fh in jump table
     182   02:580B                    ~         ;PATCH $572f, BDOS_11H_J				  ; overwrite specific function 11h in jump table
     183   02:580B                    ~         ;PATCH $5731, BDOS_12H_J				  ; overwrite specific function 12h in jump table
     184   02:580B                    ~         	
     185   02:580B                    ~         ; these patches are at the start of the routine themselves, the addresses are more or less "standardized" 
     186   02:580B                    ~         ; over several brands of diskroms	
     187   02:580B                    ~         ; in-routine patches
     188   02:580B                    ~         PATCH $4463, BDOS_0FH					  ; overwrite function 0Fh itself!
     189   02:580B                    ~         PATCH $4fb9, BDOS_11H 				  ; overwrite function 11h itself!
     190   02:580B                    ~         PATCH $5007, BDOS_12H 				  ; overwrite function 12h itself!
     191   02:580B                    ~         	
     192   02:580B                    ~        	endif
     193   02:580B                      				
     194   02:580B                              code ! $595d
     195   02:595D  21 D2 74                    ld hl,newAUX                    ; redirect AUX to host  
     196   02:5960  11 27 F3                    ld de,$f327
     197   02:5963  01 0A 00                    ld bc,10
     198   02:5966  ED B0                       ldir
     199   02:5968  00                          nop
     200   02:5969  00                          nop
     201   02:596A  00                          nop
     202   02:596B  00                          nop                             ; do not remove!
     203   02:596C                              
     204   02:596C                              code @ $7405
     205   02:7405                      
     206   02:7405                              include "common.asm"
       1.  02:7405                      ; Nowind specific
       2.  02:7405                      
       3.  02:7405                      nowindInit:
       4.  02:7405                              ;DEBUGMESSAGE "nowindInit"
       5.  02:7405  3A F8 FA                    ld a,($faf8)										; moet volgens bifi ld a,($2d) zijn, $faf8 is op msx1 deel van de rs232 area?
       6.  02:7408  B7                          or a 
       7.  02:7409  F5                          push af
       8.  02:740A  CC 5F 00                    call z,CHGMOD                   ; SCREEN 0 for MSX1
       9.  02:740D  F1                          pop af
      10.  02:740E  DD 21 85 01                 ld ix,SDFSCR                    ; restore screen mode from clockchip
      11.  02:7412  C4 5F 01                    call nz,EXTROM
      12.  02:7415                                      
      13.  02:7415  CD 86 5F                    call PRINTTEXT
      14.  02:7418                              ifndef DEBUG
      15.  02:7418                    ~         db "Nowind USB Diskrom!",0
      16.  02:7418                    ~         else
      17.  02:7418                              db "Nowind USB Diskrom! [debug]",0
      17.  02:7418  4E 6F 77 69 6E 64 20 55 53 42 20 44 69 73 6B 72 
      17.  02:7428  6F 6D 21 20 5B 64 65 62 75 67 5D 00 
      18.  02:7434                              endif
      19.  02:7434                      
      20.  02:7434                              ; call insertBootCode
      21.  02:7434  CD 62 7D                    call flashWriter
      22.  02:7437  C9                          ret
      23.  02:7438                      
      24.  02:7438                      initDiskBasic:
      25.  02:7438                              DEBUGMESSAGE "initDiskBasic"
      25.  02:7438                    >         ifdef DEBUG
      25.  02:7438  52                >         ld d,d
      25.  02:7439  18 0D             >         jr .skip
      25.  02:743B                    >         db string
      25.  02:743B  69 6E 69 74 44 69 73 6B 42 61 73 69 63 
      25.  02:7448                    > .skip:
      25.  02:7448                    >         endif
      26.  02:7448  21 99 FD                    ld hl,DEVICE
      27.  02:744B  CB BE                       res 7,(hl)
      28.  02:744D                              
      29.  02:744D                              if MSXDOSVER = 1 
      30.  02:744D  C3 97 58                    jp $5897
      31.  02:7450                              else
      32.  02:7450                    ~         jp $495b
      33.  02:7450                    ~         endif
      34.  02:7450                      
      35.  02:7450                      ; search call statement or device name
      36.  02:7450                      findStatementName:
      37.  02:7450                              DEBUGMESSAGE "findStatementName"
      37.  02:7450                    >         ifdef DEBUG
      37.  02:7450  52                >         ld d,d
      37.  02:7451  18 11             >         jr .skip
      37.  02:7453                    >         db string
      37.  02:7453  66 69 6E 64 53 74 61 74 65 6D 65 6E 74 4E 61 6D 
      37.  02:7463  65 
      37.  02:7464                    > .skip:
      37.  02:7464                    >         endif
      38.  02:7464  11 89 FD                    ld de,PROCNM
      39.  02:7467  1A                  .loop:  ld a,(de)
      40.  02:7468  BE                          cp (hl)
      41.  02:7469  20 06                       jr nz,.nextStatement
      42.  02:746B  23                          inc hl
      43.  02:746C  B7                          or a
      44.  02:746D  C8                          ret z                           ; name found
      45.  02:746E  13                          inc de
      46.  02:746F  18 F6                       jr .loop        
      47.  02:7471                      .nextStatement:
      48.  02:7471  AF                          xor a
      49.  02:7472  4F                          ld c,a
      50.  02:7473  ED B1                       cpir
      51.  02:7475  23                          inc hl
      52.  02:7476  23                          inc hl
      53.  02:7477  B6                          or (hl)
      54.  02:7478  20 D6                       jr nz,findStatementName        
      55.  02:747A  37                          scf                             ; not found
      56.  02:747B  C9                          ret
      57.  02:747C                      
      58.  02:747C                      sendRegisters:
      59.  02:747C  F5                          push af
      60.  02:747D  7C                          ld a,h
      61.  02:747E  26 40                       ld h,HIGH usbwr
      62.  02:7480  36 AF                       ld (hl),$af                     ; header
      63.  02:7482  36 05                       ld (hl),$05
      64.  02:7484  71                          ld (hl),c
      65.  02:7485  70                          ld (hl),b
      66.  02:7486  73                          ld (hl),e
      67.  02:7487  72                          ld (hl),d
      68.  02:7488  75                          ld (hl),l
      69.  02:7489  77                          ld (hl),a                       ; register h
      70.  02:748A  D1                          pop de
      71.  02:748B  73                          ld (hl),e                       ; register f
      72.  02:748C  72                          ld (hl),d                       ; register a
      73.  02:748D  C9                          ret
      74.  02:748E                              
      75.  02:748E                      getHeader:
      76.  02:748E  06 FF                       ld b,HIGH 65535                 ; 42000 * 60 states ~ 0,7 sec (time out)
      77.  02:7490  7E                  .loop:  ld a,(hl)
      78.  02:7491  FE AF               .chkaf: cp $af
      79.  02:7493  28 20                       jr z,.chk05
      80.  02:7495  0B                          dec bc
      81.  02:7496  78                          ld a,b
      82.  02:7497  B1                          or c
      83.  02:7498  20 F6                       jr nz,.loop
      84.  02:749A                              DEBUGMESSAGE "getHeader Timed out!"
      84.  02:749A                    >         ifdef DEBUG
      84.  02:749A  52                >         ld d,d
      84.  02:749B  18 14             >         jr .skip
      84.  02:749D                    >         db string
      84.  02:749D  67 65 74 48 65 61 64 65 72 20 54 69 6D 65 64 20 
      84.  02:74AD  6F 75 74 21 
      84.  02:74B1                    > .skip:
      84.  02:74B1                    >         endif
      85.  02:74B1  3E 02                       ld a,2                          ; not ready
      86.  02:74B3  37                          scf
      87.  02:74B4  C9                          ret
      88.  02:74B5                      
      89.  02:74B5  7E                  .chk05: ld a,(hl)
      90.  02:74B6  FE 05                       cp $05
      91.  02:74B8  20 D7                       jr nz,.chkaf
      92.  02:74BA  7E                          ld a,(hl)
      93.  02:74BB  C9                          ret
      94.  02:74BC                      
      95.  02:74BC                      sendMessage:
      96.  02:74BC                              ;DEBUGMESSAGE "sendMsg"
      97.  02:74BC  E3                          ex (sp),hl
      98.  02:74BD  F5                          push af
      99.  02:74BE  D5                          push de
     100.  02:74BF  E5                          push hl        
     101.  02:74C0  CD 7C 74                    call sendRegisters
     102.  02:74C3  36 90                       ld (hl),C_MESSAGE
     103.  02:74C5  E1                          pop hl
     104.  02:74C6  7E                  .loop:  ld a,(hl)
     105.  02:74C7  23                          inc hl
     106.  02:74C8  32 00 40                    ld (usbwr),a
     107.  02:74CB  B7                          or a
     108.  02:74CC  20 F8                       jr nz,.loop
     109.  02:74CE  D1                          pop de
     110.  02:74CF  F1                          pop af
     111.  02:74D0  E3                          ex (sp),hl
     112.  02:74D1  C9                          ret
     113.  02:74D2                              
     114.  02:74D2                      ; AUX device
     115.  02:74D2                              
     116.  02:74D2  C3 DC 74            newAUX: jp AUXin
     117.  02:74D5  00                          nop
     118.  02:74D6  00                          nop
     119.  02:74D7  C3 21 75                    jp AUXout
     120.  02:74DA  00                          nop
     121.  02:74DB  00                          nop
     122.  02:74DC                      
     123.  02:74DC                      AUXin:  DEBUGMESSAGE "AUX in"
     123.  02:74DC                    >         ifdef DEBUG
     123.  02:74DC  52                >         ld d,d
     123.  02:74DD  18 06             >         jr .skip
     123.  02:74DF  41 55 58 20 69 6E >         db string
     123.  02:74E5                    > .skip:
     123.  02:74E5                    >         endif
     124.  02:74E5  E5                          push hl
     125.  02:74E6  D5                          push de
     126.  02:74E7  C5                          push bc
     127.  02:74E8  CD 7C 74                    call sendRegisters
     128.  02:74EB  36 8E                       ld (hl),C_AUXIN
     129.  02:74ED  CD 0D 76                    call enableNowindPage0
     130.  02:74F0  26 20                       ld h,HIGH usbrd
     131.  02:74F2  CD 8E 74                    call getHeader
     132.  02:74F5  D2 10 75                    jp nc,.getCharacter
     133.  02:74F8                              
     134.  02:74F8                              DEBUGMESSAGE "not connected"
     134.  02:74F8                    >         ifdef DEBUG
     134.  02:74F8  52                >         ld d,d
     134.  02:74F9  18 0D             >         jr .skip
     134.  02:74FB                    >         db string
     134.  02:74FB  6E 6F 74 20 63 6F 6E 6E 65 63 74 65 64 
     134.  02:7508                    > .skip:
     134.  02:7508                    >         endif
     135.  02:7508  3E 1A                       ld a,$1a                        ; eof
     136.  02:750A  C1                  .exit:  pop bc
     137.  02:750B  D1                          pop de
     138.  02:750C  E1                          pop hl
     139.  02:750D  C3 18 76                    jp restorePage0        
     140.  02:7510                                    
     141.  02:7510                      .getCharacter:
     142.  02:7510                              DEBUGMESSAGE "getChar"
     142.  02:7510                    >         ifdef DEBUG
     142.  02:7510  52                >         ld d,d
     142.  02:7511  18 07             >         jr .skip
     142.  02:7513                    >         db string
     142.  02:7513  67 65 74 43 68 61 72 
     142.  02:751A                    > .skip:
     142.  02:751A                    >         endif
     143.  02:751A  CD 8E 74                    call getHeader
     144.  02:751D  38 F1                       jr c,.getCharacter
     145.  02:751F  18 E9                       jr .exit
     146.  02:7521                      
     147.  02:7521                      
     148.  02:7521                      AUXout: DEBUGMESSAGE "AUX out"
     148.  02:7521                    >         ifdef DEBUG
     148.  02:7521  52                >         ld d,d
     148.  02:7522  18 07             >         jr .skip
     148.  02:7524                    >         db string
     148.  02:7524  41 55 58 20 6F 75 74 
     148.  02:752B                    > .skip:
     148.  02:752B                    >         endif
     149.  02:752B                              DEBUGDUMPREGISTERS
     149.  02:752B                    >         ifdef DEBUG
     149.  02:752B  ED 07             >         db $ed,7
     149.  02:752D                    >         endif
     149.  02:752D                    >         
     149.  02:752D                    >         ifdef USBDEBUG
     149.  02:752D                    ~         assert ($ < $8000)
     149.  02:752D                    ~         call sendCpuInfo
     149.  02:752D                    ~         endif
     150.  02:752D  E5                          push hl
     151.  02:752E  D5                          push de
     152.  02:752F                      ;        push bc
     153.  02:752F                      ;        ld a,(RAMAD1) ; TODO: WTF???
     154.  02:752F                      ;        call RDSLT
     155.  02:752F  F5                          push af        
     156.  02:7530  CD 7C 74                    call sendRegisters
     157.  02:7533  36 8F                       ld (hl),C_AUXOUT
     158.  02:7535  F1                          pop af
     159.  02:7536                      ;        pop bc
     160.  02:7536  D1                          pop de
     161.  02:7537  E1                          pop hl
     162.  02:7538  C9                          ret
     163.  02:7539                      
     164.  02:7539                      ;insertBootCode:
     165.  02:7539                      ;        DEBUGMESSAGE "BOOTCODE"
     166.  02:7539                      ;        call sendRegisters
     167.  02:7539                      ;        ld (hl),C_BOOTCODE
     168.  02:7539                      ;        call enableNowindPage0
     169.  02:7539                      ;        call getHeader
     170.  02:7539                      ;        jp c,restorePage0
     171.  02:7539                              
     172.  02:7539                      ;        DEBUGMESSAGE "BOOTCODE"
     173.  02:7539                      ;        jp restorePage0
     174.  02:7539                      
     175.  02:7539                      ; send 32 bytes starting from address specified by DE to the usb
     176.  02:7539                      sdendFCB:
     177.  02:7539  D5                          push de
     178.  02:753A  C5                          push bc
     179.  02:753B                              
     180.  02:753B  06 20                       ld b,32
     181.  02:753D  1A                  .loop:  ld a,(de)
     182.  02:753E  32 00 40                    ld (usbwr),a
     183.  02:7541  13                          inc de
     184.  02:7542  10 F9                       djnz .loop
     185.  02:7544  C1                          pop bc
     186.  02:7545  D1                          pop de
     187.  02:7546  C9                          ret
     188.  02:7547                      
     189.  02:7547                      ; receive 32 bytes and write to the address specified by DE 
     190.  02:7547                      receiveFCB:
     191.  02:7547  D5                          push de
     192.  02:7548  C5                          push bc
     193.  02:7549                              
     194.  02:7549  06 20                       ld b,32
     195.  02:754B  3A 00 20            .loop:  ld a,(usbrd)
     196.  02:754E  32 00 40            	ld (usbwr),a			; loop back
     197.  02:7551  12                          ld (de),a
     198.  02:7552  13                          inc de
     199.  02:7553  10 F6                       djnz .loop
     200.  02:7555  C1                          pop bc
     201.  02:7556  D1                          pop de
     202.  02:7557  C9                          ret
     203.  02:7558                              
     207   02:7558                              include "extendedBios.asm"
       1.  02:7558                      
       2.  02:7558                      installExtendedBios:
       3.  02:7558                      
       4.  02:7558                              ; Called from INIENV, so EXTBIO hook is already initialized
       5.  02:7558                      
       6.  02:7558                              DEBUGMESSAGE "extbio"
       6.  02:7558                    >         ifdef DEBUG
       6.  02:7558  52                >         ld d,d
       6.  02:7559  18 06             >         jr .skip
       6.  02:755B  65 78 74 62 69 6F >         db string
       6.  02:7561                    > .skip:
       6.  02:7561                    >         endif
       7.  02:7561  CD 98 76                    call getEntrySLTWRK             ; save previous EXTBIO hook
       8.  02:7564  23                          inc hl
       9.  02:7565  EB                          ex de,hl        
      10.  02:7566  21 CA FF                    ld hl,EXTBIO
      11.  02:7569  01 05 00                    ld bc,5
      12.  02:756C  ED B0                       ldir
      13.  02:756E                              
      14.  02:756E  E5                          push hl                         ; determine device number
      15.  02:756F  AF                          xor a
      16.  02:7570  11 01 4E                    ld de,$4e01
      17.  02:7573  CD CA FF                    call EXTBIO
      18.  02:7576  E1                          pop hl
      19.  02:7577  77                          ld (hl),a
      20.  02:7578                                      
      21.  02:7578  CD 2D 40                    call GETSLT                     ; install new EXTBIO hook
      22.  02:757B  2E F7                       ld l,$f7
      23.  02:757D  67                          ld h,a
      24.  02:757E  22 CA FF                    ld (EXTBIO),hl
      25.  02:7581  21 8D 75                    ld hl,extendedBios
      26.  02:7584  22 CC FF                    ld (EXTBIO+2),hl
      27.  02:7587  3E C9                       ld a,$c9
      28.  02:7589  32 CE FF                    ld (EXTBIO+4),a    
      29.  02:758C  C9                          ret
      30.  02:758D                      
      31.  02:758D                      extendedBios:
      32.  02:758D                              ; broadcast (0x00) not implemented
      33.  02:758D                              ; system exclusive (0xff) not implemented
      34.  02:758D                      
      35.  02:758D  FB                          ei
      36.  02:758E  F5                          push af
      37.  02:758F  7A                          ld a,d
      38.  02:7590  FE 4E                       cp $4e
      39.  02:7592  28 0E                       jr z,determineFunction
      40.  02:7594                      .exit:
      41.  02:7594  E5                          push hl
      42.  02:7595  C5                          push bc
      43.  02:7596  CD 98 76                    call getEntrySLTWRK
      44.  02:7599  2C                          inc l                           ; previous EXTBIO hook 
      45.  02:759A  E5                          push hl
      46.  02:759B  DD E1                       pop ix
      47.  02:759D  C1                          pop bc        
      48.  02:759E  E1                          pop hl
      49.  02:759F  F1                          pop af
      50.  02:75A0  DD E9                       jp (ix)                         ; process other EXTBIO handles
      51.  02:75A2                      
      52.  02:75A2                      determineFunction:
      53.  02:75A2  E5                          push hl
      54.  02:75A3  21 AE D9                    ld hl,functionTable - 2 * $4e00
      55.  02:75A6  19                          add hl,de
      56.  02:75A7  19                          add hl,de
      57.  02:75A8  7E                          ld a,(hl)
      58.  02:75A9  23                          inc hl
      59.  02:75AA  66                          ld h,(hl)
      60.  02:75AB  6F                          ld l,a
      61.  02:75AC  E3                          ex (sp),hl
      62.  02:75AD  C9                          ret
      63.  02:75AE                      
      64.  02:75AE                      functionTable:
      65.  02:75AE  B4 75                       dw getNowindSlot
      66.  02:75B0  D0 75                       dw numberOfDevices
      67.  02:75B2  E7 75                       dw debugMessage
      68.  02:75B4                      
      69.  02:75B4                      getNowindSlot:               
      70.  02:75B4                              DEBUGMESSAGE "getNowindSlot"
      70.  02:75B4                    >         ifdef DEBUG
      70.  02:75B4  52                >         ld d,d
      70.  02:75B5  18 0D             >         jr .skip
      70.  02:75B7                    >         db string
      70.  02:75B7  67 65 74 4E 6F 77 69 6E 64 53 6C 6F 74 
      70.  02:75C4                    > .skip:
      70.  02:75C4                    >         endif
      71.  02:75C4  F1                          pop af
      72.  02:75C5  3D                          dec a
      73.  02:75C6  F5                          push af
      74.  02:75C7  F2 94 75                    jp p,extendedBios.exit         ; not this device
      75.  02:75CA                              
      76.  02:75CA  F1                          pop af
      77.  02:75CB  CD 68 76                    call getSlotPage1
      78.  02:75CE  37                          scf
      79.  02:75CF  C9                          ret
      80.  02:75D0                              
      81.  02:75D0                      numberOfDevices:
      82.  02:75D0                              DEBUGMESSAGE "numberOfDevices"
      82.  02:75D0                    >         ifdef DEBUG
      82.  02:75D0  52                >         ld d,d
      82.  02:75D1  18 0F             >         jr .skip
      82.  02:75D3                    >         db string
      82.  02:75D3  6E 75 6D 62 65 72 4F 66 44 65 76 69 63 65 73 
      82.  02:75E2                    > .skip:
      82.  02:75E2                    >         endif
      83.  02:75E2  F1                          pop af
      84.  02:75E3  3C                          inc a
      85.  02:75E4  F5                          push af
      86.  02:75E5  18 AD                       jr extendedBios.exit
      87.  02:75E7                              
      88.  02:75E7                      debugMessage:
      89.  02:75E7                              DEBUGMESSAGE "debugMessage"
      89.  02:75E7                    >         ifdef DEBUG
      89.  02:75E7  52                >         ld d,d
      89.  02:75E8  18 0C             >         jr .skip
      89.  02:75EA                    >         db string
      89.  02:75EA  64 65 62 75 67 4D 65 73 73 61 67 65 
      89.  02:75F6                    > .skip:
      89.  02:75F6                    >         endif
      90.  02:75F6  F1                          pop af
      91.  02:75F7  3D                          dec a
      92.  02:75F8  F5                          push af
      93.  02:75F9  F2 94 75                    jp p,extendedBios.exit
      94.  02:75FC                      
      95.  02:75FC  E5                          push hl
      96.  02:75FD  CD 7C 74                    call sendRegisters
      97.  02:7600  36 90                       ld (hl),C_MESSAGE
      98.  02:7602  E1                          pop hl
      99.  02:7603  7E                  .loop:  ld a,(hl)
     100.  02:7604  23                          inc hl
     101.  02:7605  32 00 40                    ld (usbwr),a
     102.  02:7608  B7                          or a
     103.  02:7609  20 F8                       jr nz,.loop
     104.  02:760B                              
     105.  02:760B  F1                          pop af        
     106.  02:760C  C9                          ret
     208   02:760D                              include "slotRoutines.asm"
       1.  02:760D                      ; These routines are used for slot selection
       2.  02:760D                      
       3.  02:760D                      enableNowindPage0:
       4.  02:760D  CD 5D 76                    call getSlotPage0
       5.  02:7610  DD 67                       ld ixh,a
       6.  02:7612  CD 68 76                    call getSlotPage1
       7.  02:7615  C3 21 76                    jp enableSlotPage0       
       8.  02:7618                      
       9.  02:7618                      restorePage0:
      10.  02:7618  F5                          push af
      11.  02:7619  DD 7C                       ld a,ixh
      12.  02:761B  CD 21 76                    call enableSlotPage0
      13.  02:761E  FB                          ei
      14.  02:761F  F1                          pop af
      15.  02:7620  C9                          ret
      16.  02:7621                      
      17.  02:7621                      enableSlotPage0:
      18.  02:7621                              ; HL and D remain unchanged
      19.  02:7621                              ; enableSlotPage0 can be called in page 1 and 2 (no absolute jumps)
      20.  02:7621                      
      21.  02:7621                              ;DEBUGMESSAGE "enasltP0"
      22.  02:7621  5F                          ld e,a                          ; store slotcode for further use
      23.  02:7622  E6 03                       and 3
      24.  02:7624  4F                          ld c,a                          ; new primary slot in c  
      25.  02:7625  CB 7B                       bit 7,e
      26.  02:7627  F3                          di
      27.  02:7628  20 08                       jr nz,.expanded
      28.  02:762A                      
      29.  02:762A  DB A8                       in a,($a8)
      30.  02:762C  E6 FC                       and %11111100
      31.  02:762E  B1                          or c                            ; enable new primary slot in page 0
      32.  02:762F  D3 A8                       out ($a8),a
      33.  02:7631  C9                          ret
      34.  02:7632                              
      35.  02:7632                      .expanded:
      36.  02:7632  7B                          ld a,e                          ; store secondary slot in e
      37.  02:7633  E6 0C                       and %00001100     
      38.  02:7635  0F                          rrca
      39.  02:7636  0F                          rrca
      40.  02:7637  5F                          ld e,a
      41.  02:7638                      
      42.  02:7638  DB A8                       in a,($a8)
      43.  02:763A  E6 FC                       and %11111100
      44.  02:763C  B1                          or c                            ; new primary slot in page 0
      45.  02:763D  47                          ld b,a                          ; used to restore
      46.  02:763E  17                          rla
      47.  02:763F  A7                          and a                           ; (reset carry)
      48.  02:7640  17                          rla
      49.  02:7641  B1                          or c                            ; new primary slot in page 3
      50.  02:7642  0F                          rrca
      51.  02:7643  0F                          rrca
      52.  02:7644  D3 A8                       out ($a8),a
      53.  02:7646                      
      54.  02:7646  3A FF FF                    ld a,(-1)                       ; write secondary slot register
      55.  02:7649  2F                          cpl
      56.  02:764A  E6 FC                       and %11111100
      57.  02:764C  B3                          or e                            ; apply new secondary slot for page 0
      58.  02:764D  32 FF FF                    ld (-1),a
      59.  02:7650  5F                          ld e,a                          ; store secondary slot register (for SLTTBL)
      60.  02:7651                      
      61.  02:7651  78                          ld a,b                          ; restore primary slot page 3
      62.  02:7652  D3 A8                       out ($a8),a
      63.  02:7654                      
      64.  02:7654  3E C5                       ld a,LOW SLTTBL                 ; update SLTTBL
      65.  02:7656  81                          add c                           ; add primary slot
      66.  02:7657  4F                          ld c,a
      67.  02:7658  06 FC                       ld b,HIGH SLTTBL
      68.  02:765A  7B                          ld a,e                          ; restore secondary slot register
      69.  02:765B  02                          ld (bc),a
      70.  02:765C  C9                          ret
      71.  02:765D                      
      72.  02:765D                      ; These routines determine the current slot and subslot of a page.
      73.  02:765D                      
      74.  02:765D                      getSlotPage0:
      75.  02:765D                              ;DEBUGMESSAGE "getsltP0"
      76.  02:765D  DB A8                       in a,($a8)
      77.  02:765F  CD 82 76                    call expanded
      78.  02:7662  07                          rlca
      79.  02:7663  07                          rlca
      80.  02:7664  E6 0C                       and %00001100           ; keep subSlot
      81.  02:7666  B1                          or c                    ; add mainSlot and expanded bit
      82.  02:7667  C9                          ret
      83.  02:7668                                      
      84.  02:7668                      getSlotPage1:
      85.  02:7668                      ;        DEBUGMESSAGE "getsltP1"
      86.  02:7668  DB A8                       in a,($a8)
      87.  02:766A  0F                          rrca
      88.  02:766B  0F                          rrca
      89.  02:766C  CD 82 76                    call expanded
      90.  02:766F  E6 0C                       and %00001100           ; keep subSlot
      91.  02:7671  B1                          or c                    ; add mainSlot and expanded bit
      92.  02:7672  C9                          ret        
      93.  02:7673                                      
      94.  02:7673                      getSlotPage2:
      95.  02:7673                      ;        DEBUGMESSAGE "getsltP2"
      96.  02:7673  DB A8                       in a,($a8)
      97.  02:7675  0F                          rrca
      98.  02:7676  0F                          rrca
      99.  02:7677  0F                          rrca
     100.  02:7678  0F                          rrca
     101.  02:7679  CD 82 76                    call expanded
     102.  02:767C  0F                          rrca
     103.  02:767D  0F                          rrca
     104.  02:767E  E6 0C                       and %00001100           ; keep subSlot
     105.  02:7680  B1                          or c                    ; add mainSlot and expanded bit
     106.  02:7681  C9                          ret
     107.  02:7682                      
     108.  02:7682                      ;expanded:        
     109.  02:7682                      ;        ld hl,EXPTBL - $0300
     110.  02:7682                      ;        ld b,3
     111.  02:7682                      ;        and b
     112.  02:7682                      ;        ld c,a
     113.  02:7682                      ;        add hl,bc      
     114.  02:7682                      ;        
     115.  02:7682                      ;        or (hl)        ; BUGGIE!!!! (a will be used again!)
     116.  02:7682                      ;        ret p                           ; return when slot is not expanded
     117.  02:7682                      ;        
     118.  02:7682                      ;        ld c,a
     119.  02:7682                      ;        ld a,4
     120.  02:7682                      ;        add a,l
     121.  02:7682                      ;        ld l,a
     122.  02:7682                      ;        ld a,(hl)
     123.  02:7682                      ;        ret
     124.  02:7682                      
     125.  02:7682                      expanded:        
     126.  02:7682  21 C1 F9                    ld hl,EXPTBL - $0300
     127.  02:7685  06 03                       ld b,3
     128.  02:7687  A0                          and b
     129.  02:7688  4F                          ld c,a
     130.  02:7689  09                          add hl,bc
     131.  02:768A  CB 7E                       bit 7,(hl)
     132.  02:768C  28 08                       jr z,notExpanded
     133.  02:768E                      
     134.  02:768E  CB F9                       set 7,c
     135.  02:7690  2C                          inc l
     136.  02:7691  2C                          inc l
     137.  02:7692  2C                          inc l
     138.  02:7693  2C                          inc l
     139.  02:7694  7E                          ld a,(hl)
     140.  02:7695  C9                          ret        
     141.  02:7696                      
     142.  02:7696                      notExpanded:
     143.  02:7696  C1                          pop bc
     144.  02:7697  C9                          ret
     145.  02:7698                      
     146.  02:7698                      getEntrySLTWRK:
     147.  02:7698  CD 68 76                    call getSlotPage1
     148.  02:769B  21 09 FD                    ld hl,SLTWRK
     149.  02:769E  4F                          ld c,a
     150.  02:769F  0F                          rrca
     151.  02:76A0  0F                          rrca
     152.  02:76A1  0F                          rrca
     153.  02:76A2  E6 60                       and %01100000           ; main slot x 32
     154.  02:76A4  47                          ld b,a
     155.  02:76A5  79                          ld a,c
     156.  02:76A6  07                          rlca
     157.  02:76A7  E6 18                       and %00011000           ; sub slot x 8
     158.  02:76A9  80                          add b
     159.  02:76AA  85                          add l
     160.  02:76AB  6F                          ld l,a
     161.  02:76AC  C9                          ret
     162.  02:76AD                      
     209   02:76AD                              include "nowindDriver.asm"
       1.  02:76AD  (02:0008)           MYSIZE          equ 8                   ; size of work area (not used, some programs write here to stop drives spinning)
       2.  02:76AD  (02:0200)           SECLEN          equ 512                 ; sector size
       3.  02:76AD                      
       4.  02:76AD                      ; SLTWRK entry
       5.  02:76AD                      ; +0    rom drive number
       6.  02:76AD                      ; +1..5 previous EXTBIO
       7.  02:76AD                      ; +6    not used
       8.  02:76AD                      ; +7    not used
       9.  02:76AD                      
      10.  02:76AD                             
      11.  02:76AD                      ; if this is defined we tell DOS2.3 that we _are DOS2.3 also, so
      12.  02:76AD                      ; it does not try to override our initilazations 
      13.  02:76AD                      
      14.  02:76AD                      define  PRETEND_2B_DOS23
      15.  02:76AD                              
      16.  02:76AD                      INIHRD: 
      17.  02:76AD                              DEBUGMESSAGE "INIHRD"        
      17.  02:76AD                    >         ifdef DEBUG
      17.  02:76AD  52                >         ld d,d
      17.  02:76AE  18 06             >         jr .skip
      17.  02:76B0  49 4E 49 48 52 44 >         db string
      17.  02:76B6                    > .skip:
      17.  02:76B6                    >         endif
      18.  02:76B6                              
      19.  02:76B6                      ;        call getWorkArea
      20.  02:76B6                      ;        DEBUGDUMPREGISTERS
      21.  02:76B6                                                      
      22.  02:76B6  CD 0D 76                    call enableNowindPage0                  ; clear hostToMSXFifo by reading 4Kb of random data
      23.  02:76B9  01 00 10                    ld bc,4096
      24.  02:76BC  3A 00 20            .loop:  ld a,(usbrd)
      25.  02:76BF  0B                          dec bc
      26.  02:76C0  78                          ld a,b
      27.  02:76C1  B1                          or c
      28.  02:76C2  20 F8                       jr nz,.loop
      29.  02:76C4  CD 18 76                    call restorePage0
      30.  02:76C7                              
      31.  02:76C7  26 40                       ld h,HIGH usbwr
      32.  02:76C9  36 AF                       ld (hl),$af                     ; INIHRD command
      33.  02:76CB  36 FF                       ld (hl),$ff
      34.  02:76CD  C3 05 74                    jp nowindInit
      35.  02:76D0                      
      36.  02:76D0                      DRIVES:
      37.  02:76D0                              DEBUGMESSAGE "DRIVES"
      37.  02:76D0                    >         ifdef DEBUG
      37.  02:76D0  52                >         ld d,d
      37.  02:76D1  18 06             >         jr .skip
      37.  02:76D3  44 52 49 56 45 53 >         db string
      37.  02:76D9                    > .skip:
      37.  02:76D9                    >         endif
      38.  02:76D9  F5                          push af                         ; A, BC and DE should be preserved!
      39.  02:76DA  C5                          push bc
      40.  02:76DB  D5                          push de
      41.  02:76DC  3A 99 FD                    ld a,(DEVICE)
      42.  02:76DF  CD 7C 74                    call sendRegisters
      43.  02:76E2  36 85                       ld (hl),C_DRIVES
      44.  02:76E4  CD 0D 76                    call enableNowindPage0
      45.  02:76E7  26 20                       ld h,HIGH usbrd
      46.  02:76E9  CD 8E 74                    call getHeader
      47.  02:76EC  2E 02                       ld l,2                          ; default 2 drives
      48.  02:76EE  38 2C                       jr c,.notconnected
      49.  02:76F0                      
      50.  02:76F0                              PRINTVDPTEXT " Host connected."
      50.  02:76F0                    >         
      50.  02:76F0  E5                >         push hl
      50.  02:76F1  21 FA 76          >         ld hl,.text
      50.  02:76F4  CD 64 7C          >         call printVdpText2
      50.  02:76F7  E1                >         pop hl
      50.  02:76F8  18 11             >         jr .skip
      50.  02:76FA                    > .text   db string
      50.  02:76FA  20 48 6F 73 74 20 63 6F 6E 6E 65 63 74 65 64 2E 
      50.  02:770A  00                >         db 0
      50.  02:770B                    > .skip:
      51.  02:770B                                                      
      52.  02:770B  32 3F F3                    ld (LASTDRV),a                  ; install phantom drives (CRTL key)?
      53.  02:770E  7E                          ld a,(hl)                       ; allow other drives (SHIFT key)?
      54.  02:770F  32 99 FD                    ld (DEVICE),a
      55.  02:7712  6E                          ld l,(hl)                       ; number of drives
      56.  02:7713  E5                  .exit:  push hl  
      57.  02:7714  CD 18 76                    call restorePage0
      58.  02:7717  E1                          pop hl
      59.  02:7718  D1                          pop de
      60.  02:7719  C1                          pop bc
      61.  02:771A  F1                          pop af
      62.  02:771B  C9                          ret
      63.  02:771C                              
      64.  02:771C                      .notconnected:
      65.  02:771C                              PRINTVDPTEXT " Host timed out!"            
      65.  02:771C                    >         
      65.  02:771C  E5                >         push hl
      65.  02:771D  21 26 77          >         ld hl,.text
      65.  02:7720  CD 64 7C          >         call printVdpText2
      65.  02:7723  E1                >         pop hl
      65.  02:7724  18 11             >         jr .skip
      65.  02:7726                    > .text   db string
      65.  02:7726  20 48 6F 73 74 20 74 69 6D 65 64 20 6F 75 74 21 
      65.  02:7736  00                >         db 0
      65.  02:7737                    > .skip:
      66.  02:7737  18 DA                       jr .exit
      67.  02:7739                      
      68.  02:7739                      
      69.  02:7739                      INIENV:
      70.  02:7739                      ; Interrupt handler can be installed here and
      71.  02:7739                      ; work area can be initialized when it was requested
      72.  02:7739                              DEBUGMESSAGE "INIENV"
      72.  02:7739                    >         ifdef DEBUG
      72.  02:7739  52                >         ld d,d
      72.  02:773A  18 06             >         jr .skip
      72.  02:773C  49 4E 49 45 4E 56 >         db string
      72.  02:7742                    > .skip:
      72.  02:7742                    >         endif
      73.  02:7742                      
      74.  02:7742                              ifdef PRETEND_2B_DOS23
      75.  02:7742                              DEBUGMESSAGE "Lie about being DOS v2.31"
      75.  02:7742                    >         ifdef DEBUG
      75.  02:7742  52                >         ld d,d
      75.  02:7743  18 19             >         jr .skip
      75.  02:7745                    >         db string
      75.  02:7745  4C 69 65 20 61 62 6F 75 74 20 62 65 69 6E 67 20 
      75.  02:7755  44 4F 53 20 76 32 2E 33 31 
      75.  02:775E                    > .skip:
      75.  02:775E                    >         endif
      76.  02:775E  3E 23                       ld a,$23
      77.  02:7760  32 13 F3                    ld ($f313),a
      78.  02:7763                              endif
      79.  02:7763                              
      80.  02:7763  CD 58 75                    call installExtendedBios
      81.  02:7766  CD 7C 74                    call sendRegisters
      82.  02:7769  36 86                       ld (hl),C_INIENV
      83.  02:776B  CD 0D 76                    call enableNowindPage0
      84.  02:776E  26 20                       ld h,HIGH usbrd
      85.  02:7770  CD 8E 74                    call getHeader
      86.  02:7773  F5                          push af
      87.  02:7774                      ;        push ix
      88.  02:7774                      ;        call GETWRK
      89.  02:7774                      ;        pop ix
      90.  02:7774  CD 98 76                    call getEntrySLTWRK
      91.  02:7777  F1                          pop af
      92.  02:7778  36 00                       ld (hl),0                       ; romdisk in drive A: (default)          
      93.  02:777A  38 01                       jr c,.exit
      94.  02:777C  77                          ld (hl),a                       ; store romdisk drive number (255 = no romdisk)
      95.  02:777D  C3 18 76            .exit:  jp restorePage0
      96.  02:7780                      
      97.  02:7780                      checkWorkArea:
      98.  02:7780  3E 01                       ld a,1
      99.  02:7782  A7                          and a
     100.  02:7783  C9                          ret
     101.  02:7784                              
     102.  02:7784  C5                          push bc
     103.  02:7785  E5                          push hl
     104.  02:7786  F5                          push af
     105.  02:7787                      ;        call GETWRK
     106.  02:7787  CD 98 76                    call getEntrySLTWRK
     107.  02:778A  F1                          pop af
     108.  02:778B  BE                          cp (hl)
     109.  02:778C  E1                          pop hl
     110.  02:778D  C1                          pop bc
     111.  02:778E  C9                          ret        
     112.  02:778F                      
     113.  02:778F                      DSKIO: 
     114.  02:778F                      ; Input     F   Carry for set for write, reset for read
     115.  02:778F                      ;           A   Drive number
     116.  02:778F                      ;           B   Number of sectors to read/write
     117.  02:778F                      ;           C   Media descriptor
     118.  02:778F                      ;           DE  Logical sector number
     119.  02:778F                      ;           HL  Transfer address
     120.  02:778F                      ; Output    F   Carry set when not succesfull
     121.  02:778F                      ;           A   Error code
     122.  02:778F                      ;           B   Number of remaining sectors (TODO: check! even without error?)
     123.  02:778F                      
     124.  02:778F                              DEBUGMESSAGE "DSKIO"
     124.  02:778F                    >         ifdef DEBUG
     124.  02:778F  52                >         ld d,d
     124.  02:7790  18 05             >         jr .skip
     124.  02:7792  44 53 4B 49 4F    >         db string
     124.  02:7797                    > .skip:
     124.  02:7797                    >         endif
     125.  02:7797  F5                          push af
     126.  02:7798  CD 80 77                    call checkWorkArea
     127.  02:779B  CA FE 7C                    jp z,ROMDISK_DSKIO
     128.  02:779E  F1                          pop af
     129.  02:779F                      
     130.  02:779F  CD 7C 74                    call sendRegisters
     131.  02:77A2  36 80                       ld (hl),C_DSKIO
     132.  02:77A4  38 58                       jr c,dskioWrite                 ; read or write?
     133.  02:77A6                             
     134.  02:77A6                      dskioRead:
     135.  02:77A6  07                          rlca                            ; < 0x8000 ?
     136.  02:77A7  38 3F                       jr c,.page2and3
     137.  02:77A9                      
     138.  02:77A9                              DEBUGMESSAGE "read01"
     138.  02:77A9                    >         ifdef DEBUG
     138.  02:77A9  52                >         ld d,d
     138.  02:77AA  18 06             >         jr .skip
     138.  02:77AC  72 65 61 64 30 31 >         db string
     138.  02:77B2                    > .skip:
     138.  02:77B2                    >         endif
     139.  02:77B2  CD 73 76                    call getSlotPage2               ; enable nowind in page 2
     140.  02:77B5  F5                          push af
     141.  02:77B6  CD 68 76                    call getSlotPage1
     142.  02:77B9  DD 67                       ld ixh,a                        ; ixh = current nowind slot
     143.  02:77BB  26 80                       ld h,$80
     144.  02:77BD  CD 24 00                    call ENASLT
     145.  02:77C0  C3 C3 B7                    jp .page2
     146.  02:77C3                              
     147.  02:77C3  (B7C3)                      PHASE $ + $4000
     148.  02:B7C3                      .page2:
     149.  02:B7C3  3A 42 F3                    ld a,(RAMAD1)                   ; enable RAM in page 1
     150.  02:B7C6  26 40                       ld h,$40
     151.  02:B7C8  CD 24 00                    call ENASLT
     152.  02:B7CB                              
     153.  02:B7CB  CD 3E B9                    call readSectors01 
     154.  02:B7CE                              ; TODO: carry checken?----------------------------------------------!!!!!!!!!!!!!!!
     155.  02:B7CE                              
     156.  02:B7CE  DD 7C                       ld a,ixh                        ; enable nowind in page 1 
     157.  02:B7D0  26 40                       ld h,$40
     158.  02:B7D2  CD 24 00                    call ENASLT
     159.  02:B7D5  C3 D8 77                    jp .page1        
     160.  02:B7D8                      
     161.  02:B7D8  (77D8)                      DEPHASE
     162.  02:77D8                      .page1:
     163.  02:77D8  3A 00 80                    ld a,(usb2)
     164.  02:77DB  DD 67                       ld ixh,a
     165.  02:77DD  F1                          pop af
     166.  02:77DE  26 80                       ld h,$80
     167.  02:77E0  CD 24 00                    call ENASLT                     ; restore page 2
     168.  02:77E3  DD 7C                       ld a,ixh
     169.  02:77E5  B7                          or a
     170.  02:77E6  FB                          ei
     171.  02:77E7  C8                          ret z                           ; nothing more to read
     172.  02:77E8                                      
     173.  02:77E8                      .page2and3:                     
     174.  02:77E8                              DEBUGMESSAGE "read23"
     174.  02:77E8                    >         ifdef DEBUG
     174.  02:77E8  52                >         ld d,d
     174.  02:77E9  18 06             >         jr .skip
     174.  02:77EB  72 65 61 64 32 33 >         db string
     174.  02:77F1                    > .skip:
     174.  02:77F1                    >         endif
     175.  02:77F1  CD 0D 76                    call enableNowindPage0
     176.  02:77F4  FD E5                       push iy
     177.  02:77F6  CD 91 79                    call readSectors23
     178.  02:77F9  FD E1                       pop iy
     179.  02:77FB  C3 18 76                    jp restorePage0
     180.  02:77FE                      
     181.  02:77FE                      dskioWrite:
     182.  02:77FE                              DEBUGMESSAGE "dskwrite"
     182.  02:77FE                    >         ifdef DEBUG
     182.  02:77FE  52                >         ld d,d
     182.  02:77FF  18 08             >         jr .skip
     182.  02:7801                    >         db string
     182.  02:7801  64 73 6B 77 72 69 74 65 
     182.  02:7809                    > .skip:
     182.  02:7809                    >         endif
     183.  02:7809  07                          rlca
     184.  02:780A  38 3E                       jr c,.page2and3        
     185.  02:780C                              
     186.  02:780C                              ;call enableNowindPage2 (todo: make common routine?) 
     187.  02:780C  CD 73 76                    call getSlotPage2               ; save current slot page 2
     188.  02:780F  DD 67                       ld ixh,a
     189.  02:7811  CD 68 76                    call getSlotPage1
     190.  02:7814  DD 6F                       ld ixl,a
     191.  02:7816  26 80                       ld h,$80
     192.  02:7818  CD 24 00                    call ENASLT                     ; nowind in page 2
     193.  02:781B  C3 1E B8                    jp .page2
     194.  02:781E                      
     195.  02:781E  (B81E)                      PHASE $ + $4000
     196.  02:B81E                      .page2:
     197.  02:B81E  3A 42 F3                    ld a,(RAMAD1)
     198.  02:B821  26 40                       ld h,$40
     199.  02:B823  CD 24 00                    call ENASLT                     ; ram in page 1
     200.  02:B826                              
     201.  02:B826  CD 6C B9                    call writeLoop01
     202.  02:B829  F5                          push af
     203.  02:B82A                              
     204.  02:B82A  DD 7D                       ld a,ixl
     205.  02:B82C  26 40                       ld h,$40
     206.  02:B82E  CD 24 00                    call ENASLT                     ; restore nowind in page 1
     207.  02:B831  C3 34 78                    jp .page1
     208.  02:B834                              
     209.  02:B834  (7834)                      DEPHASE
     210.  02:7834                      .page1:
     211.  02:7834  DD 7C                       ld a,ixh
     212.  02:7836  26 80                       ld h,$80
     213.  02:7838  CD 24 00                    call ENASLT
     214.  02:783B  F1                          pop af
     215.  02:783C  D8                          ret c                           ; return error (error code in a)
     216.  02:783D  E8                          ret pe                          ; host returns 0xfe when data for page 2/3 is available
     217.  02:783E                              DEBUGMESSAGE "doorgaan!"
     217.  02:783E                    >         ifdef DEBUG
     217.  02:783E  52                >         ld d,d
     217.  02:783F  18 09             >         jr .skip
     217.  02:7841                    >         db string
     217.  02:7841  64 6F 6F 72 67 61 61 6E 21 
     217.  02:784A                    > .skip:
     217.  02:784A                    >         endif
     218.  02:784A                              
     219.  02:784A                      .page2and3:
     220.  02:784A                              DEBUGMESSAGE "page2and3"
     220.  02:784A                    >         ifdef DEBUG
     220.  02:784A  52                >         ld d,d
     220.  02:784B  18 09             >         jr .skip
     220.  02:784D                    >         db string
     220.  02:784D  70 61 67 65 32 61 6E 64 33 
     220.  02:7856                    > .skip:
     220.  02:7856                    >         endif
     221.  02:7856  CD 0D 76                    call enableNowindPage0
     222.  02:7859  CD 5F 78                    call .writeLoop23
     223.  02:785C  C3 18 76                    jp restorePage0
     224.  02:785F                              
     225.  02:785F                      .writeLoop23:
     226.  02:785F                              DEBUGMESSAGE "writeLoop23"
     226.  02:785F                    >         ifdef DEBUG
     226.  02:785F  52                >         ld d,d
     226.  02:7860  18 0B             >         jr .skip
     226.  02:7862                    >         db string
     226.  02:7862  77 72 69 74 65 4C 6F 6F 70 32 33 
     226.  02:786D                    > .skip:
     226.  02:786D                    >         endif
     227.  02:786D                              
     228.  02:786D  26 20                       ld h,HIGH usbrd
     229.  02:786F  CD 8E 74                    call getHeader
     230.  02:7872  D8                          ret c                           ; exit (not ready)
     231.  02:7873  B7                          or a
     232.  02:7874  F8                          ret m                           ; exit (no error)
     233.  02:7875  20 18                       jr nz,.error
     234.  02:7877                      
     235.  02:7877                              DEBUGMESSAGE "send23"
     235.  02:7877                    >         ifdef DEBUG
     235.  02:7877  52                >         ld d,d
     235.  02:7878  18 06             >         jr .skip
     235.  02:787A  73 65 6E 64 32 33 >         db string
     235.  02:7880                    > .skip:
     235.  02:7880                    >         endif
     236.  02:7880  5E                          ld e,(hl)                       ; address
     237.  02:7881  56                          ld d,(hl)
     238.  02:7882  4E                          ld c,(hl)                       ; number of bytes        
     239.  02:7883  46                          ld b,(hl)
     240.  02:7884  7E                          ld a,(hl)                       ; block sequence number
     241.  02:7885                              
     242.  02:7885                              ;DEBUGDUMPREGISTERS
     243.  02:7885  EB                          ex de,hl
     244.  02:7886  11 00 40                    ld de,usbwr
     245.  02:7889  12                          ld (de),a                       ; mark block begin
     246.  02:788A  ED B0                       ldir
     247.  02:788C  12                          ld (de),a                       ; mark block end
     248.  02:788D  18 D0                       jr .writeLoop23
     249.  02:788F                      
     250.  02:788F  37                  .error: scf
     251.  02:7890  7E                          ld a,(hl)                       ; get error code
     252.  02:7891  C9                          ret
     253.  02:7892                      
     254.  02:7892                                     
     255.  02:7892                      DSKCHG:
     256.  02:7892                      ; Input     A   Drive number
     257.  02:7892                      ;           B   0
     258.  02:7892                      ;           C   Media descriptor (previous)
     259.  02:7892                      ;           HL  Base address of DPB
     260.  02:7892                      ; Output    B   1   Disk unchanged
     261.  02:7892                      ;               0   Unknown (DPB is updated)
     262.  02:7892                      ;               -1  Disk changed (DPB is updated)
     263.  02:7892                      ;           F   Carry set when not succesfull
     264.  02:7892                      ;           A   Error code
     265.  02:7892                      
     266.  02:7892                              DEBUGMESSAGE "DSKCHG"
     266.  02:7892                    >         ifdef DEBUG
     266.  02:7892  52                >         ld d,d
     266.  02:7893  18 06             >         jr .skip
     266.  02:7895  44 53 4B 43 48 47 >         db string
     266.  02:789B                    > .skip:
     266.  02:789B                    >         endif
     267.  02:789B  F5                          push af
     268.  02:789C  CD 80 77                    call checkWorkArea
     269.  02:789F  CA 5D 7D                    jp z,ROMDISK_DSKCHG
     270.  02:78A2  F1                          pop af       
     271.  02:78A3                      
     272.  02:78A3  E5                          push hl
     273.  02:78A4  CD 7C 74                    call sendRegisters
     274.  02:78A7  36 81                       ld (hl),C_DSKCHG
     275.  02:78A9  CD 0D 76                    call enableNowindPage0
     276.  02:78AC  26 20                       ld h,HIGH usbrd
     277.  02:78AE  CD 8E 74                    call getHeader
     278.  02:78B1  4E                          ld c,(hl)               ; media descriptor (when disk was changed)
     279.  02:78B2  F5                          push af
     280.  02:78B3  C5                          push bc
     281.  02:78B4  CD 18 76                    call restorePage0
     282.  02:78B7  C1                          pop bc
     283.  02:78B8  F1                          pop af
     284.  02:78B9  E1                          pop hl
     285.  02:78BA  D8                          ret c           ; not ready
     286.  02:78BB  B7                          or a
     287.  02:78BC  06 01                       ld b,1
     288.  02:78BE  C8                          ret z           ; not changed
     289.  02:78BF  41                          ld b,c
     290.  02:78C0  CD C9 78                    call GETDPB
     291.  02:78C3  3E 0A                       ld a,10
     292.  02:78C5  D8                          ret c
     293.  02:78C6  06 FF                       ld b,255
     294.  02:78C8  C9                          ret
     295.  02:78C9                      
     296.  02:78C9                      GETDPB:
     297.  02:78C9                      ; Input     A   Drive number
     298.  02:78C9                      ;           B   Media descriptor (first byte of FAT)
     299.  02:78C9                      ;           C   Previous media descriptor (does not seem to be used in other drivers)
     300.  02:78C9                      ;           HL  Base address of HL
     301.  02:78C9                      ; Output    DPB for specified drive in [HL+1]..[HL+18]
     302.  02:78C9                      
     303.  02:78C9                              DEBUGMESSAGE "GETDPB"
     303.  02:78C9                    >         ifdef DEBUG
     303.  02:78C9  52                >         ld d,d
     303.  02:78CA  18 06             >         jr .skip
     303.  02:78CC  47 45 54 44 50 42 >         db string
     303.  02:78D2                    > .skip:
     303.  02:78D2                    >         endif
     304.  02:78D2  EB                          ex de,hl
     305.  02:78D3  13                          inc de
     306.  02:78D4  67                          ld h,a
     307.  02:78D5  78                          ld a,b
     308.  02:78D6  FE F0                       cp $f0
     309.  02:78D8  7C                          ld a,h
     310.  02:78D9  28 24                       jr z,.hddImage
     311.  02:78DB                              
     312.  02:78DB                              MESSAGE "ROM GETDPB"
     312.  02:78DB  CD BC 74          >         call sendMessage
     312.  02:78DE                    >         db string
     312.  02:78DE  52 4F 4D 20 47 45 54 44 50 42 
     312.  02:78E8  00                > .skip2: nop
     313.  02:78E9                      
     314.  02:78E9  78                          ld a,b
     315.  02:78EA  D6 F8                       sub $f8
     316.  02:78EC  D8                          ret c                           ; not supported in msxdos1
     317.  02:78ED  07                          rlca                            ; 2x
     318.  02:78EE  4F                          ld c,a
     319.  02:78EF  07                          rlca                            ; 4x
     320.  02:78F0  07                          rlca                            ; 8x
     321.  02:78F1  07                          rlca                            ; 16x
     322.  02:78F2  81                          add a,c                         ; 18x
     323.  02:78F3  4F                          ld c,a
     324.  02:78F4  06 00                       ld b,0        
     325.  02:78F6  21 6E 7C                    ld hl,supportedMedia
     326.  02:78F9  09                          add hl,bc
     327.  02:78FA  0E 12                       ld c,18
     328.  02:78FC  ED B0                       ldir
     329.  02:78FE  C9                          ret
     330.  02:78FF                      
     331.  02:78FF                      .hddImage:
     332.  02:78FF                              DEBUGMESSAGE ".hddImage"
     332.  02:78FF                    >         ifdef DEBUG
     332.  02:78FF  52                >         ld d,d
     332.  02:7900  18 09             >         jr .skip
     332.  02:7902                    >         db string
     332.  02:7902  2E 68 64 64 49 6D 61 67 65 
     332.  02:790B                    > .skip:
     332.  02:790B                    >         endif
     333.  02:790B                                      MESSAGE "HOST GETDPB"
     333.  02:790B  CD BC 74          >         call sendMessage
     333.  02:790E                    >         db string
     333.  02:790E  48 4F 53 54 20 47 45 54 44 50 42 
     333.  02:7919  00                > .skip2: nop
     334.  02:791A  CD 7C 74                    call sendRegisters
     335.  02:791D  36 82                       ld (hl),C_GETDPB
     336.  02:791F  CD 0D 76                    call enableNowindPage0
     337.  02:7922  26 20                       ld h,HIGH usbrd
     338.  02:7924  CD 8E 74                    call getHeader
     339.  02:7927  38 09                       jr c,.exit                      ; not ready
     340.  02:7929  5F                          ld e,a                          ; destination
     341.  02:792A  56                          ld d,(hl)
     342.  02:792B  01 12 00                    ld bc,18
     343.  02:792E                              DEBUGDUMPREGISTERS
     343.  02:792E                    >         ifdef DEBUG
     343.  02:792E  ED 07             >         db $ed,7
     343.  02:7930                    >         endif
     343.  02:7930                    >         
     343.  02:7930                    >         ifdef USBDEBUG
     343.  02:7930                    ~         assert ($ < $8000)
     343.  02:7930                    ~         call sendCpuInfo
     343.  02:7930                    ~         endif
     344.  02:7930  ED B0                       ldir
     345.  02:7932                              ;DB $ed, $0a       
     346.  02:7932  C3 18 76            .exit:  jp restorePage0        
     347.  02:7935                      
     348.  02:7935                      CHOICE:
     349.  02:7935                              ;DEBUGMESSAGE "CHOICE"
     350.  02:7935                              ifdef MSXDOS2
     351.  02:7935                    ~         ld hl,.noFormat
     352.  02:7935                    ~         else
     353.  02:7935  21 00 00                    ld hl,0                         ; no choice
     354.  02:7938                              endif
     355.  02:7938  C9                          ret
     356.  02:7939                      
     357.  02:7939                      .noFormat:
     358.  02:7939  00                          db 0
     359.  02:793A                      
     360.  02:793A                      DSKFMT:
     361.  02:793A  37                          scf
     362.  02:793B  3E 10                       ld a,16                         ; other error
     363.  02:793D  C9                          ret
     364.  02:793E                              
     365.  02:793E  (B93E)                      PHASE $ + $4000
     366.  02:B93E                              
     367.  02:B93E                      readSectors01:
     368.  02:B93E                              DEBUGMESSAGE "readSectors01"
     368.  02:B93E                    >         ifdef DEBUG
     368.  02:B93E  52                >         ld d,d
     368.  02:B93F  18 0D             >         jr .skip
     368.  02:B941                    >         db string
     368.  02:B941  72 65 61 64 53 65 63 74 6F 72 73 30 31 
     368.  02:B94E                    > .skip:
     368.  02:B94E                    >         endif
     369.  02:B94E  26 80                       ld h,HIGH usb2
     370.  02:B950  CD 8E B4                    call getHeader + $4000                                  
     371.  02:B953  D8                          ret c                           ; carry means timeout, no carry: A == 0 means slow transfer, A == 1 means exit, A == 2 means fast transfer                                      
     372.  02:B954  3D                          dec a
     373.  02:B955  C8                          ret z
     374.  02:B956  FA 60 B9                    jp m,.slowTransfer                              
     375.  02:B959  CD D2 B9                    call reverseTransfer + $4000
     376.  02:B95C  70                          ld (hl),b
     377.  02:B95D  71                          ld (hl),c
     378.  02:B95E  18 DE                       jr readSectors01
     379.  02:B960                      
     380.  02:B960                      .slowTransfer:
     381.  02:B960  5E                          ld e,(hl)                       ; transfer address
     382.  02:B961  56                          ld d,(hl)
     383.  02:B962  4E                          ld c,(hl)                       ; transfer amount 
     384.  02:B963  46                          ld b,(hl)
     385.  02:B964  ED B0                       ldir        
     386.  02:B966                              
     387.  02:B966  56                          ld d,(hl)                       ; BUG in emulator (byte direct terugschrijven, geeft 'rukkert!')
     388.  02:B967  7E                          ld a,(hl)
     389.  02:B968  72                          ld (hl),d                       ; return end marker ($af, $0f)
     390.  02:B969  77                          ld (hl),a
     391.  02:B96A  18 D2                       jr readSectors01
     392.  02:B96C                      
     393.  02:B96C                      writeLoop01:
     394.  02:B96C  26 80                       ld h,HIGH usb2
     395.  02:B96E  CD 8E B4                    call getHeader + $4000
     396.  02:B971  D8                          ret c                           ; exit (not ready)
     397.  02:B972  B7                          or a
     398.  02:B973  F8                          ret m                           ; exit (no error)
     399.  02:B974  20 18                       jr nz,.error
     400.  02:B976                      
     401.  02:B976                              DEBUGMESSAGE "send01"
     401.  02:B976                    >         ifdef DEBUG
     401.  02:B976  52                >         ld d,d
     401.  02:B977  18 06             >         jr .skip
     401.  02:B979  73 65 6E 64 30 31 >         db string
     401.  02:B97F                    > .skip:
     401.  02:B97F                    >         endif
     402.  02:B97F  5E                          ld e,(hl)                       ; address
     403.  02:B980  56                          ld d,(hl)
     404.  02:B981  4E                          ld c,(hl)                       ; number of bytes        
     405.  02:B982  46                          ld b,(hl)
     406.  02:B983  7E                          ld a,(hl)                       ; block sequence number
     407.  02:B984                      
     408.  02:B984  EB                          ex de,hl
     409.  02:B985  11 00 80                    ld de,usb2
     410.  02:B988  12                          ld (de),a                       ; mark block begin
     411.  02:B989  ED B0                       ldir
     412.  02:B98B  12                          ld (de),a                       ; mark block end
     413.  02:B98C  18 DE                       jr writeLoop01
     414.  02:B98E                      
     415.  02:B98E  37                  .error: scf
     416.  02:B98F  7E                          ld a,(hl)                       ; get error code
     417.  02:B990  C9                          ret
     418.  02:B991                      
     419.  02:B991  (7991)                      DEPHASE
     420.  02:7991                       
     421.  02:7991                      readSectors23:
     422.  02:7991                              DEBUGMESSAGE "readSectors23"
     422.  02:7991                    >         ifdef DEBUG
     422.  02:7991  52                >         ld d,d
     422.  02:7992  18 0D             >         jr .skip
     422.  02:7994                    >         db string
     422.  02:7994  72 65 61 64 53 65 63 74 6F 72 73 32 33 
     422.  02:79A1                    > .skip:
     422.  02:79A1                    >         endif
     423.  02:79A1  26 20                       ld h,HIGH usbrd
     424.  02:79A3  CD 8E 74                    call getHeader
     425.  02:79A6  D8                          ret c
     426.  02:79A7  3D                          dec a
     427.  02:79A8  C8                          ret z                           ; no more data
     428.  02:79A9  FA B5 79                    jp m,.slowTransfer        
     429.  02:79AC  CD D2 79                    call reverseTransfer
     430.  02:79AF  26 40                       ld h,HIGH usbwr 
     431.  02:79B1  70                          ld (hl),b
     432.  02:79B2  71                          ld (hl),c
     433.  02:79B3  18 DC                       jr readSectors23
     434.  02:79B5                      
     435.  02:79B5                      .slowTransfer:
     436.  02:79B5                              DEBUGMESSAGE "slowtransfer"
     436.  02:79B5                    >         ifdef DEBUG
     436.  02:79B5  52                >         ld d,d
     436.  02:79B6  18 0C             >         jr .skip
     436.  02:79B8                    >         db string
     436.  02:79B8  73 6C 6F 77 74 72 61 6E 73 66 65 72 
     436.  02:79C4                    > .skip:
     436.  02:79C4                    >         endif
     437.  02:79C4  5E                          ld e,(hl)                       ; transfer address
     438.  02:79C5  56                          ld d,(hl)
     439.  02:79C6  4E                          ld c,(hl)                       ; transfer amount 
     440.  02:79C7  46                          ld b,(hl)
     441.  02:79C8  ED B0                       ldir
     442.  02:79CA  56                          ld d,(hl)
     443.  02:79CB  7E                          ld a,(hl)
     444.  02:79CC  26 40                       ld h,HIGH usbwr
     445.  02:79CE  72                          ld (hl),d                       ; return end marker ($af, $0f)
     446.  02:79CF  77                          ld (hl),a
     447.  02:79D0  18 BF                       jr readSectors23
     448.  02:79D2                                     
     449.  02:79D2                      reverseTransfer:
     450.  02:79D2  FD 21 00 00                 ld iy,0                         ; save stack pointer
     451.  02:79D6  FD 39                       add iy,sp
     452.  02:79D8  5E                          ld e,(hl)                       ; transfer address
     453.  02:79D9  56                          ld d,(hl)
     454.  02:79DA  EB                          ex de,hl
     455.  02:79DB  F9                          ld sp,hl
     456.  02:79DC  EB                          ex de,hl
     457.  02:79DD  46                          ld b,(hl)                       ; number of loops       
     458.  02:79DE                      .loop:
     459.  02:79DE                              repeat 32                       ; blocks of 64 bytes hardcoded (NowindHost.cpp)
     460.  02:79DE                    <         ld d,(hl)
     461.  02:79DE                    <         ld e,(hl)
     462.  02:79DE                    <         push de
     463.  02:79DE                    <         endrepeat
     463.  02:79DE  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     463.  02:79EE  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     463.  02:79FE  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     463.  02:7A0E  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     463.  02:7A1E  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     463.  02:7A2E  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     464.  02:7A3E  10 9E                       djnz .loop
     465.  02:7A40                              
     466.  02:7A40  FD F9                       ld sp,iy                        ; restore stack pointer
     467.  02:7A42  46                          ld b,(hl)                       ; return end marker
     468.  02:7A43  4E                          ld c,(hl)
     469.  02:7A44  C9                          ret
     470.  02:7A45                            
     471.  02:7A45                      OEMSTA:
     472.  02:7A45  E5                          push hl
     473.  02:7A46  21 53 7A                    ld hl,.statement
     474.  02:7A49  CD 50 74                    call findStatementName
     475.  02:7A4C  5E                          ld e,(hl)
     476.  02:7A4D  23                          inc hl
     477.  02:7A4E  56                          ld d,(hl)
     478.  02:7A4F  E1                          pop hl        
     479.  02:7A50  D8                          ret c
     480.  02:7A51  D5                          push de
     481.  02:7A52  C9                          ret
     482.  02:7A53                      
     483.  02:7A53                      .statement:
     484.  02:7A53  49 4D 41 47 45 00           db "IMAGE",0
     485.  02:7A59  66 7A                       dw changeImage
     486.  02:7A5B                              db "VSTREAM",0
     486.  02:7A5B  56 53 54 52 45 41 4D 00 
     487.  02:7A63  93 7A                       dw videoStream
     488.  02:7A65  00                          db 0
     489.  02:7A66                      
     490.  02:7A66                      ; send arguments, command, filename, end with ":"
     491.  02:7A66                      changeImage:
     492.  02:7A66                              DEBUGMESSAGE "changeImage"
     492.  02:7A66                    >         ifdef DEBUG
     492.  02:7A66  52                >         ld d,d
     492.  02:7A67  18 0B             >         jr .skip
     492.  02:7A69                    >         db string
     492.  02:7A69  63 68 61 6E 67 65 49 6D 61 67 65 
     492.  02:7A74                    > .skip:
     492.  02:7A74                    >         endif
     493.  02:7A74  E5                          push hl
     494.  02:7A75  CD 7C 74                    call sendRegisters
     495.  02:7A78  36 91                       ld (hl),C_CHANGEIMAGE
     496.  02:7A7A  E1                          pop hl
     497.  02:7A7B                              
     498.  02:7A7B                      call_exit:
     499.  02:7A7B                              DEBUGMESSAGE "call_exit"
     499.  02:7A7B                    >         ifdef DEBUG
     499.  02:7A7B  52                >         ld d,d
     499.  02:7A7C  18 09             >         jr .skip
     499.  02:7A7E                    >         db string
     499.  02:7A7E  63 61 6C 6C 5F 65 78 69 74 
     499.  02:7A87                    > .skip:
     499.  02:7A87                    >         endif
     500.  02:7A87  7E                  .loop:  ld a,(hl)
     501.  02:7A88  32 00 40                    ld (usbwr),a
     502.  02:7A8B  FE 3A                       cp ":"
     503.  02:7A8D  C8                          ret z
     504.  02:7A8E  B7                          or a
     505.  02:7A8F  C8                          ret z
     506.  02:7A90  23                          inc hl
     507.  02:7A91  18 F4                       jr .loop
     508.  02:7A93                              
     509.  02:7A93                      videoStream: 
     510.  02:7A93  E5                          push hl
     511.  02:7A94                              include "vram.asm"
       1:  02:7A94                              
       2:  02:7A94                      vramDump:
       3:  02:7A94  F3                  	di
       4:  02:7A95  CD 0D 76                    call enableNowindPage0
       5:  02:7A98                      
       6:  02:7A98  3E 02                       ld a,2
       7:  02:7A9A  D3 99                       out ($99),a
       8:  02:7A9C  3E 8F                       ld a,$80+15             ; status register pointer at S#2
       9:  02:7A9E  D3 99                       out ($99),a
      10:  02:7AA0                      
      11:  02:7AA0                      evenFrame:
      12:  02:7AA0                              ; vram address 0x0000
      13:  02:7AA0                              
      14:  02:7AA0                              ;xor a
      15:  02:7AA0                              ;out ($99),a
      16:  02:7AA0                              ;ld a,$80+2
      17:  02:7AA0                              ;out ($99),a
      18:  02:7AA0                              
      19:  02:7AA0  3E 03                       ld a,%00000011                 ; pattern generator table
      20:  02:7AA2  D3 99                       out ($99),a
      21:  02:7AA4  3E 84                       ld a,$80+4
      22:  02:7AA6  D3 99                       out ($99),a
      23:  02:7AA8                      
      24:  02:7AA8  AF                          xor a                   ; color table high
      25:  02:7AA9  D3 99                       out ($99),a
      26:  02:7AAB  3E 8A                       ld a,$80+10
      27:  02:7AAD  D3 99                       out ($99),a
      28:  02:7AAF                              
      29:  02:7AAF  3E 04                       ld a,%00000100          ; vram access at 0x10000
      30:  02:7AB1  CD 45 7C                    call setVramAccessPointer
      31:  02:7AB4  CD DD 7A                    call tranferframe
      32:  02:7AB7  CD 53 7C                    call waitForRetrace
      33:  02:7ABA  CD F7 7B                    call changeColors
      34:  02:7ABD                      
      35:  02:7ABD                      oddFrame:
      36:  02:7ABD                              ; vram address 0x10000
      37:  02:7ABD                      
      38:  02:7ABD                              ;ld a,%01000000
      39:  02:7ABD                              ;out ($99),a
      40:  02:7ABD                              ;ld a,$80+2
      41:  02:7ABD                              ;out ($99),a
      42:  02:7ABD                      
      43:  02:7ABD  3E 23                       ld a,%00100011          ; pattern generator table
      44:  02:7ABF  D3 99                       out ($99),a
      45:  02:7AC1  3E 84                       ld a,$80+4
      46:  02:7AC3  D3 99                       out ($99),a
      47:  02:7AC5                      
      48:  02:7AC5  3E 64                       ld a,00000100           ; color table high
      49:  02:7AC7  D3 99                       out ($99),a
      50:  02:7AC9  3E 8A                       ld a,$80+10
      51:  02:7ACB  D3 99                       out ($99),a
      52:  02:7ACD                      
      53:  02:7ACD  AF                          xor a
      54:  02:7ACE  CD 45 7C                    call setVramAccessPointer
      55:  02:7AD1  CD DD 7A                    call tranferframe
      56:  02:7AD4  CD 53 7C                    call waitForRetrace
      57:  02:7AD7  CD F7 7B                    call changeColors
      58:  02:7ADA  C3 A0 7A                    jp evenFrame
      59:  02:7ADD                      
      60:  02:7ADD                      tranferframe:
      61:  02:7ADD  CD 7C 74                    call sendRegisters
      62:  02:7AE0  36 FF                       ld (hl),255
      63:  02:7AE2                                      
      64:  02:7AE2  21 00 20                    ld hl,usbrd
      65:  02:7AE5  CD 8E 74                    call getHeader
      66:  02:7AE8                              
      67:  02:7AE8  16 70                       ld d,112			; 224x64 is 1 screen 2 page of data ($3800)
      68:  02:7AEA                      write_more:        
      69:  02:7AEA  21 00 20            	ld hl,usbrd
      70:  02:7AED  01 98 00                    ld bc,$0098
      71:  02:7AF0                              repeat 128
      72:  02:7AF0                    <         outi
      73:  02:7AF0                    <         endrepeat
      73:  02:7AF0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B00  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B10  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B20  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B30  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B40  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B50  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B60  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B70  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B80  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B90  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BA0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BB0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BC0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BD0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BE0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      74:  02:7BF0                      
      75:  02:7BF0  15                          dec d
      76:  02:7BF1  7A                          ld a,d
      77:  02:7BF2  B7                          or a
      78:  02:7BF3  C2 EA 7A                    jp nz,write_more
      79:  02:7BF6  C9                          ret		
      80:  02:7BF7                      
      81:  02:7BF7                      changeColors:
      82:  02:7BF7  AF                          xor a			; set color register pointer to zero
      83:  02:7BF8  D3 99                       out ($99),a
      84:  02:7BFA  3E 90                       ld a,$80+16
      85:  02:7BFC  D3 99                       out ($99),a
      86:  02:7BFE                              
      87:  02:7BFE  21 00 20                    ld hl,usbrd
      88:  02:7C01  01 9A 00                    ld bc,$009A		; write to color register
      89:  02:7C04                      
      90:  02:7C04                              repeat 32
      91:  02:7C04                    <         outi
      92:  02:7C04                    <         endrepeat		
      92:  02:7C04  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  02:7C14  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  02:7C24  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  02:7C34  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      93:  02:7C44  C9                          ret
      94:  02:7C45                      
      95:  02:7C45                      	
      96:  02:7C45                      setVramAccessPointer:
      97:  02:7C45  D3 99                       out ($99),a
      98:  02:7C47  3E 8E                       ld a,$80+14
      99:  02:7C49  D3 99                       out ($99),a
     100:  02:7C4B  AF                          xor a
     101:  02:7C4C  D3 99                       out ($99),a
     102:  02:7C4E  3E 40                       ld a,%01000000		; vram write
     103:  02:7C50  D3 99                       out ($99),a
     104:  02:7C52  C9                          ret
     105:  02:7C53                      
     106:  02:7C53                      waitForRetrace:
     107:  02:7C53  DB 99                       in a,($99)
     108:  02:7C55  CB 77                       bit 6,a
     109:  02:7C57  20 FA                       jr nz,waitForRetrace       
     110:  02:7C59                      .lp2:        
     111:  02:7C59  DB 99                       in a,($99)
     112:  02:7C5B  CB 77                       bit 6,a
     113:  02:7C5D  28 FA                       jr z,.lp2       
     114:  02:7C5F  C9                          ret
     115:  02:7C60                              	
     116:  02:7C60                      	; just let it go... 
     512.  02:7C60  E1                          pop hl
     513.  02:7C61  C3 7B 7A                    jp call_exit
     514.  02:7C64                              
     515.  02:7C64                      ; hl points to text
     516.  02:7C64                      printVdpText2:
     517.  02:7C64  F5                                                  push af
     518.  02:7C65  7E                  .loop:  ld a,(hl)
     519.  02:7C66  D3 98                                               out ($98),a 
     520.  02:7C68  23                                                  inc hl
     521.  02:7C69  B7                                                  or a
     522.  02:7C6A  20 F9                                               jr nz,.loop
     523.  02:7C6C  F1                                                  pop af
     524.  02:7C6D  C9                                                  ret
     525.  02:7C6E                              
     526.  02:7C6E                      supportedMedia:
     527.  02:7C6E                                      
     528.  02:7C6E                      .f8:    MAKEDPB $f8, 512, 2, 112, 1 * 80 * 9, 2, 2      ; 360 kB (1 side * 80 tracks * 9 tracks/sector)
     528.  02:7C6E  (02:0001)         > .firfat equ 1
     528.  02:7C6E  (02:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     528.  02:7C6E  (02:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     528.  02:7C6E                    >         if sectorSize = 512
     528.  02:7C6E  (02:0004)         > .shft   equ 4
     528.  02:7C6E                    >         elseif sectorSize = 256
     528.  02:7C6E                    ~ .shft   equ 3
     528.  02:7C6E                    ~         endif
     528.  02:7C6E                    >         
     528.  02:7C6E  F8                >         db media
     528.  02:7C6F  00 02             >         dw sectorSize
     528.  02:7C71  0F 04             >         db (sectorSize/32)-1, .shft
     528.  02:7C73  01                >         db sectorsPerCluster-1
     528.  02:7C74  02                >         db sectorsPerCluster
     528.  02:7C75  01 00             >         dw .firfat
     528.  02:7C77  02 70             >         db fatCount, maxEnt
     528.  02:7C79  0C 00             >         dw .firrec
     528.  02:7C7B  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     528.  02:7C7D  02                >         db fatSiz
     528.  02:7C7E  05 00             >         dw .firdir
     529.  02:7C80                      .def:   MAKEDPB $f9, 512, 2, 112, 2 * 80 * 9, 3, 2      ; 720 kB
     529.  02:7C80  (02:0001)         > .firfat equ 1
     529.  02:7C80  (02:0007)         > .firdir equ .firfat+(fatCount*fatSiz)
     529.  02:7C80  (02:000E)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     529.  02:7C80                    >         if sectorSize = 512
     529.  02:7C80  (02:0004)         > .shft   equ 4
     529.  02:7C80                    >         elseif sectorSize = 256
     529.  02:7C80                    ~ .shft   equ 3
     529.  02:7C80                    ~         endif
     529.  02:7C80                    >         
     529.  02:7C80  F9                >         db media
     529.  02:7C81  00 02             >         dw sectorSize
     529.  02:7C83  0F 04             >         db (sectorSize/32)-1, .shft
     529.  02:7C85  01                >         db sectorsPerCluster-1
     529.  02:7C86  02                >         db sectorsPerCluster
     529.  02:7C87  01 00             >         dw .firfat
     529.  02:7C89  02 70             >         db fatCount, maxEnt
     529.  02:7C8B  0E 00             >         dw .firrec
     529.  02:7C8D  CA 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     529.  02:7C8F  03                >         db fatSiz
     529.  02:7C90  07 00             >         dw .firdir
     530.  02:7C92                              MAKEDPB $fa, 512, 2, 112, 1 * 80 * 8, 1, 2      ; 320 kB
     530.  02:7C92  (02:0001)         > .firfat equ 1
     530.  02:7C92  (02:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     530.  02:7C92  (02:000A)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     530.  02:7C92                    >         if sectorSize = 512
     530.  02:7C92  (02:0004)         > .shft   equ 4
     530.  02:7C92                    >         elseif sectorSize = 256
     530.  02:7C92                    ~ .shft   equ 3
     530.  02:7C92                    ~         endif
     530.  02:7C92                    >         
     530.  02:7C92  FA                >         db media
     530.  02:7C93  00 02             >         dw sectorSize
     530.  02:7C95  0F 04             >         db (sectorSize/32)-1, .shft
     530.  02:7C97  01                >         db sectorsPerCluster-1
     530.  02:7C98  02                >         db sectorsPerCluster
     530.  02:7C99  01 00             >         dw .firfat
     530.  02:7C9B  02 70             >         db fatCount, maxEnt
     530.  02:7C9D  0A 00             >         dw .firrec
     530.  02:7C9F  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     530.  02:7CA1  01                >         db fatSiz
     530.  02:7CA2  03 00             >         dw .firdir
     531.  02:7CA4                              MAKEDPB $fb, 512, 2, 112, 2 * 80 * 8, 2, 2      ; 640 kB
     531.  02:7CA4  (02:0001)         > .firfat equ 1
     531.  02:7CA4  (02:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     531.  02:7CA4  (02:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     531.  02:7CA4                    >         if sectorSize = 512
     531.  02:7CA4  (02:0004)         > .shft   equ 4
     531.  02:7CA4                    >         elseif sectorSize = 256
     531.  02:7CA4                    ~ .shft   equ 3
     531.  02:7CA4                    ~         endif
     531.  02:7CA4                    >         
     531.  02:7CA4  FB                >         db media
     531.  02:7CA5  00 02             >         dw sectorSize
     531.  02:7CA7  0F 04             >         db (sectorSize/32)-1, .shft
     531.  02:7CA9  01                >         db sectorsPerCluster-1
     531.  02:7CAA  02                >         db sectorsPerCluster
     531.  02:7CAB  01 00             >         dw .firfat
     531.  02:7CAD  02 70             >         db fatCount, maxEnt
     531.  02:7CAF  0C 00             >         dw .firrec
     531.  02:7CB1  7B 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     531.  02:7CB3  02                >         db fatSiz
     531.  02:7CB4  05 00             >         dw .firdir
     532.  02:7CB6                              MAKEDPB $fc, 512, 1, 64,  1 * 40 * 9, 2, 2      ; 180 kB
     532.  02:7CB6  (02:0001)         > .firfat equ 1
     532.  02:7CB6  (02:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     532.  02:7CB6  (02:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     532.  02:7CB6                    >         if sectorSize = 512
     532.  02:7CB6  (02:0004)         > .shft   equ 4
     532.  02:7CB6                    >         elseif sectorSize = 256
     532.  02:7CB6                    ~ .shft   equ 3
     532.  02:7CB6                    ~         endif
     532.  02:7CB6                    >         
     532.  02:7CB6  FC                >         db media
     532.  02:7CB7  00 02             >         dw sectorSize
     532.  02:7CB9  0F 04             >         db (sectorSize/32)-1, .shft
     532.  02:7CBB  00                >         db sectorsPerCluster-1
     532.  02:7CBC  01                >         db sectorsPerCluster
     532.  02:7CBD  01 00             >         dw .firfat
     532.  02:7CBF  02 40             >         db fatCount, maxEnt
     532.  02:7CC1  09 00             >         dw .firrec
     532.  02:7CC3  60 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     532.  02:7CC5  02                >         db fatSiz
     532.  02:7CC6  05 00             >         dw .firdir
     533.  02:7CC8                              MAKEDPB $fd, 512, 2, 112, 2 * 40 * 9, 2, 2      ; 360 kB
     533.  02:7CC8  (02:0001)         > .firfat equ 1
     533.  02:7CC8  (02:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     533.  02:7CC8  (02:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     533.  02:7CC8                    >         if sectorSize = 512
     533.  02:7CC8  (02:0004)         > .shft   equ 4
     533.  02:7CC8                    >         elseif sectorSize = 256
     533.  02:7CC8                    ~ .shft   equ 3
     533.  02:7CC8                    ~         endif
     533.  02:7CC8                    >         
     533.  02:7CC8  FD                >         db media
     533.  02:7CC9  00 02             >         dw sectorSize
     533.  02:7CCB  0F 04             >         db (sectorSize/32)-1, .shft
     533.  02:7CCD  01                >         db sectorsPerCluster-1
     533.  02:7CCE  02                >         db sectorsPerCluster
     533.  02:7CCF  01 00             >         dw .firfat
     533.  02:7CD1  02 70             >         db fatCount, maxEnt
     533.  02:7CD3  0C 00             >         dw .firrec
     533.  02:7CD5  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     533.  02:7CD7  02                >         db fatSiz
     533.  02:7CD8  05 00             >         dw .firdir
     534.  02:7CDA                              MAKEDPB $fe, 512, 1, 64,  1 * 40 * 8, 1, 2      ; 160 kB
     534.  02:7CDA  (02:0001)         > .firfat equ 1
     534.  02:7CDA  (02:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     534.  02:7CDA  (02:0007)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     534.  02:7CDA                    >         if sectorSize = 512
     534.  02:7CDA  (02:0004)         > .shft   equ 4
     534.  02:7CDA                    >         elseif sectorSize = 256
     534.  02:7CDA                    ~ .shft   equ 3
     534.  02:7CDA                    ~         endif
     534.  02:7CDA                    >         
     534.  02:7CDA  FE                >         db media
     534.  02:7CDB  00 02             >         dw sectorSize
     534.  02:7CDD  0F 04             >         db (sectorSize/32)-1, .shft
     534.  02:7CDF  00                >         db sectorsPerCluster-1
     534.  02:7CE0  01                >         db sectorsPerCluster
     534.  02:7CE1  01 00             >         dw .firfat
     534.  02:7CE3  02 40             >         db fatCount, maxEnt
     534.  02:7CE5  07 00             >         dw .firrec
     534.  02:7CE7  3A 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     534.  02:7CE9  01                >         db fatSiz
     534.  02:7CEA  03 00             >         dw .firdir
     535.  02:7CEC                              MAKEDPB $ff, 512, 2, 112, 2 * 40 * 8, 1, 1      ; 320 kB
     535.  02:7CEC  (02:0001)         > .firfat equ 1
     535.  02:7CEC  (02:0002)         > .firdir equ .firfat+(fatCount*fatSiz)
     535.  02:7CEC  (02:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     535.  02:7CEC                    >         if sectorSize = 512
     535.  02:7CEC  (02:0004)         > .shft   equ 4
     535.  02:7CEC                    >         elseif sectorSize = 256
     535.  02:7CEC                    ~ .shft   equ 3
     535.  02:7CEC                    ~         endif
     535.  02:7CEC                    >         
     535.  02:7CEC  FF                >         db media
     535.  02:7CED  00 02             >         dw sectorSize
     535.  02:7CEF  0F 04             >         db (sectorSize/32)-1, .shft
     535.  02:7CF1  01                >         db sectorsPerCluster-1
     535.  02:7CF2  02                >         db sectorsPerCluster
     535.  02:7CF3  01 00             >         dw .firfat
     535.  02:7CF5  01 70             >         db fatCount, maxEnt
     535.  02:7CF7  09 00             >         dw .firrec
     535.  02:7CF9  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     535.  02:7CFB  01                >         db fatSiz
     535.  02:7CFC  02 00             >         dw .firdir
     536.  02:7CFE                      
     537.  02:7CFE                      ; WARNING: in some cases DEFDPB-1 is expected!
     538.  02:7CFE  (02:7C80)           DEFDPB  equ supportedMedia.def
     210   02:7CFE                              include "romdisk.asm"
       1.  02:7CFE                      		define	ROMDSKBANK 5			; romdisk starts in bank 5
       2.  02:7CFE                      		define	ROMDSKLAST (FLASHROMSIZE/16)-1
       3.  02:7CFE                      
       4.  02:7CFE                      
       5.  02:7CFE                      ROMDISK_DSKIO:
       6.  02:7CFE                              DEBUGMESSAGE "R_DSKIO"
       6.  02:7CFE                    >         ifdef DEBUG
       6.  02:7CFE  52                >         ld d,d
       6.  02:7CFF  18 07             >         jr .skip
       6.  02:7D01                    >         db string
       6.  02:7D01  52 5F 44 53 4B 49 4F 
       6.  02:7D08                    > .skip:
       6.  02:7D08                    >         endif
       7.  02:7D08  F1                          pop af
       8.  02:7D09  3E 00                       ld a,0
       9.  02:7D0B  D8                          ret c                           ; write protected
      10.  02:7D0C                              
      11.  02:7D0C  EB                          ex de,hl
      12.  02:7D0D  C5                  .loop:  push bc
      13.  02:7D0E  E5                          push hl        
      14.  02:7D0F                              
      15.  02:7D0F  CB 7A                       bit 7,d
      16.  02:7D11  20 1C                       jr nz,.directCopy
      17.  02:7D13  7A                          ld a,d
      18.  02:7D14  FE 3E                       cp $3e        
      19.  02:7D16  38 17                       jr c,.directCopy
      20.  02:7D18                      
      21.  02:7D18  CD 3B 7D                    call .findSector
      22.  02:7D1B  D5                          push de
      23.  02:7D1C  ED 5B 4D F3                 ld de,($f34d)        
      24.  02:7D20  CD F4 7F                    call copyFromBank
      25.  02:7D23  D1                          pop de
      26.  02:7D24  01 00 02                    ld bc,512
      27.  02:7D27  2A 4D F3                    ld hl,($f34d)
      28.  02:7D2A  CD 6E F3                    call XFER
      29.  02:7D2D  18 06                       jr .nextSector           
      30.  02:7D2F                                    
      31.  02:7D2F                      .directCopy:                
      32.  02:7D2F  CD 3B 7D                    call .findSector  
      33.  02:7D32  CD F4 7F                    call copyFromBank
      34.  02:7D35                      .nextSector:
      35.  02:7D35  E1                          pop hl
      36.  02:7D36  23                          inc hl
      37.  02:7D37  C1                          pop bc
      38.  02:7D38  10 D3                       djnz .loop
      39.  02:7D3A  C9                          ret
      40.  02:7D3B                      
      41.  02:7D3B                      .findSector:        
      42.  02:7D3B  7D                          ld a,l                          ; determine bank
      43.  02:7D3C  E6 E0                       and %11100000
      44.  02:7D3E  B4                          or h
      45.  02:7D3F  07                          rlca
      46.  02:7D40  07                          rlca
      47.  02:7D41  07                          rlca
      48.  02:7D42  47                          ld b,a
      49.  02:7D43                      
      50.  02:7D43  7D                          ld a,l
      51.  02:7D44  E6 1F                       and 31
      52.  02:7D46  4F                          ld c,a
      53.  02:7D47  3E FF                       ld a,ROMDSKLAST                 ; banks with b0..5=0 reside in the last bank
      54.  02:7D49  28 05                       jr z,.skip
      55.  02:7D4B                      
      56.  02:7D4B  78                          ld a,b
      57.  02:7D4C  C6 05                       add ROMDSKBANK
      58.  02:7D4E  41                          ld b,c
      59.  02:7D4F  05                          dec b
      60.  02:7D50  4F                  .skip:  ld c,a
      61.  02:7D51  78                          ld a,b
      62.  02:7D52  07                          rlca
      63.  02:7D53  C6 41                       add $41                         ; disk images starts at $4100
      64.  02:7D55  67                          ld h,a
      65.  02:7D56  2E 00                       ld l,0
      66.  02:7D58  79                          ld a,c
      67.  02:7D59  01 00 02                    ld bc,512
      68.  02:7D5C  C9                          ret
      69.  02:7D5D                                                               
      70.  02:7D5D                      ROMDISK_DSKCHG:
      71.  02:7D5D                              ;DEBUGMESSAGE "ROM_DSKCHG"
      72.  02:7D5D  F1                          pop af
      73.  02:7D5E  A7                          and a
      74.  02:7D5F  06 01                       ld b,1                          ; not changed
      75.  02:7D61  C9                          ret
      76.  02:7D62                      
      77.  02:7D62                      ROMDISK_GETDPB:
      78.  02:7D62                              ; not implemented (standard mediadescriptor as used)
      79.  02:7D62                              
      80.  02:7D62                      ROMDISK_DSKFMT:
      81.  02:7D62                              ; not implemented (no disk can be formatted)
      82.  02:7D62                              
     211   02:7D62                              include "flashWriter.asm"
       1.  02:7D62                      ; flashWriter.asm
       2.  02:7D62                      ; Flashes and erases the AMD29F040/M29F032-D
       3.  02:7D62                           
       4.  02:7D62                      flashWriter:
       5.  02:7D62                              ;DEBUGMESSAGE "flashWriter"
       6.  02:7D62  3E 03                       ld a,3
       7.  02:7D64  CD 41 01                    call SNSMAT
       8.  02:7D67  E6 08                       and 8
       9.  02:7D69  C0                          ret nz
      10.  02:7D6A                              
      11.  02:7D6A  CD 86 5F                    call PRINTTEXT
      12.  02:7D6D                              db 10,13," FlashROM",10,13," "
      12.  02:7D6D  0A 0D 20 46 6C 61 73 68 52 4F 4D 0A 0D 20 
      13.  02:7D7B  2E (33)                     ds 33,"."
      14.  02:7D9C  0D 20 00                    db 13," ",0
      15.  02:7D9F                              
      16.  02:7D9F  CD 68 76                    call getSlotPage1
      17.  02:7DA2  CD 21 76                    call enableSlotPage0
      18.  02:7DA5                      
      19.  02:7DA5  21 B2 7D                    ld hl,.source
      20.  02:7DA8  11 00 C0                    ld de,$c000
      21.  02:7DAB  D5                          push de
      22.  02:7DAC  01 DB 00                    ld bc,flasherEnd - $c000
      23.  02:7DAF  ED B0                       ldir
      24.  02:7DB1  C9                          ret
      25.  02:7DB2                              
      26.  02:7DB2                      .source:     
      27.  02:7DB2  (C000)                      PHASE $c000  
      28.  02:C000                              
      29.  02:C000                      waitForHeader:
      30.  02:C000  26 20                       ld h,HIGH usbrd
      31.  02:C002  7E                          ld a,(hl)
      32.  02:C003  FE BB               .chkbb: cp $bb
      33.  02:C005  20 F9                       jr nz,waitForHeader
      34.  02:C007  7E                          ld a,(hl)
      35.  02:C008  FE 55                       cp $55
      36.  02:C00A  20 F7                       jr nz,.chkbb       
      37.  02:C00C                      
      38.  02:C00C  7E                          ld a,(hl)
      39.  02:C00D  FE A2                       cp $a2
      40.  02:C00F  CA A9 C0                    jp z,verifyFlash
      41.  02:C012  FE A3                       cp $a3
      42.  02:C014  28 6E                       jr z,writeFlash
      43.  02:C016  FE A4                       cp $a4
      44.  02:C018  28 52                       jr z,chipErase
      45.  02:C01A  FE A5                       cp $a5
      46.  02:C01C  28 1C                       jr z,eraseSector
      47.  02:C01E  FE A6                       cp $a6
      48.  02:C020  28 02                       jr z,autoselectMode
      49.  02:C022                      
      50.  02:C022  20 DC                       jr nz,waitForHeader
      51.  02:C024                          
      52.  02:C024                      autoselectMode:
      53.  02:C024  3E 90                       ld a,$90
      54.  02:C026  CD CC C0                    call writeCommandSequence
      55.  02:C029                      
      56.  02:C029  2A 00 40                    ld hl,($4000)
      57.  02:C02C  EB                          ex de,hl
      58.  02:C02D  26 40                       ld h,HIGH usbwr
      59.  02:C02F  36 AA                       ld (hl),$aa
      60.  02:C031  36 55                       ld (hl),$55
      61.  02:C033  73                          ld (hl),e                       ; manufacturer ID (0x01 = AMD)
      62.  02:C034  72                          ld (hl),d                       ; device ID (0xA4 = AM29F040, 0x41 = AM29F032B)
      63.  02:C035                      
      64.  02:C035  CD 66 C0                    call writeResetCommand
      65.  02:C038  18 C6                       jr waitForHeader
      66.  02:C03A                      
      67.  02:C03A                      eraseSector:
      68.  02:C03A                              ;DEBUGMESSAGE "sector erase"
      69.  02:C03A  3E 65               	ld a,"e"
      70.  02:C03C  D3 98               	out ($98),a
      71.  02:C03E                      
      72.  02:C03E  7E                          ld a,(hl)                       ; get sector number 0..63
      73.  02:C03F  CB 27                       sla a
      74.  02:C041  CB 27                       sla a
      75.  02:C043  32 01 60                    ld (mapper),a                   ; select sector
      76.  02:C046                      
      77.  02:C046  3E 80                       ld a,$80
      78.  02:C048  CD CC C0                    call writeCommandSequence
      79.  02:C04B  3E 30                       ld a,$30        
      80.  02:C04D  CD CC C0                    call writeCommandSequence
      81.  02:C050                      
      82.  02:C050  CD 56 C0                    call waitForCommandToComplete
      83.  02:C053  C3 BD C0                    jp acknowledge
      84.  02:C056                              
      85.  02:C056                      waitForCommandToComplete:
      86.  02:C056  7E                          ld a,(hl)
      87.  02:C057  46                          ld b,(hl)
      88.  02:C058  A8                          xor b
      89.  02:C059  E6 40                       and %01000000                   ; check toggle bit I (DQ6)
      90.  02:C05B  C8                          ret z                           ; operation complete
      91.  02:C05C                              
      92.  02:C05C  78                          ld a,b
      93.  02:C05D  E6 20                       and %00100000                   ; timing limits exceeded? (DQ5)
      94.  02:C05F  28 F5                       jr z,waitForCommandToComplete
      95.  02:C061                      
      96.  02:C061  CD 66 C0                    call writeResetCommand
      97.  02:C064  78                          ld a,b
      98.  02:C065  C9                          ret
      99.  02:C066                      
     100.  02:C066                      writeResetCommand:
     101.  02:C066  3E F0                       ld a,$f0                        ; write RESET command
     102.  02:C068  32 00 00                    ld (0),a
     103.  02:C06B  C9                          ret
     104.  02:C06C                      
     105.  02:C06C                      chipErase:
     106.  02:C06C                              ;DEBUGMESSAGE "chip erase"
     107.  02:C06C  3E 45               	ld a,"E"
     108.  02:C06E  D3 98               	out ($98),a
     109.  02:C070                      
     110.  02:C070  3E 80                       ld a,$80
     111.  02:C072  CD CC C0                    call writeCommandSequence
     112.  02:C075  3E 10                       ld a,$10
     113.  02:C077  CD CC C0                    call writeCommandSequence
     114.  02:C07A                      
     115.  02:C07A  3A 00 40            .wait:  ld a,($4000)                    ; read DQ7 (data# polling) 
     116.  02:C07D  07                          rlca
     117.  02:C07E  30 FA                       jr nc,.wait        
     118.  02:C080  3E 01                       ld a,1
     119.  02:C082  18 39                       jr acknowledge
     120.  02:C084                      
     121.  02:C084                      
     122.  02:C084                      writeFlash:
     123.  02:C084                              ;DEBUGMESSAGE "write"
     124.  02:C084  5E                          ld e,(hl)                       ; address
     125.  02:C085  56                          ld d,(hl)
     126.  02:C086                      
     127.  02:C086  7A                          ld a,d
     128.  02:C087  B3                          or e
     129.  02:C088  CC C7 C0                    call z,updateBar
     130.  02:C08B                      
     131.  02:C08B  7E                          ld a,(hl)                       ; bank
     132.  02:C08C  32 01 60                    ld (mapper),a
     133.  02:C08F  26 40                       ld h,$40
     134.  02:C091                              
     135.  02:C091  06 80                       ld b,128                        ; data is written in blocks of 128 bytes
     136.  02:C093  3E A0               .loop:  ld a,$a0
     137.  02:C095  CD CC C0                    call writeCommandSequence
     138.  02:C098  3A 00 20                    ld a,(usbrd)
     139.  02:C09B  12                          ld (de),a                       ; write data to flash
     140.  02:C09C  13                          inc de
     141.  02:C09D                      
     142.  02:C09D  7E                  .wait:  ld  a,(hl)                      ; write complete?
     143.  02:C09E  AE                          xor (hl)
     144.  02:C09F  E6 40                       and %01000000
     145.  02:C0A1  20 FA                       jr  nz,.wait
     146.  02:C0A3  10 EE                       djnz .loop
     147.  02:C0A5                              
     148.  02:C0A5  3E 02                       ld a,2
     149.  02:C0A7  18 14                       jr acknowledge        
     150.  02:C0A9                              
     151.  02:C0A9                      verifyFlash:
     152.  02:C0A9                              ;DEBUGMESSAGE "verify"
     153.  02:C0A9  21 00 20                    ld hl,usbrd
     154.  02:C0AC  5E                          ld e,(hl)                       ; address
     155.  02:C0AD  56                          ld d,(hl)
     156.  02:C0AE  7E                          ld a,(hl)                       ; bank
     157.  02:C0AF  32 01 60                    ld (mapper),a
     158.  02:C0B2                      
     159.  02:C0B2  06 80                       ld b,128
     160.  02:C0B4  1A                  .loop:  ld a,(de)
     161.  02:C0B5  32 00 40                    ld (usbwr),a
     162.  02:C0B8  13                          inc de
     163.  02:C0B9  10 F9                       djnz .loop
     164.  02:C0BB                      
     165.  02:C0BB  3E 03                       ld a,3
     166.  02:C0BD                      acknowledge:        
     167.  02:C0BD  26 40                       ld h,HIGH usbwr
     168.  02:C0BF  36 AA                       ld (hl),$aa
     169.  02:C0C1  36 55                       ld (hl),$55
     170.  02:C0C3  77                          ld (hl),a
     171.  02:C0C4  C3 00 C0                    jp waitForHeader
     172.  02:C0C7                      
     173.  02:C0C7                      updateBar:
     174.  02:C0C7  3E 77                       ld a,"w"  
     175.  02:C0C9  D3 98                       out ($98),a
     176.  02:C0CB  C9                          ret
     177.  02:C0CC                      
     178.  02:C0CC                      writeCommandSequence:
     179.  02:C0CC  F5                          push af
     180.  02:C0CD  3E AA                       ld a,$aa
     181.  02:C0CF  32 55 05                    ld ($0555),a
     182.  02:C0D2  2F                          cpl
     183.  02:C0D3  32 AA 02                    ld ($02aa),a
     184.  02:C0D6  F1                          pop af
     185.  02:C0D7  32 55 05                    ld ($0555),a
     186.  02:C0DA  C9                          ret
     187.  02:C0DB                              
     188.  02:C0DB                      flasherEnd:
     189.  02:C0DB  (7E8D)                      DEPHASE
     212   02:7E8D                              include "device.asm"
       1.  02:7E8D                      ; device.asm
       2.  02:7E8D                      ; implements a basic now: device
       3.  02:7E8D                          
       4.  02:7E8D                      device:
       5.  02:7E8D  E5                          push hl
       6.  02:7E8E  21 9F 7E                    ld hl,deviceFunctions
       7.  02:7E91  0F                          rrca
       8.  02:7E92  3C                          inc a
       9.  02:7E93  07                          rlca
      10.  02:7E94  85                          add a,l
      11.  02:7E95  6F                          ld l,a
      12.  02:7E96  30 01                       jr nc,.nocy
      13.  02:7E98  24                          inc h  
      14.  02:7E99  7E                  .nocy:  ld a,(hl)
      15.  02:7E9A  23                          inc hl
      16.  02:7E9B  66                          ld h,(hl)
      17.  02:7E9C  6F                          ld l,a
      18.  02:7E9D  E3                          ex (sp),hl
      19.  02:7E9E  C9                          ret
      20.  02:7E9F                      
      21.  02:7E9F                      deviceFunctions:
      22.  02:7E9F  B5 7E                       dw identifyDevice               ; 0xff
      23.  02:7EA1  D5 7E                       dw open                         ;  0
      24.  02:7EA3  0D 7F                       dw close                        ;  2
      25.  02:7EA5  13 7F                       dw randomIO                     ;  4
      26.  02:7EA7  17 7F                       dw write                        ;  6
      27.  02:7EA9  1D 7F                       dw read                         ;  8
      28.  02:7EAB  73 7F                       dw loc                          ; 10
      29.  02:7EAD  85 7F                       dw lof                          ; 12
      30.  02:7EAF  51 7F                       dw eof                          ; 14
      31.  02:7EB1  85 7F                       dw fpos                         ; 16
      32.  02:7EB3  85 7F                       dw putback                      ; 18
      33.  02:7EB5                                
      34.  02:7EB5                      identifyDevice:
      35.  02:7EB5                              DEBUGMESSAGE "identifyDevice"
      35.  02:7EB5                    >         ifdef DEBUG
      35.  02:7EB5  52                >         ld d,d
      35.  02:7EB6  18 0E             >         jr .skip
      35.  02:7EB8                    >         db string
      35.  02:7EB8  69 64 65 6E 74 69 66 79 44 65 76 69 63 65 
      35.  02:7EC6                    > .skip:
      35.  02:7EC6                    >         endif
      36.  02:7EC6  21 CE 7E                    ld hl,deviceNameList
      37.  02:7EC9  CD 50 74                    call findStatementName
      38.  02:7ECC  7E                          ld a,(hl)                       ; device number
      39.  02:7ECD  C9                          ret                             ; carry is set when invalid device name
      40.  02:7ECE                              
      41.  02:7ECE                      deviceNameList:
      42.  02:7ECE  4E 4F 57 00 00 00           db "NOW",0,0,0                  ; name, end marker, device number, dummy
      43.  02:7ED4                              ;db "STDIN",0,1,0
      44.  02:7ED4  00                          db 0
      45.  02:7ED5                      
      46.  02:7ED5                      ; Input     D   Global device code
      47.  02:7ED5                      ;           E   File mode    
      48.  02:7ED5                      ;           HL  address fcb
      49.  02:7ED5                      open:
      50.  02:7ED5                      ;        DEBUGMESSAGE "open"
      51.  02:7ED5                      ;        DEBUGDUMPMEMHL 9
      52.  02:7ED5  22 64 F8                    ld (PTRFIL),hl
      53.  02:7ED8  CD 7C 74                    call sendRegisters
      54.  02:7EDB  36 88                       ld (hl),C_DEVICEOPEN
      55.  02:7EDD  EB                          ex de,hl
      56.  02:7EDE  01 0B 00                    ld bc,11
      57.  02:7EE1  21 66 F8                    ld hl,FILNAM
      58.  02:7EE4  ED B0                       ldir
      59.  02:7EE6                      
      60.  02:7EE6  CD 0D 76                    call enableNowindPage0
      61.  02:7EE9  26 20                       ld h,HIGH usbrd
      62.  02:7EEB  CD 8E 74                    call getHeader
      63.  02:7EEE  38 0C                       jr c,deviceIoError              ; time out?
      64.  02:7EF0  B7                          or a
      65.  02:7EF1  20 0B                       jr nz,openError
      66.  02:7EF3                      
      67.  02:7EF3  5E                          ld e,(hl)                       ; update fcb (including buffer)
      68.  02:7EF4  56                          ld d,(hl)
      69.  02:7EF5  4E                          ld c,(hl)
      70.  02:7EF6  46                          ld b,(hl)
      71.  02:7EF7  ED B0                       ldir
      72.  02:7EF9  C3 18 76                    jp restorePage0        
      73.  02:7EFC                      
      74.  02:7EFC                      deviceIoError:
      75.  02:7EFC  3E 13                       ld a,19
      76.  02:7EFE                      
      77.  02:7EFE                      openError:
      78.  02:7EFE  CD 18 76                    call restorePage0
      79.  02:7F01  5F                          ld e,a
      80.  02:7F02                      
      81.  02:7F02                      basicError:
      82.  02:7F02  DD 21 6F 40                 ld ix,$406f
      83.  02:7F06  FD 2A C0 FC                 ld iy,(EXPTBL-1)
      84.  02:7F0A  C3 1C 00                    jp CALSLT
      85.  02:7F0D                                      
      86.  02:7F0D                      close:
      87.  02:7F0D                      ;        DEBUGMESSAGE "close"
      88.  02:7F0D  CD 7C 74                    call sendRegisters
      89.  02:7F10  36 89                       ld (hl),C_DEVICECLOSE
      90.  02:7F12  C9                          ret
      91.  02:7F13                              
      92.  02:7F13                      randomIO:
      93.  02:7F13                      ;        DEBUGMESSAGE "randomIO"
      94.  02:7F13  1E 3D                       ld e,61                         ; bad file mode
      95.  02:7F15  18 EB                       jr basicError
      96.  02:7F17                      
      97.  02:7F17                      write:
      98.  02:7F17                      ;        DEBUGMESSAGE "write"
      99.  02:7F17  CD 7C 74                    call sendRegisters
     100.  02:7F1A  36 8B                       ld (hl),C_DEVICEWRITE
     101.  02:7F1C  C9                          ret        
     102.  02:7F1D                      
     103.  02:7F1D                      read:
     104.  02:7F1D                      ;        DEBUGMESSAGE "read"
     105.  02:7F1D  11 06 00                    ld de,6
     106.  02:7F20  19                          add hl,de
     107.  02:7F21  E5                          push hl
     108.  02:7F22  5E                          ld e,(hl)
     109.  02:7F23  23                          inc hl
     110.  02:7F24  23                          inc hl
     111.  02:7F25  23                          inc hl
     112.  02:7F26  19                          add hl,de
     113.  02:7F27  7E                          ld a,(hl)
     114.  02:7F28  E1                          pop hl
     115.  02:7F29  FE 1A                       cp $1a
     116.  02:7F2B  37                          scf
     117.  02:7F2C  C8                          ret z                           ; end of file
     118.  02:7F2D  3F                          ccf
     119.  02:7F2E  34                          inc (hl)                        ; increment position
     120.  02:7F2F  C0                          ret nz                          ; buffer empty?
     121.  02:7F30                              
     122.  02:7F30  F5                          push af
     123.  02:7F31  2B                          dec hl
     124.  02:7F32  34                          inc (hl)                        ; increment position (high)        
     125.  02:7F33  11 FB FF                    ld de,-5
     126.  02:7F36  19                          add hl,de
     127.  02:7F37  CD 7C 74                    call sendRegisters
     128.  02:7F3A  36 8C                       ld (hl),C_DEVICEREAD
     129.  02:7F3C  CD 0D 76                    call enableNowindPage0
     130.  02:7F3F  26 20                       ld h,HIGH usbrd
     131.  02:7F41  CD 8E 74                    call getHeader
     132.  02:7F44  38 B6                       jr c,deviceIoError
     133.  02:7F46                      
     134.  02:7F46  5E                          ld e,(hl)
     135.  02:7F47  56                          ld d,(hl)
     136.  02:7F48  4E                          ld c,(hl)
     137.  02:7F49  46                          ld b,(hl)
     138.  02:7F4A  ED B0                       ldir                            ; update fcb buffer
     139.  02:7F4C  CD 18 76                    call restorePage0
     140.  02:7F4F  F1                          pop af                          ; return last character
     141.  02:7F50  C9                          ret
     142.  02:7F51                      
     143.  02:7F51                      eof:
     144.  02:7F51                      ;        DEBUGMESSAGE "eof"
     145.  02:7F51  7E                          ld a,(hl)
     146.  02:7F52  FE 01                       cp 1                            ; input mode?        
     147.  02:7F54  1E 3D                       ld e,61                         ; bad file mode
     148.  02:7F56  C2 02 7F                    jp nz,basicError
     149.  02:7F59                                      
     150.  02:7F59  11 06 00                    ld de,6
     151.  02:7F5C  19                          add hl,de
     152.  02:7F5D  5E                          ld e,(hl)
     153.  02:7F5E  23                          inc hl
     154.  02:7F5F  23                          inc hl
     155.  02:7F60  23                          inc hl
     156.  02:7F61  19                          add hl,de
     157.  02:7F62  7E                          ld a,(hl)
     158.  02:7F63  ED 62                       sbc hl,hl
     159.  02:7F65  FE 1A                       cp $1a        
     160.  02:7F67  20 01                       jr nz,.skip
     161.  02:7F69  2B                          dec hl
     162.  02:7F6A  22 F8 F7            .skip:  ld (DAC+2),hl
     163.  02:7F6D  3E 02                       ld a,2
     164.  02:7F6F  32 63 F6                    ld (VALTYP),a
     165.  02:7F72  C9                          ret
     166.  02:7F73                      
     167.  02:7F73                      loc:
     168.  02:7F73  E5                          push hl
     169.  02:7F74  FD E1                       pop iy
     170.  02:7F76  FD 6E 06                    ld l,(iy+6)
     171.  02:7F79  FD 66 05                    ld h,(iy+5)
     172.  02:7F7C                      ;        DEBUGASSERT
     173.  02:7F7C  22 F8 F7                    ld (DAC+2),hl
     174.  02:7F7F  3E 02                       ld a,2
     175.  02:7F81  32 63 F6                    ld (VALTYP),a
     176.  02:7F84  C9                          ret
     177.  02:7F85                              
     178.  02:7F85                      putback:
     179.  02:7F85                      ;        DEBUGMESSAGE "putback"
     180.  02:7F85                      ;        push hl
     181.  02:7F85                      ;        pop iy
     182.  02:7F85                      ;        ld (iy+3),c
     183.  02:7F85                      ;        DEBUGASSERT
     184.  02:7F85                      ;        ret
     185.  02:7F85                      
     186.  02:7F85                      lof:
     187.  02:7F85                      fpos:
     188.  02:7F85                              DEBUGMESSAGE "no support!"
     188.  02:7F85                    >         ifdef DEBUG
     188.  02:7F85  52                >         ld d,d
     188.  02:7F86  18 0B             >         jr .skip
     188.  02:7F88                    >         db string
     188.  02:7F88  6E 6F 20 73 75 70 70 6F 72 74 21 
     188.  02:7F93                    > .skip:
     188.  02:7F93                    >         endif
     189.  02:7F93                      
     190.  02:7F93                      illegalFunctionCall:
     191.  02:7F93  1E 05                       ld e,5
     192.  02:7F95  C3 02 7F                    jp basicError
     193.  02:7F98                      
     194.  02:7F98                      ;FCB for DISK BASIC
     195.  02:7F98                      ; +0 FL.MOD     file mode
     196.  02:7F98                      ; +1 FL.FCA     Pointer to FCB for BDOS (low)
     197.  02:7F98                      ; +2 FL.LCA     Pointer to FCB for BDOS (high)
     198.  02:7F98                      ; +3 FL.LSA     Back up character
     199.  02:7F98                      ; +4 FL.DSK     device number
     200.  02:7F98                      ; +5 FL.SLB
     201.  02:7F98                      ; +6 FL.BPS     Position in FL.BUF
     202.  02:7F98                      ; +7 FL.FLG     Holds various information
     203.  02:7F98                      ; +8 FL.OPS     Pseudo head position
     204.  02:7F98                      ; +9 FL.BUF     256-byte file buffer
     205.  02:7F98                      
     206.  02:7F98                      ; device codes
     207.  02:7F98                      ;          SS0           SS1           SS2           SS3
     208.  02:7F98                      ;    ---------------------------------------------------------
     209.  02:7F98                      ;    | 00 04 08 0C | 10 14 18 1C | 20 24 28 2C | 30 34 38 3C | PS0
     210.  02:7F98                      ;    ---------------------------------------------------------
     211.  02:7F98                      ;    | 40 44 48 4C | 50 54 58 5C | 60 64 68 6C | 70 74 78 7C | PS1
     212.  02:7F98                      ;    ---------------------------------------------------------
     213.  02:7F98                      ;    | 80 84 88 8C | 90 94 98 9C | A0 A4 A8 AC | B0 B4 B8 BC | PS2
     214.  02:7F98                      ;    ---------------------------------------------------------
     215.  02:7F98                      ;    | C0 C4 C8 CC | D0 D4 D8 DC | E0 E4 E8 EC | F0 F4 F8 FC | PS3
     216.  02:7F98                      ;    ---------------------------------------------------------
     217.  02:7F98                      
     218.  02:7F98                      ; fileModes
     219.  02:7F98                      ; FOR INPUT (01H)
     220.  02:7F98                      ; FOR OUTPUT (02H)
     221.  02:7F98                      ; FOR APPEND (08H)
     222.  02:7F98                      ; random mode (04H)
     223.  02:7F98                      
     224.  02:7F98                      ; maximum number of files open: MAXFILES=15
     225.  02:7F98                              
     226.  02:7F98                      ; File Control Block
     227.  02:7F98                      ;       0     1     2     3     4     5     6     7     8
     228.  02:7F98                      ;    -------------------------------------------------------
     229.  02:7F98                      ;    | Mod | 00H | 00H | 00H | DEV | 00H | POS | 00H | PPS |
     230.  02:7F98                      ;    -------------------------------------------------------
     231.  02:7F98                      ;                  err? bckup       posHi 
     232.  02:7F98                      ; followed by a 256 byte buffer
     213   02:7F98                              
     214   02:7F98                              ifdef BDOS_NOWIND
     215   02:7F98                    ~         include "nowindbdos.asm"
     216   02:7F98                    ~         endif
     217   02:7F98                              
     218   02:7F98  FF (92)                    ds $8000-(endCopyFromBank-copyFromBank)-$, $ff
     219   02:7FF4                      
     220   02:7FF4                      ; bank switching and data transfer
     221   02:7FF4                      copyFromBank:
     222   02:7FF4  32 01 60                    ld (mapper),a
     223   02:7FF7  ED B0                       ldir
     224   02:7FF9                      enableBank0:
     225   02:7FF9  AF                          xor a
     226   02:7FFA  F5                          push af
     227   02:7FFB  32 01 60                    ld (mapper),a
     228   02:7FFE  F1                          pop af
     229   02:7FFF  C9                          ret
     230   02:8000                      endCopyFromBank:
     231   02:8000                      
     232   02:8000  (03)                        page 3
     233   03:0000  BA (442368)                 ds (512-80)*1024, $ba

    LABELS
---------------------------------------
00:0000000C X RDSLT
00:00000014 X WRSLT
00:0000001C   CALSLT
00:00000024   ENASLT
00:0000005F   CHGMOD
00:00000141   SNSMAT
00:0000015F   EXTROM
00:00000185   SDFSCR
00:0000F33F   LASTDRV
00:0000F342   RAMAD1
00:0000F36E   XFER
00:0000F663   VALTYP
00:0000F7F6   DAC
00:0000F864   PTRFIL
00:0000F866   FILNAM
00:0000FCC1   EXPTBL
00:0000FCC5   SLTTBL
00:0000FCC9 X SLTATR
00:0000FD09   SLTWRK
00:0000FD89   PROCNM
00:0000FD99   DEVICE
00:0000FFCA   EXTBIO
00:0000402D   GETSLT
00:0000FECB X H.RUNC
00:00004000   usbwr
00:00002000   usbrd
00:00008000   usb2
00:00006001   mapper
00:00000080   C_DSKIO
00:00000081   C_DSKCHG
00:00000082   C_GETDPB
00:00000083 X C_CHOICE
00:00000084 X C_DSKFMT
00:00000085   C_DRIVES
00:00000086   C_INIENV
00:00000087 X C_SETDATE
00:00000088   C_DEVICEOPEN
00:00000089   C_DEVICECLOSE
00:0000008A X C_DEVICERNDIO
00:0000008B   C_DEVICEWRITE
00:0000008C   C_DEVICEREAD
00:0000008D X C_DEVICEEOF
00:0000008E   C_AUXIN
00:0000008F   C_AUXOUT
00:00000090   C_MESSAGE
00:00000091   C_CHANGEIMAGE
00:00000092   C_GETDOSVERSION
00:00000093   C_CMDREQUEST
00:000072F0   MSXDOS2_PART.getBootArgs
00:000072F4   MSXDOS2_PART.next
00:0000731A   MSXDOS2_PART.noNextCommand
00:0000734B   MSXDOS2_PART.bootMSXDOS1
00:00007354   MSXDOS2_PART.nowindInit
00:00007387   MSXDOS2_PART.initDiskBasic
00:0000739F   MSXDOS2_PART.findStatementName
00:000073B6   MSXDOS2_PART.findStatementName.loop
00:000073C0   MSXDOS2_PART.findStatementName.nextStatement
00:000073CB   MSXDOS2_PART.sendRegisters
00:000073DD   MSXDOS2_PART.getHeader
00:000073DF   MSXDOS2_PART.getHeader.loop
00:000073E0   MSXDOS2_PART.getHeader.chkaf
00:00007404   MSXDOS2_PART.getHeader.chk05
00:0000740B   MSXDOS2_PART.sendMessage
00:00007415   MSXDOS2_PART.sendMessage.loop
00:00007421   MSXDOS2_PART.newAUX
00:0000742B   MSXDOS2_PART.AUXin
00:00007459   MSXDOS2_PART.AUXin.exit
00:0000745F   MSXDOS2_PART.AUXin.getCharacter
00:00007470   MSXDOS2_PART.AUXout
00:00007488 X MSXDOS2_PART.sdendFCB
00:0000748C   MSXDOS2_PART.sdendFCB.loop
00:00007496 X MSXDOS2_PART.receiveFCB
00:0000749A   MSXDOS2_PART.receiveFCB.loop
00:000074A7   MSXDOS2_PART.installExtendedBios
00:000074DC   MSXDOS2_PART.extendedBios
00:000074E3   MSXDOS2_PART.extendedBios.exit
00:000074F1   MSXDOS2_PART.determineFunction
00:000074FD   MSXDOS2_PART.functionTable
00:00007503   MSXDOS2_PART.getNowindSlot
00:0000751F   MSXDOS2_PART.numberOfDevices
00:00007536   MSXDOS2_PART.debugMessage
00:00007552   MSXDOS2_PART.debugMessage.loop
00:0000755C   MSXDOS2_PART.enableNowindPage0
00:00007567   MSXDOS2_PART.restorePage0
00:00007570   MSXDOS2_PART.enableSlotPage0
00:00007581   MSXDOS2_PART.enableSlotPage0.expanded
00:000075AC   MSXDOS2_PART.getSlotPage0
00:000075B7   MSXDOS2_PART.getSlotPage1
00:000075C2   MSXDOS2_PART.getSlotPage2
00:000075D1   MSXDOS2_PART.expanded
00:000075E5   MSXDOS2_PART.notExpanded
00:000075E7   MSXDOS2_PART.getEntrySLTWRK
00:00000008   MSXDOS2_PART.MYSIZE
00:00000200   MSXDOS2_PART.SECLEN
00:000075FC   MSXDOS2_PART.INIHRD
00:0000760B   MSXDOS2_PART.INIHRD.loop
00:0000761F   MSXDOS2_PART.DRIVES
00:00007662   MSXDOS2_PART.DRIVES.exit
00:0000766B   MSXDOS2_PART.DRIVES.notconnected
00:00007688   MSXDOS2_PART.INIENV
00:000076CC   MSXDOS2_PART.INIENV.exit
00:000076CF   MSXDOS2_PART.checkWorkArea
00:000076DE   MSXDOS2_PART.DSKIO
00:000076F5 X MSXDOS2_PART.dskioRead
00:0000B712   MSXDOS2_PART.dskioRead.page2
00:00007727   MSXDOS2_PART.dskioRead.page1
00:00007737   MSXDOS2_PART.dskioRead.page2and3
00:0000774D   MSXDOS2_PART.dskioWrite
00:0000B76D   MSXDOS2_PART.dskioWrite.page2
00:00007783   MSXDOS2_PART.dskioWrite.page1
00:00007799   MSXDOS2_PART.dskioWrite.page2and3
00:000077AE   MSXDOS2_PART.dskioWrite.writeLoop23
00:000077DE   MSXDOS2_PART.dskioWrite.error
00:000077E1   MSXDOS2_PART.DSKCHG
00:00007818   MSXDOS2_PART.GETDPB
00:0000784E   MSXDOS2_PART.GETDPB.hddImage
00:00007881   MSXDOS2_PART.GETDPB.exit
00:00007884   MSXDOS2_PART.CHOICE
00:00007888 X MSXDOS2_PART.CHOICE.noFormat
00:00007889   MSXDOS2_PART.DSKFMT
00:0000B88D   MSXDOS2_PART.readSectors01
00:0000B8AF   MSXDOS2_PART.readSectors01.slowTransfer
00:0000B8BB   MSXDOS2_PART.writeLoop01
00:0000B8DD   MSXDOS2_PART.writeLoop01.error
00:000078E0   MSXDOS2_PART.readSectors23
00:00007904   MSXDOS2_PART.readSectors23.slowTransfer
00:00007921   MSXDOS2_PART.reverseTransfer
00:0000792D   MSXDOS2_PART.reverseTransfer.loop
00:00007994   MSXDOS2_PART.OEMSTA
00:000079A2   MSXDOS2_PART.OEMSTA.statement
00:000079B5   MSXDOS2_PART.changeImage
00:000079CA   MSXDOS2_PART.call_exit
00:000079D6   MSXDOS2_PART.call_exit.loop
00:000079E2   MSXDOS2_PART.videoStream
00:000079E3 X MSXDOS2_PART.vramDump
00:000079EF   MSXDOS2_PART.evenFrame
00:00007A0C X MSXDOS2_PART.oddFrame
00:00007A2C   MSXDOS2_PART.tranferframe
00:00007A39   MSXDOS2_PART.write_more
00:00007B46   MSXDOS2_PART.changeColors
00:00007B94   MSXDOS2_PART.setVramAccessPointer
00:00007BA2   MSXDOS2_PART.waitForRetrace
00:00007BA8   MSXDOS2_PART.waitForRetrace.lp2
00:00007BB3   MSXDOS2_PART.printVdpText2
00:00007BB4   MSXDOS2_PART.printVdpText2.loop
00:00007BBD   MSXDOS2_PART.supportedMedia
00:00007BBD X MSXDOS2_PART.supportedMedia.f8
00:00007BCF   MSXDOS2_PART.supportedMedia.def
00:00007BCF   MSXDOS2_PART.DEFDPB
00:00007C4D   MSXDOS2_PART.ROMDISK_DSKIO
00:00007C5C   MSXDOS2_PART.ROMDISK_DSKIO.loop
00:00007C7E   MSXDOS2_PART.ROMDISK_DSKIO.directCopy
00:00007C84   MSXDOS2_PART.ROMDISK_DSKIO.nextSector
00:00007C8A   MSXDOS2_PART.ROMDISK_DSKIO.findSector
00:00007C9F   MSXDOS2_PART.ROMDISK_DSKIO.skip
00:00007CAC   MSXDOS2_PART.ROMDISK_DSKCHG
00:00007CB1 X MSXDOS2_PART.ROMDISK_GETDPB
00:00007CB1 X MSXDOS2_PART.ROMDISK_DSKFMT
00:00007CB1   MSXDOS2_PART.flashWriter
00:00007D01   MSXDOS2_PART.flashWriter.source
00:0000C000   MSXDOS2_PART.waitForHeader
00:0000C003   MSXDOS2_PART.waitForHeader.chkbb
00:0000C024   MSXDOS2_PART.autoselectMode
00:0000C03A   MSXDOS2_PART.eraseSector
00:0000C056   MSXDOS2_PART.waitForCommandToComplete
00:0000C066   MSXDOS2_PART.writeResetCommand
00:0000C06C   MSXDOS2_PART.chipErase
00:0000C07A   MSXDOS2_PART.chipErase.wait
00:0000C084   MSXDOS2_PART.writeFlash
00:0000C093   MSXDOS2_PART.writeFlash.loop
00:0000C09D   MSXDOS2_PART.writeFlash.wait
00:0000C0A9   MSXDOS2_PART.verifyFlash
00:0000C0B4   MSXDOS2_PART.verifyFlash.loop
00:0000C0BD   MSXDOS2_PART.acknowledge
00:0000C0C7   MSXDOS2_PART.updateBar
00:0000C0CC   MSXDOS2_PART.writeCommandSequence
00:0000C0DB   MSXDOS2_PART.flasherEnd
00:00007DDC   MSXDOS2_PART.device
00:00007DE8   MSXDOS2_PART.device.nocy
00:00007DEE   MSXDOS2_PART.deviceFunctions
00:00007E04   MSXDOS2_PART.identifyDevice
00:00007E1D   MSXDOS2_PART.deviceNameList
00:00007E24   MSXDOS2_PART.open
00:00007E4B   MSXDOS2_PART.deviceIoError
00:00007E4D   MSXDOS2_PART.openError
00:00007E51   MSXDOS2_PART.basicError
00:00007E5C   MSXDOS2_PART.close
00:00007E62   MSXDOS2_PART.randomIO
00:00007E66   MSXDOS2_PART.write
00:00007E6C   MSXDOS2_PART.read
00:00007EA0   MSXDOS2_PART.eof
00:00007EB9   MSXDOS2_PART.eof.skip
00:00007EC2   MSXDOS2_PART.loc
00:00007ED4   MSXDOS2_PART.putback
00:00007ED4   MSXDOS2_PART.lof
00:00007ED4   MSXDOS2_PART.fpos
00:00007EE2 X MSXDOS2_PART.illegalFunctionCall
00:00007FF4   MSXDOS2_PART.copyFromBank
00:00007FF9 X MSXDOS2_PART.enableBank0
00:00007FFA   MSXDOS2_PART.switchBank
00:00008000   MSXDOS2_PART.endCopyFromBank
02:00007405   MSXDOS1_PART.nowindInit
02:00007438   MSXDOS1_PART.initDiskBasic
02:00007450   MSXDOS1_PART.findStatementName
02:00007467   MSXDOS1_PART.findStatementName.loop
02:00007471   MSXDOS1_PART.findStatementName.nextStatement
02:0000747C   MSXDOS1_PART.sendRegisters
02:0000748E   MSXDOS1_PART.getHeader
02:00007490   MSXDOS1_PART.getHeader.loop
02:00007491   MSXDOS1_PART.getHeader.chkaf
02:000074B5   MSXDOS1_PART.getHeader.chk05
02:000074BC   MSXDOS1_PART.sendMessage
02:000074C6   MSXDOS1_PART.sendMessage.loop
02:000074D2   MSXDOS1_PART.newAUX
02:000074DC   MSXDOS1_PART.AUXin
02:0000750A   MSXDOS1_PART.AUXin.exit
02:00007510   MSXDOS1_PART.AUXin.getCharacter
02:00007521   MSXDOS1_PART.AUXout
02:00007539 X MSXDOS1_PART.sdendFCB
02:0000753D   MSXDOS1_PART.sdendFCB.loop
02:00007547 X MSXDOS1_PART.receiveFCB
02:0000754B   MSXDOS1_PART.receiveFCB.loop
02:00007558   MSXDOS1_PART.installExtendedBios
02:0000758D   MSXDOS1_PART.extendedBios
02:00007594   MSXDOS1_PART.extendedBios.exit
02:000075A2   MSXDOS1_PART.determineFunction
02:000075AE   MSXDOS1_PART.functionTable
02:000075B4   MSXDOS1_PART.getNowindSlot
02:000075D0   MSXDOS1_PART.numberOfDevices
02:000075E7   MSXDOS1_PART.debugMessage
02:00007603   MSXDOS1_PART.debugMessage.loop
02:0000760D   MSXDOS1_PART.enableNowindPage0
02:00007618   MSXDOS1_PART.restorePage0
02:00007621   MSXDOS1_PART.enableSlotPage0
02:00007632   MSXDOS1_PART.enableSlotPage0.expanded
02:0000765D   MSXDOS1_PART.getSlotPage0
02:00007668   MSXDOS1_PART.getSlotPage1
02:00007673   MSXDOS1_PART.getSlotPage2
02:00007682   MSXDOS1_PART.expanded
02:00007696   MSXDOS1_PART.notExpanded
02:00007698   MSXDOS1_PART.getEntrySLTWRK
02:00000008   MSXDOS1_PART.MYSIZE
02:00000200   MSXDOS1_PART.SECLEN
02:000076AD   MSXDOS1_PART.INIHRD
02:000076BC   MSXDOS1_PART.INIHRD.loop
02:000076D0   MSXDOS1_PART.DRIVES
02:00007713   MSXDOS1_PART.DRIVES.exit
02:0000771C   MSXDOS1_PART.DRIVES.notconnected
02:00007739   MSXDOS1_PART.INIENV
02:0000777D   MSXDOS1_PART.INIENV.exit
02:00007780   MSXDOS1_PART.checkWorkArea
02:0000778F   MSXDOS1_PART.DSKIO
02:000077A6 X MSXDOS1_PART.dskioRead
02:0000B7C3   MSXDOS1_PART.dskioRead.page2
02:000077D8   MSXDOS1_PART.dskioRead.page1
02:000077E8   MSXDOS1_PART.dskioRead.page2and3
02:000077FE   MSXDOS1_PART.dskioWrite
02:0000B81E   MSXDOS1_PART.dskioWrite.page2
02:00007834   MSXDOS1_PART.dskioWrite.page1
02:0000784A   MSXDOS1_PART.dskioWrite.page2and3
02:0000785F   MSXDOS1_PART.dskioWrite.writeLoop23
02:0000788F   MSXDOS1_PART.dskioWrite.error
02:00007892   MSXDOS1_PART.DSKCHG
02:000078C9   MSXDOS1_PART.GETDPB
02:000078FF   MSXDOS1_PART.GETDPB.hddImage
02:00007932   MSXDOS1_PART.GETDPB.exit
02:00007935   MSXDOS1_PART.CHOICE
02:00007939 X MSXDOS1_PART.CHOICE.noFormat
02:0000793A   MSXDOS1_PART.DSKFMT
02:0000B93E   MSXDOS1_PART.readSectors01
02:0000B960   MSXDOS1_PART.readSectors01.slowTransfer
02:0000B96C   MSXDOS1_PART.writeLoop01
02:0000B98E   MSXDOS1_PART.writeLoop01.error
02:00007991   MSXDOS1_PART.readSectors23
02:000079B5   MSXDOS1_PART.readSectors23.slowTransfer
02:000079D2   MSXDOS1_PART.reverseTransfer
02:000079DE   MSXDOS1_PART.reverseTransfer.loop
02:00007A45   MSXDOS1_PART.OEMSTA
02:00007A53   MSXDOS1_PART.OEMSTA.statement
02:00007A66   MSXDOS1_PART.changeImage
02:00007A7B   MSXDOS1_PART.call_exit
02:00007A87   MSXDOS1_PART.call_exit.loop
02:00007A93   MSXDOS1_PART.videoStream
02:00007A94 X MSXDOS1_PART.vramDump
02:00007AA0   MSXDOS1_PART.evenFrame
02:00007ABD X MSXDOS1_PART.oddFrame
02:00007ADD   MSXDOS1_PART.tranferframe
02:00007AEA   MSXDOS1_PART.write_more
02:00007BF7   MSXDOS1_PART.changeColors
02:00007C45   MSXDOS1_PART.setVramAccessPointer
02:00007C53   MSXDOS1_PART.waitForRetrace
02:00007C59   MSXDOS1_PART.waitForRetrace.lp2
02:00007C64   MSXDOS1_PART.printVdpText2
02:00007C65   MSXDOS1_PART.printVdpText2.loop
02:00007C6E   MSXDOS1_PART.supportedMedia
02:00007C6E X MSXDOS1_PART.supportedMedia.f8
02:00007C80   MSXDOS1_PART.supportedMedia.def
02:00007C80   MSXDOS1_PART.DEFDPB
02:00007CFE   MSXDOS1_PART.ROMDISK_DSKIO
02:00007D0D   MSXDOS1_PART.ROMDISK_DSKIO.loop
02:00007D2F   MSXDOS1_PART.ROMDISK_DSKIO.directCopy
02:00007D35   MSXDOS1_PART.ROMDISK_DSKIO.nextSector
02:00007D3B   MSXDOS1_PART.ROMDISK_DSKIO.findSector
02:00007D50   MSXDOS1_PART.ROMDISK_DSKIO.skip
02:00007D5D   MSXDOS1_PART.ROMDISK_DSKCHG
02:00007D62 X MSXDOS1_PART.ROMDISK_GETDPB
02:00007D62 X MSXDOS1_PART.ROMDISK_DSKFMT
02:00007D62   MSXDOS1_PART.flashWriter
02:00007DB2   MSXDOS1_PART.flashWriter.source
02:0000C000   MSXDOS1_PART.waitForHeader
02:0000C003   MSXDOS1_PART.waitForHeader.chkbb
02:0000C024   MSXDOS1_PART.autoselectMode
02:0000C03A   MSXDOS1_PART.eraseSector
02:0000C056   MSXDOS1_PART.waitForCommandToComplete
02:0000C066   MSXDOS1_PART.writeResetCommand
02:0000C06C   MSXDOS1_PART.chipErase
02:0000C07A   MSXDOS1_PART.chipErase.wait
02:0000C084   MSXDOS1_PART.writeFlash
02:0000C093   MSXDOS1_PART.writeFlash.loop
02:0000C09D   MSXDOS1_PART.writeFlash.wait
02:0000C0A9   MSXDOS1_PART.verifyFlash
02:0000C0B4   MSXDOS1_PART.verifyFlash.loop
02:0000C0BD   MSXDOS1_PART.acknowledge
02:0000C0C7   MSXDOS1_PART.updateBar
02:0000C0CC   MSXDOS1_PART.writeCommandSequence
02:0000C0DB   MSXDOS1_PART.flasherEnd
02:00007E8D   MSXDOS1_PART.device
02:00007E99   MSXDOS1_PART.device.nocy
02:00007E9F   MSXDOS1_PART.deviceFunctions
02:00007EB5   MSXDOS1_PART.identifyDevice
02:00007ECE   MSXDOS1_PART.deviceNameList
02:00007ED5   MSXDOS1_PART.open
02:00007EFC   MSXDOS1_PART.deviceIoError
02:00007EFE   MSXDOS1_PART.openError
02:00007F02   MSXDOS1_PART.basicError
02:00007F0D   MSXDOS1_PART.close
02:00007F13   MSXDOS1_PART.randomIO
02:00007F17   MSXDOS1_PART.write
02:00007F1D   MSXDOS1_PART.read
02:00007F51   MSXDOS1_PART.eof
02:00007F6A   MSXDOS1_PART.eof.skip
02:00007F73   MSXDOS1_PART.loc
02:00007F85   MSXDOS1_PART.putback
02:00007F85   MSXDOS1_PART.lof
02:00007F85   MSXDOS1_PART.fpos
02:00007F93 X MSXDOS1_PART.illegalFunctionCall
02:00007FF4   MSXDOS1_PART.copyFromBank
02:00007FF9 X MSXDOS1_PART.enableBank0
02:00008000   MSXDOS1_PART.endCopyFromBank


Output: d:\project\nowindlibraries\msxsrc\nowind.out
--------------------------------------

 Page: 00
  Org: 00000000  Size: *  Used: 00000000

    No output

Output: nowind.rom
--------------------------------------

 Page: 00
  Org: 00004000  Size: 00004000  Used: 00004000

   Address   Length Align  Label
   00004000   13040        
   000072F0    3344     @  MSXDOS2_PART.getBootArgs

  Overlay parts:
   Address   Length Align  Label
   00004006       2     @  
   00004010      18     @  
   00004093       2     @  
   000047D7       2     @  
   00004881       1     @  
   00004884       1     @  
   0000488D       2     @  
   0000489F       2     @  
   000048B9       2     @  
   000048EB       2     @  
   000048F7       2     @  
   000049A3      16     @  
   00005797       2     @  

 Page: 01
  Org: 00004000  Size: 0000C000  Used: 0000C000

   Address   Length Align  Label
   00004000   49152        

  Overlay parts:
   Address   Length Align  Label
   00004093       2     @  
   00008093       2     @  
   0000C093       2     @  

 Page: 02
  Org: 00004000  Size: 00004000  Used: 00004000

   Address   Length Align  Label
   00004000   13317        
   00007405    3067     @  MSXDOS1_PART.nowindInit

  Overlay parts:
   Address   Length Align  Label
   00004006       2     @  
   00004010      18     @  
   00005770       2     @  
   000057AA       2     @  
   00005809       2     @  
   0000581E       2     @  
   0000582F       2     @  
   00005851       2     @  
   00005884       2     @  
   00005890       2     @  
   0000595D      15     @  
   00005AE8       2     @  
   000065AF       2     @  

 Page: 03
  Org: 00000000  Size: 0006C000  Used: 0006C000

   Address   Length Align  Label
   00000000  442368        

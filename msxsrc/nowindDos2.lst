Sjasm Z80 Assembler v0.4 BETA 6 - www.xl2s.tk             [2010.01.23 - 21:55:57]

nowindDos2.asm
Errors: 3

       1   00:0000  (00:47D6)           romInit:        equ $47d6
       2   00:0000  (00:728E)           printText:      equ $728e
       3   00:0000                      
       4   00:0000                              define  MSXDOS2
       5   00:0000                              define  DEBUG
       6   00:0000                              define  ROMDSKBANK 4            ; first bank of ROMdisk image
       7   00:0000                              define  ROMDSKLAST 4+24-1
       8   00:0000                              
       9   00:0000                              output  "nowindDos2.rom"
      10   00:0000                              include "labels.asm"
       1.  00:0000                      ; BIOS routines
       2.  00:0000  (00:000C)           RDSLT           equ $000c
       3.  00:0000  (00:0014)           WRSLT           equ $0014
       4.  00:0000  (00:001C)           CALSLT          equ $001c
       5.  00:0000  (00:0024)           ENASLT          equ $0024
       6.  00:0000  (00:005F)           CHGMOD          equ $005f
       7.  00:0000  (00:0141)           SNSMAT          equ $0141
       8.  00:0000  (00:015F)           EXTROM          equ $015f
       9.  00:0000  (00:0185)           SDFSCR          equ $0185               ; restore screen parameters from clockchip (in SUBROM)
      10.  00:0000                      
      11.  00:0000                      ; BIOS variables (really?)
      12.  00:0000  (00:F33F)           LASTDRV         equ $f33f               ; stores CTRL-key status during boot
      13.  00:0000  (00:F342)           RAMAD1          equ $f342
      14.  00:0000  (00:F36E)           XFER            equ $f36e
      15.  00:0000                      
      16.  00:0000  (00:F663)           VALTYP          equ $f663
      17.  00:0000  (00:F7F6)           DAC             equ $f7f6
      18.  00:0000  (00:F864)           PTRFIL          equ $f864
      19.  00:0000  (00:F866)           FILNAM          equ $f866
      20.  00:0000                      
      21.  00:0000  (00:FCC1)           EXPTBL          equ $fcc1
      22.  00:0000  (00:FCC5)           SLTTBL          equ $fcc5
      23.  00:0000  (00:FCC9)           SLTATR          equ $fcc9
      24.  00:0000  (00:FD09)           SLTWRK          equ $fd09
      25.  00:0000  (00:FD89)           PROCNM          equ $fd89
      26.  00:0000  (00:FD99)           DEVICE          equ $fd99
      27.  00:0000  (00:FFCA)           EXTBIO          equ $ffca
      28.  00:0000                      
      29.  00:0000                      ; Diskrom routines
      30.  00:0000  (00:402D)           GETSLT          equ $402d
      31.  00:0000                               
      32.  00:0000                      ; Hooks
      33.  00:0000  (00:FECB)           H.RUNC          equ $fecb               ; Intercepted by diskrom
      34.  00:0000                      
      35.  00:0000                      ; Nowind hardware addresses
      36.  00:0000  (00:4000)           usbwr           equ $4000               ; 0x4000..0x5fff
      37.  00:0000  (00:2000)           usbrd           equ $2000               ; 0x2000..0x3fff
      38.  00:0000  (00:8000)           usb2            equ $8000               ; 0x8000..0x9fff (read and write)
      39.  00:0000  (00:6001)           mapper          equ $6001               ; 0x6001..0x7fff (odd numbers only)
      40.  00:0000                      
      41.  00:0000                      ; Host commands
      42.  00:0000  (00:0080)           C_DSKIO         equ $80
      43.  00:0000  (00:0081)           C_DSKCHG        equ $81
      44.  00:0000  (00:0082)           C_GETDPB        equ $82
      45.  00:0000  (00:0083)           C_CHOICE        equ $83
      46.  00:0000  (00:0084)           C_DSKFMT        equ $84
      47.  00:0000  (00:0085)           C_DRIVES        equ $85
      48.  00:0000  (00:0086)           C_INIENV        equ $86
      49.  00:0000  (00:0087)           C_SETDATE       equ $87
      50.  00:0000  (00:0088)           C_DEVICEOPEN    equ $88
      51.  00:0000  (00:0089)           C_DEVICECLOSE   equ $89
      52.  00:0000  (00:008A)           C_DEVICERNDIO   equ $8a
      53.  00:0000  (00:008B)           C_DEVICEWRITE   equ $8b
      54.  00:0000  (00:008C)           C_DEVICEREAD    equ $8c
      55.  00:0000  (00:008D)           C_DEVICEEOF     equ $8d
      56.  00:0000  (00:008E)           C_AUXIN         equ $8e
      57.  00:0000  (00:008F)           C_AUXOUT        equ $8f
      58.  00:0000  (00:0090)           C_MESSAGE       equ $90
      59.  00:0000  (00:00A0)           C_CHANGEIMAGE   equ $a0
      60.  00:0000  (00:00A1)           C_BOOTCODE      equ $a1
      61.  00:0000                      
      62.  00:0000                      ; BDOS commands 0x0F- 0x37 can just use their original command code in register C
      63.  00:0000                      
      64.  00:0000                      ; PATCH       
      65.  00:0000                              macro PATCH address, word
      66.  00:0000                    <         code ! address
      67.  00:0000                    <         dw word
      68.  00:0000                    <         endmacro
      69.  00:0000                      
      70.  00:0000                      ; DEBUGMESSAGE
      71.  00:0000                              macro DEBUGMESSAGE string
      72.  00:0000                    <         ifdef DEBUG
      73.  00:0000                    <         ld d,d
      74.  00:0000                    <         jr .skip
      75.  00:0000                    <         db string
      76.  00:0000                    < .skip:  
      77.  00:0000                    <         endif
      78.  00:0000                    <         endmacro
      79.  00:0000                      
      80.  00:0000                      ; MESSAGE
      81.  00:0000                              macro MESSAGE string
      82.  00:0000                    <         call sendMessage
      83.  00:0000                    <         db string
      84.  00:0000                    < .skip2: nop
      85.  00:0000                    <         endmacro
      86.  00:0000                      
      87.  00:0000                      ; DEBUGDUMPREGISTERS
      88.  00:0000                              macro DEBUGDUMPREGISTERS
      89.  00:0000                    <         ifdef DEBUG
      90.  00:0000                    <         db $ed,7
      91.  00:0000                    <         endif
      92.  00:0000                    <         
      93.  00:0000                    <         ifdef USBDEBUG
      94.  00:0000                    <         assert ($ < $8000)
      95.  00:0000                    <         call sendCpuInfo
      96.  00:0000                    <         endif
      97.  00:0000                    <         endmacro
      98.  00:0000                      
      99.  00:0000                      ; MAKEDPB macro
     100.  00:0000                              macro MAKEDPB media, sectorSize, sectorsPerCluster, maxEnt, maxSector, fatSiz, fatCount
     101.  00:0000                    < .firfat equ 1
     102.  00:0000                    < .firdir equ .firfat+(fatCount*fatSiz)
     103.  00:0000                    < .firrec equ .firdir+(maxEnt/(sectorSize/32))
     104.  00:0000                    <         if sectorSize = 512
     105.  00:0000                    < .shft   equ 4
     106.  00:0000                    <         elseif sectorSize = 256
     107.  00:0000                    < .shft   equ 3
     108.  00:0000                    <         endif
     109.  00:0000                    <         
     110.  00:0000                    <         db media                                        ; media descriptor
     111.  00:0000                    <         dw sectorSize                                   ; sector size
     112.  00:0000                    <         db (sectorSize/32)-1, .shft                     ; dirmsk
     113.  00:0000                    <         db sectorsPerCluster-1                          ; clusmsk 
     114.  00:0000                    <         db sectorsPerCluster                            ; clusshft (TODO: only correct for 1 and 2 sec/clus)         
     115.  00:0000                    <         dw .firfat
     116.  00:0000                    <         db fatCount, maxEnt
     117.  00:0000                    <         dw .firrec
     118.  00:0000                    <         dw (maxSector-.firrec)/sectorsPerCluster+1      ; maxclus
     119.  00:0000                    <         db fatSiz
     120.  00:0000                    <         dw .firdir
     121.  00:0000                    <         endmacro
     122.  00:0000                      
     123.  00:0000                      
     124.  00:0000                      ; ROMHEADER macro
     125.  00:0000                              macro romheader r   
     126.  00:0000                    < .addr := $4000        
     127.  00:0000                    <         repeat r
     128.  00:0000                    <         code ! .addr
     129.  00:0000                    < 
     130.  00:0000                    <         org $4000
     131.  00:0000                    <         db "AB"
     132.  00:0000                    <         dw .init
     133.  00:0000                    <         ds 12,0
     134.  00:0000                    < 
     135.  00:0000                    <         call .redir                     ; DSKIO
     136.  00:0000                    <         call .redir                     ; DSKCHG
     137.  00:0000                    <         call .redir                     ; GETDPB
     138.  00:0000                    <         call .redir                     ; CHOICE
     139.  00:0000                    <         call .redir                     ; DSKFMT
     140.  00:0000                    <         ds 3,0                          ; DRVOFF
     141.  00:0000                    < 
     142.  00:0000                    <         code ! .addr + $3fe7
     143.  00:0000                    <         org $7fe7
     144.  00:0000                    <         
     145.  00:0000                    < .init:  ld hl,romInit
     146.  00:0000                    <         push hl
     147.  00:0000                    <         jr .enableBank0        
     148.  00:0000                    < 
     149.  00:0000                    < .redir: ex (sp),hl
     150.  00:0000                    <         dec hl
     151.  00:0000                    <         dec hl
     152.  00:0000                    <         dec hl
     153.  00:0000                    <         ex (sp),hl
     154.  00:0000                    <         jr .enableBank0
     155.  00:0000                    < 
     156.  00:0000                    <         ld (mapper),a                   ; copyFromBank
     157.  00:0000                    <         ldir
     158.  00:0000                    < .enableBank0:
     159.  00:0000                    <         push af                         ; enable bank 0 (no registers changed)
     160.  00:0000                    <         xor a
     161.  00:0000                    <         ld (mapper),a
     162.  00:0000                    <         pop af
     163.  00:0000                    <         ret
     164.  00:0000                    <         
     165.  00:0000                    < .@addr := .addr + $4000
     166.  00:0000                    <         endrepeat
     167.  00:0000                    <         endmacro
     168.  00:0000                      
     169.  00:0000                      ; MACRO debugdisasm
     170.  00:0000                              macro DEBUGDISASM
     171.  00:0000                    <         db $ed, $0b
     172.  00:0000                    <         endmacro
     173.  00:0000                              
     174.  00:0000                      ; MACRO debugdisasmoff
     175.  00:0000                              macro DEBUGDISASMOFF
     176.  00:0000                    <         db $ed, $0c
     177.  00:0000                    <         endmacro        
     178.  00:0000                      
     179.  00:0000                      ; MACRO breakpoint
     180.  00:0000                              macro BREAKPOINT
     181.  00:0000                    <         ld b,b
     182.  00:0000                    <         jr $+2
     183.  00:0000                    <         endmacro
     184.  00:0000                      
     185.  00:0000                              
     186.  00:0000                              macro PRINTVDPTEXT string
     187.  00:0000                    <         
     188.  00:0000                    <         push hl
     189.  00:0000                    <         ld hl,.text 
     190.  00:0000                    <         call printVdpText2
     191.  00:0000                    <         pop hl
     192.  00:0000                    <         jr .skip
     193.  00:0000                    < .text   db string
     194.  00:0000                    <         db 0
     195.  00:0000                    < .skip:
     196.  00:0000                    <         endmacro
      11   00:0000                              
      12   00:0000                              defpage 0, $4000, $4000
      13   00:0000                              defpage 1, $4000, 3 * $4000
      14   00:0000                              defpage 2, $4000, 28 * $4000
      15   00:0000                              
      16   00:0000  (00)                        page 0
      17   00:4000                      
      18   00:4000  (32F0)                      incbin "..\roms\MSXDOS22.ROM", 0, $72f0-$4000
      19   00:72F0                                      
      20   00:72F0                              PATCH $4006, device
      20   00:72F0                    >         code ! address
      20   00:4006  49 7D             >         dw word
      21   00:4008                      
      22   00:4008                              code ! $4010
      23   00:4010  C3 9D 76                    jp DSKIO
      24   00:4013  C3 A0 77                    jp DSKCHG
      25   00:4016  C3 D7 77                    jp GETDPB
      26   00:4019  C3 43 78                    jp CHOICE
      27   00:401C  C3 48 78                    jp DSKFMT
      28   00:401F  00 00 00                    db 0,0,0                        ; no DRVOFF
      29   00:4022                              
      30   00:4022                              PATCH $47d7, INIHRD
      30   00:4022                    >         code ! address
      30   00:47D7  BF 75             >         dw word
      31   00:47D9                      ;        PATCH $47dd, 0                  ; do not check for MSX1
      32   00:47D9                              PATCH $488d, MYSIZE
      32   00:47D9                    >         code ! address
      32   00:488D  08 00             >         dw word
      33   00:488F                              PATCH $489f, SECLEN
      33   00:488F                    >         code ! address
      33   00:489F  00 02             >         dw word
      34   00:48A1                              PATCH $48b9, DRIVES
      34   00:48A1                    >         code ! address
      34   00:48B9  E2 75             >         dw word
      35   00:48BB                              PATCH $48eb, DEFDPB - 1
      35   00:48BB                    >         code ! address
      35   00:48EB  8D 7B             >         dw word
      36   00:48ED                              PATCH $48f7, INIENV
      36   00:48ED                    >         code ! address
      36   00:48F7  4B 76             >         dw word
      37   00:48F9                              PATCH $5797, OEMSTA
      37   00:48F9                    >         code ! address
      37   00:5797  53 79             >         dw word
      38   00:5799                      
      39   00:5799                              code ! $4881
      40   00:4881  23                          db LOW initDiskBasic
      41   00:4882                              code ! $4884
      42   00:4884  73                          db HIGH initDiskBasic
      43   00:4885                       
      44   00:4885                              code ! $49a3
      45   00:49A3  21 BD 73                    ld hl,newAUX                    ; redirect AUX to host  
      46   00:49A6  11 27 F3                    ld de,$f327
      47   00:49A9  01 0A 00                    ld bc,10
      48   00:49AC  ED B0                       ldir
      49   00:49AE  00                          nop
      50   00:49AF  00                          nop
      51   00:49B0  00                          nop
      52   00:49B1  00                          nop
      53   00:49B2  00                          nop                             ; do not remove!
      54   00:49B3                              
      55   00:49B3                              code @ $72f0
      56   00:72F0                              
      57   00:72F0                              include "common.asm"
       1.  00:72F0                      ; Nowind specific
       2.  00:72F0                      
       3.  00:72F0                      nowindInit:
       4.  00:72F0  3A F8 FA                    ld a,($faf8)										; moet volgens bifi ld a,($2d) zijn, $faf8 is op msx1 deel van de rs232 area?
       5.  00:72F3  B7                          or a 
       6.  00:72F4  F5                          push af
       7.  00:72F5  CC 5F 00                    call z,CHGMOD                   ; SCREEN 0 for MSX1
       8.  00:72F8  F1                          pop af
       9.  00:72F9  DD 21 85 01                 ld ix,SDFSCR                    ; restore screen mode from clockchip
      10.  00:72FD  C4 5F 01                    call nz,EXTROM
      11.  00:7300                                      
common.asm line 12: Label not found: PRINTTEXT
      12.  00:7300  CD 00 00                    call PRINTTEXT
      13.  00:7303                              ifndef DEBUG
      14.  00:7303                    ~         db "Nowind USB Diskrom!",0
      15.  00:7303                    ~         else
      16.  00:7303                              db "Nowind USB Diskrom! [debug]",0
      16.  00:7303  4E 6F 77 69 6E 64 20 55 53 42 20 44 69 73 6B 72 
      16.  00:7313  6F 6D 21 20 5B 64 65 62 75 67 5D 00 
      17.  00:731F                              endif
      18.  00:731F                      
      19.  00:731F                              ; call insertBootCode
      20.  00:731F  CD 70 7C                    call flashWriter
      21.  00:7322  C9                          ret
      22.  00:7323                      
      23.  00:7323                      initDiskBasic:
      24.  00:7323                              DEBUGMESSAGE "initDiskBasic"
      24.  00:7323                    >         ifdef DEBUG
      24.  00:7323  52                >         ld d,d
      24.  00:7324  18 0D             >         jr .skip
      24.  00:7326                    >         db string
      24.  00:7326  69 6E 69 74 44 69 73 6B 42 61 73 69 63 
      24.  00:7333                    > .skip:
      24.  00:7333                    >         endif
      25.  00:7333  21 99 FD                    ld hl,DEVICE
      26.  00:7336  CB BE                       res 7,(hl)
      27.  00:7338                              
      28.  00:7338                              ifdef MSXDOS1
      29.  00:7338                    ~         jp $5897
      30.  00:7338                    ~         else
      31.  00:7338  C3 5B 49                    jp $495b
      32.  00:733B                              endif
      33.  00:733B                      
      34.  00:733B                      ; search call statement or device name
      35.  00:733B                      findStatementName:
      36.  00:733B                              DEBUGMESSAGE "findStatementName"
      36.  00:733B                    >         ifdef DEBUG
      36.  00:733B  52                >         ld d,d
      36.  00:733C  18 11             >         jr .skip
      36.  00:733E                    >         db string
      36.  00:733E  66 69 6E 64 53 74 61 74 65 6D 65 6E 74 4E 61 6D 
      36.  00:734E  65 
      36.  00:734F                    > .skip:
      36.  00:734F                    >         endif
      37.  00:734F  11 89 FD                    ld de,PROCNM
      38.  00:7352  1A                  .loop:  ld a,(de)
      39.  00:7353  BE                          cp (hl)
      40.  00:7354  20 06                       jr nz,.nextStatement
      41.  00:7356  23                          inc hl
      42.  00:7357  B7                          or a
      43.  00:7358  C8                          ret z                           ; name found
      44.  00:7359  13                          inc de
      45.  00:735A  18 F6                       jr .loop        
      46.  00:735C                      .nextStatement:
      47.  00:735C  AF                          xor a
      48.  00:735D  4F                          ld c,a
      49.  00:735E  ED B1                       cpir
      50.  00:7360  23                          inc hl
      51.  00:7361  23                          inc hl
      52.  00:7362  B6                          or (hl)
      53.  00:7363  20 D6                       jr nz,findStatementName        
      54.  00:7365  37                          scf                             ; not found
      55.  00:7366  C9                          ret
      56.  00:7367                      
      57.  00:7367                      sendRegisters:
      58.  00:7367  F5                          push af
      59.  00:7368  7C                          ld a,h
      60.  00:7369  26 40                       ld h,HIGH usbwr
      61.  00:736B  36 AF                       ld (hl),$af                     ; header
      62.  00:736D  36 05                       ld (hl),$05
      63.  00:736F  71                          ld (hl),c
      64.  00:7370  70                          ld (hl),b
      65.  00:7371  73                          ld (hl),e
      66.  00:7372  72                          ld (hl),d
      67.  00:7373  75                          ld (hl),l
      68.  00:7374  77                          ld (hl),a                       ; register h
      69.  00:7375  D1                          pop de
      70.  00:7376  73                          ld (hl),e                       ; register f
      71.  00:7377  72                          ld (hl),d                       ; register a
      72.  00:7378  C9                          ret
      73.  00:7379                              
      74.  00:7379                      getHeader:
      75.  00:7379  06 FF                       ld b,HIGH 65535                 ; 42000 * 60 states ~ 0,7 sec (time out)
      76.  00:737B  7E                  .loop:  ld a,(hl)
      77.  00:737C  FE AF               .chkaf: cp $af
      78.  00:737E  28 20                       jr z,.chk05
      79.  00:7380  0B                          dec bc
      80.  00:7381  78                          ld a,b
      81.  00:7382  B1                          or c
      82.  00:7383  20 F6                       jr nz,.loop
      83.  00:7385                              DEBUGMESSAGE "getHeader Timed out!"
      83.  00:7385                    >         ifdef DEBUG
      83.  00:7385  52                >         ld d,d
      83.  00:7386  18 14             >         jr .skip
      83.  00:7388                    >         db string
      83.  00:7388  67 65 74 48 65 61 64 65 72 20 54 69 6D 65 64 20 
      83.  00:7398  6F 75 74 21 
      83.  00:739C                    > .skip:
      83.  00:739C                    >         endif
      84.  00:739C  3E 02                       ld a,2                          ; not ready
      85.  00:739E  37                          scf
      86.  00:739F  C9                          ret
      87.  00:73A0                      
      88.  00:73A0  7E                  .chk05: ld a,(hl)
      89.  00:73A1  FE 05                       cp $05
      90.  00:73A3  20 D7                       jr nz,.chkaf
      91.  00:73A5  7E                          ld a,(hl)
      92.  00:73A6  C9                          ret
      93.  00:73A7                      
      94.  00:73A7                      sendMessage:
      95.  00:73A7                              ;DEBUGMESSAGE "sendMsg"
      96.  00:73A7  E3                          ex (sp),hl
      97.  00:73A8  F5                          push af
      98.  00:73A9  D5                          push de
      99.  00:73AA  E5                          push hl        
     100.  00:73AB  CD 67 73                    call sendRegisters
     101.  00:73AE  36 90                       ld (hl),C_MESSAGE
     102.  00:73B0  E1                          pop hl
     103.  00:73B1  7E                  .loop:  ld a,(hl)
     104.  00:73B2  23                          inc hl
     105.  00:73B3  32 00 40                    ld (usbwr),a
     106.  00:73B6  B7                          or a
     107.  00:73B7  20 F8                       jr nz,.loop
     108.  00:73B9  D1                          pop de
     109.  00:73BA  F1                          pop af
     110.  00:73BB  E3                          ex (sp),hl
     111.  00:73BC  C9                          ret
     112.  00:73BD                              
     113.  00:73BD                      ; AUX device
     114.  00:73BD                              
     115.  00:73BD  C3 C7 73            newAUX: jp AUXin
     116.  00:73C0  00                          nop
     117.  00:73C1  00                          nop
     118.  00:73C2  C3 0C 74                    jp AUXout
     119.  00:73C5  00                          nop
     120.  00:73C6  00                          nop
     121.  00:73C7                      
     122.  00:73C7                      AUXin:  DEBUGMESSAGE "AUX in"
     122.  00:73C7                    >         ifdef DEBUG
     122.  00:73C7  52                >         ld d,d
     122.  00:73C8  18 06             >         jr .skip
     122.  00:73CA  41 55 58 20 69 6E >         db string
     122.  00:73D0                    > .skip:
     122.  00:73D0                    >         endif
     123.  00:73D0  E5                          push hl
     124.  00:73D1  D5                          push de
     125.  00:73D2  C5                          push bc
     126.  00:73D3  CD 67 73                    call sendRegisters
     127.  00:73D6  36 8E                       ld (hl),C_AUXIN
     128.  00:73D8  CD 1F 75                    call enableNowindPage0
     129.  00:73DB  26 20                       ld h,HIGH usbrd
     130.  00:73DD  CD 79 73                    call getHeader
     131.  00:73E0  D2 FB 73                    jp nc,.getCharacter
     132.  00:73E3                              
     133.  00:73E3                              DEBUGMESSAGE "not connected"
     133.  00:73E3                    >         ifdef DEBUG
     133.  00:73E3  52                >         ld d,d
     133.  00:73E4  18 0D             >         jr .skip
     133.  00:73E6                    >         db string
     133.  00:73E6  6E 6F 74 20 63 6F 6E 6E 65 63 74 65 64 
     133.  00:73F3                    > .skip:
     133.  00:73F3                    >         endif
     134.  00:73F3  3E 1A                       ld a,$1a                        ; eof
     135.  00:73F5  C1                  .exit:  pop bc
     136.  00:73F6  D1                          pop de
     137.  00:73F7  E1                          pop hl
     138.  00:73F8  C3 2A 75                    jp restorePage0        
     139.  00:73FB                                    
     140.  00:73FB                      .getCharacter:
     141.  00:73FB                              DEBUGMESSAGE "getChar"
     141.  00:73FB                    >         ifdef DEBUG
     141.  00:73FB  52                >         ld d,d
     141.  00:73FC  18 07             >         jr .skip
     141.  00:73FE                    >         db string
     141.  00:73FE  67 65 74 43 68 61 72 
     141.  00:7405                    > .skip:
     141.  00:7405                    >         endif
     142.  00:7405  CD 79 73                    call getHeader
     143.  00:7408  38 F1                       jr c,.getCharacter
     144.  00:740A  18 E9                       jr .exit
     145.  00:740C                      
     146.  00:740C                      
     147.  00:740C                      AUXout: DEBUGMESSAGE "AUX out"
     147.  00:740C                    >         ifdef DEBUG
     147.  00:740C  52                >         ld d,d
     147.  00:740D  18 07             >         jr .skip
     147.  00:740F                    >         db string
     147.  00:740F  41 55 58 20 6F 75 74 
     147.  00:7416                    > .skip:
     147.  00:7416                    >         endif
     148.  00:7416                              DEBUGDUMPREGISTERS
     148.  00:7416                    >         ifdef DEBUG
     148.  00:7416  ED 07             >         db $ed,7
     148.  00:7418                    >         endif
     148.  00:7418                    >         
     148.  00:7418                    >         ifdef USBDEBUG
     148.  00:7418                    ~         assert ($ < $8000)
     148.  00:7418                    ~         call sendCpuInfo
     148.  00:7418                    ~         endif
     149.  00:7418  E5                          push hl
     150.  00:7419  D5                          push de
     151.  00:741A                      ;        push bc
     152.  00:741A                      ;        ld a,(RAMAD1) ; TODO: WTF???
     153.  00:741A                      ;        call RDSLT
     154.  00:741A  F5                          push af        
     155.  00:741B  CD 67 73                    call sendRegisters
     156.  00:741E  36 8F                       ld (hl),C_AUXOUT
     157.  00:7420  F1                          pop af
     158.  00:7421                      ;        pop bc
     159.  00:7421  D1                          pop de
     160.  00:7422  E1                          pop hl
     161.  00:7423  C9                          ret
     162.  00:7424                      
     163.  00:7424                      insertBootCode:
     164.  00:7424                              DEBUGMESSAGE "BOOTCODE"
     164.  00:7424                    >         ifdef DEBUG
     164.  00:7424  52                >         ld d,d
     164.  00:7425  18 08             >         jr .skip
     164.  00:7427                    >         db string
     164.  00:7427  42 4F 4F 54 43 4F 44 45 
     164.  00:742F                    > .skip:
     164.  00:742F                    >         endif
     165.  00:742F  CD 67 73                    call sendRegisters
     166.  00:7432  36 A1                       ld (hl),C_BOOTCODE
     167.  00:7434  CD 1F 75                    call enableNowindPage0
     168.  00:7437  CD 79 73                    call getHeader
     169.  00:743A  DA 2A 75                    jp c,restorePage0
     170.  00:743D                              
     171.  00:743D                              DEBUGMESSAGE "BOOTCODE"
     171.  00:743D                    >         ifdef DEBUG
     171.  00:743D  52                >         ld d,d
     171.  00:743E  18 08             >         jr .skip
     171.  00:7440                    >         db string
     171.  00:7440  42 4F 4F 54 43 4F 44 45 
     171.  00:7448                    > .skip:
     171.  00:7448                    >         endif
     172.  00:7448  C3 2A 75                    jp restorePage0
     173.  00:744B                      
     174.  00:744B                      ; send 32 bytes starting from address specified by DE to the usb
     175.  00:744B                      sdendFCB:
     176.  00:744B  D5                          push de
     177.  00:744C  C5                          push bc
     178.  00:744D                              
     179.  00:744D  06 20                       ld b,32
     180.  00:744F  1A                  .loop:  ld a,(de)
     181.  00:7450  32 00 40                    ld (usbwr),a
     182.  00:7453  13                          inc de
     183.  00:7454  10 F9                       djnz .loop
     184.  00:7456  C1                          pop bc
     185.  00:7457  D1                          pop de
     186.  00:7458  C9                          ret
     187.  00:7459                      
     188.  00:7459                      ; receive 32 bytes and write to the address specified by DE 
     189.  00:7459                      receiveFCB:
     190.  00:7459  D5                          push de
     191.  00:745A  C5                          push bc
     192.  00:745B                              
     193.  00:745B  06 20                       ld b,32
     194.  00:745D  3A 00 20            .loop:  ld a,(usbrd)
     195.  00:7460  32 00 40            	ld (usbwr),a			; loop back
     196.  00:7463  12                          ld (de),a
     197.  00:7464  13                          inc de
     198.  00:7465  10 F6                       djnz .loop
     199.  00:7467  C1                          pop bc
     200.  00:7468  D1                          pop de
     201.  00:7469  C9                          ret
     202.  00:746A                              
      58   00:746A                              include "extendedBios.asm"
       1.  00:746A                      
       2.  00:746A                      installExtendedBios:
       3.  00:746A                      
       4.  00:746A                              ; Called from INIENV, so EXTBIO hook is already initialized
       5.  00:746A                      
       6.  00:746A                              DEBUGMESSAGE "extbio"
       6.  00:746A                    >         ifdef DEBUG
       6.  00:746A  52                >         ld d,d
       6.  00:746B  18 06             >         jr .skip
       6.  00:746D  65 78 74 62 69 6F >         db string
       6.  00:7473                    > .skip:
       6.  00:7473                    >         endif
       7.  00:7473  CD AA 75                    call getEntrySLTWRK             ; save previous EXTBIO hook
       8.  00:7476  23                          inc hl
       9.  00:7477  EB                          ex de,hl        
      10.  00:7478  21 CA FF                    ld hl,EXTBIO
      11.  00:747B  01 05 00                    ld bc,5
      12.  00:747E  ED B0                       ldir
      13.  00:7480                              
      14.  00:7480  E5                          push hl                         ; determine device number
      15.  00:7481  AF                          xor a
      16.  00:7482  11 01 4E                    ld de,$4e01
      17.  00:7485  CD CA FF                    call EXTBIO
      18.  00:7488  E1                          pop hl
      19.  00:7489  77                          ld (hl),a
      20.  00:748A                                      
      21.  00:748A  CD 2D 40                    call GETSLT                     ; install new EXTBIO hook
      22.  00:748D  2E F7                       ld l,$f7
      23.  00:748F  67                          ld h,a
      24.  00:7490  22 CA FF                    ld (EXTBIO),hl
      25.  00:7493  21 9F 74                    ld hl,extendedBios
      26.  00:7496  22 CC FF                    ld (EXTBIO+2),hl
      27.  00:7499  3E C9                       ld a,$c9
      28.  00:749B  32 CE FF                    ld (EXTBIO+4),a    
      29.  00:749E  C9                          ret
      30.  00:749F                      
      31.  00:749F                      extendedBios:
      32.  00:749F                              ; broadcast (0x00) not implemented
      33.  00:749F                              ; system exclusive (0xff) not implemented
      34.  00:749F                      
      35.  00:749F  FB                          ei
      36.  00:74A0  F5                          push af
      37.  00:74A1  7A                          ld a,d
      38.  00:74A2  FE 4E                       cp $4e
      39.  00:74A4  28 0E                       jr z,determineFunction
      40.  00:74A6                      .exit:
      41.  00:74A6  E5                          push hl
      42.  00:74A7  C5                          push bc
      43.  00:74A8  CD AA 75                    call getEntrySLTWRK
      44.  00:74AB  2C                          inc l                           ; previous EXTBIO hook 
      45.  00:74AC  E5                          push hl
      46.  00:74AD  DD E1                       pop ix
      47.  00:74AF  C1                          pop bc        
      48.  00:74B0  E1                          pop hl
      49.  00:74B1  F1                          pop af
      50.  00:74B2  DD E9                       jp (ix)                         ; process other EXTBIO handles
      51.  00:74B4                      
      52.  00:74B4                      determineFunction:
      53.  00:74B4  E5                          push hl
      54.  00:74B5  21 C0 D8                    ld hl,functionTable - 2 * $4e00
      55.  00:74B8  19                          add hl,de
      56.  00:74B9  19                          add hl,de
      57.  00:74BA  7E                          ld a,(hl)
      58.  00:74BB  23                          inc hl
      59.  00:74BC  66                          ld h,(hl)
      60.  00:74BD  6F                          ld l,a
      61.  00:74BE  E3                          ex (sp),hl
      62.  00:74BF  C9                          ret
      63.  00:74C0                      
      64.  00:74C0                      functionTable:
      65.  00:74C0  C6 74                       dw getNowindSlot
      66.  00:74C2  E2 74                       dw numberOfDevices
      67.  00:74C4  F9 74                       dw debugMessage
      68.  00:74C6                      
      69.  00:74C6                      getNowindSlot:               
      70.  00:74C6                              DEBUGMESSAGE "getNowindSlot"
      70.  00:74C6                    >         ifdef DEBUG
      70.  00:74C6  52                >         ld d,d
      70.  00:74C7  18 0D             >         jr .skip
      70.  00:74C9                    >         db string
      70.  00:74C9  67 65 74 4E 6F 77 69 6E 64 53 6C 6F 74 
      70.  00:74D6                    > .skip:
      70.  00:74D6                    >         endif
      71.  00:74D6  F1                          pop af
      72.  00:74D7  3D                          dec a
      73.  00:74D8  F5                          push af
      74.  00:74D9  F2 A6 74                    jp p,extendedBios.exit         ; not this device
      75.  00:74DC                              
      76.  00:74DC  F1                          pop af
      77.  00:74DD  CD 7A 75                    call getSlotPage1
      78.  00:74E0  37                          scf
      79.  00:74E1  C9                          ret
      80.  00:74E2                              
      81.  00:74E2                      numberOfDevices:
      82.  00:74E2                              DEBUGMESSAGE "numberOfDevices"
      82.  00:74E2                    >         ifdef DEBUG
      82.  00:74E2  52                >         ld d,d
      82.  00:74E3  18 0F             >         jr .skip
      82.  00:74E5                    >         db string
      82.  00:74E5  6E 75 6D 62 65 72 4F 66 44 65 76 69 63 65 73 
      82.  00:74F4                    > .skip:
      82.  00:74F4                    >         endif
      83.  00:74F4  F1                          pop af
      84.  00:74F5  3C                          inc a
      85.  00:74F6  F5                          push af
      86.  00:74F7  18 AD                       jr extendedBios.exit
      87.  00:74F9                              
      88.  00:74F9                      debugMessage:
      89.  00:74F9                              DEBUGMESSAGE "debugMessage"
      89.  00:74F9                    >         ifdef DEBUG
      89.  00:74F9  52                >         ld d,d
      89.  00:74FA  18 0C             >         jr .skip
      89.  00:74FC                    >         db string
      89.  00:74FC  64 65 62 75 67 4D 65 73 73 61 67 65 
      89.  00:7508                    > .skip:
      89.  00:7508                    >         endif
      90.  00:7508  F1                          pop af
      91.  00:7509  3D                          dec a
      92.  00:750A  F5                          push af
      93.  00:750B  F2 A6 74                    jp p,extendedBios.exit
      94.  00:750E                      
      95.  00:750E  E5                          push hl
      96.  00:750F  CD 67 73                    call sendRegisters
      97.  00:7512  36 90                       ld (hl),C_MESSAGE
      98.  00:7514  E1                          pop hl
      99.  00:7515  7E                  .loop:  ld a,(hl)
     100.  00:7516  23                          inc hl
     101.  00:7517  32 00 40                    ld (usbwr),a
     102.  00:751A  B7                          or a
     103.  00:751B  20 F8                       jr nz,.loop
     104.  00:751D                              
     105.  00:751D  F1                          pop af        
     106.  00:751E  C9                          ret
      59   00:751F                              include "slotRoutines.asm"
       1.  00:751F                      ; These routines are used for slot selection
       2.  00:751F                      
       3.  00:751F                      enableNowindPage0:
       4.  00:751F  CD 6F 75                    call getSlotPage0
       5.  00:7522  DD 67                       ld ixh,a
       6.  00:7524  CD 7A 75                    call getSlotPage1
       7.  00:7527  C3 33 75                    jp enableSlotPage0       
       8.  00:752A                      
       9.  00:752A                      restorePage0:
      10.  00:752A  F5                          push af
      11.  00:752B  DD 7C                       ld a,ixh
      12.  00:752D  CD 33 75                    call enableSlotPage0
      13.  00:7530  FB                          ei
      14.  00:7531  F1                          pop af
      15.  00:7532  C9                          ret
      16.  00:7533                      
      17.  00:7533                      enableSlotPage0:
      18.  00:7533                              ; HL and D remain unchanged
      19.  00:7533                              ; enableSlotPage0 can be called in page 1 and 2 (no absolute jumps)
      20.  00:7533                      
      21.  00:7533                              ;DEBUGMESSAGE "enasltP0"
      22.  00:7533  5F                          ld e,a                          ; store slotcode for further use
      23.  00:7534  E6 03                       and 3
      24.  00:7536  4F                          ld c,a                          ; new primary slot in c  
      25.  00:7537  CB 7B                       bit 7,e
      26.  00:7539  F3                          di
      27.  00:753A  20 08                       jr nz,.expanded
      28.  00:753C                      
      29.  00:753C  DB A8                       in a,($a8)
      30.  00:753E  E6 FC                       and %11111100
      31.  00:7540  B1                          or c                            ; enable new primary slot in page 0
      32.  00:7541  D3 A8                       out ($a8),a
      33.  00:7543  C9                          ret
      34.  00:7544                              
      35.  00:7544                      .expanded:
      36.  00:7544  7B                          ld a,e                          ; store secondary slot in e
      37.  00:7545  E6 0C                       and %00001100     
      38.  00:7547  0F                          rrca
      39.  00:7548  0F                          rrca
      40.  00:7549  5F                          ld e,a
      41.  00:754A                      
      42.  00:754A  DB A8                       in a,($a8)
      43.  00:754C  E6 FC                       and %11111100
      44.  00:754E  B1                          or c                            ; new primary slot in page 0
      45.  00:754F  47                          ld b,a                          ; used to restore
      46.  00:7550  17                          rla
      47.  00:7551  A7                          and a                           ; (reset carry)
      48.  00:7552  17                          rla
      49.  00:7553  B1                          or c                            ; new primary slot in page 3
      50.  00:7554  0F                          rrca
      51.  00:7555  0F                          rrca
      52.  00:7556  D3 A8                       out ($a8),a
      53.  00:7558                      
      54.  00:7558  3A FF FF                    ld a,(-1)                       ; write secondary slot register
      55.  00:755B  2F                          cpl
      56.  00:755C  E6 FC                       and %11111100
      57.  00:755E  B3                          or e                            ; apply new secondary slot for page 0
      58.  00:755F  32 FF FF                    ld (-1),a
      59.  00:7562  5F                          ld e,a                          ; store secondary slot register (for SLTTBL)
      60.  00:7563                      
      61.  00:7563  78                          ld a,b                          ; restore primary slot page 3
      62.  00:7564  D3 A8                       out ($a8),a
      63.  00:7566                      
      64.  00:7566  3E C5                       ld a,LOW SLTTBL                 ; update SLTTBL
      65.  00:7568  81                          add c                           ; add primary slot
      66.  00:7569  4F                          ld c,a
      67.  00:756A  06 FC                       ld b,HIGH SLTTBL
      68.  00:756C  7B                          ld a,e                          ; restore secondary slot register
      69.  00:756D  02                          ld (bc),a
      70.  00:756E  C9                          ret
      71.  00:756F                      
      72.  00:756F                      ; These routines determine the current slot and subslot of a page.
      73.  00:756F                      
      74.  00:756F                      getSlotPage0:
      75.  00:756F                              ;DEBUGMESSAGE "getsltP0"
      76.  00:756F  DB A8                       in a,($a8)
      77.  00:7571  CD 94 75                    call expanded
      78.  00:7574  07                          rlca
      79.  00:7575  07                          rlca
      80.  00:7576  E6 0C                       and %00001100           ; keep subSlot
      81.  00:7578  B1                          or c                    ; add mainSlot and expanded bit
      82.  00:7579  C9                          ret
      83.  00:757A                                      
      84.  00:757A                      getSlotPage1:
      85.  00:757A                      ;        DEBUGMESSAGE "getsltP1"
      86.  00:757A  DB A8                       in a,($a8)
      87.  00:757C  0F                          rrca
      88.  00:757D  0F                          rrca
      89.  00:757E  CD 94 75                    call expanded
      90.  00:7581  E6 0C                       and %00001100           ; keep subSlot
      91.  00:7583  B1                          or c                    ; add mainSlot and expanded bit
      92.  00:7584  C9                          ret        
      93.  00:7585                                      
      94.  00:7585                      getSlotPage2:
      95.  00:7585                      ;        DEBUGMESSAGE "getsltP2"
      96.  00:7585  DB A8                       in a,($a8)
      97.  00:7587  0F                          rrca
      98.  00:7588  0F                          rrca
      99.  00:7589  0F                          rrca
     100.  00:758A  0F                          rrca
     101.  00:758B  CD 94 75                    call expanded
     102.  00:758E  0F                          rrca
     103.  00:758F  0F                          rrca
     104.  00:7590  E6 0C                       and %00001100           ; keep subSlot
     105.  00:7592  B1                          or c                    ; add mainSlot and expanded bit
     106.  00:7593  C9                          ret
     107.  00:7594                      
     108.  00:7594                      ;expanded:        
     109.  00:7594                      ;        ld hl,EXPTBL - $0300
     110.  00:7594                      ;        ld b,3
     111.  00:7594                      ;        and b
     112.  00:7594                      ;        ld c,a
     113.  00:7594                      ;        add hl,bc      
     114.  00:7594                      ;        
     115.  00:7594                      ;        or (hl)        ; BUGGIE!!!! (a will be used again!)
     116.  00:7594                      ;        ret p                           ; return when slot is not expanded
     117.  00:7594                      ;        
     118.  00:7594                      ;        ld c,a
     119.  00:7594                      ;        ld a,4
     120.  00:7594                      ;        add a,l
     121.  00:7594                      ;        ld l,a
     122.  00:7594                      ;        ld a,(hl)
     123.  00:7594                      ;        ret
     124.  00:7594                      
     125.  00:7594                      expanded:        
     126.  00:7594  21 C1 F9                    ld hl,EXPTBL - $0300
     127.  00:7597  06 03                       ld b,3
     128.  00:7599  A0                          and b
     129.  00:759A  4F                          ld c,a
     130.  00:759B  09                          add hl,bc
     131.  00:759C  CB 7E                       bit 7,(hl)
     132.  00:759E  28 08                       jr z,notExpanded
     133.  00:75A0                      
     134.  00:75A0  CB F9                       set 7,c
     135.  00:75A2  2C                          inc l
     136.  00:75A3  2C                          inc l
     137.  00:75A4  2C                          inc l
     138.  00:75A5  2C                          inc l
     139.  00:75A6  7E                          ld a,(hl)
     140.  00:75A7  C9                          ret        
     141.  00:75A8                      
     142.  00:75A8                      notExpanded:
     143.  00:75A8  C1                          pop bc
     144.  00:75A9  C9                          ret
     145.  00:75AA                      
     146.  00:75AA                      getEntrySLTWRK:
     147.  00:75AA  CD 7A 75                    call getSlotPage1
     148.  00:75AD  21 09 FD                    ld hl,SLTWRK
     149.  00:75B0  4F                          ld c,a
     150.  00:75B1  0F                          rrca
     151.  00:75B2  0F                          rrca
     152.  00:75B3  0F                          rrca
     153.  00:75B4  E6 60                       and %01100000           ; main slot x 32
     154.  00:75B6  47                          ld b,a
     155.  00:75B7  79                          ld a,c
     156.  00:75B8  07                          rlca
     157.  00:75B9  E6 18                       and %00011000           ; sub slot x 8
     158.  00:75BB  80                          add b
     159.  00:75BC  85                          add l
     160.  00:75BD  6F                          ld l,a
     161.  00:75BE  C9                          ret
     162.  00:75BF                      
      60   00:75BF                              include "nowindDriver.asm"
       1.  00:75BF  (00:0008)           MYSIZE          equ 8                   ; size of work area (not used, some programs write here to stop drives spinning)
       2.  00:75BF  (00:0200)           SECLEN          equ 512                 ; sector size
       3.  00:75BF                      
       4.  00:75BF                      ; SLTWRK entry
       5.  00:75BF                      ; +0    rom drive number
       6.  00:75BF                      ; +1..5 previous EXTBIO
       7.  00:75BF                      ; +6    not used
       8.  00:75BF                      ; +7    not used
       9.  00:75BF                      
      10.  00:75BF                             
      11.  00:75BF                      ; if this is defined we tell DOS2.3 that we _are DOS2.3 also, so
      12.  00:75BF                      ; it does not try to override our initilazations 
      13.  00:75BF                      
      14.  00:75BF                      define  PRETEND_2B_DOS23
      15.  00:75BF                              
      16.  00:75BF                      INIHRD: 
      17.  00:75BF                              DEBUGMESSAGE "INIHRD"        
      17.  00:75BF                    >         ifdef DEBUG
      17.  00:75BF  52                >         ld d,d
      17.  00:75C0  18 06             >         jr .skip
      17.  00:75C2  49 4E 49 48 52 44 >         db string
      17.  00:75C8                    > .skip:
      17.  00:75C8                    >         endif
      18.  00:75C8                              
      19.  00:75C8                      ;        call getWorkArea
      20.  00:75C8                      ;        DEBUGDUMPREGISTERS
      21.  00:75C8                                                      
      22.  00:75C8  CD 1F 75                    call enableNowindPage0                  ; clear hostToMSXFifo by reading 4Kb of random data
      23.  00:75CB  01 00 10                    ld bc,4096
      24.  00:75CE  3A 00 20            .loop:  ld a,(usbrd)
      25.  00:75D1  0B                          dec bc
      26.  00:75D2  78                          ld a,b
      27.  00:75D3  B1                          or c
      28.  00:75D4  20 F8                       jr nz,.loop
      29.  00:75D6  CD 2A 75                    call restorePage0
      30.  00:75D9                              
      31.  00:75D9  26 40                       ld h,HIGH usbwr
      32.  00:75DB  36 AF                       ld (hl),$af                     ; INIHRD command
      33.  00:75DD  36 FF                       ld (hl),$ff
      34.  00:75DF  C3 F0 72                    jp nowindInit
      35.  00:75E2                      
      36.  00:75E2                      DRIVES:
      37.  00:75E2                              DEBUGMESSAGE "DRIVES"
      37.  00:75E2                    >         ifdef DEBUG
      37.  00:75E2  52                >         ld d,d
      37.  00:75E3  18 06             >         jr .skip
      37.  00:75E5  44 52 49 56 45 53 >         db string
      37.  00:75EB                    > .skip:
      37.  00:75EB                    >         endif
      38.  00:75EB  F5                          push af                         ; A, BC and DE should be preserved!
      39.  00:75EC  C5                          push bc
      40.  00:75ED  D5                          push de
      41.  00:75EE  3A 99 FD                    ld a,(DEVICE)
      42.  00:75F1  CD 67 73                    call sendRegisters
      43.  00:75F4  36 85                       ld (hl),C_DRIVES
      44.  00:75F6  CD 1F 75                    call enableNowindPage0
      45.  00:75F9  26 20                       ld h,HIGH usbrd
      46.  00:75FB  CD 79 73                    call getHeader
      47.  00:75FE  2E 02                       ld l,2                          ; default 2 drives
      48.  00:7600  38 2C                       jr c,.notconnected
      49.  00:7602                      
      50.  00:7602                              PRINTVDPTEXT " Host connected."
      50.  00:7602                    >         
      50.  00:7602  E5                >         push hl
      50.  00:7603  21 0C 76          >         ld hl,.text
      50.  00:7606  CD 72 7B          >         call printVdpText2
      50.  00:7609  E1                >         pop hl
      50.  00:760A  18 11             >         jr .skip
      50.  00:760C                    > .text   db string
      50.  00:760C  20 48 6F 73 74 20 63 6F 6E 6E 65 63 74 65 64 2E 
      50.  00:761C  00                >         db 0
      50.  00:761D                    > .skip:
      51.  00:761D                                                      
      52.  00:761D  32 3F F3                    ld (LASTDRV),a                  ; install phantom drives (CRTL key)?
      53.  00:7620  7E                          ld a,(hl)                       ; allow other drives (SHIFT key)?
      54.  00:7621  32 99 FD                    ld (DEVICE),a
      55.  00:7624  6E                          ld l,(hl)                       ; number of drives
      56.  00:7625  E5                  .exit:  push hl  
      57.  00:7626  CD 2A 75                    call restorePage0
      58.  00:7629  E1                          pop hl
      59.  00:762A  D1                          pop de
      60.  00:762B  C1                          pop bc
      61.  00:762C  F1                          pop af
      62.  00:762D  C9                          ret
      63.  00:762E                              
      64.  00:762E                      .notconnected:
      65.  00:762E                              PRINTVDPTEXT " Host timed out!"            
      65.  00:762E                    >         
      65.  00:762E  E5                >         push hl
      65.  00:762F  21 38 76          >         ld hl,.text
      65.  00:7632  CD 72 7B          >         call printVdpText2
      65.  00:7635  E1                >         pop hl
      65.  00:7636  18 11             >         jr .skip
      65.  00:7638                    > .text   db string
      65.  00:7638  20 48 6F 73 74 20 74 69 6D 65 64 20 6F 75 74 21 
      65.  00:7648  00                >         db 0
      65.  00:7649                    > .skip:
      66.  00:7649  18 DA                       jr .exit
      67.  00:764B                      
      68.  00:764B                      
      69.  00:764B                      INIENV:
      70.  00:764B                      ; Interrupt handler can be installed here and
      71.  00:764B                      ; work area can be initialized when it was requested
      72.  00:764B                              DEBUGMESSAGE "INIENV"
      72.  00:764B                    >         ifdef DEBUG
      72.  00:764B  52                >         ld d,d
      72.  00:764C  18 06             >         jr .skip
      72.  00:764E  49 4E 49 45 4E 56 >         db string
      72.  00:7654                    > .skip:
      72.  00:7654                    >         endif
      73.  00:7654                      
      74.  00:7654                              ifdef PRETEND_2B_DOS23
      75.  00:7654                              DEBUGMESSAGE "Lie about being DOS v2.31"
      75.  00:7654                    >         ifdef DEBUG
      75.  00:7654  52                >         ld d,d
      75.  00:7655  18 19             >         jr .skip
      75.  00:7657                    >         db string
      75.  00:7657  4C 69 65 20 61 62 6F 75 74 20 62 65 69 6E 67 20 
      75.  00:7667  44 4F 53 20 76 32 2E 33 31 
      75.  00:7670                    > .skip:
      75.  00:7670                    >         endif
      76.  00:7670  3E 23                       ld a,$23
      77.  00:7672  32 13 F3                    ld ($f313),a
      78.  00:7675                              endif
      79.  00:7675                              
      80.  00:7675  CD 6A 74                    call installExtendedBios
      81.  00:7678  CD 67 73                    call sendRegisters
      82.  00:767B  36 86                       ld (hl),C_INIENV
      83.  00:767D  CD 1F 75                    call enableNowindPage0
      84.  00:7680  26 20                       ld h,HIGH usbrd
      85.  00:7682  CD 79 73                    call getHeader
      86.  00:7685  F5                          push af
      87.  00:7686                      ;        push ix
      88.  00:7686                      ;        call GETWRK
      89.  00:7686                      ;        pop ix
      90.  00:7686  CD AA 75                    call getEntrySLTWRK
      91.  00:7689  F1                          pop af
      92.  00:768A  36 00                       ld (hl),0                       ; romdisk in drive A: (default)          
      93.  00:768C  38 01                       jr c,.exit
      94.  00:768E  77                          ld (hl),a                       ; store romdisk drive number (255 = no romdisk)
      95.  00:768F  C3 2A 75            .exit:  jp restorePage0
      96.  00:7692                      
      97.  00:7692                      checkWorkArea:
      98.  00:7692  C5                          push bc
      99.  00:7693  E5                          push hl
     100.  00:7694  F5                          push af
     101.  00:7695                      ;        call GETWRK
     102.  00:7695  CD AA 75                    call getEntrySLTWRK
     103.  00:7698  F1                          pop af
     104.  00:7699  BE                          cp (hl)
     105.  00:769A  E1                          pop hl
     106.  00:769B  C1                          pop bc
     107.  00:769C  C9                          ret        
     108.  00:769D                      
     109.  00:769D                      DSKIO: 
     110.  00:769D                      ; Input     F   Carry for set for write, reset for read
     111.  00:769D                      ;           A   Drive number
     112.  00:769D                      ;           B   Number of sectors to read/write
     113.  00:769D                      ;           C   Media descriptor
     114.  00:769D                      ;           DE  Logical sector number
     115.  00:769D                      ;           HL  Transfer address
     116.  00:769D                      ; Output    F   Carry set when not succesfull
     117.  00:769D                      ;           A   Error code
     118.  00:769D                      ;           B   Number of remaining sectors (TODO: check! even without error?)
     119.  00:769D                      
     120.  00:769D                              DEBUGMESSAGE "DSKIO"
     120.  00:769D                    >         ifdef DEBUG
     120.  00:769D  52                >         ld d,d
     120.  00:769E  18 05             >         jr .skip
     120.  00:76A0  44 53 4B 49 4F    >         db string
     120.  00:76A5                    > .skip:
     120.  00:76A5                    >         endif
     121.  00:76A5  F5                          push af
     122.  00:76A6  CD 92 76                    call checkWorkArea
     123.  00:76A9  CA 0C 7C                    jp z,ROMDISK_DSKIO
     124.  00:76AC  F1                          pop af
     125.  00:76AD                      
     126.  00:76AD  CD 67 73                    call sendRegisters
     127.  00:76B0  36 80                       ld (hl),C_DSKIO
     128.  00:76B2  38 58                       jr c,dskioWrite                 ; read or write?
     129.  00:76B4                             
     130.  00:76B4                      dskioRead:
     131.  00:76B4  07                          rlca                            ; < 0x8000 ?
     132.  00:76B5  38 3F                       jr c,.page2and3
     133.  00:76B7                      
     134.  00:76B7                              DEBUGMESSAGE "read01"
     134.  00:76B7                    >         ifdef DEBUG
     134.  00:76B7  52                >         ld d,d
     134.  00:76B8  18 06             >         jr .skip
     134.  00:76BA  72 65 61 64 30 31 >         db string
     134.  00:76C0                    > .skip:
     134.  00:76C0                    >         endif
     135.  00:76C0  CD 85 75                    call getSlotPage2               ; enable nowind in page 2
     136.  00:76C3  F5                          push af
     137.  00:76C4  CD 7A 75                    call getSlotPage1
     138.  00:76C7  DD 67                       ld ixh,a                        ; ixh = current nowind slot
     139.  00:76C9  26 80                       ld h,$80
     140.  00:76CB  CD 24 00                    call ENASLT
     141.  00:76CE  C3 D1 B6                    jp .page2
     142.  00:76D1                              
     143.  00:76D1  (B6D1)                      PHASE $ + $4000
     144.  00:B6D1                      .page2:
     145.  00:B6D1  3A 42 F3                    ld a,(RAMAD1)                   ; enable RAM in page 1
     146.  00:B6D4  26 40                       ld h,$40
     147.  00:B6D6  CD 24 00                    call ENASLT
     148.  00:B6D9                              
     149.  00:B6D9  CD 4C B8                    call readSectors01 
     150.  00:B6DC                              ; TODO: carry checken?----------------------------------------------!!!!!!!!!!!!!!!
     151.  00:B6DC                              
     152.  00:B6DC  DD 7C                       ld a,ixh                        ; enable nowind in page 1 
     153.  00:B6DE  26 40                       ld h,$40
     154.  00:B6E0  CD 24 00                    call ENASLT
     155.  00:B6E3  C3 E6 76                    jp .page1        
     156.  00:B6E6                      
     157.  00:B6E6  (76E6)                      DEPHASE
     158.  00:76E6                      .page1:
     159.  00:76E6  3A 00 80                    ld a,(usb2)
     160.  00:76E9  DD 67                       ld ixh,a
     161.  00:76EB  F1                          pop af
     162.  00:76EC  26 80                       ld h,$80
     163.  00:76EE  CD 24 00                    call ENASLT                     ; restore page 2
     164.  00:76F1  DD 7C                       ld a,ixh
     165.  00:76F3  B7                          or a
     166.  00:76F4  FB                          ei
     167.  00:76F5  C8                          ret z                           ; nothing more to read
     168.  00:76F6                                      
     169.  00:76F6                      .page2and3:                     
     170.  00:76F6                              DEBUGMESSAGE "read23"
     170.  00:76F6                    >         ifdef DEBUG
     170.  00:76F6  52                >         ld d,d
     170.  00:76F7  18 06             >         jr .skip
     170.  00:76F9  72 65 61 64 32 33 >         db string
     170.  00:76FF                    > .skip:
     170.  00:76FF                    >         endif
     171.  00:76FF  CD 1F 75                    call enableNowindPage0
     172.  00:7702  FD E5                       push iy
     173.  00:7704  CD 9F 78                    call readSectors23
     174.  00:7707  FD E1                       pop iy
     175.  00:7709  C3 2A 75                    jp restorePage0
     176.  00:770C                      
     177.  00:770C                      dskioWrite:
     178.  00:770C                              DEBUGMESSAGE "dskwrite"
     178.  00:770C                    >         ifdef DEBUG
     178.  00:770C  52                >         ld d,d
     178.  00:770D  18 08             >         jr .skip
     178.  00:770F                    >         db string
     178.  00:770F  64 73 6B 77 72 69 74 65 
     178.  00:7717                    > .skip:
     178.  00:7717                    >         endif
     179.  00:7717  07                          rlca
     180.  00:7718  38 3E                       jr c,.page2and3        
     181.  00:771A                              
     182.  00:771A                              ;call enableNowindPage2 (todo: make common routine?) 
     183.  00:771A  CD 85 75                    call getSlotPage2               ; save current slot page 2
     184.  00:771D  DD 67                       ld ixh,a
     185.  00:771F  CD 7A 75                    call getSlotPage1
     186.  00:7722  DD 6F                       ld ixl,a
     187.  00:7724  26 80                       ld h,$80
     188.  00:7726  CD 24 00                    call ENASLT                     ; nowind in page 2
     189.  00:7729  C3 2C B7                    jp .page2
     190.  00:772C                      
     191.  00:772C  (B72C)                      PHASE $ + $4000
     192.  00:B72C                      .page2:
     193.  00:B72C  3A 42 F3                    ld a,(RAMAD1)
     194.  00:B72F  26 40                       ld h,$40
     195.  00:B731  CD 24 00                    call ENASLT                     ; ram in page 1
     196.  00:B734                              
     197.  00:B734  CD 7A B8                    call writeLoop01
     198.  00:B737  F5                          push af
     199.  00:B738                              
     200.  00:B738  DD 7D                       ld a,ixl
     201.  00:B73A  26 40                       ld h,$40
     202.  00:B73C  CD 24 00                    call ENASLT                     ; restore nowind in page 1
     203.  00:B73F  C3 42 77                    jp .page1
     204.  00:B742                              
     205.  00:B742  (7742)                      DEPHASE
     206.  00:7742                      .page1:
     207.  00:7742  DD 7C                       ld a,ixh
     208.  00:7744  26 80                       ld h,$80
     209.  00:7746  CD 24 00                    call ENASLT
     210.  00:7749  F1                          pop af
     211.  00:774A  D8                          ret c                           ; return error (error code in a)
     212.  00:774B  E8                          ret pe                          ; host returns 0xfe when data for page 2/3 is available
     213.  00:774C                              DEBUGMESSAGE "doorgaan!"
     213.  00:774C                    >         ifdef DEBUG
     213.  00:774C  52                >         ld d,d
     213.  00:774D  18 09             >         jr .skip
     213.  00:774F                    >         db string
     213.  00:774F  64 6F 6F 72 67 61 61 6E 21 
     213.  00:7758                    > .skip:
     213.  00:7758                    >         endif
     214.  00:7758                              
     215.  00:7758                      .page2and3:
     216.  00:7758                              DEBUGMESSAGE "page2and3"
     216.  00:7758                    >         ifdef DEBUG
     216.  00:7758  52                >         ld d,d
     216.  00:7759  18 09             >         jr .skip
     216.  00:775B                    >         db string
     216.  00:775B  70 61 67 65 32 61 6E 64 33 
     216.  00:7764                    > .skip:
     216.  00:7764                    >         endif
     217.  00:7764  CD 1F 75                    call enableNowindPage0
     218.  00:7767  CD 6D 77                    call .writeLoop23
     219.  00:776A  C3 2A 75                    jp restorePage0
     220.  00:776D                              
     221.  00:776D                      .writeLoop23:
     222.  00:776D                              DEBUGMESSAGE "writeLoop23"
     222.  00:776D                    >         ifdef DEBUG
     222.  00:776D  52                >         ld d,d
     222.  00:776E  18 0B             >         jr .skip
     222.  00:7770                    >         db string
     222.  00:7770  77 72 69 74 65 4C 6F 6F 70 32 33 
     222.  00:777B                    > .skip:
     222.  00:777B                    >         endif
     223.  00:777B                              
     224.  00:777B  26 20                       ld h,HIGH usbrd
     225.  00:777D  CD 79 73                    call getHeader
     226.  00:7780  D8                          ret c                           ; exit (not ready)
     227.  00:7781  B7                          or a
     228.  00:7782  F8                          ret m                           ; exit (no error)
     229.  00:7783  20 18                       jr nz,.error
     230.  00:7785                      
     231.  00:7785                              DEBUGMESSAGE "send23"
     231.  00:7785                    >         ifdef DEBUG
     231.  00:7785  52                >         ld d,d
     231.  00:7786  18 06             >         jr .skip
     231.  00:7788  73 65 6E 64 32 33 >         db string
     231.  00:778E                    > .skip:
     231.  00:778E                    >         endif
     232.  00:778E  5E                          ld e,(hl)                       ; address
     233.  00:778F  56                          ld d,(hl)
     234.  00:7790  4E                          ld c,(hl)                       ; number of bytes        
     235.  00:7791  46                          ld b,(hl)
     236.  00:7792  7E                          ld a,(hl)                       ; block sequence number
     237.  00:7793                              
     238.  00:7793                              ;DEBUGDUMPREGISTERS
     239.  00:7793  EB                          ex de,hl
     240.  00:7794  11 00 40                    ld de,usbwr
     241.  00:7797  12                          ld (de),a                       ; mark block begin
     242.  00:7798  ED B0                       ldir
     243.  00:779A  12                          ld (de),a                       ; mark block end
     244.  00:779B  18 D0                       jr .writeLoop23
     245.  00:779D                      
     246.  00:779D  37                  .error: scf
     247.  00:779E  7E                          ld a,(hl)                       ; get error code
     248.  00:779F  C9                          ret
     249.  00:77A0                      
     250.  00:77A0                                     
     251.  00:77A0                      DSKCHG:
     252.  00:77A0                      ; Input     A   Drive number
     253.  00:77A0                      ;           B   0
     254.  00:77A0                      ;           C   Media descriptor (previous)
     255.  00:77A0                      ;           HL  Base address of DPB
     256.  00:77A0                      ; Output    B   1   Disk unchanged
     257.  00:77A0                      ;               0   Unknown (DPB is updated)
     258.  00:77A0                      ;               -1  Disk changed (DPB is updated)
     259.  00:77A0                      ;           F   Carry set when not succesfull
     260.  00:77A0                      ;           A   Error code
     261.  00:77A0                      
     262.  00:77A0                              DEBUGMESSAGE "DSKCHG"
     262.  00:77A0                    >         ifdef DEBUG
     262.  00:77A0  52                >         ld d,d
     262.  00:77A1  18 06             >         jr .skip
     262.  00:77A3  44 53 4B 43 48 47 >         db string
     262.  00:77A9                    > .skip:
     262.  00:77A9                    >         endif
     263.  00:77A9  F5                          push af
     264.  00:77AA  CD 92 76                    call checkWorkArea
     265.  00:77AD  CA 6B 7C                    jp z,ROMDISK_DSKCHG
     266.  00:77B0  F1                          pop af       
     267.  00:77B1                      
     268.  00:77B1  E5                          push hl
     269.  00:77B2  CD 67 73                    call sendRegisters
     270.  00:77B5  36 81                       ld (hl),C_DSKCHG
     271.  00:77B7  CD 1F 75                    call enableNowindPage0
     272.  00:77BA  26 20                       ld h,HIGH usbrd
     273.  00:77BC  CD 79 73                    call getHeader
     274.  00:77BF  4E                          ld c,(hl)               ; media descriptor (when disk was changed)
     275.  00:77C0  F5                          push af
     276.  00:77C1  C5                          push bc
     277.  00:77C2  CD 2A 75                    call restorePage0
     278.  00:77C5  C1                          pop bc
     279.  00:77C6  F1                          pop af
     280.  00:77C7  E1                          pop hl
     281.  00:77C8  D8                          ret c           ; not ready
     282.  00:77C9  B7                          or a
     283.  00:77CA  06 01                       ld b,1
     284.  00:77CC  C8                          ret z           ; not changed
     285.  00:77CD  41                          ld b,c
     286.  00:77CE  CD D7 77                    call GETDPB
     287.  00:77D1  3E 0A                       ld a,10
     288.  00:77D3  D8                          ret c
     289.  00:77D4  06 FF                       ld b,255
     290.  00:77D6  C9                          ret
     291.  00:77D7                      
     292.  00:77D7                      GETDPB:
     293.  00:77D7                      ; Input     A   Drive number
     294.  00:77D7                      ;           B   Media descriptor (first byte of FAT)
     295.  00:77D7                      ;           C   Previous media descriptor (does not seem to be used in other drivers)
     296.  00:77D7                      ;           HL  Base address of HL
     297.  00:77D7                      ; Output    DPB for specified drive in [HL+1]..[HL+18]
     298.  00:77D7                      
     299.  00:77D7                              DEBUGMESSAGE "GETDPB"
     299.  00:77D7                    >         ifdef DEBUG
     299.  00:77D7  52                >         ld d,d
     299.  00:77D8  18 06             >         jr .skip
     299.  00:77DA  47 45 54 44 50 42 >         db string
     299.  00:77E0                    > .skip:
     299.  00:77E0                    >         endif
     300.  00:77E0  EB                          ex de,hl
     301.  00:77E1  13                          inc de
     302.  00:77E2  67                          ld h,a
     303.  00:77E3  78                          ld a,b
     304.  00:77E4  FE F0                       cp $f0
     305.  00:77E6  7C                          ld a,h
     306.  00:77E7  28 24                       jr z,.hddImage
     307.  00:77E9                              
     308.  00:77E9                              MESSAGE "ROM GETDPB"
     308.  00:77E9  CD A7 73          >         call sendMessage
     308.  00:77EC                    >         db string
     308.  00:77EC  52 4F 4D 20 47 45 54 44 50 42 
     308.  00:77F6  00                > .skip2: nop
     309.  00:77F7                      
     310.  00:77F7  78                          ld a,b
     311.  00:77F8  D6 F8                       sub $f8
     312.  00:77FA  D8                          ret c                           ; not supported in msxdos1
     313.  00:77FB  07                          rlca                            ; 2x
     314.  00:77FC  4F                          ld c,a
     315.  00:77FD  07                          rlca                            ; 4x
     316.  00:77FE  07                          rlca                            ; 8x
     317.  00:77FF  07                          rlca                            ; 16x
     318.  00:7800  81                          add a,c                         ; 18x
     319.  00:7801  4F                          ld c,a
     320.  00:7802  06 00                       ld b,0        
     321.  00:7804  21 7C 7B                    ld hl,supportedMedia
     322.  00:7807  09                          add hl,bc
     323.  00:7808  0E 12                       ld c,18
     324.  00:780A  ED B0                       ldir
     325.  00:780C  C9                          ret
     326.  00:780D                      
     327.  00:780D                      .hddImage:
     328.  00:780D                              DEBUGMESSAGE ".hddImage"
     328.  00:780D                    >         ifdef DEBUG
     328.  00:780D  52                >         ld d,d
     328.  00:780E  18 09             >         jr .skip
     328.  00:7810                    >         db string
     328.  00:7810  2E 68 64 64 49 6D 61 67 65 
     328.  00:7819                    > .skip:
     328.  00:7819                    >         endif
     329.  00:7819                                      MESSAGE "HOST GETDPB"
     329.  00:7819  CD A7 73          >         call sendMessage
     329.  00:781C                    >         db string
     329.  00:781C  48 4F 53 54 20 47 45 54 44 50 42 
     329.  00:7827  00                > .skip2: nop
     330.  00:7828  CD 67 73                    call sendRegisters
     331.  00:782B  36 82                       ld (hl),C_GETDPB
     332.  00:782D  CD 1F 75                    call enableNowindPage0
     333.  00:7830  26 20                       ld h,HIGH usbrd
     334.  00:7832  CD 79 73                    call getHeader
     335.  00:7835  38 09                       jr c,.exit                      ; not ready
     336.  00:7837  5F                          ld e,a                          ; destination
     337.  00:7838  56                          ld d,(hl)
     338.  00:7839  01 12 00                    ld bc,18
     339.  00:783C                              DEBUGDUMPREGISTERS
     339.  00:783C                    >         ifdef DEBUG
     339.  00:783C  ED 07             >         db $ed,7
     339.  00:783E                    >         endif
     339.  00:783E                    >         
     339.  00:783E                    >         ifdef USBDEBUG
     339.  00:783E                    ~         assert ($ < $8000)
     339.  00:783E                    ~         call sendCpuInfo
     339.  00:783E                    ~         endif
     340.  00:783E  ED B0                       ldir
     341.  00:7840                              ;DB $ed, $0a       
     342.  00:7840  C3 2A 75            .exit:  jp restorePage0        
     343.  00:7843                      
     344.  00:7843                      CHOICE:
     345.  00:7843                              ;DEBUGMESSAGE "CHOICE"
     346.  00:7843                              ifdef MSXDOS2
     347.  00:7843  21 47 78                    ld hl,.noFormat
     348.  00:7846                              else
     349.  00:7846                    ~         ld hl,0                         ; no choice
     350.  00:7846                    ~         endif
     351.  00:7846  C9                          ret
     352.  00:7847                      
     353.  00:7847                      .noFormat:
     354.  00:7847  00                          db 0
     355.  00:7848                      
     356.  00:7848                      DSKFMT:
     357.  00:7848  37                          scf
     358.  00:7849  3E 10                       ld a,16                         ; other error
     359.  00:784B  C9                          ret
     360.  00:784C                              
     361.  00:784C  (B84C)                      PHASE $ + $4000
     362.  00:B84C                              
     363.  00:B84C                      readSectors01:
     364.  00:B84C                              DEBUGMESSAGE "readSectors01"
     364.  00:B84C                    >         ifdef DEBUG
     364.  00:B84C  52                >         ld d,d
     364.  00:B84D  18 0D             >         jr .skip
     364.  00:B84F                    >         db string
     364.  00:B84F  72 65 61 64 53 65 63 74 6F 72 73 30 31 
     364.  00:B85C                    > .skip:
     364.  00:B85C                    >         endif
     365.  00:B85C  26 80                       ld h,HIGH usb2
     366.  00:B85E  CD 79 B3                    call getHeader + $4000                                  
     367.  00:B861  D8                          ret c                           ; carry means timeout, no carry: A == 0 means slow transfer, A == 1 means exit, A == 2 means fast transfer                                      
     368.  00:B862  3D                          dec a
     369.  00:B863  C8                          ret z
     370.  00:B864  FA 6E B8                    jp m,.slowTransfer                              
     371.  00:B867  CD E0 B8                    call reverseTransfer + $4000
     372.  00:B86A  70                          ld (hl),b
     373.  00:B86B  71                          ld (hl),c
     374.  00:B86C  18 DE                       jr readSectors01
     375.  00:B86E                      
     376.  00:B86E                      .slowTransfer:
     377.  00:B86E  5E                          ld e,(hl)                       ; transfer address
     378.  00:B86F  56                          ld d,(hl)
     379.  00:B870  4E                          ld c,(hl)                       ; transfer amount 
     380.  00:B871  46                          ld b,(hl)
     381.  00:B872  ED B0                       ldir        
     382.  00:B874                              
     383.  00:B874  56                          ld d,(hl)                       ; BUG in emulator (byte direct terugschrijven, geeft 'rukkert!')
     384.  00:B875  7E                          ld a,(hl)
     385.  00:B876  72                          ld (hl),d                       ; return end marker ($af, $0f)
     386.  00:B877  77                          ld (hl),a
     387.  00:B878  18 D2                       jr readSectors01
     388.  00:B87A                      
     389.  00:B87A                      writeLoop01:
     390.  00:B87A  26 80                       ld h,HIGH usb2
     391.  00:B87C  CD 79 B3                    call getHeader + $4000
     392.  00:B87F  D8                          ret c                           ; exit (not ready)
     393.  00:B880  B7                          or a
     394.  00:B881  F8                          ret m                           ; exit (no error)
     395.  00:B882  20 18                       jr nz,.error
     396.  00:B884                      
     397.  00:B884                              DEBUGMESSAGE "send01"
     397.  00:B884                    >         ifdef DEBUG
     397.  00:B884  52                >         ld d,d
     397.  00:B885  18 06             >         jr .skip
     397.  00:B887  73 65 6E 64 30 31 >         db string
     397.  00:B88D                    > .skip:
     397.  00:B88D                    >         endif
     398.  00:B88D  5E                          ld e,(hl)                       ; address
     399.  00:B88E  56                          ld d,(hl)
     400.  00:B88F  4E                          ld c,(hl)                       ; number of bytes        
     401.  00:B890  46                          ld b,(hl)
     402.  00:B891  7E                          ld a,(hl)                       ; block sequence number
     403.  00:B892                      
     404.  00:B892  EB                          ex de,hl
     405.  00:B893  11 00 80                    ld de,usb2
     406.  00:B896  12                          ld (de),a                       ; mark block begin
     407.  00:B897  ED B0                       ldir
     408.  00:B899  12                          ld (de),a                       ; mark block end
     409.  00:B89A  18 DE                       jr writeLoop01
     410.  00:B89C                      
     411.  00:B89C  37                  .error: scf
     412.  00:B89D  7E                          ld a,(hl)                       ; get error code
     413.  00:B89E  C9                          ret
     414.  00:B89F                      
     415.  00:B89F  (789F)                      DEPHASE
     416.  00:789F                       
     417.  00:789F                      readSectors23:
     418.  00:789F                              DEBUGMESSAGE "readSectors23"
     418.  00:789F                    >         ifdef DEBUG
     418.  00:789F  52                >         ld d,d
     418.  00:78A0  18 0D             >         jr .skip
     418.  00:78A2                    >         db string
     418.  00:78A2  72 65 61 64 53 65 63 74 6F 72 73 32 33 
     418.  00:78AF                    > .skip:
     418.  00:78AF                    >         endif
     419.  00:78AF  26 20                       ld h,HIGH usbrd
     420.  00:78B1  CD 79 73                    call getHeader
     421.  00:78B4  D8                          ret c
     422.  00:78B5  3D                          dec a
     423.  00:78B6  C8                          ret z                           ; no more data
     424.  00:78B7  FA C3 78                    jp m,.slowTransfer        
     425.  00:78BA  CD E0 78                    call reverseTransfer
     426.  00:78BD  26 40                       ld h,HIGH usbwr 
     427.  00:78BF  70                          ld (hl),b
     428.  00:78C0  71                          ld (hl),c
     429.  00:78C1  18 DC                       jr readSectors23
     430.  00:78C3                      
     431.  00:78C3                      .slowTransfer:
     432.  00:78C3                              DEBUGMESSAGE "slowtransfer"
     432.  00:78C3                    >         ifdef DEBUG
     432.  00:78C3  52                >         ld d,d
     432.  00:78C4  18 0C             >         jr .skip
     432.  00:78C6                    >         db string
     432.  00:78C6  73 6C 6F 77 74 72 61 6E 73 66 65 72 
     432.  00:78D2                    > .skip:
     432.  00:78D2                    >         endif
     433.  00:78D2  5E                          ld e,(hl)                       ; transfer address
     434.  00:78D3  56                          ld d,(hl)
     435.  00:78D4  4E                          ld c,(hl)                       ; transfer amount 
     436.  00:78D5  46                          ld b,(hl)
     437.  00:78D6  ED B0                       ldir
     438.  00:78D8  56                          ld d,(hl)
     439.  00:78D9  7E                          ld a,(hl)
     440.  00:78DA  26 40                       ld h,HIGH usbwr
     441.  00:78DC  72                          ld (hl),d                       ; return end marker ($af, $0f)
     442.  00:78DD  77                          ld (hl),a
     443.  00:78DE  18 BF                       jr readSectors23
     444.  00:78E0                                     
     445.  00:78E0                      reverseTransfer:
     446.  00:78E0  FD 21 00 00                 ld iy,0                         ; save stack pointer
     447.  00:78E4  FD 39                       add iy,sp
     448.  00:78E6  5E                          ld e,(hl)                       ; transfer address
     449.  00:78E7  56                          ld d,(hl)
     450.  00:78E8  EB                          ex de,hl
     451.  00:78E9  F9                          ld sp,hl
     452.  00:78EA  EB                          ex de,hl
     453.  00:78EB  46                          ld b,(hl)                       ; number of loops       
     454.  00:78EC                      .loop:
     455.  00:78EC                              repeat 32                       ; blocks of 64 bytes hardcoded (NowindHost.cpp)
     456.  00:78EC                    <         ld d,(hl)
     457.  00:78EC                    <         ld e,(hl)
     458.  00:78EC                    <         push de
     459.  00:78EC                    <         endrepeat
     459.  00:78EC  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     459.  00:78FC  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     459.  00:790C  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     459.  00:791C  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     459.  00:792C  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     459.  00:793C  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     460.  00:794C  10 9E                       djnz .loop
     461.  00:794E                              
     462.  00:794E  FD F9                       ld sp,iy                        ; restore stack pointer
     463.  00:7950  46                          ld b,(hl)                       ; return end marker
     464.  00:7951  4E                          ld c,(hl)
     465.  00:7952  C9                          ret
     466.  00:7953                            
     467.  00:7953                      OEMSTA:
     468.  00:7953  E5                          push hl
     469.  00:7954  21 61 79                    ld hl,.statement
     470.  00:7957  CD 3B 73                    call findStatementName
     471.  00:795A  5E                          ld e,(hl)
     472.  00:795B  23                          inc hl
     473.  00:795C  56                          ld d,(hl)
     474.  00:795D  E1                          pop hl        
     475.  00:795E  D8                          ret c
     476.  00:795F  D5                          push de
     477.  00:7960  C9                          ret
     478.  00:7961                      
     479.  00:7961                      .statement:
     480.  00:7961  49 4D 41 47 45 00           db "IMAGE",0
     481.  00:7967  74 79                       dw changeImage
     482.  00:7969                              db "VSTREAM",0
     482.  00:7969  56 53 54 52 45 41 4D 00 
     483.  00:7971  A1 79                       dw videoStream
     484.  00:7973  00                          db 0
     485.  00:7974                      
     486.  00:7974                      ; send arguments, command, filename, end with ":"
     487.  00:7974                      changeImage:
     488.  00:7974                              DEBUGMESSAGE "changeImage"
     488.  00:7974                    >         ifdef DEBUG
     488.  00:7974  52                >         ld d,d
     488.  00:7975  18 0B             >         jr .skip
     488.  00:7977                    >         db string
     488.  00:7977  63 68 61 6E 67 65 49 6D 61 67 65 
     488.  00:7982                    > .skip:
     488.  00:7982                    >         endif
     489.  00:7982  E5                          push hl
     490.  00:7983  CD 67 73                    call sendRegisters
     491.  00:7986  36 A0                       ld (hl),C_CHANGEIMAGE
     492.  00:7988  E1                          pop hl
     493.  00:7989                              
     494.  00:7989                      call_exit:
     495.  00:7989                              DEBUGMESSAGE "call_exit"
     495.  00:7989                    >         ifdef DEBUG
     495.  00:7989  52                >         ld d,d
     495.  00:798A  18 09             >         jr .skip
     495.  00:798C                    >         db string
     495.  00:798C  63 61 6C 6C 5F 65 78 69 74 
     495.  00:7995                    > .skip:
     495.  00:7995                    >         endif
     496.  00:7995  7E                  .loop:  ld a,(hl)
     497.  00:7996  32 00 40                    ld (usbwr),a
     498.  00:7999  FE 3A                       cp ":"
     499.  00:799B  C8                          ret z
     500.  00:799C  B7                          or a
     501.  00:799D  C8                          ret z
     502.  00:799E  23                          inc hl
     503.  00:799F  18 F4                       jr .loop
     504.  00:79A1                              
     505.  00:79A1                      videoStream: 
     506.  00:79A1  E5                          push hl
     507.  00:79A2                              include "vram.asm"
       1:  00:79A2                              
       2:  00:79A2                      vramDump:
       3:  00:79A2  F3                  	di
       4:  00:79A3  CD 1F 75                    call enableNowindPage0
       5:  00:79A6                      
       6:  00:79A6  3E 02                       ld a,2
       7:  00:79A8  D3 99                       out ($99),a
       8:  00:79AA  3E 8F                       ld a,$80+15             ; status register pointer at S#2
       9:  00:79AC  D3 99                       out ($99),a
      10:  00:79AE                      
      11:  00:79AE                      evenFrame:
      12:  00:79AE                              ; vram address 0x0000
      13:  00:79AE                              
      14:  00:79AE                              ;xor a
      15:  00:79AE                              ;out ($99),a
      16:  00:79AE                              ;ld a,$80+2
      17:  00:79AE                              ;out ($99),a
      18:  00:79AE                              
      19:  00:79AE  3E 03                       ld a,%00000011                 ; pattern generator table
      20:  00:79B0  D3 99                       out ($99),a
      21:  00:79B2  3E 84                       ld a,$80+4
      22:  00:79B4  D3 99                       out ($99),a
      23:  00:79B6                      
      24:  00:79B6  AF                          xor a                   ; color table high
      25:  00:79B7  D3 99                       out ($99),a
      26:  00:79B9  3E 8A                       ld a,$80+10
      27:  00:79BB  D3 99                       out ($99),a
      28:  00:79BD                              
      29:  00:79BD  3E 04                       ld a,%00000100          ; vram access at 0x10000
      30:  00:79BF  CD 53 7B                    call setVramAccessPointer
      31:  00:79C2  CD EB 79                    call tranferframe
      32:  00:79C5  CD 61 7B                    call waitForRetrace
      33:  00:79C8  CD 05 7B                    call changeColors
      34:  00:79CB                      
      35:  00:79CB                      oddFrame:
      36:  00:79CB                              ; vram address 0x10000
      37:  00:79CB                      
      38:  00:79CB                              ;ld a,%01000000
      39:  00:79CB                              ;out ($99),a
      40:  00:79CB                              ;ld a,$80+2
      41:  00:79CB                              ;out ($99),a
      42:  00:79CB                      
      43:  00:79CB  3E 23                       ld a,%00100011          ; pattern generator table
      44:  00:79CD  D3 99                       out ($99),a
      45:  00:79CF  3E 84                       ld a,$80+4
      46:  00:79D1  D3 99                       out ($99),a
      47:  00:79D3                      
      48:  00:79D3  3E 64                       ld a,00000100           ; color table high
      49:  00:79D5  D3 99                       out ($99),a
      50:  00:79D7  3E 8A                       ld a,$80+10
      51:  00:79D9  D3 99                       out ($99),a
      52:  00:79DB                      
      53:  00:79DB  AF                          xor a
      54:  00:79DC  CD 53 7B                    call setVramAccessPointer
      55:  00:79DF  CD EB 79                    call tranferframe
      56:  00:79E2  CD 61 7B                    call waitForRetrace
      57:  00:79E5  CD 05 7B                    call changeColors
      58:  00:79E8  C3 AE 79                    jp evenFrame
      59:  00:79EB                      
      60:  00:79EB                      tranferframe:
      61:  00:79EB  CD 67 73                    call sendRegisters
      62:  00:79EE  36 FF                       ld (hl),255
      63:  00:79F0                                      
      64:  00:79F0  21 00 20                    ld hl,usbrd
      65:  00:79F3  CD 79 73                    call getHeader
      66:  00:79F6                              
      67:  00:79F6  16 70                       ld d,112			; 224x64 is 1 screen 2 page of data ($3800)
      68:  00:79F8                      write_more:        
      69:  00:79F8  21 00 20            	ld hl,usbrd
      70:  00:79FB  01 98 00                    ld bc,$0098
      71:  00:79FE                              repeat 128
      72:  00:79FE                    <         outi
      73:  00:79FE                    <         endrepeat
      73:  00:79FE  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A0E  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A1E  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A2E  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A3E  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A4E  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A5E  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A6E  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A7E  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A8E  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A9E  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AAE  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7ABE  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7ACE  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7ADE  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AEE  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      74:  00:7AFE                      
      75:  00:7AFE  15                          dec d
      76:  00:7AFF  7A                          ld a,d
      77:  00:7B00  B7                          or a
      78:  00:7B01  C2 F8 79                    jp nz,write_more
      79:  00:7B04  C9                          ret		
      80:  00:7B05                      
      81:  00:7B05                      changeColors:
      82:  00:7B05  AF                          xor a			; set color register pointer to zero
      83:  00:7B06  D3 99                       out ($99),a
      84:  00:7B08  3E 90                       ld a,$80+16
      85:  00:7B0A  D3 99                       out ($99),a
      86:  00:7B0C                              
      87:  00:7B0C  21 00 20                    ld hl,usbrd
      88:  00:7B0F  01 9A 00                    ld bc,$009A		; write to color register
      89:  00:7B12                      
      90:  00:7B12                              repeat 32
      91:  00:7B12                    <         outi
      92:  00:7B12                    <         endrepeat		
      92:  00:7B12  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B22  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B32  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B42  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      93:  00:7B52  C9                          ret
      94:  00:7B53                      
      95:  00:7B53                      	
      96:  00:7B53                      setVramAccessPointer:
      97:  00:7B53  D3 99                       out ($99),a
      98:  00:7B55  3E 8E                       ld a,$80+14
      99:  00:7B57  D3 99                       out ($99),a
     100:  00:7B59  AF                          xor a
     101:  00:7B5A  D3 99                       out ($99),a
     102:  00:7B5C  3E 40                       ld a,%01000000		; vram write
     103:  00:7B5E  D3 99                       out ($99),a
     104:  00:7B60  C9                          ret
     105:  00:7B61                      
     106:  00:7B61                      waitForRetrace:
     107:  00:7B61  DB 99                       in a,($99)
     108:  00:7B63  CB 77                       bit 6,a
     109:  00:7B65  20 FA                       jr nz,waitForRetrace       
     110:  00:7B67                      .lp2:        
     111:  00:7B67  DB 99                       in a,($99)
     112:  00:7B69  CB 77                       bit 6,a
     113:  00:7B6B  28 FA                       jr z,.lp2       
     114:  00:7B6D  C9                          ret
     115:  00:7B6E                              	
     116:  00:7B6E                      	; just let it go... 
     508.  00:7B6E  E1                          pop hl
     509.  00:7B6F  C3 89 79                    jp call_exit
     510.  00:7B72                              
     511.  00:7B72                      ; hl points to text
     512.  00:7B72                      printVdpText2:
     513.  00:7B72  F5                                                  push af
     514.  00:7B73  7E                  .loop:  ld a,(hl)
     515.  00:7B74  D3 98                                               out ($98),a 
     516.  00:7B76  23                                                  inc hl
     517.  00:7B77  B7                                                  or a
     518.  00:7B78  20 F9                                               jr nz,.loop
     519.  00:7B7A  F1                                                  pop af
     520.  00:7B7B  C9                                                  ret
     521.  00:7B7C                              
     522.  00:7B7C                      supportedMedia:
     523.  00:7B7C                                      
     524.  00:7B7C                      .f8:    MAKEDPB $f8, 512, 2, 112, 1 * 80 * 9, 2, 2      ; 360 kB (1 side * 80 tracks * 9 tracks/sector)
     524.  00:7B7C  (00:0001)         > .firfat equ 1
     524.  00:7B7C  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     524.  00:7B7C  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     524.  00:7B7C                    >         if sectorSize = 512
     524.  00:7B7C  (00:0004)         > .shft   equ 4
     524.  00:7B7C                    >         elseif sectorSize = 256
     524.  00:7B7C                    ~ .shft   equ 3
     524.  00:7B7C                    ~         endif
     524.  00:7B7C                    >         
     524.  00:7B7C  F8                >         db media
     524.  00:7B7D  00 02             >         dw sectorSize
     524.  00:7B7F  0F 04             >         db (sectorSize/32)-1, .shft
     524.  00:7B81  01                >         db sectorsPerCluster-1
     524.  00:7B82  02                >         db sectorsPerCluster
     524.  00:7B83  01 00             >         dw .firfat
     524.  00:7B85  02 70             >         db fatCount, maxEnt
     524.  00:7B87  0C 00             >         dw .firrec
     524.  00:7B89  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     524.  00:7B8B  02                >         db fatSiz
     524.  00:7B8C  05 00             >         dw .firdir
     525.  00:7B8E                      .def:   MAKEDPB $f9, 512, 2, 112, 2 * 80 * 9, 3, 2      ; 720 kB
     525.  00:7B8E  (00:0001)         > .firfat equ 1
     525.  00:7B8E  (00:0007)         > .firdir equ .firfat+(fatCount*fatSiz)
     525.  00:7B8E  (00:000E)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     525.  00:7B8E                    >         if sectorSize = 512
     525.  00:7B8E  (00:0004)         > .shft   equ 4
     525.  00:7B8E                    >         elseif sectorSize = 256
     525.  00:7B8E                    ~ .shft   equ 3
     525.  00:7B8E                    ~         endif
     525.  00:7B8E                    >         
     525.  00:7B8E  F9                >         db media
     525.  00:7B8F  00 02             >         dw sectorSize
     525.  00:7B91  0F 04             >         db (sectorSize/32)-1, .shft
     525.  00:7B93  01                >         db sectorsPerCluster-1
     525.  00:7B94  02                >         db sectorsPerCluster
     525.  00:7B95  01 00             >         dw .firfat
     525.  00:7B97  02 70             >         db fatCount, maxEnt
     525.  00:7B99  0E 00             >         dw .firrec
     525.  00:7B9B  CA 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     525.  00:7B9D  03                >         db fatSiz
     525.  00:7B9E  07 00             >         dw .firdir
     526.  00:7BA0                              MAKEDPB $fa, 512, 2, 112, 1 * 80 * 8, 1, 2      ; 320 kB
     526.  00:7BA0  (00:0001)         > .firfat equ 1
     526.  00:7BA0  (00:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     526.  00:7BA0  (00:000A)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     526.  00:7BA0                    >         if sectorSize = 512
     526.  00:7BA0  (00:0004)         > .shft   equ 4
     526.  00:7BA0                    >         elseif sectorSize = 256
     526.  00:7BA0                    ~ .shft   equ 3
     526.  00:7BA0                    ~         endif
     526.  00:7BA0                    >         
     526.  00:7BA0  FA                >         db media
     526.  00:7BA1  00 02             >         dw sectorSize
     526.  00:7BA3  0F 04             >         db (sectorSize/32)-1, .shft
     526.  00:7BA5  01                >         db sectorsPerCluster-1
     526.  00:7BA6  02                >         db sectorsPerCluster
     526.  00:7BA7  01 00             >         dw .firfat
     526.  00:7BA9  02 70             >         db fatCount, maxEnt
     526.  00:7BAB  0A 00             >         dw .firrec
     526.  00:7BAD  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     526.  00:7BAF  01                >         db fatSiz
     526.  00:7BB0  03 00             >         dw .firdir
     527.  00:7BB2                              MAKEDPB $fb, 512, 2, 112, 2 * 80 * 8, 2, 2      ; 640 kB
     527.  00:7BB2  (00:0001)         > .firfat equ 1
     527.  00:7BB2  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     527.  00:7BB2  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     527.  00:7BB2                    >         if sectorSize = 512
     527.  00:7BB2  (00:0004)         > .shft   equ 4
     527.  00:7BB2                    >         elseif sectorSize = 256
     527.  00:7BB2                    ~ .shft   equ 3
     527.  00:7BB2                    ~         endif
     527.  00:7BB2                    >         
     527.  00:7BB2  FB                >         db media
     527.  00:7BB3  00 02             >         dw sectorSize
     527.  00:7BB5  0F 04             >         db (sectorSize/32)-1, .shft
     527.  00:7BB7  01                >         db sectorsPerCluster-1
     527.  00:7BB8  02                >         db sectorsPerCluster
     527.  00:7BB9  01 00             >         dw .firfat
     527.  00:7BBB  02 70             >         db fatCount, maxEnt
     527.  00:7BBD  0C 00             >         dw .firrec
     527.  00:7BBF  7B 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     527.  00:7BC1  02                >         db fatSiz
     527.  00:7BC2  05 00             >         dw .firdir
     528.  00:7BC4                              MAKEDPB $fc, 512, 1, 64,  1 * 40 * 9, 2, 2      ; 180 kB
     528.  00:7BC4  (00:0001)         > .firfat equ 1
     528.  00:7BC4  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     528.  00:7BC4  (00:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     528.  00:7BC4                    >         if sectorSize = 512
     528.  00:7BC4  (00:0004)         > .shft   equ 4
     528.  00:7BC4                    >         elseif sectorSize = 256
     528.  00:7BC4                    ~ .shft   equ 3
     528.  00:7BC4                    ~         endif
     528.  00:7BC4                    >         
     528.  00:7BC4  FC                >         db media
     528.  00:7BC5  00 02             >         dw sectorSize
     528.  00:7BC7  0F 04             >         db (sectorSize/32)-1, .shft
     528.  00:7BC9  00                >         db sectorsPerCluster-1
     528.  00:7BCA  01                >         db sectorsPerCluster
     528.  00:7BCB  01 00             >         dw .firfat
     528.  00:7BCD  02 40             >         db fatCount, maxEnt
     528.  00:7BCF  09 00             >         dw .firrec
     528.  00:7BD1  60 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     528.  00:7BD3  02                >         db fatSiz
     528.  00:7BD4  05 00             >         dw .firdir
     529.  00:7BD6                              MAKEDPB $fd, 512, 2, 112, 2 * 40 * 9, 2, 2      ; 360 kB
     529.  00:7BD6  (00:0001)         > .firfat equ 1
     529.  00:7BD6  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     529.  00:7BD6  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     529.  00:7BD6                    >         if sectorSize = 512
     529.  00:7BD6  (00:0004)         > .shft   equ 4
     529.  00:7BD6                    >         elseif sectorSize = 256
     529.  00:7BD6                    ~ .shft   equ 3
     529.  00:7BD6                    ~         endif
     529.  00:7BD6                    >         
     529.  00:7BD6  FD                >         db media
     529.  00:7BD7  00 02             >         dw sectorSize
     529.  00:7BD9  0F 04             >         db (sectorSize/32)-1, .shft
     529.  00:7BDB  01                >         db sectorsPerCluster-1
     529.  00:7BDC  02                >         db sectorsPerCluster
     529.  00:7BDD  01 00             >         dw .firfat
     529.  00:7BDF  02 70             >         db fatCount, maxEnt
     529.  00:7BE1  0C 00             >         dw .firrec
     529.  00:7BE3  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     529.  00:7BE5  02                >         db fatSiz
     529.  00:7BE6  05 00             >         dw .firdir
     530.  00:7BE8                              MAKEDPB $fe, 512, 1, 64,  1 * 40 * 8, 1, 2      ; 160 kB
     530.  00:7BE8  (00:0001)         > .firfat equ 1
     530.  00:7BE8  (00:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     530.  00:7BE8  (00:0007)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     530.  00:7BE8                    >         if sectorSize = 512
     530.  00:7BE8  (00:0004)         > .shft   equ 4
     530.  00:7BE8                    >         elseif sectorSize = 256
     530.  00:7BE8                    ~ .shft   equ 3
     530.  00:7BE8                    ~         endif
     530.  00:7BE8                    >         
     530.  00:7BE8  FE                >         db media
     530.  00:7BE9  00 02             >         dw sectorSize
     530.  00:7BEB  0F 04             >         db (sectorSize/32)-1, .shft
     530.  00:7BED  00                >         db sectorsPerCluster-1
     530.  00:7BEE  01                >         db sectorsPerCluster
     530.  00:7BEF  01 00             >         dw .firfat
     530.  00:7BF1  02 40             >         db fatCount, maxEnt
     530.  00:7BF3  07 00             >         dw .firrec
     530.  00:7BF5  3A 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     530.  00:7BF7  01                >         db fatSiz
     530.  00:7BF8  03 00             >         dw .firdir
     531.  00:7BFA                              MAKEDPB $ff, 512, 2, 112, 2 * 40 * 8, 1, 1      ; 320 kB
     531.  00:7BFA  (00:0001)         > .firfat equ 1
     531.  00:7BFA  (00:0002)         > .firdir equ .firfat+(fatCount*fatSiz)
     531.  00:7BFA  (00:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     531.  00:7BFA                    >         if sectorSize = 512
     531.  00:7BFA  (00:0004)         > .shft   equ 4
     531.  00:7BFA                    >         elseif sectorSize = 256
     531.  00:7BFA                    ~ .shft   equ 3
     531.  00:7BFA                    ~         endif
     531.  00:7BFA                    >         
     531.  00:7BFA  FF                >         db media
     531.  00:7BFB  00 02             >         dw sectorSize
     531.  00:7BFD  0F 04             >         db (sectorSize/32)-1, .shft
     531.  00:7BFF  01                >         db sectorsPerCluster-1
     531.  00:7C00  02                >         db sectorsPerCluster
     531.  00:7C01  01 00             >         dw .firfat
     531.  00:7C03  01 70             >         db fatCount, maxEnt
     531.  00:7C05  09 00             >         dw .firrec
     531.  00:7C07  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     531.  00:7C09  01                >         db fatSiz
     531.  00:7C0A  02 00             >         dw .firdir
     532.  00:7C0C                      
     533.  00:7C0C                      ; WARNING: in some cases DEFDPB-1 is expected!
     534.  00:7C0C  (00:7B8E)           DEFDPB  equ supportedMedia.def
      61   00:7C0C                              include "romdisk.asm"
       1.  00:7C0C                      		define	ROMDSKBANK 5			; romdisk starts in bank 5
       2.  00:7C0C                      		define	ROMDSKLAST (FLASHROMSIZE/16)-1
       3.  00:7C0C                      
       4.  00:7C0C                      
       5.  00:7C0C                      ROMDISK_DSKIO:
       6.  00:7C0C                              DEBUGMESSAGE "R_DSKIO"
       6.  00:7C0C                    >         ifdef DEBUG
       6.  00:7C0C  52                >         ld d,d
       6.  00:7C0D  18 07             >         jr .skip
       6.  00:7C0F                    >         db string
       6.  00:7C0F  52 5F 44 53 4B 49 4F 
       6.  00:7C16                    > .skip:
       6.  00:7C16                    >         endif
       7.  00:7C16  F1                          pop af
       8.  00:7C17  3E 00                       ld a,0
       9.  00:7C19  D8                          ret c                           ; write protected
      10.  00:7C1A                              
      11.  00:7C1A  EB                          ex de,hl
      12.  00:7C1B  C5                  .loop:  push bc
      13.  00:7C1C  E5                          push hl        
      14.  00:7C1D                              
      15.  00:7C1D  CB 7A                       bit 7,d
      16.  00:7C1F  20 1C                       jr nz,.directCopy
      17.  00:7C21  7A                          ld a,d
      18.  00:7C22  FE 3E                       cp $3e        
      19.  00:7C24  38 17                       jr c,.directCopy
      20.  00:7C26                      
      21.  00:7C26  CD 49 7C                    call .findSector
      22.  00:7C29  D5                          push de
      23.  00:7C2A  ED 5B 4D F3                 ld de,($f34d)        
      24.  00:7C2E  CD F4 7F                    call copyFromBank
      25.  00:7C31  D1                          pop de
      26.  00:7C32  01 00 02                    ld bc,512
      27.  00:7C35  2A 4D F3                    ld hl,($f34d)
      28.  00:7C38  CD 6E F3                    call XFER
      29.  00:7C3B  18 06                       jr .nextSector           
      30.  00:7C3D                                    
      31.  00:7C3D                      .directCopy:                
      32.  00:7C3D  CD 49 7C                    call .findSector  
      33.  00:7C40  CD F4 7F                    call copyFromBank
      34.  00:7C43                      .nextSector:
      35.  00:7C43  E1                          pop hl
      36.  00:7C44  23                          inc hl
      37.  00:7C45  C1                          pop bc
      38.  00:7C46  10 D3                       djnz .loop
      39.  00:7C48  C9                          ret
      40.  00:7C49                      
      41.  00:7C49                      .findSector:        
      42.  00:7C49  7D                          ld a,l                          ; determine bank
      43.  00:7C4A  E6 E0                       and %11100000
      44.  00:7C4C  B4                          or h
      45.  00:7C4D  07                          rlca
      46.  00:7C4E  07                          rlca
      47.  00:7C4F  07                          rlca
      48.  00:7C50  47                          ld b,a
      49.  00:7C51                      
      50.  00:7C51  7D                          ld a,l
      51.  00:7C52  E6 1F                       and 31
      52.  00:7C54  4F                          ld c,a
romdisk.asm line 53: Label not found: FLASHROMSIZE
      53.  00:7C55  3E FF                       ld a,ROMDSKLAST                 ; banks with b0..5=0 reside in the last bank
      54.  00:7C57  28 05                       jr z,.skip
      55.  00:7C59                      
      56.  00:7C59  78                          ld a,b
      57.  00:7C5A  C6 05                       add ROMDSKBANK
      58.  00:7C5C  41                          ld b,c
      59.  00:7C5D  05                          dec b
      60.  00:7C5E  4F                  .skip:  ld c,a
      61.  00:7C5F  78                          ld a,b
      62.  00:7C60  07                          rlca
      63.  00:7C61  C6 41                       add $41                         ; disk images starts at $4100
      64.  00:7C63  67                          ld h,a
      65.  00:7C64  2E 00                       ld l,0
      66.  00:7C66  79                          ld a,c
      67.  00:7C67  01 00 02                    ld bc,512
      68.  00:7C6A  C9                          ret
      69.  00:7C6B                                                               
      70.  00:7C6B                      ROMDISK_DSKCHG:
      71.  00:7C6B                              ;DEBUGMESSAGE "ROM_DSKCHG"
      72.  00:7C6B  F1                          pop af
      73.  00:7C6C  A7                          and a
      74.  00:7C6D  06 01                       ld b,1                          ; not changed
      75.  00:7C6F  C9                          ret
      76.  00:7C70                      
      77.  00:7C70                      ROMDISK_GETDPB:
      78.  00:7C70                              ; not implemented (standard mediadescriptor as used)
      79.  00:7C70                              
      80.  00:7C70                      ROMDISK_DSKFMT:
      81.  00:7C70                              ; not implemented (no disk can be formatted)
      82.  00:7C70                              
      62   00:7C70                              include "flashWriter.asm"
       1.  00:7C70                      ; flashWriter.asm
       2.  00:7C70                      ; Flashes and erases the AMD29F040/M29F032-D
       3.  00:7C70                           
       4.  00:7C70                      flashWriter:
       5.  00:7C70  3E 03                       ld a,3
       6.  00:7C72  CD 41 01                    call SNSMAT
       7.  00:7C75  E6 08                       and 8
       8.  00:7C77  C0                          ret nz
       9.  00:7C78                              
flashWriter.asm line 10: Label not found: PRINTTEXT
      10.  00:7C78  CD 00 00                    call PRINTTEXT
      11.  00:7C7B                              db 10,13," FlashROM",10,13," "
      11.  00:7C7B  0A 0D 20 46 6C 61 73 68 52 4F 4D 0A 0D 20 
      12.  00:7C89  2E (33)                     ds 33,"."
      13.  00:7CAA  0D 20 00                    db 13," ",0
      14.  00:7CAD                              
      15.  00:7CAD  CD 7A 75                    call getSlotPage1
      16.  00:7CB0  CD 33 75                    call enableSlotPage0
      17.  00:7CB3                      
      18.  00:7CB3  21 C0 7C                    ld hl,.source
      19.  00:7CB6  11 00 C0                    ld de,$c000
      20.  00:7CB9  D5                          push de
      21.  00:7CBA  01 89 00                    ld bc,flasherEnd - $c000
      22.  00:7CBD  ED B0                       ldir
      23.  00:7CBF  C9                          ret
      24.  00:7CC0                              
      25.  00:7CC0                      .source:     
      26.  00:7CC0  (C000)                      PHASE $c000  
      27.  00:C000                              
      28.  00:C000                      waitForHeader:
      29.  00:C000  26 20                       ld h,HIGH usbrd
      30.  00:C002  7E                          ld a,(hl)
      31.  00:C003  FE BB               .chkbb: cp $bb
      32.  00:C005  20 F9                       jr nz,waitForHeader
      33.  00:C007  7E                          ld a,(hl)
      34.  00:C008  FE 55                       cp $55
      35.  00:C00A  20 F7                       jr nz,.chkbb       
      36.  00:C00C                      
      37.  00:C00C  7E                          ld a,(hl)
      38.  00:C00D  FE A2                       cp $a2
      39.  00:C00F  CA 57 C0                    jp z,verifyFlash
      40.  00:C012  FE A3                       cp $a3
      41.  00:C014  28 1C                       jr z,writeFlash
      42.  00:C016  FE A4                       cp $a4
      43.  00:C018  20 E6                       jr nz,waitForHeader
      44.  00:C01A                      
      45.  00:C01A                      chipErase:
      46.  00:C01A                              ;DEBUGMESSAGE "erase"
      47.  00:C01A  3E 65               		ld a,"e"
      48.  00:C01C  D3 98               		out ($98),a
      49.  00:C01E                      
      50.  00:C01E  3E 80                       ld a,$80
      51.  00:C020  CD 7A C0                    call AM29F040Command
      52.  00:C023  3E 10                       ld a,$10
      53.  00:C025  CD 7A C0                    call AM29F040Command
      54.  00:C028                      
      55.  00:C028  3A 00 40            .wait:  ld a,($4000)                    ; read DQ7 (data# polling) 
      56.  00:C02B  07                          rlca
      57.  00:C02C  30 FA                       jr nc,.wait        
      58.  00:C02E  3E 01                       ld a,1
      59.  00:C030  18 39                       jr acknowledge
      60.  00:C032                              
      61.  00:C032                      writeFlash:
      62.  00:C032                              ;DEBUGMESSAGE "write"
      63.  00:C032  5E                          ld e,(hl)                       ; address
      64.  00:C033  56                          ld d,(hl)
      65.  00:C034                      
      66.  00:C034  7A                          ld a,d
      67.  00:C035  B3                          or e
      68.  00:C036  CC 75 C0                    call z,updateBar
      69.  00:C039                      
      70.  00:C039  7E                          ld a,(hl)                       ; bank
      71.  00:C03A  32 01 60                    ld (mapper),a
      72.  00:C03D  26 40                       ld h,$40
      73.  00:C03F                              
      74.  00:C03F  06 80                       ld b,128                        ; data is written in blocks of 128 bytes
      75.  00:C041  3E A0               .loop:  ld a,$a0
      76.  00:C043  CD 7A C0                    call AM29F040Command
      77.  00:C046  3A 00 20                    ld a,(usbrd)
      78.  00:C049  12                          ld (de),a                       ; write data to flash
      79.  00:C04A  13                          inc de
      80.  00:C04B                      
      81.  00:C04B  7E                  .wait:  ld  a,(hl)                      ; write complete?
      82.  00:C04C  AE                          xor (hl)
      83.  00:C04D  E6 40                       and %01000000
      84.  00:C04F  20 FA                       jr  nz,.wait
      85.  00:C051  10 EE                       djnz .loop
      86.  00:C053                              
      87.  00:C053  3E 02                       ld a,2
      88.  00:C055  18 14                       jr acknowledge        
      89.  00:C057                              
      90.  00:C057                      verifyFlash:
      91.  00:C057                              ;DEBUGMESSAGE "verify"
      92.  00:C057  21 00 20                    ld hl,usbrd
      93.  00:C05A  5E                          ld e,(hl)                       ; address
      94.  00:C05B  56                          ld d,(hl)
      95.  00:C05C  7E                          ld a,(hl)                       ; bank
      96.  00:C05D  32 01 60                    ld (mapper),a
      97.  00:C060                      
      98.  00:C060  06 80                       ld b,128
      99.  00:C062  1A                  .loop:  ld a,(de)
     100.  00:C063  32 00 40                    ld (usbwr),a
     101.  00:C066  13                          inc de
     102.  00:C067  10 F9                       djnz .loop
     103.  00:C069                      
     104.  00:C069  3E 03                       ld a,3
     105.  00:C06B                      acknowledge:        
     106.  00:C06B  26 40                       ld h,HIGH usbwr
     107.  00:C06D  36 AA                       ld (hl),$aa
     108.  00:C06F  36 55                       ld (hl),$55
     109.  00:C071  77                          ld (hl),a
     110.  00:C072  C3 00 C0                    jp waitForHeader
     111.  00:C075                      
     112.  00:C075                      updateBar:
     113.  00:C075  3E 77                       ld a,"w"  
     114.  00:C077  D3 98                       out ($98),a
     115.  00:C079  C9                          ret
     116.  00:C07A                      
     117.  00:C07A                      AM29F040Command:
     118.  00:C07A  F5                          push af
     119.  00:C07B  3E AA                       ld a,$aa
     120.  00:C07D  32 55 05                    ld ($0555),a
     121.  00:C080  2F                          cpl
     122.  00:C081  32 AA 02                    ld ($02aa),a
     123.  00:C084  F1                          pop af
     124.  00:C085  32 55 05                    ld ($0555),a
     125.  00:C088  C9                          ret
     126.  00:C089                              
     127.  00:C089                      flasherEnd:
     128.  00:C089  (7D49)                      DEPHASE
      63   00:7D49                              include "device.asm"
       1.  00:7D49                      ; device.asm
       2.  00:7D49                      ; implements a basic now: device
       3.  00:7D49                          
       4.  00:7D49                      device:
       5.  00:7D49  E5                          push hl
       6.  00:7D4A  21 5B 7D                    ld hl,deviceFunctions
       7.  00:7D4D  0F                          rrca
       8.  00:7D4E  3C                          inc a
       9.  00:7D4F  07                          rlca
      10.  00:7D50  85                          add a,l
      11.  00:7D51  6F                          ld l,a
      12.  00:7D52  30 01                       jr nc,.nocy
      13.  00:7D54  24                          inc h  
      14.  00:7D55  7E                  .nocy:  ld a,(hl)
      15.  00:7D56  23                          inc hl
      16.  00:7D57  66                          ld h,(hl)
      17.  00:7D58  6F                          ld l,a
      18.  00:7D59  E3                          ex (sp),hl
      19.  00:7D5A  C9                          ret
      20.  00:7D5B                      
      21.  00:7D5B                      deviceFunctions:
      22.  00:7D5B  71 7D                       dw identifyDevice               ; 0xff
      23.  00:7D5D  91 7D                       dw open                         ;  0
      24.  00:7D5F  C9 7D                       dw close                        ;  2
      25.  00:7D61  CF 7D                       dw randomIO                     ;  4
      26.  00:7D63  D3 7D                       dw write                        ;  6
      27.  00:7D65  D9 7D                       dw read                         ;  8
      28.  00:7D67  2F 7E                       dw loc                          ; 10
      29.  00:7D69  41 7E                       dw lof                          ; 12
      30.  00:7D6B  0D 7E                       dw eof                          ; 14
      31.  00:7D6D  41 7E                       dw fpos                         ; 16
      32.  00:7D6F  41 7E                       dw putback                      ; 18
      33.  00:7D71                                
      34.  00:7D71                      identifyDevice:
      35.  00:7D71                              DEBUGMESSAGE "identifyDevice"
      35.  00:7D71                    >         ifdef DEBUG
      35.  00:7D71  52                >         ld d,d
      35.  00:7D72  18 0E             >         jr .skip
      35.  00:7D74                    >         db string
      35.  00:7D74  69 64 65 6E 74 69 66 79 44 65 76 69 63 65 
      35.  00:7D82                    > .skip:
      35.  00:7D82                    >         endif
      36.  00:7D82  21 8A 7D                    ld hl,deviceNameList
      37.  00:7D85  CD 3B 73                    call findStatementName
      38.  00:7D88  7E                          ld a,(hl)                       ; device number
      39.  00:7D89  C9                          ret                             ; carry is set when invalid device name
      40.  00:7D8A                              
      41.  00:7D8A                      deviceNameList:
      42.  00:7D8A  4E 4F 57 00 00 00           db "NOW",0,0,0                  ; name, end marker, device number, dummy
      43.  00:7D90                              ;db "STDIN",0,1,0
      44.  00:7D90  00                          db 0
      45.  00:7D91                      
      46.  00:7D91                      ; Input     D   Global device code
      47.  00:7D91                      ;           E   File mode    
      48.  00:7D91                      ;           HL  address fcb
      49.  00:7D91                      open:
      50.  00:7D91                      ;        DEBUGMESSAGE "open"
      51.  00:7D91                      ;        DEBUGDUMPMEMHL 9
      52.  00:7D91  22 64 F8                    ld (PTRFIL),hl
      53.  00:7D94  CD 67 73                    call sendRegisters
      54.  00:7D97  36 88                       ld (hl),C_DEVICEOPEN
      55.  00:7D99  EB                          ex de,hl
      56.  00:7D9A  01 0B 00                    ld bc,11
      57.  00:7D9D  21 66 F8                    ld hl,FILNAM
      58.  00:7DA0  ED B0                       ldir
      59.  00:7DA2                      
      60.  00:7DA2  CD 1F 75                    call enableNowindPage0
      61.  00:7DA5  26 20                       ld h,HIGH usbrd
      62.  00:7DA7  CD 79 73                    call getHeader
      63.  00:7DAA  38 0C                       jr c,deviceIoError              ; time out?
      64.  00:7DAC  B7                          or a
      65.  00:7DAD  20 0B                       jr nz,openError
      66.  00:7DAF                      
      67.  00:7DAF  5E                          ld e,(hl)                       ; update fcb (including buffer)
      68.  00:7DB0  56                          ld d,(hl)
      69.  00:7DB1  4E                          ld c,(hl)
      70.  00:7DB2  46                          ld b,(hl)
      71.  00:7DB3  ED B0                       ldir
      72.  00:7DB5  C3 2A 75                    jp restorePage0        
      73.  00:7DB8                      
      74.  00:7DB8                      deviceIoError:
      75.  00:7DB8  3E 13                       ld a,19
      76.  00:7DBA                      
      77.  00:7DBA                      openError:
      78.  00:7DBA  CD 2A 75                    call restorePage0
      79.  00:7DBD  5F                          ld e,a
      80.  00:7DBE                      
      81.  00:7DBE                      basicError:
      82.  00:7DBE  DD 21 6F 40                 ld ix,$406f
      83.  00:7DC2  FD 2A C0 FC                 ld iy,(EXPTBL-1)
      84.  00:7DC6  C3 1C 00                    jp CALSLT
      85.  00:7DC9                                      
      86.  00:7DC9                      close:
      87.  00:7DC9                      ;        DEBUGMESSAGE "close"
      88.  00:7DC9  CD 67 73                    call sendRegisters
      89.  00:7DCC  36 89                       ld (hl),C_DEVICECLOSE
      90.  00:7DCE  C9                          ret
      91.  00:7DCF                              
      92.  00:7DCF                      randomIO:
      93.  00:7DCF                      ;        DEBUGMESSAGE "randomIO"
      94.  00:7DCF  1E 3D                       ld e,61                         ; bad file mode
      95.  00:7DD1  18 EB                       jr basicError
      96.  00:7DD3                      
      97.  00:7DD3                      write:
      98.  00:7DD3                      ;        DEBUGMESSAGE "write"
      99.  00:7DD3  CD 67 73                    call sendRegisters
     100.  00:7DD6  36 8B                       ld (hl),C_DEVICEWRITE
     101.  00:7DD8  C9                          ret        
     102.  00:7DD9                      
     103.  00:7DD9                      read:
     104.  00:7DD9                      ;        DEBUGMESSAGE "read"
     105.  00:7DD9  11 06 00                    ld de,6
     106.  00:7DDC  19                          add hl,de
     107.  00:7DDD  E5                          push hl
     108.  00:7DDE  5E                          ld e,(hl)
     109.  00:7DDF  23                          inc hl
     110.  00:7DE0  23                          inc hl
     111.  00:7DE1  23                          inc hl
     112.  00:7DE2  19                          add hl,de
     113.  00:7DE3  7E                          ld a,(hl)
     114.  00:7DE4  E1                          pop hl
     115.  00:7DE5  FE 1A                       cp $1a
     116.  00:7DE7  37                          scf
     117.  00:7DE8  C8                          ret z                           ; end of file
     118.  00:7DE9  3F                          ccf
     119.  00:7DEA  34                          inc (hl)                        ; increment position
     120.  00:7DEB  C0                          ret nz                          ; buffer empty?
     121.  00:7DEC                              
     122.  00:7DEC  F5                          push af
     123.  00:7DED  2B                          dec hl
     124.  00:7DEE  34                          inc (hl)                        ; increment position (high)        
     125.  00:7DEF  11 FB FF                    ld de,-5
     126.  00:7DF2  19                          add hl,de
     127.  00:7DF3  CD 67 73                    call sendRegisters
     128.  00:7DF6  36 8C                       ld (hl),C_DEVICEREAD
     129.  00:7DF8  CD 1F 75                    call enableNowindPage0
     130.  00:7DFB  26 20                       ld h,HIGH usbrd
     131.  00:7DFD  CD 79 73                    call getHeader
     132.  00:7E00  38 B6                       jr c,deviceIoError
     133.  00:7E02                      
     134.  00:7E02  5E                          ld e,(hl)
     135.  00:7E03  56                          ld d,(hl)
     136.  00:7E04  4E                          ld c,(hl)
     137.  00:7E05  46                          ld b,(hl)
     138.  00:7E06  ED B0                       ldir                            ; update fcb buffer
     139.  00:7E08  CD 2A 75                    call restorePage0
     140.  00:7E0B  F1                          pop af                          ; return last character
     141.  00:7E0C  C9                          ret
     142.  00:7E0D                      
     143.  00:7E0D                      eof:
     144.  00:7E0D                      ;        DEBUGMESSAGE "eof"
     145.  00:7E0D  7E                          ld a,(hl)
     146.  00:7E0E  FE 01                       cp 1                            ; input mode?        
     147.  00:7E10  1E 3D                       ld e,61                         ; bad file mode
     148.  00:7E12  C2 BE 7D                    jp nz,basicError
     149.  00:7E15                                      
     150.  00:7E15  11 06 00                    ld de,6
     151.  00:7E18  19                          add hl,de
     152.  00:7E19  5E                          ld e,(hl)
     153.  00:7E1A  23                          inc hl
     154.  00:7E1B  23                          inc hl
     155.  00:7E1C  23                          inc hl
     156.  00:7E1D  19                          add hl,de
     157.  00:7E1E  7E                          ld a,(hl)
     158.  00:7E1F  ED 62                       sbc hl,hl
     159.  00:7E21  FE 1A                       cp $1a        
     160.  00:7E23  20 01                       jr nz,.skip
     161.  00:7E25  2B                          dec hl
     162.  00:7E26  22 F8 F7            .skip:  ld (DAC+2),hl
     163.  00:7E29  3E 02                       ld a,2
     164.  00:7E2B  32 63 F6                    ld (VALTYP),a
     165.  00:7E2E  C9                          ret
     166.  00:7E2F                      
     167.  00:7E2F                      loc:
     168.  00:7E2F  E5                          push hl
     169.  00:7E30  FD E1                       pop iy
     170.  00:7E32  FD 6E 06                    ld l,(iy+6)
     171.  00:7E35  FD 66 05                    ld h,(iy+5)
     172.  00:7E38                      ;        DEBUGASSERT
     173.  00:7E38  22 F8 F7                    ld (DAC+2),hl
     174.  00:7E3B  3E 02                       ld a,2
     175.  00:7E3D  32 63 F6                    ld (VALTYP),a
     176.  00:7E40  C9                          ret
     177.  00:7E41                              
     178.  00:7E41                      putback:
     179.  00:7E41                      ;        DEBUGMESSAGE "putback"
     180.  00:7E41                      ;        push hl
     181.  00:7E41                      ;        pop iy
     182.  00:7E41                      ;        ld (iy+3),c
     183.  00:7E41                      ;        DEBUGASSERT
     184.  00:7E41                      ;        ret
     185.  00:7E41                      
     186.  00:7E41                      lof:
     187.  00:7E41                      fpos:
     188.  00:7E41                              DEBUGMESSAGE "no support!"
     188.  00:7E41                    >         ifdef DEBUG
     188.  00:7E41  52                >         ld d,d
     188.  00:7E42  18 0B             >         jr .skip
     188.  00:7E44                    >         db string
     188.  00:7E44  6E 6F 20 73 75 70 70 6F 72 74 21 
     188.  00:7E4F                    > .skip:
     188.  00:7E4F                    >         endif
     189.  00:7E4F                      
     190.  00:7E4F                      illegalFunctionCall:
     191.  00:7E4F  1E 05                       ld e,5
     192.  00:7E51  C3 BE 7D                    jp basicError
     193.  00:7E54                      
     194.  00:7E54                      ;FCB for DISK BASIC
     195.  00:7E54                      ; +0 FL.MOD     file mode
     196.  00:7E54                      ; +1 FL.FCA     Pointer to FCB for BDOS (low)
     197.  00:7E54                      ; +2 FL.LCA     Pointer to FCB for BDOS (high)
     198.  00:7E54                      ; +3 FL.LSA     Back up character
     199.  00:7E54                      ; +4 FL.DSK     device number
     200.  00:7E54                      ; +5 FL.SLB
     201.  00:7E54                      ; +6 FL.BPS     Position in FL.BUF
     202.  00:7E54                      ; +7 FL.FLG     Holds various information
     203.  00:7E54                      ; +8 FL.OPS     Pseudo head position
     204.  00:7E54                      ; +9 FL.BUF     256-byte file buffer
     205.  00:7E54                      
     206.  00:7E54                      ; device codes
     207.  00:7E54                      ;          SS0           SS1           SS2           SS3
     208.  00:7E54                      ;    ---------------------------------------------------------
     209.  00:7E54                      ;    | 00 04 08 0C | 10 14 18 1C | 20 24 28 2C | 30 34 38 3C | PS0
     210.  00:7E54                      ;    ---------------------------------------------------------
     211.  00:7E54                      ;    | 40 44 48 4C | 50 54 58 5C | 60 64 68 6C | 70 74 78 7C | PS1
     212.  00:7E54                      ;    ---------------------------------------------------------
     213.  00:7E54                      ;    | 80 84 88 8C | 90 94 98 9C | A0 A4 A8 AC | B0 B4 B8 BC | PS2
     214.  00:7E54                      ;    ---------------------------------------------------------
     215.  00:7E54                      ;    | C0 C4 C8 CC | D0 D4 D8 DC | E0 E4 E8 EC | F0 F4 F8 FC | PS3
     216.  00:7E54                      ;    ---------------------------------------------------------
     217.  00:7E54                      
     218.  00:7E54                      ; fileModes
     219.  00:7E54                      ; FOR INPUT (01H)
     220.  00:7E54                      ; FOR OUTPUT (02H)
     221.  00:7E54                      ; FOR APPEND (08H)
     222.  00:7E54                      ; random mode (04H)
     223.  00:7E54                      
     224.  00:7E54                      ; maximum number of files open: MAXFILES=15
     225.  00:7E54                              
     226.  00:7E54                      ; File Control Block
     227.  00:7E54                      ;       0     1     2     3     4     5     6     7     8
     228.  00:7E54                      ;    -------------------------------------------------------
     229.  00:7E54                      ;    | Mod | 00H | 00H | 00H | DEV | 00H | POS | 00H | PPS |
     230.  00:7E54                      ;    -------------------------------------------------------
     231.  00:7E54                      ;                  err? bckup       posHi 
     232.  00:7E54                      ; followed by a 256 byte buffer
      64   00:7E54                      
      65   00:7E54  FF (416)                    ds $8000-$-12, $ff
      66   00:7FF4                      
      67   00:7FF4                      ; bank switching and data transfer
      68   00:7FF4                      copyFromBank:
      69   00:7FF4  32 01 60                    ld (mapper),a                   ; no not remove!
      70   00:7FF7  ED B0                       ldir                            ; no not remove!
      71   00:7FF9                      enableBank0:
      72   00:7FF9  AF                          xor a                           ; no not remove!
      73   00:7FFA  F5                          push af                         ; no not remove!
      74   00:7FFB  32 01 60                    ld (mapper),a                   ; no not remove!
      75   00:7FFE  F1                          pop af                          ; no not remove!
      76   00:7FFF  C9                          ret                             ; no not remove!
      77   00:8000                      
      78   00:8000  (01)                        page 1
      79   01:4000                      
      80   01:4000  (C000)                      incbin "..\roms\MSXDOS22.ROM", $4000, 3 * $4000
      81   01!0000                      
      82   01!0000  (02)                        page 2  
      83   02:4000  (60000)                     incbin "..\roms\romdisk.bin"        
      84   02!4000                              romheader 28
      84   02!4000  (02:4000)         > .addr := $4000
      84   02!4000                    >         repeat r
      84   02!4000                    <         code ! .addr
      84   02!4000                    < 
      84   02!4000                    <         org $4000
      84   02!4000                    <         db "AB"
      84   02!4000                    <         dw .init
      84   02!4000                    <         ds 12,0
      84   02!4000                    < 
      84   02!4000                    <         call .redir
      84   02!4000                    <         call .redir
      84   02!4000                    <         call .redir
      84   02!4000                    <         call .redir
      84   02!4000                    <         call .redir
      84   02!4000                    <         ds 3,0
      84   02!4000                    < 
      84   02!4000                    <         code ! .addr + $3fe7
      84   02!4000                    <         org $7fe7
      84   02!4000                    <         
      84   02!4000                    < .init:  ld hl,romInit
      84   02!4000                    <         push hl
      84   02!4000                    <         jr .enableBank0
      84   02!4000                    < 
      84   02!4000                    < .redir: ex (sp),hl
      84   02!4000                    <         dec hl
      84   02!4000                    <         dec hl
      84   02!4000                    <         dec hl
      84   02!4000                    <         ex (sp),hl
      84   02!4000                    <         jr .enableBank0
      84   02!4000                    < 
      84   02!4000                    <         ld (mapper),a
      84   02!4000                    <         ldir
      84   02!4000                    < .enableBank0:
      84   02!4000                    <         push af
      84   02!4000                    <         xor a
      84   02!4000                    <         ld (mapper),a
      84   02!4000                    <         pop af
      84   02!4000                    <         ret
      84   02!4000                    <         
      84   02!4000                    < .@addr := .addr + $4000
      84   02!4000                    <         endrepeat
      84   02!4000  41 42 E7 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 
      84   02!64010 CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 
      84   02!64020032 01 60 ED B0 F5 AF 32 01 60 F1 C9 41 42 E7 7F 
      84   02!640300CD ED 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 21 
      84   02!640400D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 32 01 60 ED 
      84   02!640500B0 F5 AF 32 01 60 F1 C9 41 42 E7 7F CD ED 7F CD 
      84   02!640600ED 7F CD ED 7F CD ED 7F CD ED 7F 21 D6 47 E5 18 
      84   02!6407000C E3 2B 2B 2B E3 18 05 32 01 60 ED B0 F5 AF 32 
      84   02!64080001 60 F1 C9 41 42 E7 7F CD ED 7F CD ED 7F CD ED 
      84   02!6409007F CD ED 7F CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 
      84   02!640A002B E3 18 05 32 01 60 ED B0 F5 AF 32 01 60 F1 C9 
      84   02!640B0041 42 E7 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 
      84   02!640C00CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 
      84   02!640D0032 01 60 ED B0 F5 AF 32 01 60 F1 C9 41 42 E7 7F 
      84   02!640E00CD ED 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 21 
      84   02!640F00D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 32 01 60 ED 
      84   02!641000B0 F5 AF 32 01 60 F1 C9 41 42 E7 7F CD ED 7F CD 
      84   02!641100ED 7F CD ED 7F CD ED 7F CD ED 7F 21 D6 47 E5 18 
      84   02!6412000C E3 2B 2B 2B E3 18 05 32 01 60 ED B0 F5 AF 32 
      84   02!64130001 60 F1 C9 41 42 E7 7F CD ED 7F CD ED 7F CD ED 
      84   02!6414007F CD ED 7F CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 
      84   02!6415002B E3 18 05 32 01 60 ED B0 F5 AF 32 01 60 F1 C9 
      84   02!64160041 42 E7 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 
      84   02!641700CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 
      84   02!64180032 01 60 ED B0 F5 AF 32 01 60 F1 C9 41 42 E7 7F 
      84   02!641900CD ED 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 21 
      84   02!641A00D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 32 01 60 ED 
      84   02!641B00B0 F5 AF 32 01 60 F1 C9 41 42 E7 7F CD ED 7F CD 
      84   02!641C00ED 7F CD ED 7F CD ED 7F CD ED 7F 21 D6 47 E5 18 
      84   02!641D000C E3 2B 2B 2B E3 18 05 32 01 60 ED B0 F5 AF 32 
      84   02!641E0001 60 F1 C9 41 42 E7 7F CD ED 7F CD ED 7F CD ED 
      84   02!641F007F CD ED 7F CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 
      84   02!6420002B E3 18 05 32 01 60 ED B0 F5 AF 32 01 60 F1 C9 
      84   02!64210041 42 E7 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 
      84   02!642200CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 
      84   02!64230032 01 60 ED B0 F5 AF 32 01 60 F1 C9 41 42 E7 7F 
      84   02!642400CD ED 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 21 
      84   02!642500D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 32 01 60 ED 
      84   02!642600B0 F5 AF 32 01 60 F1 C9 41 42 E7 7F CD ED 7F CD 
      84   02!642700ED 7F CD ED 7F CD ED 7F CD ED 7F 21 D6 47 E5 18 
      84   02!6428000C E3 2B 2B 2B E3 18 05 32 01 60 ED B0 F5 AF 32 
      84   02!64290001 60 F1 C9 41 42 E7 7F CD ED 7F CD ED 7F CD ED 
      84   02!642A007F CD ED 7F CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 
      84   02!642B002B E3 18 05 32 01 60 ED B0 F5 AF 32 01 60 F1 C9 
      84   02!642C0041 42 E7 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 
      84   02!642D00CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 
      84   02!642E0032 01 60 ED B0 F5 AF 32 01 60 F1 C9 41 42 E7 7F 
      84   02!642F00CD ED 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 21 
      84   02!643000D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 32 01 60 ED 
      84   02!643100B0 F5 AF 32 01 60 F1 C9 41 42 E7 7F CD ED 7F CD 
      84   02!643200ED 7F CD ED 7F CD ED 7F CD ED 7F 21 D6 47 E5 18 
      84   02!6433000C E3 2B 2B 2B E3 18 05 32 01 60 ED B0 F5 AF 32 
      84   02!64340001 60 F1 C9 41 42 E7 7F CD ED 7F CD ED 7F CD ED 
      84   02!6435007F CD ED 7F CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 
      84   02!6436002B E3 18 05 32 01 60 ED B0 F5 AF 32 01 60 F1 C9 
      84   02!64370041 42 E7 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 
      84   02!643800CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 
      84   02!64390032 01 60 ED B0 F5 AF 32 01 60 F1 C9 41 42 E7 7F 
      84   02!643A00CD ED 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 21 
      84   02!643B00D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 32 01 60 ED 
      84   02!643C00B0 F5 AF 32 01 60 F1 C9 41 42 E7 7F CD ED 7F CD 
      84   02!643D00ED 7F CD ED 7F CD ED 7F CD ED 7F 21 D6 47 E5 18 
      84   02!643E000C E3 2B 2B 2B E3 18 05 32 01 60 ED B0 F5 AF 32 
      84   02!643F0001 60 F1 C9 41 42 E7 7F CD ED 7F CD ED 7F CD ED 
      84   02!6440007F CD ED 7F CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 
      84   02!6441002B E3 18 05 32 01 60 ED B0 F5 AF 32 01 60 F1 C9 
      84   02!64420041 42 E7 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 
      84   02!644300CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 
      84   02!64440032 01 60 ED B0 F5 AF 32 01 60 F1 C9 41 42 E7 7F 
      84   02!644500CD ED 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 21 
      84   02!644600D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 32 01 60 ED 
      84   02!644700B0 F5 AF 32 01 60 F1 C9 41 42 E7 7F CD ED 7F CD 
      84   02!644800ED 7F CD ED 7F CD ED 7F CD ED 7F 21 D6 47 E5 18 
      84   02!6449000C E3 2B 2B 2B E3 18 05 32 01 60 ED B0 F5 AF 32 
      84   02!644A0001 60 F1 C9 41 42 E7 7F CD ED 7F CD ED 7F CD ED 
      84   02!644B007F CD ED 7F CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 
      84   02!644C002B E3 18 05 32 01 60 ED B0 F5 AF 32 01 60 F1 C9 

    LABELS
---------------------------------------
00:000047D6   romInit
00:0000728E X printText
00:0000000C X RDSLT
00:00000014 X WRSLT
00:0000001C   CALSLT
00:00000024   ENASLT
00:0000005F   CHGMOD
00:00000141   SNSMAT
00:0000015F   EXTROM
00:00000185   SDFSCR
00:0000F33F   LASTDRV
00:0000F342   RAMAD1
00:0000F36E   XFER
00:0000F663   VALTYP
00:0000F7F6   DAC
00:0000F864   PTRFIL
00:0000F866   FILNAM
00:0000FCC1   EXPTBL
00:0000FCC5   SLTTBL
00:0000FCC9 X SLTATR
00:0000FD09   SLTWRK
00:0000FD89   PROCNM
00:0000FD99   DEVICE
00:0000FFCA   EXTBIO
00:0000402D   GETSLT
00:0000FECB X H.RUNC
00:00004000   usbwr
00:00002000   usbrd
00:00008000   usb2
00:00006001   mapper
00:00000080   C_DSKIO
00:00000081   C_DSKCHG
00:00000082   C_GETDPB
00:00000083 X C_CHOICE
00:00000084 X C_DSKFMT
00:00000085   C_DRIVES
00:00000086   C_INIENV
00:00000087 X C_SETDATE
00:00000088   C_DEVICEOPEN
00:00000089   C_DEVICECLOSE
00:0000008A X C_DEVICERNDIO
00:0000008B   C_DEVICEWRITE
00:0000008C   C_DEVICEREAD
00:0000008D X C_DEVICEEOF
00:0000008E   C_AUXIN
00:0000008F   C_AUXOUT
00:00000090   C_MESSAGE
00:000000A0   C_CHANGEIMAGE
00:000000A1   C_BOOTCODE
00:000072F0   nowindInit
00:00007323   initDiskBasic
00:0000733B   findStatementName
00:00007352   findStatementName.loop
00:0000735C   findStatementName.nextStatement
00:00007367   sendRegisters
00:00007379   getHeader
00:0000737B   getHeader.loop
00:0000737C   getHeader.chkaf
00:000073A0   getHeader.chk05
00:000073A7   sendMessage
00:000073B1   sendMessage.loop
00:000073BD   newAUX
00:000073C7   AUXin
00:000073F5   AUXin.exit
00:000073FB   AUXin.getCharacter
00:0000740C   AUXout
00:00007424 X insertBootCode
00:0000744B X sdendFCB
00:0000744F   sdendFCB.loop
00:00007459 X receiveFCB
00:0000745D   receiveFCB.loop
00:0000746A   installExtendedBios
00:0000749F   extendedBios
00:000074A6   extendedBios.exit
00:000074B4   determineFunction
00:000074C0   functionTable
00:000074C6   getNowindSlot
00:000074E2   numberOfDevices
00:000074F9   debugMessage
00:00007515   debugMessage.loop
00:0000751F   enableNowindPage0
00:0000752A   restorePage0
00:00007533   enableSlotPage0
00:00007544   enableSlotPage0.expanded
00:0000756F   getSlotPage0
00:0000757A   getSlotPage1
00:00007585   getSlotPage2
00:00007594   expanded
00:000075A8   notExpanded
00:000075AA   getEntrySLTWRK
00:00000008   MYSIZE
00:00000200   SECLEN
00:000075BF   INIHRD
00:000075CE   INIHRD.loop
00:000075E2   DRIVES
00:00007625   DRIVES.exit
00:0000762E   DRIVES.notconnected
00:0000764B   INIENV
00:0000768F   INIENV.exit
00:00007692   checkWorkArea
00:0000769D   DSKIO
00:000076B4 X dskioRead
00:0000B6D1   dskioRead.page2
00:000076E6   dskioRead.page1
00:000076F6   dskioRead.page2and3
00:0000770C   dskioWrite
00:0000B72C   dskioWrite.page2
00:00007742   dskioWrite.page1
00:00007758   dskioWrite.page2and3
00:0000776D   dskioWrite.writeLoop23
00:0000779D   dskioWrite.error
00:000077A0   DSKCHG
00:000077D7   GETDPB
00:0000780D   GETDPB.hddImage
00:00007840   GETDPB.exit
00:00007843   CHOICE
00:00007847   CHOICE.noFormat
00:00007848   DSKFMT
00:0000B84C   readSectors01
00:0000B86E   readSectors01.slowTransfer
00:0000B87A   writeLoop01
00:0000B89C   writeLoop01.error
00:0000789F   readSectors23
00:000078C3   readSectors23.slowTransfer
00:000078E0   reverseTransfer
00:000078EC   reverseTransfer.loop
00:00007953   OEMSTA
00:00007961   OEMSTA.statement
00:00007974   changeImage
00:00007989   call_exit
00:00007995   call_exit.loop
00:000079A1   videoStream
00:000079A2 X vramDump
00:000079AE   evenFrame
00:000079CB X oddFrame
00:000079EB   tranferframe
00:000079F8   write_more
00:00007B05   changeColors
00:00007B53   setVramAccessPointer
00:00007B61   waitForRetrace
00:00007B67   waitForRetrace.lp2
00:00007B72   printVdpText2
00:00007B73   printVdpText2.loop
00:00007B7C   supportedMedia
00:00007B7C X supportedMedia.f8
00:00007B8E   supportedMedia.def
00:00007B8E   DEFDPB
00:00007C0C   ROMDISK_DSKIO
00:00007C1B   ROMDISK_DSKIO.loop
00:00007C3D   ROMDISK_DSKIO.directCopy
00:00007C43   ROMDISK_DSKIO.nextSector
00:00007C49   ROMDISK_DSKIO.findSector
00:00007C5E   ROMDISK_DSKIO.skip
00:00007C6B   ROMDISK_DSKCHG
00:00007C70 X ROMDISK_GETDPB
00:00007C70 X ROMDISK_DSKFMT
00:00007C70   flashWriter
00:00007CC0   flashWriter.source
00:0000C000   waitForHeader
00:0000C003   waitForHeader.chkbb
00:0000C01A X chipErase
00:0000C028   chipErase.wait
00:0000C032   writeFlash
00:0000C041   writeFlash.loop
00:0000C04B   writeFlash.wait
00:0000C057   verifyFlash
00:0000C062   verifyFlash.loop
00:0000C06B   acknowledge
00:0000C075   updateBar
00:0000C07A   AM29F040Command
00:0000C089   flasherEnd
00:00007D49   device
00:00007D55   device.nocy
00:00007D5B   deviceFunctions
00:00007D71   identifyDevice
00:00007D8A   deviceNameList
00:00007D91   open
00:00007DB8   deviceIoError
00:00007DBA   openError
00:00007DBE   basicError
00:00007DC9   close
00:00007DCF   randomIO
00:00007DD3   write
00:00007DD9   read
00:00007E0D   eof
00:00007E26   eof.skip
00:00007E2F   loc
00:00007E41   putback
00:00007E41   lof
00:00007E41   fpos
00:00007E4F X illegalFunctionCall
00:00007FF4   copyFromBank
00:00007FF9 X enableBank0


Output: nowindDos2.out
--------------------------------------

 Page: 00
  Org: 00004000  Size: *  Used: 00000000

    No output

Output: nowindDos2.rom
--------------------------------------

 Page: 00
  Org: 00004000  Size: 00004000  Used: 00004000

   Address   Length Align  Label
   00004000   13040        
   000072F0    3344     @  nowindInit

  Overlay parts:
   Address   Length Align  Label
   00004006       2     @  
   00004010      18     @  
   000047D7       2     @  
   00004881       1     @  
   00004884       1     @  
   0000488D       2     @  
   0000489F       2     @  
   000048B9       2     @  
   000048EB       2     @  
   000048F7       2     @  
   000049A3      16     @  
   00005797       2     @  

 Page: 01
  Org: 00004000  Size: 0000C000  Used: 0000C000

   Address   Length Align  Label
   00004000   49152        

 Page: 02
  Org: 00004000  Size: 00070000  Used: 00070000

   Address   Length Align  Label
   00004000  393216        
   00064000   65536       <empty>

  Overlay parts:
   Address   Length Align  Label
   00004000      34     @  
   00007FE7      25     @  251.252>init
   00008000      34     @  
   0000BFE7      25     @  251.253>init
   0000C000      34     @  
   0000FFE7      25     @  251.254>init
   00010000      34     @  
   00013FE7      25     @  251.255>init
   00014000      34     @  
   00017FE7      25     @  251.256>init
   00018000      34     @  
   0001BFE7      25     @  251.257>init
   0001C000      34     @  
   0001FFE7      25     @  251.258>init
   00020000      34     @  
   00023FE7      25     @  251.259>init
   00024000      34     @  
   00027FE7      25     @  251.260>init
   00028000      34     @  
   0002BFE7      25     @  251.261>init
   0002C000      34     @  
   0002FFE7      25     @  251.262>init
   00030000      34     @  
   00033FE7      25     @  251.263>init
   00034000      34     @  
   00037FE7      25     @  251.264>init
   00038000      34     @  
   0003BFE7      25     @  251.265>init
   0003C000      34     @  
   0003FFE7      25     @  251.266>init
   00040000      34     @  
   00043FE7      25     @  251.267>init
   00044000      34     @  
   00047FE7      25     @  251.268>init
   00048000      34     @  
   0004BFE7      25     @  251.269>init
   0004C000      34     @  
   0004FFE7      25     @  251.270>init
   00050000      34     @  
   00053FE7      25     @  251.271>init
   00054000      34     @  
   00057FE7      25     @  251.272>init
   00058000      34     @  
   0005BFE7      25     @  251.273>init
   0005C000      34     @  
   0005FFE7      25     @  251.274>init
   00060000      34     @  
   00063FE7      25     @  251.275>init
   00064000      34     @  
   00067FE7      25     @  251.276>init
   00068000      34     @  
   0006BFE7      25     @  251.277>init
   0006C000      34     @  
   0006FFE7      25     @  251.278>init
   00070000      34     @  
   00073FE7      25     @  251.279>init

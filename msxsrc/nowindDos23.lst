Sjasm Z80 Assembler v0.4 BETA 6 - www.xl2s.tk             [2009.05.19 - 22:30:09]

nowindDos23.asm
Errors: 0

       1   00:0000  (00:47D6)           romInit:        equ $47d6
       2   00:0000                      ;printText:      equ $728e
       3   00:0000  (00:746A)           printText:      equ printRoutineVoorDos23
       4   00:0000                      
       5   00:0000                              define  MSXDOS2
       6   00:0000                              define  DEBUG
       7   00:0000                              define  ROMDSKBANK 4            ; first bank of ROMdisk image
       8   00:0000                              define  ROMDSKLAST 4+24-1
       9   00:0000                              
      10   00:0000                              output  "nowindDos2.rom"
      11   00:0000                              include "labels.asm"
       1.  00:0000                      ; BIOS routines
       2.  00:0000  (00:000C)           RDSLT           equ $000c
       3.  00:0000  (00:0014)           WRSLT           equ $0014
       4.  00:0000  (00:001C)           CALSLT          equ $001c
       5.  00:0000  (00:0024)           ENASLT          equ $0024
       6.  00:0000  (00:005F)           CHGMOD          equ $005f
       7.  00:0000  (00:0141)           SNSMAT          equ $0141
       8.  00:0000  (00:015F)           EXTROM          equ $015f
       9.  00:0000  (00:0185)           SDFSCR          equ $0185               ; restore screen parameters from clockchip (in SUBROM)
      10.  00:0000                      
      11.  00:0000                      ; BIOS variables (really?)
      12.  00:0000  (00:F33F)           LASTDRV         equ $f33f               ; stores CTRL-key status during boot
      13.  00:0000  (00:F342)           RAMAD1          equ $f342
      14.  00:0000  (00:F36E)           XFER            equ $f36e
      15.  00:0000                      
      16.  00:0000  (00:F663)           VALTYP          equ $f663
      17.  00:0000  (00:F7F6)           DAC             equ $f7f6
      18.  00:0000  (00:F864)           PTRFIL          equ $f864
      19.  00:0000  (00:F866)           FILNAM          equ $f866
      20.  00:0000                      
      21.  00:0000  (00:FCC1)           EXPTBL          equ $fcc1
      22.  00:0000  (00:FCC5)           SLTTBL          equ $fcc5
      23.  00:0000  (00:FCC9)           SLTATR          equ $fcc9
      24.  00:0000  (00:FD09)           SLTWRK          equ $fd09
      25.  00:0000  (00:FD89)           PROCNM          equ $fd89
      26.  00:0000  (00:FD99)           DEVICE          equ $fd99
      27.  00:0000  (00:FFCA)           EXTBIO          equ $ffca
      28.  00:0000                      
      29.  00:0000                      ; Diskrom routines
      30.  00:0000  (00:402D)           GETSLT          equ $402d
      31.  00:0000                               
      32.  00:0000                      ; Hooks
      33.  00:0000  (00:FECB)           H.RUNC          equ $fecb               ; Intercepted by diskrom
      34.  00:0000                      
      35.  00:0000                      ; Nowind hardware addresses
      36.  00:0000  (00:4000)           usbwr           equ $4000               ; 0x4000..0x5fff
      37.  00:0000  (00:2000)           usbrd           equ $2000               ; 0x2000..0x3fff
      38.  00:0000  (00:8000)           usb2            equ $8000               ; 0x8000..0x9fff (read and write)
      39.  00:0000  (00:6000)           mapper          equ $6000               ; 0x6000..0x7fff
      40.  00:0000                      
      41.  00:0000                      ; Host commands
      42.  00:0000  (00:0080)           C_DSKIO         equ $80
      43.  00:0000  (00:0081)           C_DSKCHG        equ $81
      44.  00:0000  (00:0082)           C_GETDPB        equ $82
      45.  00:0000  (00:0083)           C_CHOICE        equ $83
      46.  00:0000  (00:0084)           C_DSKFMT        equ $84
      47.  00:0000  (00:0085)           C_DRIVES        equ $85
      48.  00:0000  (00:0086)           C_INIENV        equ $86
      49.  00:0000  (00:0087)           C_SETDATE       equ $87
      50.  00:0000  (00:0088)           C_DEVICEOPEN    equ $88
      51.  00:0000  (00:0089)           C_DEVICECLOSE   equ $89
      52.  00:0000  (00:008A)           C_DEVICERNDIO   equ $8a
      53.  00:0000  (00:008B)           C_DEVICEWRITE   equ $8b
      54.  00:0000  (00:008C)           C_DEVICEREAD    equ $8c
      55.  00:0000  (00:008D)           C_DEVICEEOF     equ $8d
      56.  00:0000  (00:008E)           C_AUXIN         equ $8e
      57.  00:0000  (00:008F)           C_AUXOUT        equ $8f
      58.  00:0000  (00:0090)           C_MESSAGE       equ $90
      59.  00:0000  (00:00A0)           C_CHANGEIMAGE   equ $a0
      60.  00:0000  (00:00A1)           C_BOOTCODE      equ $a1
      61.  00:0000                      
      62.  00:0000                      ; BDOS commands 0x0F- 0x37 can just use their original command code in register C
      63.  00:0000                      
      64.  00:0000                      ; PATCH       
      65.  00:0000                              macro PATCH address, word
      66.  00:0000                    <         code ! address
      67.  00:0000                    <         dw word
      68.  00:0000                    <         endmacro
      69.  00:0000                      
      70.  00:0000                      ; DEBUGMESSAGE
      71.  00:0000                              macro DEBUGMESSAGE string
      72.  00:0000                    <         ifdef DEBUG
      73.  00:0000                    <         ld d,d
      74.  00:0000                    <         jr .skip
      75.  00:0000                    <         db string
      76.  00:0000                    < .skip:  
      77.  00:0000                    <         endif
      78.  00:0000                    <         endmacro
      79.  00:0000                      
      80.  00:0000                      ; MESSAGE
      81.  00:0000                              macro MESSAGE string
      82.  00:0000                    <         call sendMessage
      83.  00:0000                    <         db string
      84.  00:0000                    < .skip2: nop
      85.  00:0000                    <         endmacro
      86.  00:0000                      
      87.  00:0000                      ; DEBUGDUMPREGISTERS
      88.  00:0000                              macro DEBUGDUMPREGISTERS
      89.  00:0000                    <         ifdef DEBUG
      90.  00:0000                    <         db $ed,7
      91.  00:0000                    <         endif
      92.  00:0000                    <         
      93.  00:0000                    <         ifdef USBDEBUG
      94.  00:0000                    <         assert ($ < $8000)
      95.  00:0000                    <         call sendCpuInfo
      96.  00:0000                    <         endif
      97.  00:0000                    <         endmacro
      98.  00:0000                      
      99.  00:0000                      ; MAKEDPB macro
     100.  00:0000                              macro MAKEDPB media, sectorSize, sectorsPerCluster, maxEnt, maxSector, fatSiz, fatCount
     101.  00:0000                    < .firfat equ 1
     102.  00:0000                    < .firdir equ .firfat+(fatCount*fatSiz)
     103.  00:0000                    < .firrec equ .firdir+(maxEnt/(sectorSize/32))
     104.  00:0000                    <         if sectorSize = 512
     105.  00:0000                    < .shft   equ 4
     106.  00:0000                    <         elseif sectorSize = 256
     107.  00:0000                    < .shft   equ 3
     108.  00:0000                    <         endif
     109.  00:0000                    <         
     110.  00:0000                    <         db media                                        ; media descriptor
     111.  00:0000                    <         dw sectorSize                                   ; sector size
     112.  00:0000                    <         db (sectorSize/32)-1, .shft                     ; dirmsk
     113.  00:0000                    <         db sectorsPerCluster-1                          ; clusmsk 
     114.  00:0000                    <         db sectorsPerCluster                            ; clusshft (TODO: only correct for 1 and 2 sec/clus)         
     115.  00:0000                    <         dw .firfat
     116.  00:0000                    <         db fatCount, maxEnt
     117.  00:0000                    <         dw .firrec
     118.  00:0000                    <         dw (maxSector-.firrec)/sectorsPerCluster+1      ; maxclus
     119.  00:0000                    <         db fatSiz
     120.  00:0000                    <         dw .firdir
     121.  00:0000                    <         endmacro
     122.  00:0000                      
     123.  00:0000                      
     124.  00:0000                      ; ROMHEADER macro
     125.  00:0000                              macro romheader r   
     126.  00:0000                    < .addr := $4000        
     127.  00:0000                    <         repeat r
     128.  00:0000                    <         code ! .addr
     129.  00:0000                    < 
     130.  00:0000                    <         org $4000
     131.  00:0000                    <         db "AB"
     132.  00:0000                    <         dw .init
     133.  00:0000                    <         ds 12,0
     134.  00:0000                    < 
     135.  00:0000                    <         call .redir                     ; DSKIO
     136.  00:0000                    <         call .redir                     ; DSKCHG
     137.  00:0000                    <         call .redir                     ; GETDPB
     138.  00:0000                    <         call .redir                     ; CHOICE
     139.  00:0000                    <         call .redir                     ; DSKFMT
     140.  00:0000                    <         ds 3,0                          ; DRVOFF
     141.  00:0000                    < 
     142.  00:0000                    <         code ! .addr + $3fe7
     143.  00:0000                    <         org $7fe7
     144.  00:0000                    <         
     145.  00:0000                    < .init:  ld hl,romInit
     146.  00:0000                    <         push hl
     147.  00:0000                    <         jr .enableBank0        
     148.  00:0000                    < 
     149.  00:0000                    < .redir: ex (sp),hl
     150.  00:0000                    <         dec hl
     151.  00:0000                    <         dec hl
     152.  00:0000                    <         dec hl
     153.  00:0000                    <         ex (sp),hl
     154.  00:0000                    <         jr .enableBank0
     155.  00:0000                    < 
     156.  00:0000                    <         ld (mapper),a                   ; copyFromBank
     157.  00:0000                    <         ldir
     158.  00:0000                    < .enableBank0:
     159.  00:0000                    <         push af                         ; enable bank 0 (no registers changed)
     160.  00:0000                    <         xor a
     161.  00:0000                    <         ld (mapper),a
     162.  00:0000                    <         pop af
     163.  00:0000                    <         ret
     164.  00:0000                    <         
     165.  00:0000                    < .@addr := .addr + $4000
     166.  00:0000                    <         endrepeat
     167.  00:0000                    <         endmacro
     168.  00:0000                      
     169.  00:0000                      ; MACRO debugdisasm
     170.  00:0000                              macro DEBUGDISASM
     171.  00:0000                    <         db $ed, $0b
     172.  00:0000                    <         endmacro
     173.  00:0000                              
     174.  00:0000                      ; MACRO debugdisasmoff
     175.  00:0000                              macro DEBUGDISASMOFF
     176.  00:0000                    <         db $ed, $0c
     177.  00:0000                    <         endmacro        
     178.  00:0000                      
     179.  00:0000                      ; MACRO breakpoint
     180.  00:0000                              macro BREAKPOINT
     181.  00:0000                    <         ld b,b
     182.  00:0000                    <         jr $+2
     183.  00:0000                    <         endmacro
      12   00:0000                              
      13   00:0000                              defpage 0, $4000, $4000
      14   00:0000                              defpage 1, $4000, 3 * $4000
      15   00:0000                              defpage 2, $4000, 28 * $4000
      16   00:0000                              
      17   00:0000  (00)                        page 0
      18   00:4000                      
      19   00:4000                      ;        incbin "..\roms\MSXDOS22.ROM", 0, $72f0-$4000
      20   00:4000  (32F0)                      incbin "..\roms\MSXDOS23.ROM", 0, $72f0-$4000                
      21   00:72F0                              
      22   00:72F0                              PATCH $4006, device
      22   00:72F0                    >         code ! address
      22   00:4006  57 7D             >         dw word
      23   00:4008                      
      24   00:4008                              code ! $4010
      25   00:4010  C3 AC 76                    jp DSKIO
      26   00:4013  C3 AF 77                    jp DSKCHG
      27   00:4016  C3 E6 77                    jp GETDPB
      28   00:4019  C3 52 78                    jp CHOICE
      29   00:401C  C3 57 78                    jp DSKFMT
      30   00:401F  00 00 00                    db 0,0,0                        ; no DRVOFF
      31   00:4022                              
      32   00:4022                              PATCH $47d7, INIHRD
      32   00:4022                    >         code ! address
      32   00:47D7  CE 75             >         dw word
      33   00:47D9                      ;        PATCH $47dd, 0                  ; do not check for MSX1
      34   00:47D9                              PATCH $488d, MYSIZE
      34   00:47D9                    >         code ! address
      34   00:488D  08 00             >         dw word
      35   00:488F                              PATCH $489f, SECLEN
      35   00:488F                    >         code ! address
      35   00:489F  00 02             >         dw word
      36   00:48A1                              PATCH $48b9, DRIVES
      36   00:48A1                    >         code ! address
      36   00:48B9  F1 75             >         dw word
      37   00:48BB                              PATCH $48eb, DEFDPB - 1
      37   00:48BB                    >         code ! address
      37   00:48EB  9C 7B             >         dw word
      38   00:48ED                              PATCH $48f7, INIENV
      38   00:48ED                    >         code ! address
      38   00:48F7  5A 76             >         dw word
      39   00:48F9                              PATCH $5797, OEMSTA
      39   00:48F9                    >         code ! address
      39   00:5797  62 79             >         dw word
      40   00:5799                      
      41   00:5799                              code ! $4881
      42   00:4881  23                          db LOW initDiskBasic
      43   00:4882                              code ! $4884
      44   00:4884  73                          db HIGH initDiskBasic
      45   00:4885                       
      46   00:4885                              code ! $49a3
      47   00:49A3  21 BD 73                    ld hl,newAUX                    ; redirect AUX to host  
      48   00:49A6  11 27 F3                    ld de,$f327
      49   00:49A9  01 0A 00                    ld bc,10
      50   00:49AC  ED B0                       ldir
      51   00:49AE  00                          nop
      52   00:49AF  00                          nop
      53   00:49B0  00                          nop
      54   00:49B1  00                          nop
      55   00:49B2  00                          nop                             ; do not remove!
      56   00:49B3                              
      57   00:49B3                              code @ $72f0
      58   00:72F0                              
      59   00:72F0                              include "common.asm"
       1.  00:72F0                      ; Nowind specific
       2.  00:72F0                      
       3.  00:72F0                      nowindInit:
       4.  00:72F0  3A F8 FA                    ld a,($faf8)										; moet volgens bifi ld a,($2d) zijn, $faf8 is op msx1 deel van de rs232 area?
       5.  00:72F3  B7                          or a 
       6.  00:72F4  F5                          push af
       7.  00:72F5  CC 5F 00                    call z,CHGMOD                   ; SCREEN 0 for MSX1
       8.  00:72F8  F1                          pop af
       9.  00:72F9  DD 21 85 01                 ld ix,SDFSCR                    ; restore screen mode from clockchip
      10.  00:72FD  C4 5F 01                    call nz,EXTROM
      11.  00:7300                                      
      12.  00:7300  CD 6A 74                    call printText
      13.  00:7303                              ifndef DEBUG
      14.  00:7303                    ~         db "Nowind USB Diskrom!",0
      15.  00:7303                    ~         else
      16.  00:7303                              db "Nowind USB Diskrom! [debug]",0
      16.  00:7303  4E 6F 77 69 6E 64 20 55 53 42 20 44 69 73 6B 72 
      16.  00:7313  6F 6D 21 20 5B 64 65 62 75 67 5D 00 
      17.  00:731F                              endif
      18.  00:731F                      
      19.  00:731F                              ; call insertBootCode
      20.  00:731F  CD 7F 7C                    call flashWriter
      21.  00:7322  C9                          ret
      22.  00:7323                      
      23.  00:7323                      initDiskBasic:
      24.  00:7323                              DEBUGMESSAGE "initDiskBasic"
      24.  00:7323                    >         ifdef DEBUG
      24.  00:7323  52                >         ld d,d
      24.  00:7324  18 0D             >         jr .skip
      24.  00:7326                    >         db string
      24.  00:7326  69 6E 69 74 44 69 73 6B 42 61 73 69 63 
      24.  00:7333                    > .skip:
      24.  00:7333                    >         endif
      25.  00:7333  21 99 FD                    ld hl,DEVICE
      26.  00:7336  CB BE                       res 7,(hl)
      27.  00:7338                              
      28.  00:7338                              ifdef MSXDOS1
      29.  00:7338                    ~         jp $5897
      30.  00:7338                    ~         else
      31.  00:7338  C3 5B 49                    jp $495b
      32.  00:733B                              endif
      33.  00:733B                      
      34.  00:733B                      ; search call statement or device name
      35.  00:733B                      findStatementName:
      36.  00:733B                              DEBUGMESSAGE "findStatementName"
      36.  00:733B                    >         ifdef DEBUG
      36.  00:733B  52                >         ld d,d
      36.  00:733C  18 11             >         jr .skip
      36.  00:733E                    >         db string
      36.  00:733E  66 69 6E 64 53 74 61 74 65 6D 65 6E 74 4E 61 6D 
      36.  00:734E  65 
      36.  00:734F                    > .skip:
      36.  00:734F                    >         endif
      37.  00:734F  11 89 FD                    ld de,PROCNM
      38.  00:7352  1A                  .loop:  ld a,(de)
      39.  00:7353  BE                          cp (hl)
      40.  00:7354  20 06                       jr nz,.nextStatement
      41.  00:7356  23                          inc hl
      42.  00:7357  B7                          or a
      43.  00:7358  C8                          ret z                           ; name found
      44.  00:7359  13                          inc de
      45.  00:735A  18 F6                       jr .loop        
      46.  00:735C                      .nextStatement:
      47.  00:735C  AF                          xor a
      48.  00:735D  4F                          ld c,a
      49.  00:735E  ED B1                       cpir
      50.  00:7360  23                          inc hl
      51.  00:7361  23                          inc hl
      52.  00:7362  B6                          or (hl)
      53.  00:7363  20 D6                       jr nz,findStatementName        
      54.  00:7365  37                          scf                             ; not found
      55.  00:7366  C9                          ret
      56.  00:7367                      
      57.  00:7367                      sendRegisters:
      58.  00:7367  F5                          push af
      59.  00:7368  7C                          ld a,h
      60.  00:7369  26 40                       ld h,HIGH usbwr
      61.  00:736B  36 AF                       ld (hl),$af                     ; header
      62.  00:736D  36 05                       ld (hl),$05
      63.  00:736F  71                          ld (hl),c
      64.  00:7370  70                          ld (hl),b
      65.  00:7371  73                          ld (hl),e
      66.  00:7372  72                          ld (hl),d
      67.  00:7373  75                          ld (hl),l
      68.  00:7374  77                          ld (hl),a                       ; register h
      69.  00:7375  D1                          pop de
      70.  00:7376  73                          ld (hl),e                       ; register f
      71.  00:7377  72                          ld (hl),d                       ; register a
      72.  00:7378  C9                          ret
      73.  00:7379                              
      74.  00:7379                      getHeader:
      75.  00:7379  06 FF                       ld b,HIGH 65535                 ; 42000 * 60 states ~ 0,7 sec (time out)
      76.  00:737B  7E                  .loop:  ld a,(hl)
      77.  00:737C  FE AF               .chkaf: cp $af
      78.  00:737E  28 20                       jr z,.chk05
      79.  00:7380  0B                          dec bc
      80.  00:7381  78                          ld a,b
      81.  00:7382  B1                          or c
      82.  00:7383  20 F6                       jr nz,.loop
      83.  00:7385                              DEBUGMESSAGE "getHeader Timed out!"
      83.  00:7385                    >         ifdef DEBUG
      83.  00:7385  52                >         ld d,d
      83.  00:7386  18 14             >         jr .skip
      83.  00:7388                    >         db string
      83.  00:7388  67 65 74 48 65 61 64 65 72 20 54 69 6D 65 64 20 
      83.  00:7398  6F 75 74 21 
      83.  00:739C                    > .skip:
      83.  00:739C                    >         endif
      84.  00:739C  3E 02                       ld a,2                          ; not ready
      85.  00:739E  37                          scf
      86.  00:739F  C9                          ret
      87.  00:73A0                      
      88.  00:73A0  7E                  .chk05: ld a,(hl)
      89.  00:73A1  FE 05                       cp $05
      90.  00:73A3  20 D7                       jr nz,.chkaf
      91.  00:73A5  7E                          ld a,(hl)
      92.  00:73A6  C9                          ret
      93.  00:73A7                      
      94.  00:73A7                      sendMessage:
      95.  00:73A7                              ;DEBUGMESSAGE "sendMsg"
      96.  00:73A7  E3                          ex (sp),hl
      97.  00:73A8  F5                          push af
      98.  00:73A9  D5                          push de
      99.  00:73AA  E5                          push hl        
     100.  00:73AB  CD 67 73                    call sendRegisters
     101.  00:73AE  36 90                       ld (hl),C_MESSAGE
     102.  00:73B0  E1                          pop hl
     103.  00:73B1  7E                  .loop:  ld a,(hl)
     104.  00:73B2  23                          inc hl
     105.  00:73B3  32 00 40                    ld (usbwr),a
     106.  00:73B6  B7                          or a
     107.  00:73B7  20 F8                       jr nz,.loop
     108.  00:73B9  D1                          pop de
     109.  00:73BA  F1                          pop af
     110.  00:73BB  E3                          ex (sp),hl
     111.  00:73BC  C9                          ret
     112.  00:73BD                              
     113.  00:73BD                      ; AUX device
     114.  00:73BD                              
     115.  00:73BD  C3 C7 73            newAUX: jp AUXin
     116.  00:73C0  00                          nop
     117.  00:73C1  00                          nop
     118.  00:73C2  C3 0C 74                    jp AUXout
     119.  00:73C5  00                          nop
     120.  00:73C6  00                          nop
     121.  00:73C7                      
     122.  00:73C7                      AUXin:  DEBUGMESSAGE "AUX in"
     122.  00:73C7                    >         ifdef DEBUG
     122.  00:73C7  52                >         ld d,d
     122.  00:73C8  18 06             >         jr .skip
     122.  00:73CA  41 55 58 20 69 6E >         db string
     122.  00:73D0                    > .skip:
     122.  00:73D0                    >         endif
     123.  00:73D0  E5                          push hl
     124.  00:73D1  D5                          push de
     125.  00:73D2  C5                          push bc
     126.  00:73D3  CD 67 73                    call sendRegisters
     127.  00:73D6  36 8E                       ld (hl),C_AUXIN
     128.  00:73D8  CD 2E 75                    call enableNowindPage0
     129.  00:73DB  26 20                       ld h,HIGH usbrd
     130.  00:73DD  CD 79 73                    call getHeader
     131.  00:73E0  D2 FB 73                    jp nc,.getCharacter
     132.  00:73E3                              
     133.  00:73E3                              DEBUGMESSAGE "not connected"
     133.  00:73E3                    >         ifdef DEBUG
     133.  00:73E3  52                >         ld d,d
     133.  00:73E4  18 0D             >         jr .skip
     133.  00:73E6                    >         db string
     133.  00:73E6  6E 6F 74 20 63 6F 6E 6E 65 63 74 65 64 
     133.  00:73F3                    > .skip:
     133.  00:73F3                    >         endif
     134.  00:73F3  3E 1A                       ld a,$1a                        ; eof
     135.  00:73F5  C1                  .exit:  pop bc
     136.  00:73F6  D1                          pop de
     137.  00:73F7  E1                          pop hl
     138.  00:73F8  C3 39 75                    jp restorePage0        
     139.  00:73FB                                    
     140.  00:73FB                      .getCharacter:
     141.  00:73FB                              DEBUGMESSAGE "getChar"
     141.  00:73FB                    >         ifdef DEBUG
     141.  00:73FB  52                >         ld d,d
     141.  00:73FC  18 07             >         jr .skip
     141.  00:73FE                    >         db string
     141.  00:73FE  67 65 74 43 68 61 72 
     141.  00:7405                    > .skip:
     141.  00:7405                    >         endif
     142.  00:7405  CD 79 73                    call getHeader
     143.  00:7408  38 F1                       jr c,.getCharacter
     144.  00:740A  18 E9                       jr .exit
     145.  00:740C                      
     146.  00:740C                      
     147.  00:740C                      AUXout: DEBUGMESSAGE "AUX out"
     147.  00:740C                    >         ifdef DEBUG
     147.  00:740C  52                >         ld d,d
     147.  00:740D  18 07             >         jr .skip
     147.  00:740F                    >         db string
     147.  00:740F  41 55 58 20 6F 75 74 
     147.  00:7416                    > .skip:
     147.  00:7416                    >         endif
     148.  00:7416                              DEBUGDUMPREGISTERS
     148.  00:7416                    >         ifdef DEBUG
     148.  00:7416  ED 07             >         db $ed,7
     148.  00:7418                    >         endif
     148.  00:7418                    >         
     148.  00:7418                    >         ifdef USBDEBUG
     148.  00:7418                    ~         assert ($ < $8000)
     148.  00:7418                    ~         call sendCpuInfo
     148.  00:7418                    ~         endif
     149.  00:7418  E5                          push hl
     150.  00:7419  D5                          push de
     151.  00:741A                      ;        push bc
     152.  00:741A                      ;        ld a,(RAMAD1) ; TODO: WTF???
     153.  00:741A                      ;        call RDSLT
     154.  00:741A  F5                          push af        
     155.  00:741B  CD 67 73                    call sendRegisters
     156.  00:741E  36 8F                       ld (hl),C_AUXOUT
     157.  00:7420  F1                          pop af
     158.  00:7421                      ;        pop bc
     159.  00:7421  D1                          pop de
     160.  00:7422  E1                          pop hl
     161.  00:7423  C9                          ret
     162.  00:7424                      
     163.  00:7424                      insertBootCode:
     164.  00:7424                              DEBUGMESSAGE "BOOTCODE"
     164.  00:7424                    >         ifdef DEBUG
     164.  00:7424  52                >         ld d,d
     164.  00:7425  18 08             >         jr .skip
     164.  00:7427                    >         db string
     164.  00:7427  42 4F 4F 54 43 4F 44 45 
     164.  00:742F                    > .skip:
     164.  00:742F                    >         endif
     165.  00:742F  CD 67 73                    call sendRegisters
     166.  00:7432  36 A1                       ld (hl),C_BOOTCODE
     167.  00:7434  CD 2E 75                    call enableNowindPage0
     168.  00:7437  CD 79 73                    call getHeader
     169.  00:743A  DA 39 75                    jp c,restorePage0
     170.  00:743D                              
     171.  00:743D                              DEBUGMESSAGE "BOOTCODE"
     171.  00:743D                    >         ifdef DEBUG
     171.  00:743D  52                >         ld d,d
     171.  00:743E  18 08             >         jr .skip
     171.  00:7440                    >         db string
     171.  00:7440  42 4F 4F 54 43 4F 44 45 
     171.  00:7448                    > .skip:
     171.  00:7448                    >         endif
     172.  00:7448  C3 39 75                    jp restorePage0
     173.  00:744B                      
     174.  00:744B                      ; send 32 bytes starting from address specified by DE to the usb
     175.  00:744B                      sdendFCB:
     176.  00:744B  D5                          push de
     177.  00:744C  C5                          push bc
     178.  00:744D                              
     179.  00:744D  06 20                       ld b,32
     180.  00:744F  1A                  .loop:  ld a,(de)
     181.  00:7450  32 00 40                    ld (usbwr),a
     182.  00:7453  13                          inc de
     183.  00:7454  10 F9                       djnz .loop
     184.  00:7456  C1                          pop bc
     185.  00:7457  D1                          pop de
     186.  00:7458  C9                          ret
     187.  00:7459                      
     188.  00:7459                      ; receive 32 bytes and write to the address specified by DE 
     189.  00:7459                      receiveFCB:
     190.  00:7459  D5                          push de
     191.  00:745A  C5                          push bc
     192.  00:745B                              
     193.  00:745B  06 20                       ld b,32
     194.  00:745D  3A 00 20            .loop:  ld a,(usbrd)
     195.  00:7460  32 00 40            	ld (usbwr),a			; loop back
     196.  00:7463  12                          ld (de),a
     197.  00:7464  13                          inc de
     198.  00:7465  10 F6                       djnz .loop
     199.  00:7467  C1                          pop bc
     200.  00:7468  D1                          pop de
     201.  00:7469  C9                          ret
     202.  00:746A                      
     203.  00:746A                      printRoutineVoorDos23:        
     204.  00:746A  E3                          EX (SP),HL  ; haal beginadres string van de stack
     205.  00:746B  CD 70 74                    CALL L5F8C  ; afdrukken string (afgesloten door 0-byte)
     206.  00:746E  E3                          EX (SP),HL  ; adres na string = terugkeeradres
     207.  00:746F  C9                          RET
     208.  00:7470                      
     209.  00:7470                      ; Deze routine zorgt voor het afdrukken van een string
     210.  00:7470                      ; Invoer: HL=beginadres string (string afgsloten door 0-byte)
     211.  00:7470                      
     212.  00:7470  7E                  L5F8C:  LD A,(HL)   ; karaktercode
     213.  00:7471  23                          INC HL      ; pointer ophogen
     214.  00:7472  A7                          AND A       ; code=0 ?
     215.  00:7473  C8                          RET Z       ; zo ja, klaar met afdrukken
     216.  00:7474  CD A2 00                    CALL $a2    ; equivalent van CHPUT
     217.  00:7477  18 F7                       JR L5F8C        
      60   00:7479                              include "extendedBios.asm"
       1.  00:7479                      
       2.  00:7479                      installExtendedBios:
       3.  00:7479                      
       4.  00:7479                              ; Called from INIENV, so EXTBIO hook is already initialized
       5.  00:7479                      
       6.  00:7479                              DEBUGMESSAGE "extbio"
       6.  00:7479                    >         ifdef DEBUG
       6.  00:7479  52                >         ld d,d
       6.  00:747A  18 06             >         jr .skip
       6.  00:747C  65 78 74 62 69 6F >         db string
       6.  00:7482                    > .skip:
       6.  00:7482                    >         endif
       7.  00:7482  CD B9 75                    call getEntrySLTWRK             ; save previous EXTBIO hook
       8.  00:7485  23                          inc hl
       9.  00:7486  EB                          ex de,hl        
      10.  00:7487  21 CA FF                    ld hl,EXTBIO
      11.  00:748A  01 05 00                    ld bc,5
      12.  00:748D  ED B0                       ldir
      13.  00:748F                              
      14.  00:748F  E5                          push hl                         ; determine device number
      15.  00:7490  AF                          xor a
      16.  00:7491  11 01 4E                    ld de,$4e01
      17.  00:7494  CD CA FF                    call EXTBIO
      18.  00:7497  E1                          pop hl
      19.  00:7498  77                          ld (hl),a
      20.  00:7499                                      
      21.  00:7499  CD 2D 40                    call GETSLT                     ; install new EXTBIO hook
      22.  00:749C  2E F7                       ld l,$f7
      23.  00:749E  67                          ld h,a
      24.  00:749F  22 CA FF                    ld (EXTBIO),hl
      25.  00:74A2  21 AE 74                    ld hl,extendedBios
      26.  00:74A5  22 CC FF                    ld (EXTBIO+2),hl
      27.  00:74A8  3E C9                       ld a,$c9
      28.  00:74AA  32 CE FF                    ld (EXTBIO+4),a    
      29.  00:74AD  C9                          ret
      30.  00:74AE                      
      31.  00:74AE                      extendedBios:
      32.  00:74AE                              ; broadcast (0x00) not implemented
      33.  00:74AE                              ; system exclusive (0xff) not implemented
      34.  00:74AE                      
      35.  00:74AE  FB                          ei
      36.  00:74AF  F5                          push af
      37.  00:74B0  7A                          ld a,d
      38.  00:74B1  FE 4E                       cp $4e
      39.  00:74B3  28 0E                       jr z,determineFunction
      40.  00:74B5                      .exit:
      41.  00:74B5  E5                          push hl
      42.  00:74B6  C5                          push bc
      43.  00:74B7  CD B9 75                    call getEntrySLTWRK
      44.  00:74BA  2C                          inc l                           ; previous EXTBIO hook 
      45.  00:74BB  E5                          push hl
      46.  00:74BC  DD E1                       pop ix
      47.  00:74BE  C1                          pop bc        
      48.  00:74BF  E1                          pop hl
      49.  00:74C0  F1                          pop af
      50.  00:74C1  DD E9                       jp (ix)                         ; process other EXTBIO handles
      51.  00:74C3                      
      52.  00:74C3                      determineFunction:
      53.  00:74C3  E5                          push hl
      54.  00:74C4  21 CF D8                    ld hl,functionTable - 2 * $4e00
      55.  00:74C7  19                          add hl,de
      56.  00:74C8  19                          add hl,de
      57.  00:74C9  7E                          ld a,(hl)
      58.  00:74CA  23                          inc hl
      59.  00:74CB  66                          ld h,(hl)
      60.  00:74CC  6F                          ld l,a
      61.  00:74CD  E3                          ex (sp),hl
      62.  00:74CE  C9                          ret
      63.  00:74CF                      
      64.  00:74CF                      functionTable:
      65.  00:74CF  D5 74                       dw getNowindSlot
      66.  00:74D1  F1 74                       dw numberOfDevices
      67.  00:74D3  08 75                       dw debugMessage
      68.  00:74D5                      
      69.  00:74D5                      getNowindSlot:               
      70.  00:74D5                              DEBUGMESSAGE "getNowindSlot"
      70.  00:74D5                    >         ifdef DEBUG
      70.  00:74D5  52                >         ld d,d
      70.  00:74D6  18 0D             >         jr .skip
      70.  00:74D8                    >         db string
      70.  00:74D8  67 65 74 4E 6F 77 69 6E 64 53 6C 6F 74 
      70.  00:74E5                    > .skip:
      70.  00:74E5                    >         endif
      71.  00:74E5  F1                          pop af
      72.  00:74E6  3D                          dec a
      73.  00:74E7  F5                          push af
      74.  00:74E8  F2 B5 74                    jp p,extendedBios.exit         ; not this device
      75.  00:74EB                              
      76.  00:74EB  F1                          pop af
      77.  00:74EC  CD 89 75                    call getSlotPage1
      78.  00:74EF  37                          scf
      79.  00:74F0  C9                          ret
      80.  00:74F1                              
      81.  00:74F1                      numberOfDevices:
      82.  00:74F1                              DEBUGMESSAGE "numberOfDevices"
      82.  00:74F1                    >         ifdef DEBUG
      82.  00:74F1  52                >         ld d,d
      82.  00:74F2  18 0F             >         jr .skip
      82.  00:74F4                    >         db string
      82.  00:74F4  6E 75 6D 62 65 72 4F 66 44 65 76 69 63 65 73 
      82.  00:7503                    > .skip:
      82.  00:7503                    >         endif
      83.  00:7503  F1                          pop af
      84.  00:7504  3C                          inc a
      85.  00:7505  F5                          push af
      86.  00:7506  18 AD                       jr extendedBios.exit
      87.  00:7508                              
      88.  00:7508                      debugMessage:
      89.  00:7508                              DEBUGMESSAGE "debugMessage"
      89.  00:7508                    >         ifdef DEBUG
      89.  00:7508  52                >         ld d,d
      89.  00:7509  18 0C             >         jr .skip
      89.  00:750B                    >         db string
      89.  00:750B  64 65 62 75 67 4D 65 73 73 61 67 65 
      89.  00:7517                    > .skip:
      89.  00:7517                    >         endif
      90.  00:7517  F1                          pop af
      91.  00:7518  3D                          dec a
      92.  00:7519  F5                          push af
      93.  00:751A  F2 B5 74                    jp p,extendedBios.exit
      94.  00:751D                      
      95.  00:751D  E5                          push hl
      96.  00:751E  CD 67 73                    call sendRegisters
      97.  00:7521  36 90                       ld (hl),C_MESSAGE
      98.  00:7523  E1                          pop hl
      99.  00:7524  7E                  .loop:  ld a,(hl)
     100.  00:7525  23                          inc hl
     101.  00:7526  32 00 40                    ld (usbwr),a
     102.  00:7529  B7                          or a
     103.  00:752A  20 F8                       jr nz,.loop
     104.  00:752C                              
     105.  00:752C  F1                          pop af        
     106.  00:752D  C9                          ret
      61   00:752E                              include "slotRoutines.asm"
       1.  00:752E                      ; These routines are used for slot selection
       2.  00:752E                      
       3.  00:752E                      enableNowindPage0:
       4.  00:752E  CD 7E 75                    call getSlotPage0
       5.  00:7531  DD 67                       ld ixh,a
       6.  00:7533  CD 89 75                    call getSlotPage1
       7.  00:7536  C3 42 75                    jp enableSlotPage0       
       8.  00:7539                      
       9.  00:7539                      restorePage0:
      10.  00:7539  F5                          push af
      11.  00:753A  DD 7C                       ld a,ixh
      12.  00:753C  CD 42 75                    call enableSlotPage0
      13.  00:753F  FB                          ei
      14.  00:7540  F1                          pop af
      15.  00:7541  C9                          ret
      16.  00:7542                      
      17.  00:7542                      enableSlotPage0:
      18.  00:7542                              ; HL and D remain unchanged
      19.  00:7542                              ; enableSlotPage0 can be called in page 1 and 2 (no absolute jumps)
      20.  00:7542                      
      21.  00:7542                              ;DEBUGMESSAGE "enasltP0"
      22.  00:7542  5F                          ld e,a                          ; store slotcode for further use
      23.  00:7543  E6 03                       and 3
      24.  00:7545  4F                          ld c,a                          ; new primary slot in c  
      25.  00:7546  CB 7B                       bit 7,e
      26.  00:7548  F3                          di
      27.  00:7549  20 08                       jr nz,.expanded
      28.  00:754B                      
      29.  00:754B  DB A8                       in a,($a8)
      30.  00:754D  E6 FC                       and %11111100
      31.  00:754F  B1                          or c                            ; enable new primary slot in page 0
      32.  00:7550  D3 A8                       out ($a8),a
      33.  00:7552  C9                          ret
      34.  00:7553                              
      35.  00:7553                      .expanded:
      36.  00:7553  7B                          ld a,e                          ; store secondary slot in e
      37.  00:7554  E6 0C                       and %00001100     
      38.  00:7556  0F                          rrca
      39.  00:7557  0F                          rrca
      40.  00:7558  5F                          ld e,a
      41.  00:7559                      
      42.  00:7559  DB A8                       in a,($a8)
      43.  00:755B  E6 FC                       and %11111100
      44.  00:755D  B1                          or c                            ; new primary slot in page 0
      45.  00:755E  47                          ld b,a                          ; used to restore
      46.  00:755F  17                          rla
      47.  00:7560  A7                          and a                           ; (reset carry)
      48.  00:7561  17                          rla
      49.  00:7562  B1                          or c                            ; new primary slot in page 3
      50.  00:7563  0F                          rrca
      51.  00:7564  0F                          rrca
      52.  00:7565  D3 A8                       out ($a8),a
      53.  00:7567                      
      54.  00:7567  3A FF FF                    ld a,(-1)                       ; write secondary slot register
      55.  00:756A  2F                          cpl
      56.  00:756B  E6 FC                       and %11111100
      57.  00:756D  B3                          or e                            ; apply new secondary slot for page 0
      58.  00:756E  32 FF FF                    ld (-1),a
      59.  00:7571  5F                          ld e,a                          ; store secondary slot register (for SLTTBL)
      60.  00:7572                      
      61.  00:7572  78                          ld a,b                          ; restore primary slot page 3
      62.  00:7573  D3 A8                       out ($a8),a
      63.  00:7575                      
      64.  00:7575  3E C5                       ld a,LOW SLTTBL                 ; update SLTTBL
      65.  00:7577  81                          add c                           ; add primary slot
      66.  00:7578  4F                          ld c,a
      67.  00:7579  06 FC                       ld b,HIGH SLTTBL
      68.  00:757B  7B                          ld a,e                          ; restore secondary slot register
      69.  00:757C  02                          ld (bc),a
      70.  00:757D  C9                          ret
      71.  00:757E                      
      72.  00:757E                      ; These routines determine the current slot and subslot of a page.
      73.  00:757E                      
      74.  00:757E                      getSlotPage0:
      75.  00:757E                              ;DEBUGMESSAGE "getsltP0"
      76.  00:757E  DB A8                       in a,($a8)
      77.  00:7580  CD A3 75                    call expanded
      78.  00:7583  07                          rlca
      79.  00:7584  07                          rlca
      80.  00:7585  E6 0C                       and %00001100           ; keep subSlot
      81.  00:7587  B1                          or c                    ; add mainSlot and expanded bit
      82.  00:7588  C9                          ret
      83.  00:7589                                      
      84.  00:7589                      getSlotPage1:
      85.  00:7589                      ;        DEBUGMESSAGE "getsltP1"
      86.  00:7589  DB A8                       in a,($a8)
      87.  00:758B  0F                          rrca
      88.  00:758C  0F                          rrca
      89.  00:758D  CD A3 75                    call expanded
      90.  00:7590  E6 0C                       and %00001100           ; keep subSlot
      91.  00:7592  B1                          or c                    ; add mainSlot and expanded bit
      92.  00:7593  C9                          ret        
      93.  00:7594                                      
      94.  00:7594                      getSlotPage2:
      95.  00:7594                      ;        DEBUGMESSAGE "getsltP2"
      96.  00:7594  DB A8                       in a,($a8)
      97.  00:7596  0F                          rrca
      98.  00:7597  0F                          rrca
      99.  00:7598  0F                          rrca
     100.  00:7599  0F                          rrca
     101.  00:759A  CD A3 75                    call expanded
     102.  00:759D  0F                          rrca
     103.  00:759E  0F                          rrca
     104.  00:759F  E6 0C                       and %00001100           ; keep subSlot
     105.  00:75A1  B1                          or c                    ; add mainSlot and expanded bit
     106.  00:75A2  C9                          ret
     107.  00:75A3                      
     108.  00:75A3                      ;expanded:        
     109.  00:75A3                      ;        ld hl,EXPTBL - $0300
     110.  00:75A3                      ;        ld b,3
     111.  00:75A3                      ;        and b
     112.  00:75A3                      ;        ld c,a
     113.  00:75A3                      ;        add hl,bc      
     114.  00:75A3                      ;        
     115.  00:75A3                      ;        or (hl)        ; BUGGIE!!!! (a will be used again!)
     116.  00:75A3                      ;        ret p                           ; return when slot is not expanded
     117.  00:75A3                      ;        
     118.  00:75A3                      ;        ld c,a
     119.  00:75A3                      ;        ld a,4
     120.  00:75A3                      ;        add a,l
     121.  00:75A3                      ;        ld l,a
     122.  00:75A3                      ;        ld a,(hl)
     123.  00:75A3                      ;        ret
     124.  00:75A3                      
     125.  00:75A3                      expanded:        
     126.  00:75A3  21 C1 F9                    ld hl,EXPTBL - $0300
     127.  00:75A6  06 03                       ld b,3
     128.  00:75A8  A0                          and b
     129.  00:75A9  4F                          ld c,a
     130.  00:75AA  09                          add hl,bc
     131.  00:75AB  CB 7E                       bit 7,(hl)
     132.  00:75AD  28 08                       jr z,notExpanded
     133.  00:75AF                      
     134.  00:75AF  CB F9                       set 7,c
     135.  00:75B1  2C                          inc l
     136.  00:75B2  2C                          inc l
     137.  00:75B3  2C                          inc l
     138.  00:75B4  2C                          inc l
     139.  00:75B5  7E                          ld a,(hl)
     140.  00:75B6  C9                          ret        
     141.  00:75B7                      
     142.  00:75B7                      notExpanded:
     143.  00:75B7  C1                          pop bc
     144.  00:75B8  C9                          ret
     145.  00:75B9                      
     146.  00:75B9                      getEntrySLTWRK:
     147.  00:75B9  CD 89 75                    call getSlotPage1
     148.  00:75BC  21 09 FD                    ld hl,SLTWRK
     149.  00:75BF  4F                          ld c,a
     150.  00:75C0  0F                          rrca
     151.  00:75C1  0F                          rrca
     152.  00:75C2  0F                          rrca
     153.  00:75C3  E6 60                       and %01100000           ; main slot x 32
     154.  00:75C5  47                          ld b,a
     155.  00:75C6  79                          ld a,c
     156.  00:75C7  07                          rlca
     157.  00:75C8  E6 18                       and %00011000           ; sub slot x 8
     158.  00:75CA  80                          add b
     159.  00:75CB  85                          add l
     160.  00:75CC  6F                          ld l,a
     161.  00:75CD  C9                          ret
     162.  00:75CE                      
      62   00:75CE                              include "nowindDriver.asm"
       1.  00:75CE  (00:0008)           MYSIZE          equ 8                   ; size of work area (not used, some programs write here to stop drives spinning)
       2.  00:75CE  (00:0200)           SECLEN          equ 512                 ; sector size
       3.  00:75CE                      
       4.  00:75CE                      ; SLTWRK entry
       5.  00:75CE                      ; +0    rom drive number
       6.  00:75CE                      ; +1..5 previous EXTBIO
       7.  00:75CE                      ; +6    not used
       8.  00:75CE                      ; +7    not used
       9.  00:75CE                      
      10.  00:75CE                              macro PRINTTEXT string
      11.  00:75CE                    <         
      12.  00:75CE                    <         push hl
      13.  00:75CE                    <         ld hl,.text 
      14.  00:75CE                    <         call printText2
      15.  00:75CE                    <         pop hl
      16.  00:75CE                    <         jr .skip
      17.  00:75CE                    < .text   db string
      18.  00:75CE                    <         db 0
      19.  00:75CE                    < .skip:
      20.  00:75CE                    <         endmacro
      21.  00:75CE                              
      22.  00:75CE                      ; if this is defined we tell DOS2.3 that we _are DOS2.3 also, so
      23.  00:75CE                      ; it does not try to override our initilazations 
      24.  00:75CE                      
      25.  00:75CE                      define  PRETEND_2B_DOS23
      26.  00:75CE                              
      27.  00:75CE                      INIHRD: 
      28.  00:75CE                              DEBUGMESSAGE "INIHRD"        
      28.  00:75CE                    >         ifdef DEBUG
      28.  00:75CE  52                >         ld d,d
      28.  00:75CF  18 06             >         jr .skip
      28.  00:75D1  49 4E 49 48 52 44 >         db string
      28.  00:75D7                    > .skip:
      28.  00:75D7                    >         endif
      29.  00:75D7                              
      30.  00:75D7                      ;        call getWorkArea
      31.  00:75D7                      ;        DEBUGDUMPREGISTERS
      32.  00:75D7                                                      
      33.  00:75D7  CD 2E 75                    call enableNowindPage0                  ; clear hostToMSXFifo by reading 4Kb of random data
      34.  00:75DA  01 00 10                    ld bc,4096
      35.  00:75DD  3A 00 20            .loop:  ld a,(usbrd)
      36.  00:75E0  0B                          dec bc
      37.  00:75E1  78                          ld a,b
      38.  00:75E2  B1                          or c
      39.  00:75E3  20 F8                       jr nz,.loop
      40.  00:75E5  CD 39 75                    call restorePage0
      41.  00:75E8                              
      42.  00:75E8  26 40                       ld h,HIGH usbwr
      43.  00:75EA  36 AF                       ld (hl),$af                     ; INIHRD command
      44.  00:75EC  36 FF                       ld (hl),$ff
      45.  00:75EE  C3 F0 72                    jp nowindInit
      46.  00:75F1                      
      47.  00:75F1                      DRIVES:
      48.  00:75F1                              DEBUGMESSAGE "DRIVES"
      48.  00:75F1                    >         ifdef DEBUG
      48.  00:75F1  52                >         ld d,d
      48.  00:75F2  18 06             >         jr .skip
      48.  00:75F4  44 52 49 56 45 53 >         db string
      48.  00:75FA                    > .skip:
      48.  00:75FA                    >         endif
      49.  00:75FA  F5                          push af                         ; A, BC and DE should be preserved!
      50.  00:75FB  C5                          push bc
      51.  00:75FC  D5                          push de
      52.  00:75FD  3A 99 FD                    ld a,(DEVICE)
      53.  00:7600  CD 67 73                    call sendRegisters
      54.  00:7603  36 85                       ld (hl),C_DRIVES
      55.  00:7605  CD 2E 75                    call enableNowindPage0
      56.  00:7608  26 20                       ld h,HIGH usbrd
      57.  00:760A  CD 79 73                    call getHeader
      58.  00:760D  2E 02                       ld l,2                          ; default 2 drives
      59.  00:760F  38 2C                       jr c,.notconnected
      60.  00:7611                      
      61.  00:7611                              PRINTTEXT " Host connected."
      61.  00:7611                    >         
      61.  00:7611  E5                >         push hl
      61.  00:7612  21 1B 76          >         ld hl,.text
      61.  00:7615  CD 81 7B          >         call printText2
      61.  00:7618  E1                >         pop hl
      61.  00:7619  18 11             >         jr .skip
      61.  00:761B                    > .text   db string
      61.  00:761B  20 48 6F 73 74 20 63 6F 6E 6E 65 63 74 65 64 2E 
      61.  00:762B  00                >         db 0
      61.  00:762C                    > .skip:
      62.  00:762C                                                      
      63.  00:762C  32 3F F3                    ld (LASTDRV),a                  ; install phantom drives (CRTL key)?
      64.  00:762F  7E                          ld a,(hl)                       ; allow other drives (SHIFT key)?
      65.  00:7630  32 99 FD                    ld (DEVICE),a
      66.  00:7633  6E                          ld l,(hl)                       ; number of drives
      67.  00:7634  E5                  .exit:  push hl  
      68.  00:7635  CD 39 75                    call restorePage0
      69.  00:7638  E1                          pop hl
      70.  00:7639  D1                          pop de
      71.  00:763A  C1                          pop bc
      72.  00:763B  F1                          pop af
      73.  00:763C  C9                          ret
      74.  00:763D                              
      75.  00:763D                      .notconnected:
      76.  00:763D                              PRINTTEXT " Host timed out!"            
      76.  00:763D                    >         
      76.  00:763D  E5                >         push hl
      76.  00:763E  21 47 76          >         ld hl,.text
      76.  00:7641  CD 81 7B          >         call printText2
      76.  00:7644  E1                >         pop hl
      76.  00:7645  18 11             >         jr .skip
      76.  00:7647                    > .text   db string
      76.  00:7647  20 48 6F 73 74 20 74 69 6D 65 64 20 6F 75 74 21 
      76.  00:7657  00                >         db 0
      76.  00:7658                    > .skip:
      77.  00:7658  18 DA                       jr .exit
      78.  00:765A                      
      79.  00:765A                      
      80.  00:765A                      INIENV:
      81.  00:765A                      ; Interrupt handler can be installed here and
      82.  00:765A                      ; work area can be initialized when it was requested
      83.  00:765A                              DEBUGMESSAGE "INIENV"
      83.  00:765A                    >         ifdef DEBUG
      83.  00:765A  52                >         ld d,d
      83.  00:765B  18 06             >         jr .skip
      83.  00:765D  49 4E 49 45 4E 56 >         db string
      83.  00:7663                    > .skip:
      83.  00:7663                    >         endif
      84.  00:7663                      
      85.  00:7663                              ifdef PRETEND_2B_DOS23
      86.  00:7663                              DEBUGMESSAGE "Lie about being DOS v2.31"
      86.  00:7663                    >         ifdef DEBUG
      86.  00:7663  52                >         ld d,d
      86.  00:7664  18 19             >         jr .skip
      86.  00:7666                    >         db string
      86.  00:7666  4C 69 65 20 61 62 6F 75 74 20 62 65 69 6E 67 20 
      86.  00:7676  44 4F 53 20 76 32 2E 33 31 
      86.  00:767F                    > .skip:
      86.  00:767F                    >         endif
      87.  00:767F  3E 23                       ld a,$23
      88.  00:7681  32 13 F3                    ld ($f313),a
      89.  00:7684                              endif
      90.  00:7684                              
      91.  00:7684  CD 79 74                    call installExtendedBios
      92.  00:7687  CD 67 73                    call sendRegisters
      93.  00:768A  36 86                       ld (hl),C_INIENV
      94.  00:768C  CD 2E 75                    call enableNowindPage0
      95.  00:768F  26 20                       ld h,HIGH usbrd
      96.  00:7691  CD 79 73                    call getHeader
      97.  00:7694  F5                          push af
      98.  00:7695                      ;        push ix
      99.  00:7695                      ;        call GETWRK
     100.  00:7695                      ;        pop ix
     101.  00:7695  CD B9 75                    call getEntrySLTWRK
     102.  00:7698  F1                          pop af
     103.  00:7699  36 00                       ld (hl),0                       ; romdisk in drive A: (default)          
     104.  00:769B  38 01                       jr c,.exit
     105.  00:769D  77                          ld (hl),a                       ; store romdisk drive number (255 = no romdisk)
     106.  00:769E  C3 39 75            .exit:  jp restorePage0
     107.  00:76A1                      
     108.  00:76A1                      checkWorkArea:
     109.  00:76A1  C5                          push bc
     110.  00:76A2  E5                          push hl
     111.  00:76A3  F5                          push af
     112.  00:76A4                      ;        call GETWRK
     113.  00:76A4  CD B9 75                    call getEntrySLTWRK
     114.  00:76A7  F1                          pop af
     115.  00:76A8  BE                          cp (hl)
     116.  00:76A9  E1                          pop hl
     117.  00:76AA  C1                          pop bc
     118.  00:76AB  C9                          ret        
     119.  00:76AC                      
     120.  00:76AC                      DSKIO: 
     121.  00:76AC                      ; Input     F   Carry for set for write, reset for read
     122.  00:76AC                      ;           A   Drive number
     123.  00:76AC                      ;           B   Number of sectors to read/write
     124.  00:76AC                      ;           C   Media descriptor
     125.  00:76AC                      ;           DE  Logical sector number
     126.  00:76AC                      ;           HL  Transfer address
     127.  00:76AC                      ; Output    F   Carry set when not succesfull
     128.  00:76AC                      ;           A   Error code
     129.  00:76AC                      ;           B   Number of remaining sectors (TODO: check! even without error?)
     130.  00:76AC                      
     131.  00:76AC                              DEBUGMESSAGE "DSKIO"
     131.  00:76AC                    >         ifdef DEBUG
     131.  00:76AC  52                >         ld d,d
     131.  00:76AD  18 05             >         jr .skip
     131.  00:76AF  44 53 4B 49 4F    >         db string
     131.  00:76B4                    > .skip:
     131.  00:76B4                    >         endif
     132.  00:76B4  F5                          push af
     133.  00:76B5  CD A1 76                    call checkWorkArea
     134.  00:76B8  CA 1B 7C                    jp z,ROMDISK_DSKIO
     135.  00:76BB  F1                          pop af
     136.  00:76BC                      
     137.  00:76BC  CD 67 73                    call sendRegisters
     138.  00:76BF  36 80                       ld (hl),C_DSKIO
     139.  00:76C1  38 58                       jr c,dskioWrite                 ; read or write?
     140.  00:76C3                             
     141.  00:76C3                      dskioRead:
     142.  00:76C3  07                          rlca                            ; < 0x8000 ?
     143.  00:76C4  38 3F                       jr c,.page2and3
     144.  00:76C6                      
     145.  00:76C6                              DEBUGMESSAGE "read01"
     145.  00:76C6                    >         ifdef DEBUG
     145.  00:76C6  52                >         ld d,d
     145.  00:76C7  18 06             >         jr .skip
     145.  00:76C9  72 65 61 64 30 31 >         db string
     145.  00:76CF                    > .skip:
     145.  00:76CF                    >         endif
     146.  00:76CF  CD 94 75                    call getSlotPage2               ; enable nowind in page 2
     147.  00:76D2  F5                          push af
     148.  00:76D3  CD 89 75                    call getSlotPage1
     149.  00:76D6  DD 67                       ld ixh,a                        ; ixh = current nowind slot
     150.  00:76D8  26 80                       ld h,$80
     151.  00:76DA  CD 24 00                    call ENASLT
     152.  00:76DD  C3 E0 B6                    jp .page2
     153.  00:76E0                              
     154.  00:76E0  (B6E0)                      PHASE $ + $4000
     155.  00:B6E0                      .page2:
     156.  00:B6E0  3A 42 F3                    ld a,(RAMAD1)                   ; enable RAM in page 1
     157.  00:B6E3  26 40                       ld h,$40
     158.  00:B6E5  CD 24 00                    call ENASLT
     159.  00:B6E8                              
     160.  00:B6E8  CD 5B B8                    call readSectors01 
     161.  00:B6EB                              ; TODO: carry checken?----------------------------------------------!!!!!!!!!!!!!!!
     162.  00:B6EB                              
     163.  00:B6EB  DD 7C                       ld a,ixh                        ; enable nowind in page 1 
     164.  00:B6ED  26 40                       ld h,$40
     165.  00:B6EF  CD 24 00                    call ENASLT
     166.  00:B6F2  C3 F5 76                    jp .page1        
     167.  00:B6F5                      
     168.  00:B6F5  (76F5)                      DEPHASE
     169.  00:76F5                      .page1:
     170.  00:76F5  3A 00 80                    ld a,(usb2)
     171.  00:76F8  DD 67                       ld ixh,a
     172.  00:76FA  F1                          pop af
     173.  00:76FB  26 80                       ld h,$80
     174.  00:76FD  CD 24 00                    call ENASLT                     ; restore page 2
     175.  00:7700  DD 7C                       ld a,ixh
     176.  00:7702  B7                          or a
     177.  00:7703  FB                          ei
     178.  00:7704  C8                          ret z                           ; nothing more to read
     179.  00:7705                                      
     180.  00:7705                      .page2and3:                     
     181.  00:7705                              DEBUGMESSAGE "read23"
     181.  00:7705                    >         ifdef DEBUG
     181.  00:7705  52                >         ld d,d
     181.  00:7706  18 06             >         jr .skip
     181.  00:7708  72 65 61 64 32 33 >         db string
     181.  00:770E                    > .skip:
     181.  00:770E                    >         endif
     182.  00:770E  CD 2E 75                    call enableNowindPage0
     183.  00:7711  FD E5                       push iy
     184.  00:7713  CD AE 78                    call readSectors23
     185.  00:7716  FD E1                       pop iy
     186.  00:7718  C3 39 75                    jp restorePage0
     187.  00:771B                      
     188.  00:771B                      dskioWrite:
     189.  00:771B                              DEBUGMESSAGE "dskwrite"
     189.  00:771B                    >         ifdef DEBUG
     189.  00:771B  52                >         ld d,d
     189.  00:771C  18 08             >         jr .skip
     189.  00:771E                    >         db string
     189.  00:771E  64 73 6B 77 72 69 74 65 
     189.  00:7726                    > .skip:
     189.  00:7726                    >         endif
     190.  00:7726  07                          rlca
     191.  00:7727  38 3E                       jr c,.page2and3        
     192.  00:7729                              
     193.  00:7729                              ;call enableNowindPage2 (todo: make common routine?) 
     194.  00:7729  CD 94 75                    call getSlotPage2               ; save current slot page 2
     195.  00:772C  DD 67                       ld ixh,a
     196.  00:772E  CD 89 75                    call getSlotPage1
     197.  00:7731  DD 6F                       ld ixl,a
     198.  00:7733  26 80                       ld h,$80
     199.  00:7735  CD 24 00                    call ENASLT                     ; nowind in page 2
     200.  00:7738  C3 3B B7                    jp .page2
     201.  00:773B                      
     202.  00:773B  (B73B)                      PHASE $ + $4000
     203.  00:B73B                      .page2:
     204.  00:B73B  3A 42 F3                    ld a,(RAMAD1)
     205.  00:B73E  26 40                       ld h,$40
     206.  00:B740  CD 24 00                    call ENASLT                     ; ram in page 1
     207.  00:B743                              
     208.  00:B743  CD 89 B8                    call writeLoop01
     209.  00:B746  F5                          push af
     210.  00:B747                              
     211.  00:B747  DD 7D                       ld a,ixl
     212.  00:B749  26 40                       ld h,$40
     213.  00:B74B  CD 24 00                    call ENASLT                     ; restore nowind in page 1
     214.  00:B74E  C3 51 77                    jp .page1
     215.  00:B751                              
     216.  00:B751  (7751)                      DEPHASE
     217.  00:7751                      .page1:
     218.  00:7751  DD 7C                       ld a,ixh
     219.  00:7753  26 80                       ld h,$80
     220.  00:7755  CD 24 00                    call ENASLT
     221.  00:7758  F1                          pop af
     222.  00:7759  D8                          ret c                           ; return error (error code in a)
     223.  00:775A  E8                          ret pe                          ; host returns 0xfe when data for page 2/3 is available
     224.  00:775B                              DEBUGMESSAGE "doorgaan!"
     224.  00:775B                    >         ifdef DEBUG
     224.  00:775B  52                >         ld d,d
     224.  00:775C  18 09             >         jr .skip
     224.  00:775E                    >         db string
     224.  00:775E  64 6F 6F 72 67 61 61 6E 21 
     224.  00:7767                    > .skip:
     224.  00:7767                    >         endif
     225.  00:7767                              
     226.  00:7767                      .page2and3:
     227.  00:7767                              DEBUGMESSAGE "page2and3"
     227.  00:7767                    >         ifdef DEBUG
     227.  00:7767  52                >         ld d,d
     227.  00:7768  18 09             >         jr .skip
     227.  00:776A                    >         db string
     227.  00:776A  70 61 67 65 32 61 6E 64 33 
     227.  00:7773                    > .skip:
     227.  00:7773                    >         endif
     228.  00:7773  CD 2E 75                    call enableNowindPage0
     229.  00:7776  CD 7C 77                    call .writeLoop23
     230.  00:7779  C3 39 75                    jp restorePage0
     231.  00:777C                              
     232.  00:777C                      .writeLoop23:
     233.  00:777C                              DEBUGMESSAGE "writeLoop23"
     233.  00:777C                    >         ifdef DEBUG
     233.  00:777C  52                >         ld d,d
     233.  00:777D  18 0B             >         jr .skip
     233.  00:777F                    >         db string
     233.  00:777F  77 72 69 74 65 4C 6F 6F 70 32 33 
     233.  00:778A                    > .skip:
     233.  00:778A                    >         endif
     234.  00:778A                              
     235.  00:778A  26 20                       ld h,HIGH usbrd
     236.  00:778C  CD 79 73                    call getHeader
     237.  00:778F  D8                          ret c                           ; exit (not ready)
     238.  00:7790  B7                          or a
     239.  00:7791  F8                          ret m                           ; exit (no error)
     240.  00:7792  20 18                       jr nz,.error
     241.  00:7794                      
     242.  00:7794                              DEBUGMESSAGE "send23"
     242.  00:7794                    >         ifdef DEBUG
     242.  00:7794  52                >         ld d,d
     242.  00:7795  18 06             >         jr .skip
     242.  00:7797  73 65 6E 64 32 33 >         db string
     242.  00:779D                    > .skip:
     242.  00:779D                    >         endif
     243.  00:779D  5E                          ld e,(hl)                       ; address
     244.  00:779E  56                          ld d,(hl)
     245.  00:779F  4E                          ld c,(hl)                       ; number of bytes        
     246.  00:77A0  46                          ld b,(hl)
     247.  00:77A1  7E                          ld a,(hl)                       ; block sequence number
     248.  00:77A2                              
     249.  00:77A2                              ;DEBUGDUMPREGISTERS
     250.  00:77A2  EB                          ex de,hl
     251.  00:77A3  11 00 40                    ld de,usbwr
     252.  00:77A6  12                          ld (de),a                       ; mark block begin
     253.  00:77A7  ED B0                       ldir
     254.  00:77A9  12                          ld (de),a                       ; mark block end
     255.  00:77AA  18 D0                       jr .writeLoop23
     256.  00:77AC                      
     257.  00:77AC  37                  .error: scf
     258.  00:77AD  7E                          ld a,(hl)                       ; get error code
     259.  00:77AE  C9                          ret
     260.  00:77AF                      
     261.  00:77AF                                     
     262.  00:77AF                      DSKCHG:
     263.  00:77AF                      ; Input     A   Drive number
     264.  00:77AF                      ;           B   0
     265.  00:77AF                      ;           C   Media descriptor (previous)
     266.  00:77AF                      ;           HL  Base address of DPB
     267.  00:77AF                      ; Output    B   1   Disk unchanged
     268.  00:77AF                      ;               0   Unknown (DPB is updated)
     269.  00:77AF                      ;               -1  Disk changed (DPB is updated)
     270.  00:77AF                      ;           F   Carry set when not succesfull
     271.  00:77AF                      ;           A   Error code
     272.  00:77AF                      
     273.  00:77AF                              DEBUGMESSAGE "DSKCHG"
     273.  00:77AF                    >         ifdef DEBUG
     273.  00:77AF  52                >         ld d,d
     273.  00:77B0  18 06             >         jr .skip
     273.  00:77B2  44 53 4B 43 48 47 >         db string
     273.  00:77B8                    > .skip:
     273.  00:77B8                    >         endif
     274.  00:77B8  F5                          push af
     275.  00:77B9  CD A1 76                    call checkWorkArea
     276.  00:77BC  CA 7A 7C                    jp z,ROMDISK_DSKCHG
     277.  00:77BF  F1                          pop af       
     278.  00:77C0                      
     279.  00:77C0  E5                          push hl
     280.  00:77C1  CD 67 73                    call sendRegisters
     281.  00:77C4  36 81                       ld (hl),C_DSKCHG
     282.  00:77C6  CD 2E 75                    call enableNowindPage0
     283.  00:77C9  26 20                       ld h,HIGH usbrd
     284.  00:77CB  CD 79 73                    call getHeader
     285.  00:77CE  4E                          ld c,(hl)               ; media descriptor (when disk was changed)
     286.  00:77CF  F5                          push af
     287.  00:77D0  C5                          push bc
     288.  00:77D1  CD 39 75                    call restorePage0
     289.  00:77D4  C1                          pop bc
     290.  00:77D5  F1                          pop af
     291.  00:77D6  E1                          pop hl
     292.  00:77D7  D8                          ret c           ; not ready
     293.  00:77D8  B7                          or a
     294.  00:77D9  06 01                       ld b,1
     295.  00:77DB  C8                          ret z           ; not changed
     296.  00:77DC  41                          ld b,c
     297.  00:77DD  CD E6 77                    call GETDPB
     298.  00:77E0  3E 0A                       ld a,10
     299.  00:77E2  D8                          ret c
     300.  00:77E3  06 FF                       ld b,255
     301.  00:77E5  C9                          ret
     302.  00:77E6                      
     303.  00:77E6                      GETDPB:
     304.  00:77E6                      ; Input     A   Drive number
     305.  00:77E6                      ;           B   Media descriptor (first byte of FAT)
     306.  00:77E6                      ;           C   Previous media descriptor (does not seem to be used in other drivers)
     307.  00:77E6                      ;           HL  Base address of HL
     308.  00:77E6                      ; Output    DPB for specified drive in [HL+1]..[HL+18]
     309.  00:77E6                      
     310.  00:77E6                              DEBUGMESSAGE "GETDPB"
     310.  00:77E6                    >         ifdef DEBUG
     310.  00:77E6  52                >         ld d,d
     310.  00:77E7  18 06             >         jr .skip
     310.  00:77E9  47 45 54 44 50 42 >         db string
     310.  00:77EF                    > .skip:
     310.  00:77EF                    >         endif
     311.  00:77EF  EB                          ex de,hl
     312.  00:77F0  13                          inc de
     313.  00:77F1  67                          ld h,a
     314.  00:77F2  78                          ld a,b
     315.  00:77F3  FE F0                       cp $f0
     316.  00:77F5  7C                          ld a,h
     317.  00:77F6  28 24                       jr z,.hddImage
     318.  00:77F8                              
     319.  00:77F8                              MESSAGE "ROM GETDPB"
     319.  00:77F8  CD A7 73          >         call sendMessage
     319.  00:77FB                    >         db string
     319.  00:77FB  52 4F 4D 20 47 45 54 44 50 42 
     319.  00:7805  00                > .skip2: nop
     320.  00:7806                      
     321.  00:7806  78                          ld a,b
     322.  00:7807  D6 F8                       sub $f8
     323.  00:7809  D8                          ret c                           ; not supported in msxdos1
     324.  00:780A  07                          rlca                            ; 2x
     325.  00:780B  4F                          ld c,a
     326.  00:780C  07                          rlca                            ; 4x
     327.  00:780D  07                          rlca                            ; 8x
     328.  00:780E  07                          rlca                            ; 16x
     329.  00:780F  81                          add a,c                         ; 18x
     330.  00:7810  4F                          ld c,a
     331.  00:7811  06 00                       ld b,0        
     332.  00:7813  21 8B 7B                    ld hl,supportedMedia
     333.  00:7816  09                          add hl,bc
     334.  00:7817  0E 12                       ld c,18
     335.  00:7819  ED B0                       ldir
     336.  00:781B  C9                          ret
     337.  00:781C                      
     338.  00:781C                      .hddImage:
     339.  00:781C                              DEBUGMESSAGE ".hddImage"
     339.  00:781C                    >         ifdef DEBUG
     339.  00:781C  52                >         ld d,d
     339.  00:781D  18 09             >         jr .skip
     339.  00:781F                    >         db string
     339.  00:781F  2E 68 64 64 49 6D 61 67 65 
     339.  00:7828                    > .skip:
     339.  00:7828                    >         endif
     340.  00:7828                                      MESSAGE "HOST GETDPB"
     340.  00:7828  CD A7 73          >         call sendMessage
     340.  00:782B                    >         db string
     340.  00:782B  48 4F 53 54 20 47 45 54 44 50 42 
     340.  00:7836  00                > .skip2: nop
     341.  00:7837  CD 67 73                    call sendRegisters
     342.  00:783A  36 82                       ld (hl),C_GETDPB
     343.  00:783C  CD 2E 75                    call enableNowindPage0
     344.  00:783F  26 20                       ld h,HIGH usbrd
     345.  00:7841  CD 79 73                    call getHeader
     346.  00:7844  38 09                       jr c,.exit                      ; not ready
     347.  00:7846  5F                          ld e,a                          ; destination
     348.  00:7847  56                          ld d,(hl)
     349.  00:7848  01 12 00                    ld bc,18
     350.  00:784B                              DEBUGDUMPREGISTERS
     350.  00:784B                    >         ifdef DEBUG
     350.  00:784B  ED 07             >         db $ed,7
     350.  00:784D                    >         endif
     350.  00:784D                    >         
     350.  00:784D                    >         ifdef USBDEBUG
     350.  00:784D                    ~         assert ($ < $8000)
     350.  00:784D                    ~         call sendCpuInfo
     350.  00:784D                    ~         endif
     351.  00:784D  ED B0                       ldir
     352.  00:784F                              ;DB $ed, $0a       
     353.  00:784F  C3 39 75            .exit:  jp restorePage0        
     354.  00:7852                      
     355.  00:7852                      CHOICE:
     356.  00:7852                              ;DEBUGMESSAGE "CHOICE"
     357.  00:7852                              ifdef MSXDOS2
     358.  00:7852  21 56 78                    ld hl,.noFormat
     359.  00:7855                              else
     360.  00:7855                    ~         ld hl,0                         ; no choice
     361.  00:7855                    ~         endif
     362.  00:7855  C9                          ret
     363.  00:7856                      
     364.  00:7856                      .noFormat:
     365.  00:7856  00                          db 0
     366.  00:7857                      
     367.  00:7857                      DSKFMT:
     368.  00:7857  37                          scf
     369.  00:7858  3E 10                       ld a,16                         ; other error
     370.  00:785A  C9                          ret
     371.  00:785B                              
     372.  00:785B  (B85B)                      PHASE $ + $4000
     373.  00:B85B                              
     374.  00:B85B                      readSectors01:
     375.  00:B85B                              DEBUGMESSAGE "readSectors01"
     375.  00:B85B                    >         ifdef DEBUG
     375.  00:B85B  52                >         ld d,d
     375.  00:B85C  18 0D             >         jr .skip
     375.  00:B85E                    >         db string
     375.  00:B85E  72 65 61 64 53 65 63 74 6F 72 73 30 31 
     375.  00:B86B                    > .skip:
     375.  00:B86B                    >         endif
     376.  00:B86B  26 80                       ld h,HIGH usb2
     377.  00:B86D  CD 79 B3                    call getHeader + $4000                                  
     378.  00:B870  D8                          ret c                           ; carry means timeout, no carry: A == 0 means slow transfer, A == 1 means exit, A == 2 means fast transfer                                      
     379.  00:B871  3D                          dec a
     380.  00:B872  C8                          ret z
     381.  00:B873  FA 7D B8                    jp m,.slowTransfer                              
     382.  00:B876  CD EF B8                    call reverseTransfer + $4000
     383.  00:B879  70                          ld (hl),b
     384.  00:B87A  71                          ld (hl),c
     385.  00:B87B  18 DE                       jr readSectors01
     386.  00:B87D                      
     387.  00:B87D                      .slowTransfer:
     388.  00:B87D  5E                          ld e,(hl)                       ; transfer address
     389.  00:B87E  56                          ld d,(hl)
     390.  00:B87F  4E                          ld c,(hl)                       ; transfer amount 
     391.  00:B880  46                          ld b,(hl)
     392.  00:B881  ED B0                       ldir        
     393.  00:B883                              
     394.  00:B883  56                          ld d,(hl)                       ; BUG in emulator (byte direct terugschrijven, geeft 'rukkert!')
     395.  00:B884  7E                          ld a,(hl)
     396.  00:B885  72                          ld (hl),d                       ; return end marker ($af, $0f)
     397.  00:B886  77                          ld (hl),a
     398.  00:B887  18 D2                       jr readSectors01
     399.  00:B889                      
     400.  00:B889                      writeLoop01:
     401.  00:B889  26 80                       ld h,HIGH usb2
     402.  00:B88B  CD 79 B3                    call getHeader + $4000
     403.  00:B88E  D8                          ret c                           ; exit (not ready)
     404.  00:B88F  B7                          or a
     405.  00:B890  F8                          ret m                           ; exit (no error)
     406.  00:B891  20 18                       jr nz,.error
     407.  00:B893                      
     408.  00:B893                              DEBUGMESSAGE "send01"
     408.  00:B893                    >         ifdef DEBUG
     408.  00:B893  52                >         ld d,d
     408.  00:B894  18 06             >         jr .skip
     408.  00:B896  73 65 6E 64 30 31 >         db string
     408.  00:B89C                    > .skip:
     408.  00:B89C                    >         endif
     409.  00:B89C  5E                          ld e,(hl)                       ; address
     410.  00:B89D  56                          ld d,(hl)
     411.  00:B89E  4E                          ld c,(hl)                       ; number of bytes        
     412.  00:B89F  46                          ld b,(hl)
     413.  00:B8A0  7E                          ld a,(hl)                       ; block sequence number
     414.  00:B8A1                      
     415.  00:B8A1  EB                          ex de,hl
     416.  00:B8A2  11 00 80                    ld de,usb2
     417.  00:B8A5  12                          ld (de),a                       ; mark block begin
     418.  00:B8A6  ED B0                       ldir
     419.  00:B8A8  12                          ld (de),a                       ; mark block end
     420.  00:B8A9  18 DE                       jr writeLoop01
     421.  00:B8AB                      
     422.  00:B8AB  37                  .error: scf
     423.  00:B8AC  7E                          ld a,(hl)                       ; get error code
     424.  00:B8AD  C9                          ret
     425.  00:B8AE                      
     426.  00:B8AE  (78AE)                      DEPHASE
     427.  00:78AE                       
     428.  00:78AE                      readSectors23:
     429.  00:78AE                              DEBUGMESSAGE "readSectors23"
     429.  00:78AE                    >         ifdef DEBUG
     429.  00:78AE  52                >         ld d,d
     429.  00:78AF  18 0D             >         jr .skip
     429.  00:78B1                    >         db string
     429.  00:78B1  72 65 61 64 53 65 63 74 6F 72 73 32 33 
     429.  00:78BE                    > .skip:
     429.  00:78BE                    >         endif
     430.  00:78BE  26 20                       ld h,HIGH usbrd
     431.  00:78C0  CD 79 73                    call getHeader
     432.  00:78C3  D8                          ret c
     433.  00:78C4  3D                          dec a
     434.  00:78C5  C8                          ret z                           ; no more data
     435.  00:78C6  FA D2 78                    jp m,.slowTransfer        
     436.  00:78C9  CD EF 78                    call reverseTransfer
     437.  00:78CC  26 40                       ld h,HIGH usbwr 
     438.  00:78CE  70                          ld (hl),b
     439.  00:78CF  71                          ld (hl),c
     440.  00:78D0  18 DC                       jr readSectors23
     441.  00:78D2                      
     442.  00:78D2                      .slowTransfer:
     443.  00:78D2                              DEBUGMESSAGE "slowtransfer"
     443.  00:78D2                    >         ifdef DEBUG
     443.  00:78D2  52                >         ld d,d
     443.  00:78D3  18 0C             >         jr .skip
     443.  00:78D5                    >         db string
     443.  00:78D5  73 6C 6F 77 74 72 61 6E 73 66 65 72 
     443.  00:78E1                    > .skip:
     443.  00:78E1                    >         endif
     444.  00:78E1  5E                          ld e,(hl)                       ; transfer address
     445.  00:78E2  56                          ld d,(hl)
     446.  00:78E3  4E                          ld c,(hl)                       ; transfer amount 
     447.  00:78E4  46                          ld b,(hl)
     448.  00:78E5  ED B0                       ldir
     449.  00:78E7  56                          ld d,(hl)
     450.  00:78E8  7E                          ld a,(hl)
     451.  00:78E9  26 40                       ld h,HIGH usbwr
     452.  00:78EB  72                          ld (hl),d                       ; return end marker ($af, $0f)
     453.  00:78EC  77                          ld (hl),a
     454.  00:78ED  18 BF                       jr readSectors23
     455.  00:78EF                                     
     456.  00:78EF                      reverseTransfer:
     457.  00:78EF  FD 21 00 00                 ld iy,0                         ; save stack pointer
     458.  00:78F3  FD 39                       add iy,sp
     459.  00:78F5  5E                          ld e,(hl)                       ; transfer address
     460.  00:78F6  56                          ld d,(hl)
     461.  00:78F7  EB                          ex de,hl
     462.  00:78F8  F9                          ld sp,hl
     463.  00:78F9  EB                          ex de,hl
     464.  00:78FA  46                          ld b,(hl)                       ; number of loops       
     465.  00:78FB                      .loop:
     466.  00:78FB                              repeat 32                       ; blocks of 64 bytes hardcoded (NowindHost.cpp)
     467.  00:78FB                    <         ld d,(hl)
     468.  00:78FB                    <         ld e,(hl)
     469.  00:78FB                    <         push de
     470.  00:78FB                    <         endrepeat
     470.  00:78FB  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     470.  00:790B  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     470.  00:791B  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     470.  00:792B  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     470.  00:793B  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     470.  00:794B  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     471.  00:795B  10 9E                       djnz .loop
     472.  00:795D                              
     473.  00:795D  FD F9                       ld sp,iy                        ; restore stack pointer
     474.  00:795F  46                          ld b,(hl)                       ; return end marker
     475.  00:7960  4E                          ld c,(hl)
     476.  00:7961  C9                          ret
     477.  00:7962                            
     478.  00:7962                      OEMSTA:
     479.  00:7962  E5                          push hl
     480.  00:7963  21 70 79                    ld hl,.statement
     481.  00:7966  CD 3B 73                    call findStatementName
     482.  00:7969  5E                          ld e,(hl)
     483.  00:796A  23                          inc hl
     484.  00:796B  56                          ld d,(hl)
     485.  00:796C  E1                          pop hl        
     486.  00:796D  D8                          ret c
     487.  00:796E  D5                          push de
     488.  00:796F  C9                          ret
     489.  00:7970                      
     490.  00:7970                      .statement:
     491.  00:7970  49 4D 41 47 45 00           db "IMAGE",0
     492.  00:7976  83 79                       dw changeImage
     493.  00:7978                              db "VSTREAM",0
     493.  00:7978  56 53 54 52 45 41 4D 00 
     494.  00:7980  B0 79                       dw videoStream
     495.  00:7982  00                          db 0
     496.  00:7983                      
     497.  00:7983                      ; send arguments, command, filename, end with ":"
     498.  00:7983                      changeImage:
     499.  00:7983                              DEBUGMESSAGE "changeImage"
     499.  00:7983                    >         ifdef DEBUG
     499.  00:7983  52                >         ld d,d
     499.  00:7984  18 0B             >         jr .skip
     499.  00:7986                    >         db string
     499.  00:7986  63 68 61 6E 67 65 49 6D 61 67 65 
     499.  00:7991                    > .skip:
     499.  00:7991                    >         endif
     500.  00:7991  E5                          push hl
     501.  00:7992  CD 67 73                    call sendRegisters
     502.  00:7995  36 A0                       ld (hl),C_CHANGEIMAGE
     503.  00:7997  E1                          pop hl
     504.  00:7998                              
     505.  00:7998                      call_exit:
     506.  00:7998                              DEBUGMESSAGE "call_exit"
     506.  00:7998                    >         ifdef DEBUG
     506.  00:7998  52                >         ld d,d
     506.  00:7999  18 09             >         jr .skip
     506.  00:799B                    >         db string
     506.  00:799B  63 61 6C 6C 5F 65 78 69 74 
     506.  00:79A4                    > .skip:
     506.  00:79A4                    >         endif
     507.  00:79A4  7E                  .loop:  ld a,(hl)
     508.  00:79A5  32 00 40                    ld (usbwr),a
     509.  00:79A8  FE 3A                       cp ":"
     510.  00:79AA  C8                          ret z
     511.  00:79AB  B7                          or a
     512.  00:79AC  C8                          ret z
     513.  00:79AD  23                          inc hl
     514.  00:79AE  18 F4                       jr .loop
     515.  00:79B0                              
     516.  00:79B0                      videoStream: 
     517.  00:79B0  E5                          push hl
     518.  00:79B1                              include "vram.asm"
       1:  00:79B1                              
       2:  00:79B1                      vramDump:
       3:  00:79B1  F3                  	di
       4:  00:79B2  CD 2E 75                    call enableNowindPage0
       5:  00:79B5                      
       6:  00:79B5  3E 02                       ld a,2
       7:  00:79B7  D3 99                       out ($99),a
       8:  00:79B9  3E 8F                       ld a,$80+15             ; status register pointer at S#2
       9:  00:79BB  D3 99                       out ($99),a
      10:  00:79BD                      
      11:  00:79BD                      evenFrame:
      12:  00:79BD                              ; vram address 0x0000
      13:  00:79BD                              
      14:  00:79BD                              ;xor a
      15:  00:79BD                              ;out ($99),a
      16:  00:79BD                              ;ld a,$80+2
      17:  00:79BD                              ;out ($99),a
      18:  00:79BD                              
      19:  00:79BD  3E 03                       ld a,%00000011                 ; pattern generator table
      20:  00:79BF  D3 99                       out ($99),a
      21:  00:79C1  3E 84                       ld a,$80+4
      22:  00:79C3  D3 99                       out ($99),a
      23:  00:79C5                      
      24:  00:79C5  AF                          xor a                   ; color table high
      25:  00:79C6  D3 99                       out ($99),a
      26:  00:79C8  3E 8A                       ld a,$80+10
      27:  00:79CA  D3 99                       out ($99),a
      28:  00:79CC                              
      29:  00:79CC  3E 04                       ld a,%00000100          ; vram access at 0x10000
      30:  00:79CE  CD 62 7B                    call setVramAccessPointer
      31:  00:79D1  CD FA 79                    call tranferframe
      32:  00:79D4  CD 70 7B                    call waitForRetrace
      33:  00:79D7  CD 14 7B                    call changeColors
      34:  00:79DA                      
      35:  00:79DA                      oddFrame:
      36:  00:79DA                              ; vram address 0x10000
      37:  00:79DA                      
      38:  00:79DA                              ;ld a,%01000000
      39:  00:79DA                              ;out ($99),a
      40:  00:79DA                              ;ld a,$80+2
      41:  00:79DA                              ;out ($99),a
      42:  00:79DA                      
      43:  00:79DA  3E 23                       ld a,%00100011          ; pattern generator table
      44:  00:79DC  D3 99                       out ($99),a
      45:  00:79DE  3E 84                       ld a,$80+4
      46:  00:79E0  D3 99                       out ($99),a
      47:  00:79E2                      
      48:  00:79E2  3E 64                       ld a,00000100           ; color table high
      49:  00:79E4  D3 99                       out ($99),a
      50:  00:79E6  3E 8A                       ld a,$80+10
      51:  00:79E8  D3 99                       out ($99),a
      52:  00:79EA                      
      53:  00:79EA  AF                          xor a
      54:  00:79EB  CD 62 7B                    call setVramAccessPointer
      55:  00:79EE  CD FA 79                    call tranferframe
      56:  00:79F1  CD 70 7B                    call waitForRetrace
      57:  00:79F4  CD 14 7B                    call changeColors
      58:  00:79F7  C3 BD 79                    jp evenFrame
      59:  00:79FA                      
      60:  00:79FA                      tranferframe:
      61:  00:79FA  CD 67 73                    call sendRegisters
      62:  00:79FD  36 FF                       ld (hl),255
      63:  00:79FF                                      
      64:  00:79FF  21 00 20                    ld hl,usbrd
      65:  00:7A02  CD 79 73                    call getHeader
      66:  00:7A05                              
      67:  00:7A05  16 70                       ld d,112			; 224x64 is 1 screen 2 page of data ($3800)
      68:  00:7A07                      write_more:        
      69:  00:7A07  21 00 20            	ld hl,usbrd
      70:  00:7A0A  01 98 00                    ld bc,$0098
      71:  00:7A0D                              repeat 128
      72:  00:7A0D                    <         outi
      73:  00:7A0D                    <         endrepeat
      73:  00:7A0D  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A1D  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A2D  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A3D  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A4D  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A5D  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A6D  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A7D  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A8D  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A9D  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AAD  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7ABD  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7ACD  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7ADD  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AED  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AFD  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      74:  00:7B0D                      
      75:  00:7B0D  15                          dec d
      76:  00:7B0E  7A                          ld a,d
      77:  00:7B0F  B7                          or a
      78:  00:7B10  C2 07 7A                    jp nz,write_more
      79:  00:7B13  C9                          ret		
      80:  00:7B14                      
      81:  00:7B14                      changeColors:
      82:  00:7B14  AF                          xor a			; set color register pointer to zero
      83:  00:7B15  D3 99                       out ($99),a
      84:  00:7B17  3E 90                       ld a,$80+16
      85:  00:7B19  D3 99                       out ($99),a
      86:  00:7B1B                              
      87:  00:7B1B  21 00 20                    ld hl,usbrd
      88:  00:7B1E  01 9A 00                    ld bc,$009A		; write to color register
      89:  00:7B21                      
      90:  00:7B21                              repeat 32
      91:  00:7B21                    <         outi
      92:  00:7B21                    <         endrepeat		
      92:  00:7B21  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B31  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B41  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B51  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      93:  00:7B61  C9                          ret
      94:  00:7B62                      
      95:  00:7B62                      	
      96:  00:7B62                      setVramAccessPointer:
      97:  00:7B62  D3 99                       out ($99),a
      98:  00:7B64  3E 8E                       ld a,$80+14
      99:  00:7B66  D3 99                       out ($99),a
     100:  00:7B68  AF                          xor a
     101:  00:7B69  D3 99                       out ($99),a
     102:  00:7B6B  3E 40                       ld a,%01000000		; vram write
     103:  00:7B6D  D3 99                       out ($99),a
     104:  00:7B6F  C9                          ret
     105:  00:7B70                      
     106:  00:7B70                      waitForRetrace:
     107:  00:7B70  DB 99                       in a,($99)
     108:  00:7B72  CB 77                       bit 6,a
     109:  00:7B74  20 FA                       jr nz,waitForRetrace       
     110:  00:7B76                      .lp2:        
     111:  00:7B76  DB 99                       in a,($99)
     112:  00:7B78  CB 77                       bit 6,a
     113:  00:7B7A  28 FA                       jr z,.lp2       
     114:  00:7B7C  C9                          ret
     115:  00:7B7D                              	
     116:  00:7B7D                      	; just let it go... 
     519.  00:7B7D  E1                          pop hl
     520.  00:7B7E  C3 98 79                    jp call_exit
     521.  00:7B81                              
     522.  00:7B81                      ; hl points to text
     523.  00:7B81                      printText2:
     524.  00:7B81  F5                                                  push af
     525.  00:7B82  7E                  .loop:  ld a,(hl)
     526.  00:7B83  D3 98                                               out ($98),a 
     527.  00:7B85  23                                                  inc hl
     528.  00:7B86  B7                                                  or a
     529.  00:7B87  20 F9                                               jr nz,.loop
     530.  00:7B89  F1                                                  pop af
     531.  00:7B8A  C9                                                  ret
     532.  00:7B8B                              
     533.  00:7B8B                      supportedMedia:
     534.  00:7B8B                                      
     535.  00:7B8B                      .f8:    MAKEDPB $f8, 512, 2, 112, 1 * 80 * 9, 2, 2      ; 360 kB (1 side * 80 tracks * 9 tracks/sector)
     535.  00:7B8B  (00:0001)         > .firfat equ 1
     535.  00:7B8B  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     535.  00:7B8B  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     535.  00:7B8B                    >         if sectorSize = 512
     535.  00:7B8B  (00:0004)         > .shft   equ 4
     535.  00:7B8B                    >         elseif sectorSize = 256
     535.  00:7B8B                    ~ .shft   equ 3
     535.  00:7B8B                    ~         endif
     535.  00:7B8B                    >         
     535.  00:7B8B  F8                >         db media
     535.  00:7B8C  00 02             >         dw sectorSize
     535.  00:7B8E  0F 04             >         db (sectorSize/32)-1, .shft
     535.  00:7B90  01                >         db sectorsPerCluster-1
     535.  00:7B91  02                >         db sectorsPerCluster
     535.  00:7B92  01 00             >         dw .firfat
     535.  00:7B94  02 70             >         db fatCount, maxEnt
     535.  00:7B96  0C 00             >         dw .firrec
     535.  00:7B98  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     535.  00:7B9A  02                >         db fatSiz
     535.  00:7B9B  05 00             >         dw .firdir
     536.  00:7B9D                      .def:   MAKEDPB $f9, 512, 2, 112, 2 * 80 * 9, 3, 2      ; 720 kB
     536.  00:7B9D  (00:0001)         > .firfat equ 1
     536.  00:7B9D  (00:0007)         > .firdir equ .firfat+(fatCount*fatSiz)
     536.  00:7B9D  (00:000E)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     536.  00:7B9D                    >         if sectorSize = 512
     536.  00:7B9D  (00:0004)         > .shft   equ 4
     536.  00:7B9D                    >         elseif sectorSize = 256
     536.  00:7B9D                    ~ .shft   equ 3
     536.  00:7B9D                    ~         endif
     536.  00:7B9D                    >         
     536.  00:7B9D  F9                >         db media
     536.  00:7B9E  00 02             >         dw sectorSize
     536.  00:7BA0  0F 04             >         db (sectorSize/32)-1, .shft
     536.  00:7BA2  01                >         db sectorsPerCluster-1
     536.  00:7BA3  02                >         db sectorsPerCluster
     536.  00:7BA4  01 00             >         dw .firfat
     536.  00:7BA6  02 70             >         db fatCount, maxEnt
     536.  00:7BA8  0E 00             >         dw .firrec
     536.  00:7BAA  CA 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     536.  00:7BAC  03                >         db fatSiz
     536.  00:7BAD  07 00             >         dw .firdir
     537.  00:7BAF                              MAKEDPB $fa, 512, 2, 112, 1 * 80 * 8, 1, 2      ; 320 kB
     537.  00:7BAF  (00:0001)         > .firfat equ 1
     537.  00:7BAF  (00:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     537.  00:7BAF  (00:000A)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     537.  00:7BAF                    >         if sectorSize = 512
     537.  00:7BAF  (00:0004)         > .shft   equ 4
     537.  00:7BAF                    >         elseif sectorSize = 256
     537.  00:7BAF                    ~ .shft   equ 3
     537.  00:7BAF                    ~         endif
     537.  00:7BAF                    >         
     537.  00:7BAF  FA                >         db media
     537.  00:7BB0  00 02             >         dw sectorSize
     537.  00:7BB2  0F 04             >         db (sectorSize/32)-1, .shft
     537.  00:7BB4  01                >         db sectorsPerCluster-1
     537.  00:7BB5  02                >         db sectorsPerCluster
     537.  00:7BB6  01 00             >         dw .firfat
     537.  00:7BB8  02 70             >         db fatCount, maxEnt
     537.  00:7BBA  0A 00             >         dw .firrec
     537.  00:7BBC  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     537.  00:7BBE  01                >         db fatSiz
     537.  00:7BBF  03 00             >         dw .firdir
     538.  00:7BC1                              MAKEDPB $fb, 512, 2, 112, 2 * 80 * 8, 2, 2      ; 640 kB
     538.  00:7BC1  (00:0001)         > .firfat equ 1
     538.  00:7BC1  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     538.  00:7BC1  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     538.  00:7BC1                    >         if sectorSize = 512
     538.  00:7BC1  (00:0004)         > .shft   equ 4
     538.  00:7BC1                    >         elseif sectorSize = 256
     538.  00:7BC1                    ~ .shft   equ 3
     538.  00:7BC1                    ~         endif
     538.  00:7BC1                    >         
     538.  00:7BC1  FB                >         db media
     538.  00:7BC2  00 02             >         dw sectorSize
     538.  00:7BC4  0F 04             >         db (sectorSize/32)-1, .shft
     538.  00:7BC6  01                >         db sectorsPerCluster-1
     538.  00:7BC7  02                >         db sectorsPerCluster
     538.  00:7BC8  01 00             >         dw .firfat
     538.  00:7BCA  02 70             >         db fatCount, maxEnt
     538.  00:7BCC  0C 00             >         dw .firrec
     538.  00:7BCE  7B 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     538.  00:7BD0  02                >         db fatSiz
     538.  00:7BD1  05 00             >         dw .firdir
     539.  00:7BD3                              MAKEDPB $fc, 512, 1, 64,  1 * 40 * 9, 2, 2      ; 180 kB
     539.  00:7BD3  (00:0001)         > .firfat equ 1
     539.  00:7BD3  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     539.  00:7BD3  (00:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     539.  00:7BD3                    >         if sectorSize = 512
     539.  00:7BD3  (00:0004)         > .shft   equ 4
     539.  00:7BD3                    >         elseif sectorSize = 256
     539.  00:7BD3                    ~ .shft   equ 3
     539.  00:7BD3                    ~         endif
     539.  00:7BD3                    >         
     539.  00:7BD3  FC                >         db media
     539.  00:7BD4  00 02             >         dw sectorSize
     539.  00:7BD6  0F 04             >         db (sectorSize/32)-1, .shft
     539.  00:7BD8  00                >         db sectorsPerCluster-1
     539.  00:7BD9  01                >         db sectorsPerCluster
     539.  00:7BDA  01 00             >         dw .firfat
     539.  00:7BDC  02 40             >         db fatCount, maxEnt
     539.  00:7BDE  09 00             >         dw .firrec
     539.  00:7BE0  60 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     539.  00:7BE2  02                >         db fatSiz
     539.  00:7BE3  05 00             >         dw .firdir
     540.  00:7BE5                              MAKEDPB $fd, 512, 2, 112, 2 * 40 * 9, 2, 2      ; 360 kB
     540.  00:7BE5  (00:0001)         > .firfat equ 1
     540.  00:7BE5  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     540.  00:7BE5  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     540.  00:7BE5                    >         if sectorSize = 512
     540.  00:7BE5  (00:0004)         > .shft   equ 4
     540.  00:7BE5                    >         elseif sectorSize = 256
     540.  00:7BE5                    ~ .shft   equ 3
     540.  00:7BE5                    ~         endif
     540.  00:7BE5                    >         
     540.  00:7BE5  FD                >         db media
     540.  00:7BE6  00 02             >         dw sectorSize
     540.  00:7BE8  0F 04             >         db (sectorSize/32)-1, .shft
     540.  00:7BEA  01                >         db sectorsPerCluster-1
     540.  00:7BEB  02                >         db sectorsPerCluster
     540.  00:7BEC  01 00             >         dw .firfat
     540.  00:7BEE  02 70             >         db fatCount, maxEnt
     540.  00:7BF0  0C 00             >         dw .firrec
     540.  00:7BF2  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     540.  00:7BF4  02                >         db fatSiz
     540.  00:7BF5  05 00             >         dw .firdir
     541.  00:7BF7                              MAKEDPB $fe, 512, 1, 64,  1 * 40 * 8, 1, 2      ; 160 kB
     541.  00:7BF7  (00:0001)         > .firfat equ 1
     541.  00:7BF7  (00:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     541.  00:7BF7  (00:0007)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     541.  00:7BF7                    >         if sectorSize = 512
     541.  00:7BF7  (00:0004)         > .shft   equ 4
     541.  00:7BF7                    >         elseif sectorSize = 256
     541.  00:7BF7                    ~ .shft   equ 3
     541.  00:7BF7                    ~         endif
     541.  00:7BF7                    >         
     541.  00:7BF7  FE                >         db media
     541.  00:7BF8  00 02             >         dw sectorSize
     541.  00:7BFA  0F 04             >         db (sectorSize/32)-1, .shft
     541.  00:7BFC  00                >         db sectorsPerCluster-1
     541.  00:7BFD  01                >         db sectorsPerCluster
     541.  00:7BFE  01 00             >         dw .firfat
     541.  00:7C00  02 40             >         db fatCount, maxEnt
     541.  00:7C02  07 00             >         dw .firrec
     541.  00:7C04  3A 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     541.  00:7C06  01                >         db fatSiz
     541.  00:7C07  03 00             >         dw .firdir
     542.  00:7C09                              MAKEDPB $ff, 512, 2, 112, 2 * 40 * 8, 1, 1      ; 320 kB
     542.  00:7C09  (00:0001)         > .firfat equ 1
     542.  00:7C09  (00:0002)         > .firdir equ .firfat+(fatCount*fatSiz)
     542.  00:7C09  (00:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     542.  00:7C09                    >         if sectorSize = 512
     542.  00:7C09  (00:0004)         > .shft   equ 4
     542.  00:7C09                    >         elseif sectorSize = 256
     542.  00:7C09                    ~ .shft   equ 3
     542.  00:7C09                    ~         endif
     542.  00:7C09                    >         
     542.  00:7C09  FF                >         db media
     542.  00:7C0A  00 02             >         dw sectorSize
     542.  00:7C0C  0F 04             >         db (sectorSize/32)-1, .shft
     542.  00:7C0E  01                >         db sectorsPerCluster-1
     542.  00:7C0F  02                >         db sectorsPerCluster
     542.  00:7C10  01 00             >         dw .firfat
     542.  00:7C12  01 70             >         db fatCount, maxEnt
     542.  00:7C14  09 00             >         dw .firrec
     542.  00:7C16  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     542.  00:7C18  01                >         db fatSiz
     542.  00:7C19  02 00             >         dw .firdir
     543.  00:7C1B                      
     544.  00:7C1B                      ; WARNING: in some cases DEFDPB-1 is expected!
     545.  00:7C1B  (00:7B9D)           DEFDPB  equ supportedMedia.def
      63   00:7C1B                              include "romdisk.asm"
       1.  00:7C1B                      
       2.  00:7C1B                      ROMDISK_DSKIO:
       3.  00:7C1B                              DEBUGMESSAGE "R_DSKIO"
       3.  00:7C1B                    >         ifdef DEBUG
       3.  00:7C1B  52                >         ld d,d
       3.  00:7C1C  18 07             >         jr .skip
       3.  00:7C1E                    >         db string
       3.  00:7C1E  52 5F 44 53 4B 49 4F 
       3.  00:7C25                    > .skip:
       3.  00:7C25                    >         endif
       4.  00:7C25  F1                          pop af
       5.  00:7C26  3E 00                       ld a,0
       6.  00:7C28  D8                          ret c                           ; write protected
       7.  00:7C29                              
       8.  00:7C29  EB                          ex de,hl
       9.  00:7C2A  C5                  .loop:  push bc
      10.  00:7C2B  E5                          push hl        
      11.  00:7C2C                              
      12.  00:7C2C  CB 7A                       bit 7,d
      13.  00:7C2E  20 1C                       jr nz,.directCopy
      14.  00:7C30  7A                          ld a,d
      15.  00:7C31  FE 3E                       cp $3e        
      16.  00:7C33  38 17                       jr c,.directCopy
      17.  00:7C35                      
      18.  00:7C35  CD 58 7C                    call .findSector
      19.  00:7C38  D5                          push de
      20.  00:7C39  ED 5B 4D F3                 ld de,($f34d)        
      21.  00:7C3D  CD F4 7F                    call copyFromBank
      22.  00:7C40  D1                          pop de
      23.  00:7C41  01 00 02                    ld bc,512
      24.  00:7C44  2A 4D F3                    ld hl,($f34d)
      25.  00:7C47  CD 6E F3                    call XFER
      26.  00:7C4A  18 06                       jr .nextSector           
      27.  00:7C4C                                    
      28.  00:7C4C                      .directCopy:                
      29.  00:7C4C  CD 58 7C                    call .findSector  
      30.  00:7C4F  CD F4 7F                    call copyFromBank
      31.  00:7C52                      .nextSector:
      32.  00:7C52  E1                          pop hl
      33.  00:7C53  23                          inc hl
      34.  00:7C54  C1                          pop bc
      35.  00:7C55  10 D3                       djnz .loop
      36.  00:7C57  C9                          ret
      37.  00:7C58                      
      38.  00:7C58                      .findSector:        
      39.  00:7C58  7D                          ld a,l                          ; determine bank
      40.  00:7C59  E6 E0                       and %11100000
      41.  00:7C5B  B4                          or h
      42.  00:7C5C  07                          rlca
      43.  00:7C5D  07                          rlca
      44.  00:7C5E  07                          rlca
      45.  00:7C5F  47                          ld b,a
      46.  00:7C60                      
      47.  00:7C60  7D                          ld a,l
      48.  00:7C61  E6 1F                       and 31
      49.  00:7C63  4F                          ld c,a
      50.  00:7C64  3E 1B                       ld a,ROMDSKLAST                 ; banks with b0..5=0 reside in the last bank
      51.  00:7C66  28 05                       jr z,.skip
      52.  00:7C68                      
      53.  00:7C68  78                          ld a,b
      54.  00:7C69  C6 04                       add ROMDSKBANK
      55.  00:7C6B  41                          ld b,c
      56.  00:7C6C  05                          dec b
      57.  00:7C6D  4F                  .skip:  ld c,a
      58.  00:7C6E  78                          ld a,b
      59.  00:7C6F  07                          rlca
      60.  00:7C70  C6 41                       add $41                         ; disk images starts at $4100
      61.  00:7C72  67                          ld h,a
      62.  00:7C73  2E 00                       ld l,0
      63.  00:7C75  79                          ld a,c
      64.  00:7C76  01 00 02                    ld bc,512
      65.  00:7C79  C9                          ret
      66.  00:7C7A                                                               
      67.  00:7C7A                      ROMDISK_DSKCHG:
      68.  00:7C7A                              ;DEBUGMESSAGE "ROM_DSKCHG"
      69.  00:7C7A  F1                          pop af
      70.  00:7C7B  A7                          and a
      71.  00:7C7C  06 01                       ld b,1                          ; not changed
      72.  00:7C7E  C9                          ret
      73.  00:7C7F                      
      74.  00:7C7F                      ROMDISK_GETDPB:
      75.  00:7C7F                              ; not implemented (standard mediadescriptor as used)
      76.  00:7C7F                              
      77.  00:7C7F                      ROMDISK_DSKFMT:
      78.  00:7C7F                              ; not implemented (no disk can be formatted)
      79.  00:7C7F                              
      64   00:7C7F                              include "flashWriter.asm"
       1.  00:7C7F                      ; flashWriter.asm
       2.  00:7C7F                      ; Flashes and erases the AMD9F040
       3.  00:7C7F                           
       4.  00:7C7F                      flashWriter:
       5.  00:7C7F  3E 03                       ld a,3
       6.  00:7C81  CD 41 01                    call SNSMAT
       7.  00:7C84  E6 08                       and 8
       8.  00:7C86  C0                          ret nz
       9.  00:7C87                              
      10.  00:7C87  CD 6A 74                    call printText
      11.  00:7C8A                              db 10,13," FlashROM",10,13," "
      11.  00:7C8A  0A 0D 20 46 6C 61 73 68 52 4F 4D 0A 0D 20 
      12.  00:7C98  2E (33)                     ds 33,"."
      13.  00:7CB9  0D 20 00                    db 13," ",0
      14.  00:7CBC                              
      15.  00:7CBC  CD 89 75                    call getSlotPage1
      16.  00:7CBF  CD 42 75                    call enableSlotPage0
      17.  00:7CC2                      
      18.  00:7CC2  21 CF 7C                    ld hl,.source
      19.  00:7CC5  11 00 C0                    ld de,$c000
      20.  00:7CC8  D5                          push de
      21.  00:7CC9  01 88 00                    ld bc,flasherEnd - $c000
      22.  00:7CCC  ED B0                       ldir
      23.  00:7CCE  C9                          ret
      24.  00:7CCF                              
      25.  00:7CCF                      .source:     
      26.  00:7CCF  (C000)                      PHASE $c000  
      27.  00:C000                              
      28.  00:C000                      waitForHeader:
      29.  00:C000  26 20                       ld h,HIGH usbrd
      30.  00:C002  7E                          ld a,(hl)
      31.  00:C003  FE BB               .chkbb: cp $bb
      32.  00:C005  20 F9                       jr nz,waitForHeader
      33.  00:C007  7E                          ld a,(hl)
      34.  00:C008  FE 55                       cp $55
      35.  00:C00A  20 F7                       jr nz,.chkbb       
      36.  00:C00C                      
      37.  00:C00C  7E                          ld a,(hl)
      38.  00:C00D  FE A2                       cp $a2
      39.  00:C00F  CA 56 C0                    jp z,verifyFlash
      40.  00:C012  FE A3                       cp $a3
      41.  00:C014  28 1B                       jr z,writeFlash
      42.  00:C016  FE A4                       cp $a4
      43.  00:C018  20 E6                       jr nz,waitForHeader
      44.  00:C01A                      
      45.  00:C01A                      chipErase:
      46.  00:C01A                              ;DEBUGMESSAGE "erase"
      47.  00:C01A  CD 74 C0                    call updateBar
      48.  00:C01D  3E 80                       ld a,$80
      49.  00:C01F  CD 79 C0                    call AM29F040Command
      50.  00:C022  3E 10                       ld a,$10
      51.  00:C024  CD 79 C0                    call AM29F040Command
      52.  00:C027                      
      53.  00:C027  3A 00 40            .wait:  ld a,($4000)                    ; read DQ7 (data# polling) 
      54.  00:C02A  07                          rlca
      55.  00:C02B  30 FA                       jr nc,.wait        
      56.  00:C02D  3E 01                       ld a,1
      57.  00:C02F  18 39                       jr acknowledge
      58.  00:C031                              
      59.  00:C031                      writeFlash:
      60.  00:C031                              ;DEBUGMESSAGE "write"
      61.  00:C031  5E                          ld e,(hl)                       ; address
      62.  00:C032  56                          ld d,(hl)
      63.  00:C033                      
      64.  00:C033  7A                          ld a,d
      65.  00:C034  B3                          or e
      66.  00:C035  CC 74 C0                    call z,updateBar
      67.  00:C038                      
      68.  00:C038  7E                          ld a,(hl)                       ; bank
      69.  00:C039  32 00 60                    ld (mapper),a
      70.  00:C03C  26 40                       ld h,$40
      71.  00:C03E                              
      72.  00:C03E  06 80                       ld b,128                        ; data is written in blocks of 128 bytes
      73.  00:C040  3E A0               .loop:  ld a,$a0
      74.  00:C042  CD 79 C0                    call AM29F040Command
      75.  00:C045  3A 00 20                    ld a,(usbrd)
      76.  00:C048  12                          ld (de),a                       ; write data to flash
      77.  00:C049  13                          inc de
      78.  00:C04A                      
      79.  00:C04A  7E                  .wait:  ld  a,(hl)                      ; write complete?
      80.  00:C04B  AE                          xor (hl)
      81.  00:C04C  E6 40                       and %01000000
      82.  00:C04E  20 FA                       jr  nz,.wait
      83.  00:C050  10 EE                       djnz .loop
      84.  00:C052                              
      85.  00:C052  3E 02                       ld a,2
      86.  00:C054  18 14                       jr acknowledge        
      87.  00:C056                              
      88.  00:C056                      verifyFlash:
      89.  00:C056                              ;DEBUGMESSAGE "verify"
      90.  00:C056  21 00 20                    ld hl,usbrd
      91.  00:C059  5E                          ld e,(hl)                       ; address
      92.  00:C05A  56                          ld d,(hl)
      93.  00:C05B  7E                          ld a,(hl)                       ; bank
      94.  00:C05C  32 00 60                    ld (mapper),a
      95.  00:C05F                      
      96.  00:C05F  06 80                       ld b,128
      97.  00:C061  1A                  .loop:  ld a,(de)
      98.  00:C062  32 00 40                    ld (usbwr),a
      99.  00:C065  13                          inc de
     100.  00:C066  10 F9                       djnz .loop
     101.  00:C068                      
     102.  00:C068  3E 03                       ld a,3
     103.  00:C06A                      acknowledge:        
     104.  00:C06A  26 40                       ld h,HIGH usbwr
     105.  00:C06C  36 AA                       ld (hl),$aa
     106.  00:C06E  36 55                       ld (hl),$55
     107.  00:C070  77                          ld (hl),a
     108.  00:C071  C3 00 C0                    jp waitForHeader
     109.  00:C074                      
     110.  00:C074                      updateBar:
     111.  00:C074  3E 77                       ld a,"w"  
     112.  00:C076  D3 98                       out ($98),a
     113.  00:C078  C9                          ret
     114.  00:C079                      
     115.  00:C079                      AM29F040Command:
     116.  00:C079  F5                          push af
     117.  00:C07A  3E AA                       ld a,$aa
     118.  00:C07C  32 55 05                    ld ($0555),a
     119.  00:C07F  2F                          cpl
     120.  00:C080  32 AA 02                    ld ($02aa),a
     121.  00:C083  F1                          pop af
     122.  00:C084  32 55 05                    ld ($0555),a
     123.  00:C087  C9                          ret
     124.  00:C088                              
     125.  00:C088                      flasherEnd:
     126.  00:C088  (7D57)                      DEPHASE
      65   00:7D57                              include "device.asm"
       1.  00:7D57                      ; device.asm
       2.  00:7D57                      ; implements a basic now: device
       3.  00:7D57                          
       4.  00:7D57                      device:
       5.  00:7D57  E5                          push hl
       6.  00:7D58  21 69 7D                    ld hl,deviceFunctions
       7.  00:7D5B  0F                          rrca
       8.  00:7D5C  3C                          inc a
       9.  00:7D5D  07                          rlca
      10.  00:7D5E  85                          add a,l
      11.  00:7D5F  6F                          ld l,a
      12.  00:7D60  30 01                       jr nc,.nocy
      13.  00:7D62  24                          inc h  
      14.  00:7D63  7E                  .nocy:  ld a,(hl)
      15.  00:7D64  23                          inc hl
      16.  00:7D65  66                          ld h,(hl)
      17.  00:7D66  6F                          ld l,a
      18.  00:7D67  E3                          ex (sp),hl
      19.  00:7D68  C9                          ret
      20.  00:7D69                      
      21.  00:7D69                      deviceFunctions:
      22.  00:7D69  7F 7D                       dw identifyDevice               ; 0xff
      23.  00:7D6B  9F 7D                       dw open                         ;  0
      24.  00:7D6D  D7 7D                       dw close                        ;  2
      25.  00:7D6F  DD 7D                       dw randomIO                     ;  4
      26.  00:7D71  E1 7D                       dw write                        ;  6
      27.  00:7D73  E7 7D                       dw read                         ;  8
      28.  00:7D75  3D 7E                       dw loc                          ; 10
      29.  00:7D77  4F 7E                       dw lof                          ; 12
      30.  00:7D79  1B 7E                       dw eof                          ; 14
      31.  00:7D7B  4F 7E                       dw fpos                         ; 16
      32.  00:7D7D  4F 7E                       dw putback                      ; 18
      33.  00:7D7F                                
      34.  00:7D7F                      identifyDevice:
      35.  00:7D7F                              DEBUGMESSAGE "identifyDevice"
      35.  00:7D7F                    >         ifdef DEBUG
      35.  00:7D7F  52                >         ld d,d
      35.  00:7D80  18 0E             >         jr .skip
      35.  00:7D82                    >         db string
      35.  00:7D82  69 64 65 6E 74 69 66 79 44 65 76 69 63 65 
      35.  00:7D90                    > .skip:
      35.  00:7D90                    >         endif
      36.  00:7D90  21 98 7D                    ld hl,deviceNameList
      37.  00:7D93  CD 3B 73                    call findStatementName
      38.  00:7D96  7E                          ld a,(hl)                       ; device number
      39.  00:7D97  C9                          ret                             ; carry is set when invalid device name
      40.  00:7D98                              
      41.  00:7D98                      deviceNameList:
      42.  00:7D98  4E 4F 57 00 00 00           db "NOW",0,0,0                  ; name, end marker, device number, dummy
      43.  00:7D9E                              ;db "STDIN",0,1,0
      44.  00:7D9E  00                          db 0
      45.  00:7D9F                      
      46.  00:7D9F                      ; Input     D   Global device code
      47.  00:7D9F                      ;           E   File mode    
      48.  00:7D9F                      ;           HL  address fcb
      49.  00:7D9F                      open:
      50.  00:7D9F                      ;        DEBUGMESSAGE "open"
      51.  00:7D9F                      ;        DEBUGDUMPMEMHL 9
      52.  00:7D9F  22 64 F8                    ld (PTRFIL),hl
      53.  00:7DA2  CD 67 73                    call sendRegisters
      54.  00:7DA5  36 88                       ld (hl),C_DEVICEOPEN
      55.  00:7DA7  EB                          ex de,hl
      56.  00:7DA8  01 0B 00                    ld bc,11
      57.  00:7DAB  21 66 F8                    ld hl,FILNAM
      58.  00:7DAE  ED B0                       ldir
      59.  00:7DB0                      
      60.  00:7DB0  CD 2E 75                    call enableNowindPage0
      61.  00:7DB3  26 20                       ld h,HIGH usbrd
      62.  00:7DB5  CD 79 73                    call getHeader
      63.  00:7DB8  38 0C                       jr c,deviceIoError              ; time out?
      64.  00:7DBA  B7                          or a
      65.  00:7DBB  20 0B                       jr nz,openError
      66.  00:7DBD                      
      67.  00:7DBD  5E                          ld e,(hl)                       ; update fcb (including buffer)
      68.  00:7DBE  56                          ld d,(hl)
      69.  00:7DBF  4E                          ld c,(hl)
      70.  00:7DC0  46                          ld b,(hl)
      71.  00:7DC1  ED B0                       ldir
      72.  00:7DC3  C3 39 75                    jp restorePage0        
      73.  00:7DC6                      
      74.  00:7DC6                      deviceIoError:
      75.  00:7DC6  3E 13                       ld a,19
      76.  00:7DC8                      
      77.  00:7DC8                      openError:
      78.  00:7DC8  CD 39 75                    call restorePage0
      79.  00:7DCB  5F                          ld e,a
      80.  00:7DCC                      
      81.  00:7DCC                      basicError:
      82.  00:7DCC  DD 21 6F 40                 ld ix,$406f
      83.  00:7DD0  FD 2A C0 FC                 ld iy,(EXPTBL-1)
      84.  00:7DD4  C3 1C 00                    jp CALSLT
      85.  00:7DD7                                      
      86.  00:7DD7                      close:
      87.  00:7DD7                      ;        DEBUGMESSAGE "close"
      88.  00:7DD7  CD 67 73                    call sendRegisters
      89.  00:7DDA  36 89                       ld (hl),C_DEVICECLOSE
      90.  00:7DDC  C9                          ret
      91.  00:7DDD                              
      92.  00:7DDD                      randomIO:
      93.  00:7DDD                      ;        DEBUGMESSAGE "randomIO"
      94.  00:7DDD  1E 3D                       ld e,61                         ; bad file mode
      95.  00:7DDF  18 EB                       jr basicError
      96.  00:7DE1                      
      97.  00:7DE1                      write:
      98.  00:7DE1                      ;        DEBUGMESSAGE "write"
      99.  00:7DE1  CD 67 73                    call sendRegisters
     100.  00:7DE4  36 8B                       ld (hl),C_DEVICEWRITE
     101.  00:7DE6  C9                          ret        
     102.  00:7DE7                      
     103.  00:7DE7                      read:
     104.  00:7DE7                      ;        DEBUGMESSAGE "read"
     105.  00:7DE7  11 06 00                    ld de,6
     106.  00:7DEA  19                          add hl,de
     107.  00:7DEB  E5                          push hl
     108.  00:7DEC  5E                          ld e,(hl)
     109.  00:7DED  23                          inc hl
     110.  00:7DEE  23                          inc hl
     111.  00:7DEF  23                          inc hl
     112.  00:7DF0  19                          add hl,de
     113.  00:7DF1  7E                          ld a,(hl)
     114.  00:7DF2  E1                          pop hl
     115.  00:7DF3  FE 1A                       cp $1a
     116.  00:7DF5  37                          scf
     117.  00:7DF6  C8                          ret z                           ; end of file
     118.  00:7DF7  3F                          ccf
     119.  00:7DF8  34                          inc (hl)                        ; increment position
     120.  00:7DF9  C0                          ret nz                          ; buffer empty?
     121.  00:7DFA                              
     122.  00:7DFA  F5                          push af
     123.  00:7DFB  2B                          dec hl
     124.  00:7DFC  34                          inc (hl)                        ; increment position (high)        
     125.  00:7DFD  11 FB FF                    ld de,-5
     126.  00:7E00  19                          add hl,de
     127.  00:7E01  CD 67 73                    call sendRegisters
     128.  00:7E04  36 8C                       ld (hl),C_DEVICEREAD
     129.  00:7E06  CD 2E 75                    call enableNowindPage0
     130.  00:7E09  26 20                       ld h,HIGH usbrd
     131.  00:7E0B  CD 79 73                    call getHeader
     132.  00:7E0E  38 B6                       jr c,deviceIoError
     133.  00:7E10                      
     134.  00:7E10  5E                          ld e,(hl)
     135.  00:7E11  56                          ld d,(hl)
     136.  00:7E12  4E                          ld c,(hl)
     137.  00:7E13  46                          ld b,(hl)
     138.  00:7E14  ED B0                       ldir                            ; update fcb buffer
     139.  00:7E16  CD 39 75                    call restorePage0
     140.  00:7E19  F1                          pop af                          ; return last character
     141.  00:7E1A  C9                          ret
     142.  00:7E1B                      
     143.  00:7E1B                      eof:
     144.  00:7E1B                      ;        DEBUGMESSAGE "eof"
     145.  00:7E1B  7E                          ld a,(hl)
     146.  00:7E1C  FE 01                       cp 1                            ; input mode?        
     147.  00:7E1E  1E 3D                       ld e,61                         ; bad file mode
     148.  00:7E20  C2 CC 7D                    jp nz,basicError
     149.  00:7E23                                      
     150.  00:7E23  11 06 00                    ld de,6
     151.  00:7E26  19                          add hl,de
     152.  00:7E27  5E                          ld e,(hl)
     153.  00:7E28  23                          inc hl
     154.  00:7E29  23                          inc hl
     155.  00:7E2A  23                          inc hl
     156.  00:7E2B  19                          add hl,de
     157.  00:7E2C  7E                          ld a,(hl)
     158.  00:7E2D  ED 62                       sbc hl,hl
     159.  00:7E2F  FE 1A                       cp $1a        
     160.  00:7E31  20 01                       jr nz,.skip
     161.  00:7E33  2B                          dec hl
     162.  00:7E34  22 F8 F7            .skip:  ld (DAC+2),hl
     163.  00:7E37  3E 02                       ld a,2
     164.  00:7E39  32 63 F6                    ld (VALTYP),a
     165.  00:7E3C  C9                          ret
     166.  00:7E3D                      
     167.  00:7E3D                      loc:
     168.  00:7E3D  E5                          push hl
     169.  00:7E3E  FD E1                       pop iy
     170.  00:7E40  FD 6E 06                    ld l,(iy+6)
     171.  00:7E43  FD 66 05                    ld h,(iy+5)
     172.  00:7E46                      ;        DEBUGASSERT
     173.  00:7E46  22 F8 F7                    ld (DAC+2),hl
     174.  00:7E49  3E 02                       ld a,2
     175.  00:7E4B  32 63 F6                    ld (VALTYP),a
     176.  00:7E4E  C9                          ret
     177.  00:7E4F                              
     178.  00:7E4F                      putback:
     179.  00:7E4F                      ;        DEBUGMESSAGE "putback"
     180.  00:7E4F                      ;        push hl
     181.  00:7E4F                      ;        pop iy
     182.  00:7E4F                      ;        ld (iy+3),c
     183.  00:7E4F                      ;        DEBUGASSERT
     184.  00:7E4F                      ;        ret
     185.  00:7E4F                      
     186.  00:7E4F                      lof:
     187.  00:7E4F                      fpos:
     188.  00:7E4F                              DEBUGMESSAGE "no support!"
     188.  00:7E4F                    >         ifdef DEBUG
     188.  00:7E4F  52                >         ld d,d
     188.  00:7E50  18 0B             >         jr .skip
     188.  00:7E52                    >         db string
     188.  00:7E52  6E 6F 20 73 75 70 70 6F 72 74 21 
     188.  00:7E5D                    > .skip:
     188.  00:7E5D                    >         endif
     189.  00:7E5D                      
     190.  00:7E5D                      illegalFunctionCall:
     191.  00:7E5D  1E 05                       ld e,5
     192.  00:7E5F  C3 CC 7D                    jp basicError
     193.  00:7E62                      
     194.  00:7E62                      ;FCB for DISK BASIC
     195.  00:7E62                      ; +0 FL.MOD     file mode
     196.  00:7E62                      ; +1 FL.FCA     Pointer to FCB for BDOS (low)
     197.  00:7E62                      ; +2 FL.LCA     Pointer to FCB for BDOS (high)
     198.  00:7E62                      ; +3 FL.LSA     Back up character
     199.  00:7E62                      ; +4 FL.DSK     device number
     200.  00:7E62                      ; +5 FL.SLB
     201.  00:7E62                      ; +6 FL.BPS     Position in FL.BUF
     202.  00:7E62                      ; +7 FL.FLG     Holds various information
     203.  00:7E62                      ; +8 FL.OPS     Pseudo head position
     204.  00:7E62                      ; +9 FL.BUF     256-byte file buffer
     205.  00:7E62                      
     206.  00:7E62                      ; device codes
     207.  00:7E62                      ;          SS0           SS1           SS2           SS3
     208.  00:7E62                      ;    ---------------------------------------------------------
     209.  00:7E62                      ;    | 00 04 08 0C | 10 14 18 1C | 20 24 28 2C | 30 34 38 3C | PS0
     210.  00:7E62                      ;    ---------------------------------------------------------
     211.  00:7E62                      ;    | 40 44 48 4C | 50 54 58 5C | 60 64 68 6C | 70 74 78 7C | PS1
     212.  00:7E62                      ;    ---------------------------------------------------------
     213.  00:7E62                      ;    | 80 84 88 8C | 90 94 98 9C | A0 A4 A8 AC | B0 B4 B8 BC | PS2
     214.  00:7E62                      ;    ---------------------------------------------------------
     215.  00:7E62                      ;    | C0 C4 C8 CC | D0 D4 D8 DC | E0 E4 E8 EC | F0 F4 F8 FC | PS3
     216.  00:7E62                      ;    ---------------------------------------------------------
     217.  00:7E62                      
     218.  00:7E62                      ; fileModes
     219.  00:7E62                      ; FOR INPUT (01H)
     220.  00:7E62                      ; FOR OUTPUT (02H)
     221.  00:7E62                      ; FOR APPEND (08H)
     222.  00:7E62                      ; random mode (04H)
     223.  00:7E62                      
     224.  00:7E62                      ; maximum number of files open: MAXFILES=15
     225.  00:7E62                              
     226.  00:7E62                      ; File Control Block
     227.  00:7E62                      ;       0     1     2     3     4     5     6     7     8
     228.  00:7E62                      ;    -------------------------------------------------------
     229.  00:7E62                      ;    | Mod | 00H | 00H | 00H | DEV | 00H | POS | 00H | PPS |
     230.  00:7E62                      ;    -------------------------------------------------------
     231.  00:7E62                      ;                  err? bckup       posHi 
     232.  00:7E62                      ; followed by a 256 byte buffer
      66   00:7E62                      
      67   00:7E62  FF (402)                    ds $8000-$-12, $ff
      68   00:7FF4                      
      69   00:7FF4                      ; bank switching and data transfer
      70   00:7FF4                      copyFromBank:
      71   00:7FF4  32 00 60                    ld (mapper),a                   ; no not remove!
      72   00:7FF7  ED B0                       ldir                            ; no not remove!
      73   00:7FF9                      enableBank0:
      74   00:7FF9  AF                          xor a                           ; no not remove!
      75   00:7FFA  F5                          push af                         ; no not remove!
      76   00:7FFB  32 00 60                    ld (mapper),a                   ; no not remove!
      77   00:7FFE  F1                          pop af                          ; no not remove!
      78   00:7FFF  C9                          ret                             ; no not remove!
      79   00:8000                      
      80   00:8000  (01)                        page 1
      81   01:4000                      
      82   01:4000  (C000)                      incbin "..\roms\MSXDOS23.ROM", $4000, 3 * $4000
      83   01!0000                      
      84   01!0000  (02)                        page 2  
      85   02:4000  (60000)                     incbin "..\roms\romdisk.bin"        
      86   02!4000                              romheader 28
      86   02!4000  (02:4000)         > .addr := $4000
      86   02!4000                    >         repeat r
      86   02!4000                    <         code ! .addr
      86   02!4000                    < 
      86   02!4000                    <         org $4000
      86   02!4000                    <         db "AB"
      86   02!4000                    <         dw .init
      86   02!4000                    <         ds 12,0
      86   02!4000                    < 
      86   02!4000                    <         call .redir
      86   02!4000                    <         call .redir
      86   02!4000                    <         call .redir
      86   02!4000                    <         call .redir
      86   02!4000                    <         call .redir
      86   02!4000                    <         ds 3,0
      86   02!4000                    < 
      86   02!4000                    <         code ! .addr + $3fe7
      86   02!4000                    <         org $7fe7
      86   02!4000                    <         
      86   02!4000                    < .init:  ld hl,romInit
      86   02!4000                    <         push hl
      86   02!4000                    <         jr .enableBank0
      86   02!4000                    < 
      86   02!4000                    < .redir: ex (sp),hl
      86   02!4000                    <         dec hl
      86   02!4000                    <         dec hl
      86   02!4000                    <         dec hl
      86   02!4000                    <         ex (sp),hl
      86   02!4000                    <         jr .enableBank0
      86   02!4000                    < 
      86   02!4000                    <         ld (mapper),a
      86   02!4000                    <         ldir
      86   02!4000                    < .enableBank0:
      86   02!4000                    <         push af
      86   02!4000                    <         xor a
      86   02!4000                    <         ld (mapper),a
      86   02!4000                    <         pop af
      86   02!4000                    <         ret
      86   02!4000                    <         
      86   02!4000                    < .@addr := .addr + $4000
      86   02!4000                    <         endrepeat
      86   02!4000  41 42 E7 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 
      86   02!64010 CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 
      86   02!64020032 00 60 ED B0 F5 AF 32 00 60 F1 C9 41 42 E7 7F 
      86   02!640300CD ED 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 21 
      86   02!640400D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 32 00 60 ED 
      86   02!640500B0 F5 AF 32 00 60 F1 C9 41 42 E7 7F CD ED 7F CD 
      86   02!640600ED 7F CD ED 7F CD ED 7F CD ED 7F 21 D6 47 E5 18 
      86   02!6407000C E3 2B 2B 2B E3 18 05 32 00 60 ED B0 F5 AF 32 
      86   02!64080000 60 F1 C9 41 42 E7 7F CD ED 7F CD ED 7F CD ED 
      86   02!6409007F CD ED 7F CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 
      86   02!640A002B E3 18 05 32 00 60 ED B0 F5 AF 32 00 60 F1 C9 
      86   02!640B0041 42 E7 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 
      86   02!640C00CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 
      86   02!640D0032 00 60 ED B0 F5 AF 32 00 60 F1 C9 41 42 E7 7F 
      86   02!640E00CD ED 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 21 
      86   02!640F00D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 32 00 60 ED 
      86   02!641000B0 F5 AF 32 00 60 F1 C9 41 42 E7 7F CD ED 7F CD 
      86   02!641100ED 7F CD ED 7F CD ED 7F CD ED 7F 21 D6 47 E5 18 
      86   02!6412000C E3 2B 2B 2B E3 18 05 32 00 60 ED B0 F5 AF 32 
      86   02!64130000 60 F1 C9 41 42 E7 7F CD ED 7F CD ED 7F CD ED 
      86   02!6414007F CD ED 7F CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 
      86   02!6415002B E3 18 05 32 00 60 ED B0 F5 AF 32 00 60 F1 C9 
      86   02!64160041 42 E7 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 
      86   02!641700CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 
      86   02!64180032 00 60 ED B0 F5 AF 32 00 60 F1 C9 41 42 E7 7F 
      86   02!641900CD ED 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 21 
      86   02!641A00D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 32 00 60 ED 
      86   02!641B00B0 F5 AF 32 00 60 F1 C9 41 42 E7 7F CD ED 7F CD 
      86   02!641C00ED 7F CD ED 7F CD ED 7F CD ED 7F 21 D6 47 E5 18 
      86   02!641D000C E3 2B 2B 2B E3 18 05 32 00 60 ED B0 F5 AF 32 
      86   02!641E0000 60 F1 C9 41 42 E7 7F CD ED 7F CD ED 7F CD ED 
      86   02!641F007F CD ED 7F CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 
      86   02!6420002B E3 18 05 32 00 60 ED B0 F5 AF 32 00 60 F1 C9 
      86   02!64210041 42 E7 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 
      86   02!642200CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 
      86   02!64230032 00 60 ED B0 F5 AF 32 00 60 F1 C9 41 42 E7 7F 
      86   02!642400CD ED 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 21 
      86   02!642500D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 32 00 60 ED 
      86   02!642600B0 F5 AF 32 00 60 F1 C9 41 42 E7 7F CD ED 7F CD 
      86   02!642700ED 7F CD ED 7F CD ED 7F CD ED 7F 21 D6 47 E5 18 
      86   02!6428000C E3 2B 2B 2B E3 18 05 32 00 60 ED B0 F5 AF 32 
      86   02!64290000 60 F1 C9 41 42 E7 7F CD ED 7F CD ED 7F CD ED 
      86   02!642A007F CD ED 7F CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 
      86   02!642B002B E3 18 05 32 00 60 ED B0 F5 AF 32 00 60 F1 C9 
      86   02!642C0041 42 E7 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 
      86   02!642D00CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 
      86   02!642E0032 00 60 ED B0 F5 AF 32 00 60 F1 C9 41 42 E7 7F 
      86   02!642F00CD ED 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 21 
      86   02!643000D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 32 00 60 ED 
      86   02!643100B0 F5 AF 32 00 60 F1 C9 41 42 E7 7F CD ED 7F CD 
      86   02!643200ED 7F CD ED 7F CD ED 7F CD ED 7F 21 D6 47 E5 18 
      86   02!6433000C E3 2B 2B 2B E3 18 05 32 00 60 ED B0 F5 AF 32 
      86   02!64340000 60 F1 C9 41 42 E7 7F CD ED 7F CD ED 7F CD ED 
      86   02!6435007F CD ED 7F CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 
      86   02!6436002B E3 18 05 32 00 60 ED B0 F5 AF 32 00 60 F1 C9 
      86   02!64370041 42 E7 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 
      86   02!643800CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 
      86   02!64390032 00 60 ED B0 F5 AF 32 00 60 F1 C9 41 42 E7 7F 
      86   02!643A00CD ED 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 21 
      86   02!643B00D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 32 00 60 ED 
      86   02!643C00B0 F5 AF 32 00 60 F1 C9 41 42 E7 7F CD ED 7F CD 
      86   02!643D00ED 7F CD ED 7F CD ED 7F CD ED 7F 21 D6 47 E5 18 
      86   02!643E000C E3 2B 2B 2B E3 18 05 32 00 60 ED B0 F5 AF 32 
      86   02!643F0000 60 F1 C9 41 42 E7 7F CD ED 7F CD ED 7F CD ED 
      86   02!6440007F CD ED 7F CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 
      86   02!6441002B E3 18 05 32 00 60 ED B0 F5 AF 32 00 60 F1 C9 
      86   02!64420041 42 E7 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 
      86   02!644300CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 
      86   02!64440032 00 60 ED B0 F5 AF 32 00 60 F1 C9 41 42 E7 7F 
      86   02!644500CD ED 7F CD ED 7F CD ED 7F CD ED 7F CD ED 7F 21 
      86   02!644600D6 47 E5 18 0C E3 2B 2B 2B E3 18 05 32 00 60 ED 
      86   02!644700B0 F5 AF 32 00 60 F1 C9 41 42 E7 7F CD ED 7F CD 
      86   02!644800ED 7F CD ED 7F CD ED 7F CD ED 7F 21 D6 47 E5 18 
      86   02!6449000C E3 2B 2B 2B E3 18 05 32 00 60 ED B0 F5 AF 32 
      86   02!644A0000 60 F1 C9 41 42 E7 7F CD ED 7F CD ED 7F CD ED 
      86   02!644B007F CD ED 7F CD ED 7F 21 D6 47 E5 18 0C E3 2B 2B 
      86   02!644C002B E3 18 05 32 00 60 ED B0 F5 AF 32 00 60 F1 C9 

    LABELS
---------------------------------------
00:000047D6   romInit
00:0000746A   printText
00:0000000C X RDSLT
00:00000014 X WRSLT
00:0000001C   CALSLT
00:00000024   ENASLT
00:0000005F   CHGMOD
00:00000141   SNSMAT
00:0000015F   EXTROM
00:00000185   SDFSCR
00:0000F33F   LASTDRV
00:0000F342   RAMAD1
00:0000F36E   XFER
00:0000F663   VALTYP
00:0000F7F6   DAC
00:0000F864   PTRFIL
00:0000F866   FILNAM
00:0000FCC1   EXPTBL
00:0000FCC5   SLTTBL
00:0000FCC9 X SLTATR
00:0000FD09   SLTWRK
00:0000FD89   PROCNM
00:0000FD99   DEVICE
00:0000FFCA   EXTBIO
00:0000402D   GETSLT
00:0000FECB X H.RUNC
00:00004000   usbwr
00:00002000   usbrd
00:00008000   usb2
00:00006000   mapper
00:00000080   C_DSKIO
00:00000081   C_DSKCHG
00:00000082   C_GETDPB
00:00000083 X C_CHOICE
00:00000084 X C_DSKFMT
00:00000085   C_DRIVES
00:00000086   C_INIENV
00:00000087 X C_SETDATE
00:00000088   C_DEVICEOPEN
00:00000089   C_DEVICECLOSE
00:0000008A X C_DEVICERNDIO
00:0000008B   C_DEVICEWRITE
00:0000008C   C_DEVICEREAD
00:0000008D X C_DEVICEEOF
00:0000008E   C_AUXIN
00:0000008F   C_AUXOUT
00:00000090   C_MESSAGE
00:000000A0   C_CHANGEIMAGE
00:000000A1   C_BOOTCODE
00:000072F0   nowindInit
00:00007323   initDiskBasic
00:0000733B   findStatementName
00:00007352   findStatementName.loop
00:0000735C   findStatementName.nextStatement
00:00007367   sendRegisters
00:00007379   getHeader
00:0000737B   getHeader.loop
00:0000737C   getHeader.chkaf
00:000073A0   getHeader.chk05
00:000073A7   sendMessage
00:000073B1   sendMessage.loop
00:000073BD   newAUX
00:000073C7   AUXin
00:000073F5   AUXin.exit
00:000073FB   AUXin.getCharacter
00:0000740C   AUXout
00:00007424 X insertBootCode
00:0000744B X sdendFCB
00:0000744F   sdendFCB.loop
00:00007459 X receiveFCB
00:0000745D   receiveFCB.loop
00:0000746A   printRoutineVoorDos23
00:00007470   L5F8C
00:00007479   installExtendedBios
00:000074AE   extendedBios
00:000074B5   extendedBios.exit
00:000074C3   determineFunction
00:000074CF   functionTable
00:000074D5   getNowindSlot
00:000074F1   numberOfDevices
00:00007508   debugMessage
00:00007524   debugMessage.loop
00:0000752E   enableNowindPage0
00:00007539   restorePage0
00:00007542   enableSlotPage0
00:00007553   enableSlotPage0.expanded
00:0000757E   getSlotPage0
00:00007589   getSlotPage1
00:00007594   getSlotPage2
00:000075A3   expanded
00:000075B7   notExpanded
00:000075B9   getEntrySLTWRK
00:00000008   MYSIZE
00:00000200   SECLEN
00:000075CE   INIHRD
00:000075DD   INIHRD.loop
00:000075F1   DRIVES
00:00007634   DRIVES.exit
00:0000763D   DRIVES.notconnected
00:0000765A   INIENV
00:0000769E   INIENV.exit
00:000076A1   checkWorkArea
00:000076AC   DSKIO
00:000076C3 X dskioRead
00:0000B6E0   dskioRead.page2
00:000076F5   dskioRead.page1
00:00007705   dskioRead.page2and3
00:0000771B   dskioWrite
00:0000B73B   dskioWrite.page2
00:00007751   dskioWrite.page1
00:00007767   dskioWrite.page2and3
00:0000777C   dskioWrite.writeLoop23
00:000077AC   dskioWrite.error
00:000077AF   DSKCHG
00:000077E6   GETDPB
00:0000781C   GETDPB.hddImage
00:0000784F   GETDPB.exit
00:00007852   CHOICE
00:00007856   CHOICE.noFormat
00:00007857   DSKFMT
00:0000B85B   readSectors01
00:0000B87D   readSectors01.slowTransfer
00:0000B889   writeLoop01
00:0000B8AB   writeLoop01.error
00:000078AE   readSectors23
00:000078D2   readSectors23.slowTransfer
00:000078EF   reverseTransfer
00:000078FB   reverseTransfer.loop
00:00007962   OEMSTA
00:00007970   OEMSTA.statement
00:00007983   changeImage
00:00007998   call_exit
00:000079A4   call_exit.loop
00:000079B0   videoStream
00:000079B1 X vramDump
00:000079BD   evenFrame
00:000079DA X oddFrame
00:000079FA   tranferframe
00:00007A07   write_more
00:00007B14   changeColors
00:00007B62   setVramAccessPointer
00:00007B70   waitForRetrace
00:00007B76   waitForRetrace.lp2
00:00007B81   printText2
00:00007B82   printText2.loop
00:00007B8B   supportedMedia
00:00007B8B X supportedMedia.f8
00:00007B9D   supportedMedia.def
00:00007B9D   DEFDPB
00:00007C1B   ROMDISK_DSKIO
00:00007C2A   ROMDISK_DSKIO.loop
00:00007C4C   ROMDISK_DSKIO.directCopy
00:00007C52   ROMDISK_DSKIO.nextSector
00:00007C58   ROMDISK_DSKIO.findSector
00:00007C6D   ROMDISK_DSKIO.skip
00:00007C7A   ROMDISK_DSKCHG
00:00007C7F X ROMDISK_GETDPB
00:00007C7F X ROMDISK_DSKFMT
00:00007C7F   flashWriter
00:00007CCF   flashWriter.source
00:0000C000   waitForHeader
00:0000C003   waitForHeader.chkbb
00:0000C01A X chipErase
00:0000C027   chipErase.wait
00:0000C031   writeFlash
00:0000C040   writeFlash.loop
00:0000C04A   writeFlash.wait
00:0000C056   verifyFlash
00:0000C061   verifyFlash.loop
00:0000C06A   acknowledge
00:0000C074   updateBar
00:0000C079   AM29F040Command
00:0000C088   flasherEnd
00:00007D57   device
00:00007D63   device.nocy
00:00007D69   deviceFunctions
00:00007D7F   identifyDevice
00:00007D98   deviceNameList
00:00007D9F   open
00:00007DC6   deviceIoError
00:00007DC8   openError
00:00007DCC   basicError
00:00007DD7   close
00:00007DDD   randomIO
00:00007DE1   write
00:00007DE7   read
00:00007E1B   eof
00:00007E34   eof.skip
00:00007E3D   loc
00:00007E4F   putback
00:00007E4F   lof
00:00007E4F   fpos
00:00007E5D X illegalFunctionCall
00:00007FF4   copyFromBank
00:00007FF9 X enableBank0


Output: nowindDos23.out
--------------------------------------

 Page: 00
  Org: 00004000  Size: *  Used: 00000000

    No output

Output: nowindDos2.rom
--------------------------------------

 Page: 00
  Org: 00004000  Size: 00004000  Used: 00004000

   Address   Length Align  Label
   00004000   13040        
   000072F0    3344     @  nowindInit

  Overlay parts:
   Address   Length Align  Label
   00004006       2     @  
   00004010      18     @  
   000047D7       2     @  
   00004881       1     @  
   00004884       1     @  
   0000488D       2     @  
   0000489F       2     @  
   000048B9       2     @  
   000048EB       2     @  
   000048F7       2     @  
   000049A3      16     @  
   00005797       2     @  

 Page: 01
  Org: 00004000  Size: 0000C000  Used: 0000C000

   Address   Length Align  Label
   00004000   49152        

 Page: 02
  Org: 00004000  Size: 00070000  Used: 00070000

   Address   Length Align  Label
   00004000  393216        
   00064000   65536       <empty>

  Overlay parts:
   Address   Length Align  Label
   00004000      34     @  
   00007FE7      25     @  251.252>init
   00008000      34     @  
   0000BFE7      25     @  251.253>init
   0000C000      34     @  
   0000FFE7      25     @  251.254>init
   00010000      34     @  
   00013FE7      25     @  251.255>init
   00014000      34     @  
   00017FE7      25     @  251.256>init
   00018000      34     @  
   0001BFE7      25     @  251.257>init
   0001C000      34     @  
   0001FFE7      25     @  251.258>init
   00020000      34     @  
   00023FE7      25     @  251.259>init
   00024000      34     @  
   00027FE7      25     @  251.260>init
   00028000      34     @  
   0002BFE7      25     @  251.261>init
   0002C000      34     @  
   0002FFE7      25     @  251.262>init
   00030000      34     @  
   00033FE7      25     @  251.263>init
   00034000      34     @  
   00037FE7      25     @  251.264>init
   00038000      34     @  
   0003BFE7      25     @  251.265>init
   0003C000      34     @  
   0003FFE7      25     @  251.266>init
   00040000      34     @  
   00043FE7      25     @  251.267>init
   00044000      34     @  
   00047FE7      25     @  251.268>init
   00048000      34     @  
   0004BFE7      25     @  251.269>init
   0004C000      34     @  
   0004FFE7      25     @  251.270>init
   00050000      34     @  
   00053FE7      25     @  251.271>init
   00054000      34     @  
   00057FE7      25     @  251.272>init
   00058000      34     @  
   0005BFE7      25     @  251.273>init
   0005C000      34     @  
   0005FFE7      25     @  251.274>init
   00060000      34     @  
   00063FE7      25     @  251.275>init
   00064000      34     @  
   00067FE7      25     @  251.276>init
   00068000      34     @  
   0006BFE7      25     @  251.277>init
   0006C000      34     @  
   0006FFE7      25     @  251.278>init
   00070000      34     @  
   00073FE7      25     @  251.279>init

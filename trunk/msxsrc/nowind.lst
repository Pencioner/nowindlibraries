Sjasm Z80 Assembler v0.42b8 - www.xl2s.tk             [2010.02.10 - 22:18:05]

d:\project\nowindlibraries\msxsrc\nowind.asm
Errors: 0

       1   00:0000                              define  DEBUG
       2   00:0000                              
       3   00:0000                              ;define NOWINDVERSION_FIRSTBATCH                        ; our handmade first batch
       4   00:0000                              define  NOWINDVERSION_SUNRISE                           ; sunrise first batch
       5   00:0000                                              
       6   00:0000                              ifdef   NOWINDVERSION_FIRSTBATCH
       7   00:0000                    ~         define  FLASHROMSIZE 512
       8   00:0000                    ~         endif
       9   00:0000                                      
      10   00:0000                              ifdef   NOWINDVERSION_SUNRISE
      11   00:0000                              define  FLASHROMSIZE 4096
      12   00:0000                              endif
      13   00:0000                                      
      14   00:0000                              output  "nowind.rom"
      15   00:0000                              include "labels.asm"
       1.  00:0000                      ; BIOS routines
       2.  00:0000  (00:000C)           RDSLT           equ $000c
       3.  00:0000  (00:0014)           WRSLT           equ $0014
       4.  00:0000  (00:001C)           CALSLT          equ $001c
       5.  00:0000  (00:0024)           ENASLT          equ $0024
       6.  00:0000  (00:005F)           CHGMOD          equ $005f
       7.  00:0000  (00:0141)           SNSMAT          equ $0141
       8.  00:0000  (00:015F)           EXTROM          equ $015f
       9.  00:0000  (00:0185)           SDFSCR          equ $0185               ; restore screen parameters from clockchip (in SUBROM)
      10.  00:0000                      
      11.  00:0000                      ; BIOS variables (really?)
      12.  00:0000  (00:F33F)           LASTDRV         equ $f33f               ; stores CTRL-key status during boot
      13.  00:0000  (00:F342)           RAMAD1          equ $f342
      14.  00:0000  (00:F36E)           XFER            equ $f36e
      15.  00:0000                       
      16.  00:0000  (00:F663)           VALTYP          equ $f663
      17.  00:0000  (00:F7F6)           DAC             equ $f7f6
      18.  00:0000  (00:F864)           PTRFIL          equ $f864
      19.  00:0000  (00:F866)           FILNAM          equ $f866
      20.  00:0000                      
      21.  00:0000  (00:FCC1)           EXPTBL          equ $fcc1
      22.  00:0000  (00:FCC5)           SLTTBL          equ $fcc5
      23.  00:0000  (00:FCC9)           SLTATR          equ $fcc9
      24.  00:0000  (00:FD09)           SLTWRK          equ $fd09
      25.  00:0000  (00:FD89)           PROCNM          equ $fd89
      26.  00:0000  (00:FD99)           DEVICE          equ $fd99
      27.  00:0000  (00:FFCA)           EXTBIO          equ $ffca
      28.  00:0000                      
      29.  00:0000                      ; Diskrom routines
      30.  00:0000  (00:402D)           GETSLT          equ $402d
      31.  00:0000                               
      32.  00:0000                      ; Hooks
      33.  00:0000  (00:FECB)           H.RUNC          equ $fecb               ; Intercepted by diskrom
      34.  00:0000                      
      35.  00:0000                      ; Nowind hardware addresses
      36.  00:0000  (00:4000)           usbwr           equ $4000               ; 0x4000..0x5fff
      37.  00:0000  (00:2000)           usbrd           equ $2000               ; 0x2000..0x3fff
      38.  00:0000  (00:8000)           usb2            equ $8000               ; 0x8000..0x9fff (read and write)
      39.  00:0000  (00:6001)           mapper          equ $6001               ; 0x6001..0x7fff (odd numbers only)
      40.  00:0000                      
      41.  00:0000                      ; Host commands
      42.  00:0000  (00:0080)           C_DSKIO         equ $80
      43.  00:0000  (00:0081)           C_DSKCHG        equ $81
      44.  00:0000  (00:0082)           C_GETDPB        equ $82
      45.  00:0000  (00:0083)           C_CHOICE        equ $83
      46.  00:0000  (00:0084)           C_DSKFMT        equ $84
      47.  00:0000  (00:0085)           C_DRIVES        equ $85
      48.  00:0000  (00:0086)           C_INIENV        equ $86
      49.  00:0000  (00:0087)           C_SETDATE       equ $87
      50.  00:0000  (00:0088)           C_DEVICEOPEN    equ $88
      51.  00:0000  (00:0089)           C_DEVICECLOSE   equ $89
      52.  00:0000  (00:008A)           C_DEVICERNDIO   equ $8a
      53.  00:0000  (00:008B)           C_DEVICEWRITE   equ $8b
      54.  00:0000  (00:008C)           C_DEVICEREAD    equ $8c
      55.  00:0000  (00:008D)           C_DEVICEEOF     equ $8d
      56.  00:0000  (00:008E)           C_AUXIN         equ $8e
      57.  00:0000  (00:008F)           C_AUXOUT        equ $8f
      58.  00:0000  (00:0090)           C_MESSAGE       equ $90
      59.  00:0000  (00:0091)           C_CHANGEIMAGE   equ $91
      60.  00:0000  (00:0092)           C_GETDOSVERSION equ $92
      61.  00:0000  (00:0093)           C_CMDREQUEST    equ $93
      62.  00:0000                      
      63.  00:0000                      ; BDOS commands 0x0F - 0x37 can just use their original command code in register C
      64.  00:0000                      
      65.  00:0000                      ; PATCH       
      66.  00:0000                              macro PATCH address, word
      67.  00:0000                    <         code ! address
      68.  00:0000                    <         dw word
      69.  00:0000                    <         endmacro
      70.  00:0000                      
      71.  00:0000                      ; DEBUGMESSAGE
      72.  00:0000                              macro DEBUGMESSAGE string
      73.  00:0000                    <         ifdef DEBUG
      74.  00:0000                    <         ld d,d
      75.  00:0000                    <         jr .skip
      76.  00:0000                    <         db string
      77.  00:0000                    < .skip:  
      78.  00:0000                    <         endif
      79.  00:0000                    <         endmacro
      80.  00:0000                      
      81.  00:0000                      ; MESSAGE
      82.  00:0000                              macro MESSAGE string
      83.  00:0000                    <         call sendMessage
      84.  00:0000                    <         db string
      85.  00:0000                    < .skip2: nop
      86.  00:0000                    <         endmacro
      87.  00:0000                      
      88.  00:0000                      ; DEBUGDUMPREGISTERS
      89.  00:0000                              macro DEBUGDUMPREGISTERS
      90.  00:0000                    <         ifdef DEBUG
      91.  00:0000                    <         db $ed,7
      92.  00:0000                    <         endif
      93.  00:0000                    <         
      94.  00:0000                    <         ifdef USBDEBUG
      95.  00:0000                    <         assert ($ < $8000)
      96.  00:0000                    <         call sendCpuInfo
      97.  00:0000                    <         endif
      98.  00:0000                    <         endmacro
      99.  00:0000                      
     100.  00:0000                      ; MAKEDPB macro
     101.  00:0000                              macro MAKEDPB media, sectorSize, sectorsPerCluster, maxEnt, maxSector, fatSiz, fatCount
     102.  00:0000                    < .firfat equ 1
     103.  00:0000                    < .firdir equ .firfat+(fatCount*fatSiz)
     104.  00:0000                    < .firrec equ .firdir+(maxEnt/(sectorSize/32))
     105.  00:0000                    <         if sectorSize = 512
     106.  00:0000                    < .shft   equ 4
     107.  00:0000                    <         elseif sectorSize = 256
     108.  00:0000                    < .shft   equ 3
     109.  00:0000                    <         endif
     110.  00:0000                    <         
     111.  00:0000                    <         db media                                        ; media descriptor
     112.  00:0000                    <         dw sectorSize                                   ; sector size
     113.  00:0000                    <         db (sectorSize/32)-1, .shft                     ; dirmsk
     114.  00:0000                    <         db sectorsPerCluster-1                          ; clusmsk 
     115.  00:0000                    <         db sectorsPerCluster                            ; clusshft (TODO: only correct for 1 and 2 sec/clus)         
     116.  00:0000                    <         dw .firfat
     117.  00:0000                    <         db fatCount, maxEnt
     118.  00:0000                    <         dw .firrec
     119.  00:0000                    <         dw (maxSector-.firrec)/sectorsPerCluster+1      ; maxclus
     120.  00:0000                    <         db fatSiz
     121.  00:0000                    <         dw .firdir
     122.  00:0000                    <         endmacro
     123.  00:0000                      
     124.  00:0000                      
     125.  00:0000                      ; ROMHEADER macro
     126.  00:0000                              macro romheader r   
     127.  00:0000                    < .addr := $4000        
     128.  00:0000                    <         repeat r
     129.  00:0000                    <         code ! .addr
     130.  00:0000                    < 
     131.  00:0000                    <         org $4000
     132.  00:0000                    <         db "AB"
     133.  00:0000                    <         dw .init
     134.  00:0000                    <         ds 12,0
     135.  00:0000                    < 
     136.  00:0000                    <         call .redir                     ; DSKIO
     137.  00:0000                    <         call .redir                     ; DSKCHG
     138.  00:0000                    <         call .redir                     ; GETDPB
     139.  00:0000                    <         call .redir                     ; CHOICE
     140.  00:0000                    <         call .redir                     ; DSKFMT
     141.  00:0000                    <         ds 3,0                          ; DRVOFF
     142.  00:0000                    < 
     143.  00:0000                    <         code ! .addr + $3fe7
     144.  00:0000                    <         org $7fe7
     145.  00:0000                    <         
     146.  00:0000                    < .init:  ld hl,romInit
     147.  00:0000                    <         push hl
     148.  00:0000                    <         jr .enableBank0        
     149.  00:0000                    < 
     150.  00:0000                    < .redir: ex (sp),hl
     151.  00:0000                    <         dec hl
     152.  00:0000                    <         dec hl
     153.  00:0000                    <         dec hl
     154.  00:0000                    <         ex (sp),hl
     155.  00:0000                    <         jr .enableBank0
     156.  00:0000                    < 
     157.  00:0000                    <         ld (mapper),a                   ; copyFromBank
     158.  00:0000                    <         ldir
     159.  00:0000                    < .enableBank0:
     160.  00:0000                    <         push af                         ; enable bank 0 (no registers changed)
     161.  00:0000                    <         xor a
     162.  00:0000                    <         ld (mapper),a
     163.  00:0000                    <         pop af
     164.  00:0000                    <         ret
     165.  00:0000                    <         
     166.  00:0000                    < .@addr := .addr + $4000
     167.  00:0000                    <         endrepeat
     168.  00:0000                    <         endmacro
     169.  00:0000                      
     170.  00:0000                      ; MACRO debugdisasm
     171.  00:0000                              macro DEBUGDISASM
     172.  00:0000                    <         db $ed, $0b
     173.  00:0000                    <         endmacro
     174.  00:0000                              
     175.  00:0000                      ; MACRO debugdisasmoff
     176.  00:0000                              macro DEBUGDISASMOFF
     177.  00:0000                    <         db $ed, $0c
     178.  00:0000                    <         endmacro        
     179.  00:0000                      
     180.  00:0000                      ; MACRO breakpoint
     181.  00:0000                              macro BREAKPOINT
     182.  00:0000                    <         ld b,b
     183.  00:0000                    <         jr $+2
     184.  00:0000                    <         endmacro
     185.  00:0000                             
     186.  00:0000                              macro PRINTVDPTEXT string
     187.  00:0000                    <         
     188.  00:0000                    <         push hl
     189.  00:0000                    <         ld hl,.text 
     190.  00:0000                    <         call printVdpText2
     191.  00:0000                    <         pop hl
     192.  00:0000                    <         jr .skip
     193.  00:0000                    < .text   db string
     194.  00:0000                    <         db 0
     195.  00:0000                    < .skip:
     196.  00:0000                    <         endmacro
     197.  00:0000                      
     198.  00:0000                      ; in: all registers, 
     199.  00:0000                      ; out: h = HIGH usbwr
     200.  00:0000                      ; unchanged: bc, ix, iy
     201.  00:0000                      ; requirements: stack available
     202.  00:0000                      macro SEND_COMMAND cmd
     203.  00:0000                    <     call sendRegisters
     204.  00:0000                    <     ld (hl),cmd
     205.  00:0000                    < endmacro
     206.  00:0000                      
     207.  00:0000                      ; in: none
     208.  00:0000                      ; out: A = first received byte, H = HIGH usbrd, CF is on timeout
     209.  00:0000                      ; unchanged: de, ix, iy
     210.  00:0000                      ; requirements: nowind in page 0! (use enableNowindPage0)
     211.  00:0000                      macro GET_RESPONSE
     212.  00:0000                    <         ld h,HIGH usbrd
     213.  00:0000                    <         call getHeader
     214.  00:0000                    < endmacro
      16   00:0000                      
      17   00:0000                              defpage 0, $4000, $4000                                         ; MSXDOS2 bank 0
      18   00:0000                              defpage 1, $4000, 3 * $4000                                     ; MSXDOS2 bank 1..3
      19   00:0000                              defpage 2, $4000, $4000                                         ; MSXDOS1
      20   00:0000                              defpage 3, 0, (512-80)*1024
      21   00:0000                      
      22   00:0000                      ; insert MSXDOS2
      23   00:0000  (00)                        page 0
      24   00:4000                              module  MSXDOS2_PART
      25   00:4000                                      
      26   00:4000                              define  MSXDOSVER 2
      27   00:4000                      ;       define  ROMINIT $47d6
      28   00:4000                              define  PRINTTEXT $728e
      29   00:4000                                      
      30   00:4000  (32F0)                      incbin "..\roms\MSXDOS22.ROM", 0, $72f0-$4000
      31   00:72F0                                      
      32   00:72F0                              PATCH $4006, device
      32   00:72F0                    >         code ! address
      32   00:4006  ED 7D             >         dw word
      33   00:4008                      
      34   00:4008                              code ! $4010
      35   00:4010  C3 EF 76                    jp DSKIO
      36   00:4013  C3 F2 77                    jp DSKCHG
      37   00:4016  C3 29 78                    jp GETDPB
      38   00:4019  C3 95 78                    jp CHOICE
      39   00:401C  C3 9A 78                    jp DSKFMT
      40   00:401F  00 00 00                    db 0,0,0                        ; no DRVOFF
      41   00:4022                              
      42   00:4022                              PATCH $47d7, getBootArgs        ; INIHDR
      42   00:4022                    >         code ! address
      42   00:47D7  F0 72             >         dw word
      43   00:47D9                      ;        PATCH $47dd, 0                  ; do not check for MSX1
      44   00:47D9                              PATCH $488d, MYSIZE
      44   00:47D9                    >         code ! address
      44   00:488D  08 00             >         dw word
      45   00:488F                              PATCH $489f, SECLEN
      45   00:488F                    >         code ! address
      45   00:489F  00 02             >         dw word
      46   00:48A1                              PATCH $48b9, DRIVES
      46   00:48A1                    >         code ! address
      46   00:48B9  30 76             >         dw word
      47   00:48BB                              PATCH $48eb, DEFDPB - 1
      47   00:48BB                    >         code ! address
      47   00:48EB  DF 7B             >         dw word
      48   00:48ED                              PATCH $48f7, INIENV
      48   00:48ED                    >         code ! address
      48   00:48F7  99 76             >         dw word
      49   00:48F9                              PATCH $5797, OEMSTA
      49   00:48F9                    >         code ! address
      49   00:5797  A5 79             >         dw word
      50   00:5799                      
      51   00:5799                              PATCH $4093, mapper
      51   00:5799                    >         code ! address
      51   00:4093  01 60             >         dw word
      52   00:4095                      
      53   00:4095                              code ! $4881
      54   00:4881  98                          db LOW initDiskBasic
      55   00:4882                              code ! $4884
      56   00:4884  73                          db HIGH initDiskBasic
      57   00:4885                       
      58   00:4885                              code ! $49a3
      59   00:49A3  21 32 74                    ld hl,newAUX                    ; redirect AUX to host  
      60   00:49A6  11 27 F3                    ld de,$f327
      61   00:49A9  01 0A 00                    ld bc,10
      62   00:49AC  ED B0                       ldir
      63   00:49AE  00                          nop
      64   00:49AF  00                          nop
      65   00:49B0  00                          nop
      66   00:49B1  00                          nop
      67   00:49B2  00                          nop                             ; nops needed to override existing code!
      68   00:49B3                              
      69   00:49B3                              code @ $72f0
      70   00:72F0                                      
      71   00:72F0                      getBootArgs:              
      72   00:72F0                              DEBUGMESSAGE "Any commands?"   
      72   00:72F0                    >         ifdef DEBUG
      72   00:72F0  52                >         ld d,d
      72   00:72F1  18 0D             >         jr .skip
      72   00:72F3                    >         db string
      72   00:72F3  41 6E 79 20 63 6F 6D 6D 61 6E 64 73 3F 
      72   00:7300                    > .skip:
      72   00:7300                    >         endif
      73   00:7300  CD 6D 75                    call enableNowindPage0
      74   00:7303  0E 00                       ld c,0                      ; c=0 means reset startup queue index 
      75   00:7305  06 00               .loop:  ld b,0                      ; b=0 means request startup command
      76   00:7307                              SEND_COMMAND C_CMDREQUEST
      76   00:7307  CD DC 73          >     call sendRegisters
      76   00:730A  36 93             >     ld (hl),cmd
      77   00:730C                              GET_RESPONSE
      77   00:730C  26 20             >         ld h,HIGH usbrd
      77   00:730E  CD EE 73          >         call getHeader
      78   00:7311  A7                          and a
      79   00:7312  28 14                       jr z,noCommand
      80   00:7314                              DEBUGMESSAGE "Got command!"   
      80   00:7314                    >         ifdef DEBUG
      80   00:7314  52                >         ld d,d
      80   00:7315  18 0C             >         jr .skip
      80   00:7317                    >         db string
      80   00:7317  47 6F 74 20 63 6F 6D 6D 61 6E 64 21 
      80   00:7323                    > .skip:
      80   00:7323                    >         endif
      81   00:7323                       
      82   00:7323  7E                          ld a,(hl)
      83   00:7324                              ;cp 1
      84   00:7324                              ;jr z, Com
      85   00:7324                                      
      86   00:7324  0E 01                       ld c,1
      87   00:7326  18 DD                       jr .loop
      88   00:7328                      
      89   00:7328                      noCommand:
      90   00:7328  CD 78 75                    call restorePage0
      91   00:732B                              DEBUGMESSAGE "End of startup commands"   
      91   00:732B                    >         ifdef DEBUG
      91   00:732B  52                >         ld d,d
      91   00:732C  18 17             >         jr .skip
      91   00:732E                    >         db string
      91   00:732E  45 6E 64 20 6F 66 20 73 74 61 72 74 75 70 20 63 
      91   00:733E  6F 6D 6D 61 6E 64 73 
      91   00:7345                    > .skip:
      91   00:7345                    >         endif
      92   00:7345                      
      93   00:7345  CD DC 73                    call sendRegisters
      94   00:7348  36 92                       ld (hl),C_GETDOSVERSION
      95   00:734A  CD 6D 75                    call enableNowindPage0
      96   00:734D  26 20                       ld h,HIGH usbrd
      97   00:734F  CD EE 73                    call getHeader
      98   00:7352                      
      99   00:7352  CD 78 75                    call restorePage0
     100   00:7355  DA 5C 73                    jp c,bootMSXDOS1                ; no reply (host not connected?)
     101   00:7358                              
     102   00:7358  A7                          and a
     103   00:7359  C2 0D 76                    jp nz,INIHRD                    ; boot MSXDOS2
     104   00:735C                      
     105   00:735C                      bootMSXDOS1:
     106   00:735C  21 6F 57                    ld hl,$576f                     ; boot MSXDOS1
     107   00:735F  E5                          push hl
     108   00:7360  3E 04                       ld a,4
     109   00:7362  C3 FA 7F                    jp switchBank
     110   00:7365                                              
     111   00:7365                              include "common.asm"
       1.  00:7365                      ; Nowind specific
       2.  00:7365                      
       3.  00:7365                      nowindInit:
       4.  00:7365                              ;DEBUGMESSAGE "nowindInit"
       5.  00:7365  3A F8 FA                    ld a,($faf8)                                                                            ; moet volgens bifi ld a,($2d) zijn, $faf8 is op msx1 deel van de rs232 area?
       6.  00:7368  B7                          or a 
       7.  00:7369  F5                          push af
       8.  00:736A  CC 5F 00                    call z,CHGMOD                   ; SCREEN 0 for MSX1
       9.  00:736D  F1                          pop af
      10.  00:736E  DD 21 85 01                 ld ix,SDFSCR                    ; restore screen mode from clockchip
      11.  00:7372  C4 5F 01                    call nz,EXTROM
      12.  00:7375                                      
      13.  00:7375  CD 8E 72                    call PRINTTEXT
      14.  00:7378                              ifndef DEBUG
      15.  00:7378                    ~         db "Nowind USB Diskrom!",0
      16.  00:7378                    ~         else
      17.  00:7378                              db "Nowind USB Diskrom! [debug]",0
      17.  00:7378  4E 6F 77 69 6E 64 20 55 53 42 20 44 69 73 6B 72 
      17.  00:7388  6F 6D 21 20 5B 64 65 62 75 67 5D 00 
      18.  00:7394                              endif
      19.  00:7394                      
      20.  00:7394                              ; call insertBootCode
      21.  00:7394  CD C2 7C                    call flashWriter
      22.  00:7397  C9                          ret
      23.  00:7398                      
      24.  00:7398                      initDiskBasic:
      25.  00:7398                              DEBUGMESSAGE "initDiskBasic"
      25.  00:7398                    >         ifdef DEBUG
      25.  00:7398  52                >         ld d,d
      25.  00:7399  18 0D             >         jr .skip
      25.  00:739B                    >         db string
      25.  00:739B  69 6E 69 74 44 69 73 6B 42 61 73 69 63 
      25.  00:73A8                    > .skip:
      25.  00:73A8                    >         endif
      26.  00:73A8  21 99 FD                    ld hl,DEVICE
      27.  00:73AB  CB BE                       res 7,(hl)
      28.  00:73AD                              
      29.  00:73AD                              if MSXDOSVER = 1 
      30.  00:73AD                    ~         jp $5897
      31.  00:73AD                    ~         else
      32.  00:73AD  C3 5B 49                    jp $495b
      33.  00:73B0                              endif
      34.  00:73B0                      
      35.  00:73B0                      ; search call statement or device name
      36.  00:73B0                      findStatementName:
      37.  00:73B0                              DEBUGMESSAGE "findStatementName"
      37.  00:73B0                    >         ifdef DEBUG
      37.  00:73B0  52                >         ld d,d
      37.  00:73B1  18 11             >         jr .skip
      37.  00:73B3                    >         db string
      37.  00:73B3  66 69 6E 64 53 74 61 74 65 6D 65 6E 74 4E 61 6D 
      37.  00:73C3  65 
      37.  00:73C4                    > .skip:
      37.  00:73C4                    >         endif
      38.  00:73C4  11 89 FD                    ld de,PROCNM
      39.  00:73C7  1A                  .loop:  ld a,(de)
      40.  00:73C8  BE                          cp (hl)
      41.  00:73C9  20 06                       jr nz,.nextStatement
      42.  00:73CB  23                          inc hl
      43.  00:73CC  B7                          or a
      44.  00:73CD  C8                          ret z                           ; name found
      45.  00:73CE  13                          inc de
      46.  00:73CF  18 F6                       jr .loop        
      47.  00:73D1                      .nextStatement:
      48.  00:73D1  AF                          xor a
      49.  00:73D2  4F                          ld c,a
      50.  00:73D3  ED B1                       cpir
      51.  00:73D5  23                          inc hl
      52.  00:73D6  23                          inc hl
      53.  00:73D7  B6                          or (hl)
      54.  00:73D8  20 D6                       jr nz,findStatementName        
      55.  00:73DA  37                          scf                             ; not found
      56.  00:73DB  C9                          ret
      57.  00:73DC                      
      58.  00:73DC                      sendRegisters:
      59.  00:73DC  F5                          push af
      60.  00:73DD  7C                          ld a,h
      61.  00:73DE  26 40                       ld h,HIGH usbwr
      62.  00:73E0  36 AF                       ld (hl),$af      ; send header
      63.  00:73E2  36 05                       ld (hl),$05      ;
      64.  00:73E4  71                          ld (hl),c
      65.  00:73E5  70                          ld (hl),b
      66.  00:73E6  73                          ld (hl),e
      67.  00:73E7  72                          ld (hl),d
      68.  00:73E8  75                          ld (hl),l
      69.  00:73E9  77                          ld (hl),a        ; send register h
      70.  00:73EA  D1                          pop de
      71.  00:73EB  73                          ld (hl),e        ; send register f
      72.  00:73EC  72                          ld (hl),d        ; send register a
      73.  00:73ED  C9                          ret
      74.  00:73EE                              
      75.  00:73EE                      getHeader:
      76.  00:73EE  06 FF                       ld b,HIGH 65535                 ; 42000 * 60 states ~ 0,7 sec (time out)
      77.  00:73F0  7E                  .loop:  ld a,(hl)
      78.  00:73F1  FE AF               .chkaf: cp $af
      79.  00:73F3  28 20                       jr z,.chk05
      80.  00:73F5  0B                          dec bc
      81.  00:73F6  78                          ld a,b
      82.  00:73F7  B1                          or c
      83.  00:73F8  20 F6                       jr nz,.loop
      84.  00:73FA                              DEBUGMESSAGE "getHeader Timed out!"
      84.  00:73FA                    >         ifdef DEBUG
      84.  00:73FA  52                >         ld d,d
      84.  00:73FB  18 14             >         jr .skip
      84.  00:73FD                    >         db string
      84.  00:73FD  67 65 74 48 65 61 64 65 72 20 54 69 6D 65 64 20 
      84.  00:740D  6F 75 74 21 
      84.  00:7411                    > .skip:
      84.  00:7411                    >         endif
      85.  00:7411  3E 02                       ld a,2                          ; not ready
      86.  00:7413  37                          scf
      87.  00:7414  C9                          ret
      88.  00:7415                      
      89.  00:7415  7E                  .chk05: ld a,(hl)
      90.  00:7416  FE 05                       cp $05
      91.  00:7418  20 D7                       jr nz,.chkaf
      92.  00:741A  7E                          ld a,(hl)
      93.  00:741B  C9                          ret
      94.  00:741C                      
      95.  00:741C                      sendMessage:
      96.  00:741C                              ;DEBUGMESSAGE "sendMsg"
      97.  00:741C  E3                          ex (sp),hl
      98.  00:741D  F5                          push af
      99.  00:741E  D5                          push de
     100.  00:741F  E5                          push hl        
     101.  00:7420  CD DC 73                    call sendRegisters
     102.  00:7423  36 90                       ld (hl),C_MESSAGE
     103.  00:7425  E1                          pop hl
     104.  00:7426  7E                  .loop:  ld a,(hl)
     105.  00:7427  23                          inc hl
     106.  00:7428  32 00 40                    ld (usbwr),a
     107.  00:742B  B7                          or a
     108.  00:742C  20 F8                       jr nz,.loop
     109.  00:742E  D1                          pop de
     110.  00:742F  F1                          pop af
     111.  00:7430  E3                          ex (sp),hl
     112.  00:7431  C9                          ret
     113.  00:7432                              
     114.  00:7432                      ; AUX device
     115.  00:7432                              
     116.  00:7432  C3 3C 74            newAUX: jp AUXin
     117.  00:7435  00                          nop
     118.  00:7436  00                          nop
     119.  00:7437  C3 81 74                    jp AUXout
     120.  00:743A  00                          nop
     121.  00:743B  00                          nop
     122.  00:743C                      
     123.  00:743C                      AUXin:  DEBUGMESSAGE "AUX in"
     123.  00:743C                    >         ifdef DEBUG
     123.  00:743C  52                >         ld d,d
     123.  00:743D  18 06             >         jr .skip
     123.  00:743F  41 55 58 20 69 6E >         db string
     123.  00:7445                    > .skip:
     123.  00:7445                    >         endif
     124.  00:7445  E5                          push hl
     125.  00:7446  D5                          push de
     126.  00:7447  C5                          push bc
     127.  00:7448  CD DC 73                    call sendRegisters
     128.  00:744B  36 8E                       ld (hl),C_AUXIN
     129.  00:744D  CD 6D 75                    call enableNowindPage0
     130.  00:7450  26 20                       ld h,HIGH usbrd
     131.  00:7452  CD EE 73                    call getHeader
     132.  00:7455  D2 70 74                    jp nc,.getCharacter
     133.  00:7458                              
     134.  00:7458                              DEBUGMESSAGE "not connected"
     134.  00:7458                    >         ifdef DEBUG
     134.  00:7458  52                >         ld d,d
     134.  00:7459  18 0D             >         jr .skip
     134.  00:745B                    >         db string
     134.  00:745B  6E 6F 74 20 63 6F 6E 6E 65 63 74 65 64 
     134.  00:7468                    > .skip:
     134.  00:7468                    >         endif
     135.  00:7468  3E 1A                       ld a,$1a                        ; eof
     136.  00:746A  C1                  .exit:  pop bc
     137.  00:746B  D1                          pop de
     138.  00:746C  E1                          pop hl
     139.  00:746D  C3 78 75                    jp restorePage0        
     140.  00:7470                                    
     141.  00:7470                      .getCharacter:
     142.  00:7470                              DEBUGMESSAGE "getChar"
     142.  00:7470                    >         ifdef DEBUG
     142.  00:7470  52                >         ld d,d
     142.  00:7471  18 07             >         jr .skip
     142.  00:7473                    >         db string
     142.  00:7473  67 65 74 43 68 61 72 
     142.  00:747A                    > .skip:
     142.  00:747A                    >         endif
     143.  00:747A  CD EE 73                    call getHeader
     144.  00:747D  38 F1                       jr c,.getCharacter
     145.  00:747F  18 E9                       jr .exit
     146.  00:7481                      
     147.  00:7481                      
     148.  00:7481                      AUXout: DEBUGMESSAGE "AUX out"
     148.  00:7481                    >         ifdef DEBUG
     148.  00:7481  52                >         ld d,d
     148.  00:7482  18 07             >         jr .skip
     148.  00:7484                    >         db string
     148.  00:7484  41 55 58 20 6F 75 74 
     148.  00:748B                    > .skip:
     148.  00:748B                    >         endif
     149.  00:748B                              DEBUGDUMPREGISTERS
     149.  00:748B                    >         ifdef DEBUG
     149.  00:748B  ED 07             >         db $ed,7
     149.  00:748D                    >         endif
     149.  00:748D                    >         
     149.  00:748D                    >         ifdef USBDEBUG
     149.  00:748D                    ~         assert ($ < $8000)
     149.  00:748D                    ~         call sendCpuInfo
     149.  00:748D                    ~         endif
     150.  00:748D  E5                          push hl
     151.  00:748E  D5                          push de
     152.  00:748F                      ;        push bc
     153.  00:748F                      ;        ld a,(RAMAD1) ; TODO: WTF???
     154.  00:748F                      ;        call RDSLT
     155.  00:748F  F5                          push af        
     156.  00:7490  CD DC 73                    call sendRegisters
     157.  00:7493  36 8F                       ld (hl),C_AUXOUT
     158.  00:7495  F1                          pop af
     159.  00:7496                      ;        pop bc
     160.  00:7496  D1                          pop de
     161.  00:7497  E1                          pop hl
     162.  00:7498  C9                          ret
     163.  00:7499                      
     164.  00:7499                      ;insertBootCode:
     165.  00:7499                      ;        DEBUGMESSAGE "BOOTCODE"
     166.  00:7499                      ;        call sendRegisters
     167.  00:7499                      ;        ld (hl),C_BOOTCODE
     168.  00:7499                      ;        call enableNowindPage0
     169.  00:7499                      ;        call getHeader
     170.  00:7499                      ;        jp c,restorePage0
     171.  00:7499                              
     172.  00:7499                      ;        DEBUGMESSAGE "BOOTCODE"
     173.  00:7499                      ;        jp restorePage0
     174.  00:7499                      
     175.  00:7499                      ; send 32 bytes starting from address specified by DE to the usb
     176.  00:7499                      sdendFCB:
     177.  00:7499  D5                          push de
     178.  00:749A  C5                          push bc
     179.  00:749B                              
     180.  00:749B  06 20                       ld b,32
     181.  00:749D  1A                  .loop:  ld a,(de)
     182.  00:749E  32 00 40                    ld (usbwr),a
     183.  00:74A1  13                          inc de
     184.  00:74A2  10 F9                       djnz .loop
     185.  00:74A4  C1                          pop bc
     186.  00:74A5  D1                          pop de
     187.  00:74A6  C9                          ret
     188.  00:74A7                      
     189.  00:74A7                      ; receive 32 bytes and write to the address specified by DE 
     190.  00:74A7                      receiveFCB:
     191.  00:74A7  D5                          push de
     192.  00:74A8  C5                          push bc
     193.  00:74A9                              
     194.  00:74A9  06 20                       ld b,32
     195.  00:74AB  3A 00 20            .loop:  ld a,(usbrd)
     196.  00:74AE  32 00 40                    ld (usbwr),a                    ; loop back
     197.  00:74B1  12                          ld (de),a
     198.  00:74B2  13                          inc de
     199.  00:74B3  10 F6                       djnz .loop
     200.  00:74B5  C1                          pop bc
     201.  00:74B6  D1                          pop de
     202.  00:74B7  C9                          ret
     203.  00:74B8                              
     112   00:74B8                              include "extendedBios.asm"
       1.  00:74B8                      
       2.  00:74B8                      installExtendedBios:
       3.  00:74B8                      
       4.  00:74B8                              ; Called from INIENV, so EXTBIO hook is already initialized
       5.  00:74B8                      
       6.  00:74B8                              DEBUGMESSAGE "extbio"
       6.  00:74B8                    >         ifdef DEBUG
       6.  00:74B8  52                >         ld d,d
       6.  00:74B9  18 06             >         jr .skip
       6.  00:74BB  65 78 74 62 69 6F >         db string
       6.  00:74C1                    > .skip:
       6.  00:74C1                    >         endif
       7.  00:74C1  CD F8 75                    call getEntrySLTWRK             ; save previous EXTBIO hook
       8.  00:74C4  23                          inc hl
       9.  00:74C5  EB                          ex de,hl        
      10.  00:74C6  21 CA FF                    ld hl,EXTBIO
      11.  00:74C9  01 05 00                    ld bc,5
      12.  00:74CC  ED B0                       ldir
      13.  00:74CE                              
      14.  00:74CE  E5                          push hl                         ; determine device number
      15.  00:74CF  AF                          xor a
      16.  00:74D0  11 01 4E                    ld de,$4e01
      17.  00:74D3  CD CA FF                    call EXTBIO
      18.  00:74D6  E1                          pop hl
      19.  00:74D7  77                          ld (hl),a
      20.  00:74D8                                      
      21.  00:74D8  CD 2D 40                    call GETSLT                     ; install new EXTBIO hook
      22.  00:74DB  2E F7                       ld l,$f7
      23.  00:74DD  67                          ld h,a
      24.  00:74DE  22 CA FF                    ld (EXTBIO),hl
      25.  00:74E1  21 ED 74                    ld hl,extendedBios
      26.  00:74E4  22 CC FF                    ld (EXTBIO+2),hl
      27.  00:74E7  3E C9                       ld a,$c9
      28.  00:74E9  32 CE FF                    ld (EXTBIO+4),a    
      29.  00:74EC  C9                          ret
      30.  00:74ED                      
      31.  00:74ED                      extendedBios:
      32.  00:74ED                              ; broadcast (0x00) not implemented
      33.  00:74ED                              ; system exclusive (0xff) not implemented
      34.  00:74ED                      
      35.  00:74ED  FB                          ei
      36.  00:74EE  F5                          push af
      37.  00:74EF  7A                          ld a,d
      38.  00:74F0  FE 4E                       cp $4e
      39.  00:74F2  28 0E                       jr z,determineFunction
      40.  00:74F4                      .exit:
      41.  00:74F4  E5                          push hl
      42.  00:74F5  C5                          push bc
      43.  00:74F6  CD F8 75                    call getEntrySLTWRK
      44.  00:74F9  2C                          inc l                           ; previous EXTBIO hook 
      45.  00:74FA  E5                          push hl
      46.  00:74FB  DD E1                       pop ix
      47.  00:74FD  C1                          pop bc        
      48.  00:74FE  E1                          pop hl
      49.  00:74FF  F1                          pop af
      50.  00:7500  DD E9                       jp (ix)                         ; process other EXTBIO handles
      51.  00:7502                      
      52.  00:7502                      determineFunction:
      53.  00:7502  E5                          push hl
      54.  00:7503  21 0E D9                    ld hl,functionTable - 2 * $4e00
      55.  00:7506  19                          add hl,de
      56.  00:7507  19                          add hl,de
      57.  00:7508  7E                          ld a,(hl)
      58.  00:7509  23                          inc hl
      59.  00:750A  66                          ld h,(hl)
      60.  00:750B  6F                          ld l,a
      61.  00:750C  E3                          ex (sp),hl
      62.  00:750D  C9                          ret
      63.  00:750E                      
      64.  00:750E                      functionTable:
      65.  00:750E  14 75                       dw getNowindSlot
      66.  00:7510  30 75                       dw numberOfDevices
      67.  00:7512  47 75                       dw debugMessage
      68.  00:7514                      
      69.  00:7514                      getNowindSlot:               
      70.  00:7514                              DEBUGMESSAGE "getNowindSlot"
      70.  00:7514                    >         ifdef DEBUG
      70.  00:7514  52                >         ld d,d
      70.  00:7515  18 0D             >         jr .skip
      70.  00:7517                    >         db string
      70.  00:7517  67 65 74 4E 6F 77 69 6E 64 53 6C 6F 74 
      70.  00:7524                    > .skip:
      70.  00:7524                    >         endif
      71.  00:7524  F1                          pop af
      72.  00:7525  3D                          dec a
      73.  00:7526  F5                          push af
      74.  00:7527  F2 F4 74                    jp p,extendedBios.exit         ; not this device
      75.  00:752A                              
      76.  00:752A  F1                          pop af
      77.  00:752B  CD C8 75                    call getSlotPage1
      78.  00:752E  37                          scf
      79.  00:752F  C9                          ret
      80.  00:7530                              
      81.  00:7530                      numberOfDevices:
      82.  00:7530                              DEBUGMESSAGE "numberOfDevices"
      82.  00:7530                    >         ifdef DEBUG
      82.  00:7530  52                >         ld d,d
      82.  00:7531  18 0F             >         jr .skip
      82.  00:7533                    >         db string
      82.  00:7533  6E 75 6D 62 65 72 4F 66 44 65 76 69 63 65 73 
      82.  00:7542                    > .skip:
      82.  00:7542                    >         endif
      83.  00:7542  F1                          pop af
      84.  00:7543  3C                          inc a
      85.  00:7544  F5                          push af
      86.  00:7545  18 AD                       jr extendedBios.exit
      87.  00:7547                              
      88.  00:7547                      debugMessage:
      89.  00:7547                              DEBUGMESSAGE "debugMessage"
      89.  00:7547                    >         ifdef DEBUG
      89.  00:7547  52                >         ld d,d
      89.  00:7548  18 0C             >         jr .skip
      89.  00:754A                    >         db string
      89.  00:754A  64 65 62 75 67 4D 65 73 73 61 67 65 
      89.  00:7556                    > .skip:
      89.  00:7556                    >         endif
      90.  00:7556  F1                          pop af
      91.  00:7557  3D                          dec a
      92.  00:7558  F5                          push af
      93.  00:7559  F2 F4 74                    jp p,extendedBios.exit
      94.  00:755C                      
      95.  00:755C  E5                          push hl
      96.  00:755D  CD DC 73                    call sendRegisters
      97.  00:7560  36 90                       ld (hl),C_MESSAGE
      98.  00:7562  E1                          pop hl
      99.  00:7563  7E                  .loop:  ld a,(hl)
     100.  00:7564  23                          inc hl
     101.  00:7565  32 00 40                    ld (usbwr),a
     102.  00:7568  B7                          or a
     103.  00:7569  20 F8                       jr nz,.loop
     104.  00:756B                              
     105.  00:756B  F1                          pop af        
     106.  00:756C  C9                          ret
     113   00:756D                              include "slotRoutines.asm"
       1.  00:756D                      ; These routines are used for slot selection
       2.  00:756D                      
       3.  00:756D                      ; function: enabled the selected slot of page 1 in page 0
       4.  00:756D                      ; in: none
       5.  00:756D                      ; out: ixh = previous slot selection for page 0
       6.  00:756D                      ; unchanged: d, iy
       7.  00:756D                      ; requirements: stack available
       8.  00:756D                      enableNowindPage0:
       9.  00:756D  CD BD 75                    call getSlotPage0
      10.  00:7570  DD 67                       ld ixh,a
      11.  00:7572  CD C8 75                    call getSlotPage1
      12.  00:7575  C3 81 75                    jp enableSlotPage0       
      13.  00:7578                      
      14.  00:7578                      restorePage0:
      15.  00:7578  F5                          push af
      16.  00:7579  DD 7C                       ld a,ixh
      17.  00:757B  CD 81 75                    call enableSlotPage0
      18.  00:757E  FB                          ei
      19.  00:757F  F1                          pop af
      20.  00:7580  C9                          ret
      21.  00:7581                      
      22.  00:7581                      enableSlotPage0:
      23.  00:7581                              ; HL and D remain unchanged
      24.  00:7581                              ; enableSlotPage0 can be called in page 1 and 2 (no absolute jumps)
      25.  00:7581                      
      26.  00:7581                              ;DEBUGMESSAGE "enasltP0"
      27.  00:7581  5F                          ld e,a                          ; store slotcode for further use
      28.  00:7582  E6 03                       and 3
      29.  00:7584  4F                          ld c,a                          ; new primary slot in c  
      30.  00:7585  CB 7B                       bit 7,e
      31.  00:7587  F3                          di
      32.  00:7588  20 08                       jr nz,.expanded
      33.  00:758A                      
      34.  00:758A  DB A8                       in a,($a8)
      35.  00:758C  E6 FC                       and %11111100
      36.  00:758E  B1                          or c                            ; enable new primary slot in page 0
      37.  00:758F  D3 A8                       out ($a8),a
      38.  00:7591  C9                          ret
      39.  00:7592                              
      40.  00:7592                      .expanded:
      41.  00:7592  7B                          ld a,e                          ; store secondary slot in e
      42.  00:7593  E6 0C                       and %00001100     
      43.  00:7595  0F                          rrca
      44.  00:7596  0F                          rrca
      45.  00:7597  5F                          ld e,a
      46.  00:7598                      
      47.  00:7598  DB A8                       in a,($a8)
      48.  00:759A  E6 FC                       and %11111100
      49.  00:759C  B1                          or c                            ; new primary slot in page 0
      50.  00:759D  47                          ld b,a                          ; used to restore
      51.  00:759E  17                          rla
      52.  00:759F  A7                          and a                           ; (reset carry)
      53.  00:75A0  17                          rla
      54.  00:75A1  B1                          or c                            ; new primary slot in page 3
      55.  00:75A2  0F                          rrca
      56.  00:75A3  0F                          rrca
      57.  00:75A4  D3 A8                       out ($a8),a
      58.  00:75A6                      
      59.  00:75A6  3A FF FF                    ld a,(-1)                       ; write secondary slot register
      60.  00:75A9  2F                          cpl
      61.  00:75AA  E6 FC                       and %11111100
      62.  00:75AC  B3                          or e                            ; apply new secondary slot for page 0
      63.  00:75AD  32 FF FF                    ld (-1),a
      64.  00:75B0  5F                          ld e,a                          ; store secondary slot register (for SLTTBL)
      65.  00:75B1                      
      66.  00:75B1  78                          ld a,b                          ; restore primary slot page 3
      67.  00:75B2  D3 A8                       out ($a8),a
      68.  00:75B4                      
      69.  00:75B4  3E C5                       ld a,LOW SLTTBL                 ; update SLTTBL
      70.  00:75B6  81                          add c                           ; add primary slot
      71.  00:75B7  4F                          ld c,a
      72.  00:75B8  06 FC                       ld b,HIGH SLTTBL
      73.  00:75BA  7B                          ld a,e                          ; restore secondary slot register
      74.  00:75BB  02                          ld (bc),a
      75.  00:75BC  C9                          ret
      76.  00:75BD                      
      77.  00:75BD                      ; These routines determine the current slot and subslot of a page.
      78.  00:75BD                      
      79.  00:75BD                      getSlotPage0:
      80.  00:75BD                              ;DEBUGMESSAGE "getsltP0"
      81.  00:75BD  DB A8                       in a,($a8)
      82.  00:75BF  CD E2 75                    call expanded
      83.  00:75C2  07                          rlca
      84.  00:75C3  07                          rlca
      85.  00:75C4  E6 0C                       and %00001100           ; keep subSlot
      86.  00:75C6  B1                          or c                    ; add mainSlot and expanded bit
      87.  00:75C7  C9                          ret
      88.  00:75C8                                      
      89.  00:75C8                      getSlotPage1:
      90.  00:75C8                      ;        DEBUGMESSAGE "getsltP1"
      91.  00:75C8  DB A8                       in a,($a8)
      92.  00:75CA  0F                          rrca
      93.  00:75CB  0F                          rrca
      94.  00:75CC  CD E2 75                    call expanded
      95.  00:75CF  E6 0C                       and %00001100           ; keep subSlot
      96.  00:75D1  B1                          or c                    ; add mainSlot and expanded bit
      97.  00:75D2  C9                          ret        
      98.  00:75D3                                      
      99.  00:75D3                      getSlotPage2:
     100.  00:75D3                      ;        DEBUGMESSAGE "getsltP2"
     101.  00:75D3  DB A8                       in a,($a8)
     102.  00:75D5  0F                          rrca
     103.  00:75D6  0F                          rrca
     104.  00:75D7  0F                          rrca
     105.  00:75D8  0F                          rrca
     106.  00:75D9  CD E2 75                    call expanded
     107.  00:75DC  0F                          rrca
     108.  00:75DD  0F                          rrca
     109.  00:75DE  E6 0C                       and %00001100           ; keep subSlot
     110.  00:75E0  B1                          or c                    ; add mainSlot and expanded bit
     111.  00:75E1  C9                          ret
     112.  00:75E2                      
     113.  00:75E2                      ;expanded:        
     114.  00:75E2                      ;        ld hl,EXPTBL - $0300
     115.  00:75E2                      ;        ld b,3
     116.  00:75E2                      ;        and b
     117.  00:75E2                      ;        ld c,a
     118.  00:75E2                      ;        add hl,bc      
     119.  00:75E2                      ;        
     120.  00:75E2                      ;        or (hl)        ; BUGGIE!!!! (a will be used again!)
     121.  00:75E2                      ;        ret p                           ; return when slot is not expanded
     122.  00:75E2                      ;        
     123.  00:75E2                      ;        ld c,a
     124.  00:75E2                      ;        ld a,4
     125.  00:75E2                      ;        add a,l
     126.  00:75E2                      ;        ld l,a
     127.  00:75E2                      ;        ld a,(hl)
     128.  00:75E2                      ;        ret
     129.  00:75E2                      
     130.  00:75E2                      expanded:        
     131.  00:75E2  21 C1 F9                    ld hl,EXPTBL - $0300
     132.  00:75E5  06 03                       ld b,3
     133.  00:75E7  A0                          and b
     134.  00:75E8  4F                          ld c,a
     135.  00:75E9  09                          add hl,bc
     136.  00:75EA  CB 7E                       bit 7,(hl)
     137.  00:75EC  28 08                       jr z,notExpanded
     138.  00:75EE                      
     139.  00:75EE  CB F9                       set 7,c
     140.  00:75F0  2C                          inc l
     141.  00:75F1  2C                          inc l
     142.  00:75F2  2C                          inc l
     143.  00:75F3  2C                          inc l
     144.  00:75F4  7E                          ld a,(hl)
     145.  00:75F5  C9                          ret        
     146.  00:75F6                      
     147.  00:75F6                      notExpanded:
     148.  00:75F6  C1                          pop bc
     149.  00:75F7  C9                          ret
     150.  00:75F8                      
     151.  00:75F8                      getEntrySLTWRK:
     152.  00:75F8  CD C8 75                    call getSlotPage1
     153.  00:75FB  21 09 FD                    ld hl,SLTWRK
     154.  00:75FE  4F                          ld c,a
     155.  00:75FF  0F                          rrca
     156.  00:7600  0F                          rrca
     157.  00:7601  0F                          rrca
     158.  00:7602  E6 60                       and %01100000           ; main slot x 32
     159.  00:7604  47                          ld b,a
     160.  00:7605  79                          ld a,c
     161.  00:7606  07                          rlca
     162.  00:7607  E6 18                       and %00011000           ; sub slot x 8
     163.  00:7609  80                          add b
     164.  00:760A  85                          add l
     165.  00:760B  6F                          ld l,a
     166.  00:760C  C9                          ret
     167.  00:760D                      
     114   00:760D                              include "nowindDriver.asm"
       1.  00:760D  (00:0008)           MYSIZE          equ 8                   ; size of work area (not used, some programs write here to stop drives spinning)
       2.  00:760D  (00:0200)           SECLEN          equ 512                 ; sector size
       3.  00:760D                      
       4.  00:760D                      ; SLTWRK entry
       5.  00:760D                      ; +0    rom drive number
       6.  00:760D                      ; +1..5 previous EXTBIO
       7.  00:760D                      ; +6    not used
       8.  00:760D                      ; +7    not used
       9.  00:760D                      
      10.  00:760D                             
      11.  00:760D                      ; if this is defined we tell DOS2.3 that we _are DOS2.3 also, so
      12.  00:760D                      ; it does not try to override our initilazations 
      13.  00:760D                      
      14.  00:760D                      define  PRETEND_2B_DOS23
      15.  00:760D                              
      16.  00:760D                      INIHRD: 
      17.  00:760D                              DEBUGMESSAGE "INIHRD"        
      17.  00:760D                    >         ifdef DEBUG
      17.  00:760D  52                >         ld d,d
      17.  00:760E  18 06             >         jr .skip
      17.  00:7610  49 4E 49 48 52 44 >         db string
      17.  00:7616                    > .skip:
      17.  00:7616                    >         endif
      18.  00:7616                              
      19.  00:7616                      ;        call getWorkArea
      20.  00:7616                      ;        DEBUGDUMPREGISTERS
      21.  00:7616                                                      
      22.  00:7616  CD 6D 75                    call enableNowindPage0                  ; clear hostToMSXFifo by reading 4Kb of random data
      23.  00:7619  01 00 10                    ld bc,4096
      24.  00:761C  3A 00 20            .loop:  ld a,(usbrd)
      25.  00:761F  0B                          dec bc
      26.  00:7620  78                          ld a,b
      27.  00:7621  B1                          or c
      28.  00:7622  20 F8                       jr nz,.loop
      29.  00:7624  CD 78 75                    call restorePage0
      30.  00:7627                              
      31.  00:7627  26 40                       ld h,HIGH usbwr
      32.  00:7629  36 AF                       ld (hl),$af                     ; INIHRD command
      33.  00:762B  36 FF                       ld (hl),$ff
      34.  00:762D  C3 65 73                    jp nowindInit
      35.  00:7630                      
      36.  00:7630                      DRIVES:
      37.  00:7630                              DEBUGMESSAGE "DRIVES"
      37.  00:7630                    >         ifdef DEBUG
      37.  00:7630  52                >         ld d,d
      37.  00:7631  18 06             >         jr .skip
      37.  00:7633  44 52 49 56 45 53 >         db string
      37.  00:7639                    > .skip:
      37.  00:7639                    >         endif
      38.  00:7639  F5                          push af                         ; A, BC and DE should be preserved!
      39.  00:763A  C5                          push bc
      40.  00:763B  D5                          push de
      41.  00:763C  3A 99 FD                    ld a,(DEVICE)
      42.  00:763F  CD DC 73                    call sendRegisters
      43.  00:7642  36 85                       ld (hl),C_DRIVES
      44.  00:7644  CD 6D 75                    call enableNowindPage0
      45.  00:7647  26 20                       ld h,HIGH usbrd
      46.  00:7649  CD EE 73                    call getHeader
      47.  00:764C  2E 02                       ld l,2                          ; default 2 drives
      48.  00:764E  38 2C                       jr c,.notconnected
      49.  00:7650                      
      50.  00:7650                              PRINTVDPTEXT " Host connected."
      50.  00:7650                    >         
      50.  00:7650  E5                >         push hl
      50.  00:7651  21 5A 76          >         ld hl,.text
      50.  00:7654  CD C4 7B          >         call printVdpText2
      50.  00:7657  E1                >         pop hl
      50.  00:7658  18 11             >         jr .skip
      50.  00:765A                    > .text   db string
      50.  00:765A  20 48 6F 73 74 20 63 6F 6E 6E 65 63 74 65 64 2E 
      50.  00:766A  00                >         db 0
      50.  00:766B                    > .skip:
      51.  00:766B                                                      
      52.  00:766B  32 3F F3                    ld (LASTDRV),a                  ; install phantom drives (CRTL key)?
      53.  00:766E  7E                          ld a,(hl)                       ; allow other drives (SHIFT key)?
      54.  00:766F  32 99 FD                    ld (DEVICE),a
      55.  00:7672  6E                          ld l,(hl)                       ; number of drives
      56.  00:7673  E5                  .exit:  push hl  
      57.  00:7674  CD 78 75                    call restorePage0
      58.  00:7677  E1                          pop hl
      59.  00:7678  D1                          pop de
      60.  00:7679  C1                          pop bc
      61.  00:767A  F1                          pop af
      62.  00:767B  C9                          ret
      63.  00:767C                              
      64.  00:767C                      .notconnected:
      65.  00:767C                              PRINTVDPTEXT " Host timed out!"            
      65.  00:767C                    >         
      65.  00:767C  E5                >         push hl
      65.  00:767D  21 86 76          >         ld hl,.text
      65.  00:7680  CD C4 7B          >         call printVdpText2
      65.  00:7683  E1                >         pop hl
      65.  00:7684  18 11             >         jr .skip
      65.  00:7686                    > .text   db string
      65.  00:7686  20 48 6F 73 74 20 74 69 6D 65 64 20 6F 75 74 21 
      65.  00:7696  00                >         db 0
      65.  00:7697                    > .skip:
      66.  00:7697  18 DA                       jr .exit
      67.  00:7699                      
      68.  00:7699                      
      69.  00:7699                      INIENV:
      70.  00:7699                      ; Interrupt handler can be installed here and
      71.  00:7699                      ; work area can be initialized when it was requested
      72.  00:7699                              DEBUGMESSAGE "INIENV"
      72.  00:7699                    >         ifdef DEBUG
      72.  00:7699  52                >         ld d,d
      72.  00:769A  18 06             >         jr .skip
      72.  00:769C  49 4E 49 45 4E 56 >         db string
      72.  00:76A2                    > .skip:
      72.  00:76A2                    >         endif
      73.  00:76A2                      
      74.  00:76A2                              ifdef PRETEND_2B_DOS23
      75.  00:76A2                              DEBUGMESSAGE "Lie about being DOS v2.31"
      75.  00:76A2                    >         ifdef DEBUG
      75.  00:76A2  52                >         ld d,d
      75.  00:76A3  18 19             >         jr .skip
      75.  00:76A5                    >         db string
      75.  00:76A5  4C 69 65 20 61 62 6F 75 74 20 62 65 69 6E 67 20 
      75.  00:76B5  44 4F 53 20 76 32 2E 33 31 
      75.  00:76BE                    > .skip:
      75.  00:76BE                    >         endif
      76.  00:76BE  3E 23                       ld a,$23
      77.  00:76C0  32 13 F3                    ld ($f313),a
      78.  00:76C3                              endif
      79.  00:76C3                              
      80.  00:76C3  CD B8 74                    call installExtendedBios
      81.  00:76C6  CD DC 73                    call sendRegisters
      82.  00:76C9  36 86                       ld (hl),C_INIENV
      83.  00:76CB  CD 6D 75                    call enableNowindPage0
      84.  00:76CE  26 20                       ld h,HIGH usbrd
      85.  00:76D0  CD EE 73                    call getHeader
      86.  00:76D3  F5                          push af
      87.  00:76D4                      ;        push ix
      88.  00:76D4                      ;        call GETWRK
      89.  00:76D4                      ;        pop ix
      90.  00:76D4  CD F8 75                    call getEntrySLTWRK
      91.  00:76D7  F1                          pop af
      92.  00:76D8  36 00                       ld (hl),0                       ; romdisk in drive A: (default)          
      93.  00:76DA  38 01                       jr c,.exit
      94.  00:76DC  77                          ld (hl),a                       ; store romdisk drive number (255 = no romdisk)
      95.  00:76DD  C3 78 75            .exit:  jp restorePage0
      96.  00:76E0                      
      97.  00:76E0                      checkWorkArea:
      98.  00:76E0  3E 01                       ld a,1
      99.  00:76E2  A7                          and a
     100.  00:76E3  C9                          ret
     101.  00:76E4                              
     102.  00:76E4  C5                          push bc
     103.  00:76E5  E5                          push hl
     104.  00:76E6  F5                          push af
     105.  00:76E7                      ;        call GETWRK
     106.  00:76E7  CD F8 75                    call getEntrySLTWRK
     107.  00:76EA  F1                          pop af
     108.  00:76EB  BE                          cp (hl)
     109.  00:76EC  E1                          pop hl
     110.  00:76ED  C1                          pop bc
     111.  00:76EE  C9                          ret        
     112.  00:76EF                      
     113.  00:76EF                      DSKIO: 
     114.  00:76EF                      ; Input     F   Carry for set for write, reset for read
     115.  00:76EF                      ;           A   Drive number
     116.  00:76EF                      ;           B   Number of sectors to read/write
     117.  00:76EF                      ;           C   Media descriptor
     118.  00:76EF                      ;           DE  Logical sector number
     119.  00:76EF                      ;           HL  Transfer address
     120.  00:76EF                      ; Output    F   Carry set when not succesfull
     121.  00:76EF                      ;           A   Error code
     122.  00:76EF                      ;           B   Number of remaining sectors (TODO: check! even without error?)
     123.  00:76EF                      
     124.  00:76EF                              DEBUGMESSAGE "DSKIO"
     124.  00:76EF                    >         ifdef DEBUG
     124.  00:76EF  52                >         ld d,d
     124.  00:76F0  18 05             >         jr .skip
     124.  00:76F2  44 53 4B 49 4F    >         db string
     124.  00:76F7                    > .skip:
     124.  00:76F7                    >         endif
     125.  00:76F7  F5                          push af
     126.  00:76F8  CD E0 76                    call checkWorkArea
     127.  00:76FB  CA 5E 7C                    jp z,ROMDISK_DSKIO
     128.  00:76FE  F1                          pop af
     129.  00:76FF                      
     130.  00:76FF  CD DC 73                    call sendRegisters
     131.  00:7702  36 80                       ld (hl),C_DSKIO
     132.  00:7704  38 58                       jr c,dskioWrite                 ; read or write?
     133.  00:7706                             
     134.  00:7706                      dskioRead:
     135.  00:7706  07                          rlca                            ; < 0x8000 ?
     136.  00:7707  38 3F                       jr c,.page2and3
     137.  00:7709                      
     138.  00:7709                              DEBUGMESSAGE "read01"
     138.  00:7709                    >         ifdef DEBUG
     138.  00:7709  52                >         ld d,d
     138.  00:770A  18 06             >         jr .skip
     138.  00:770C  72 65 61 64 30 31 >         db string
     138.  00:7712                    > .skip:
     138.  00:7712                    >         endif
     139.  00:7712  CD D3 75                    call getSlotPage2               ; enable nowind in page 2
     140.  00:7715  F5                          push af
     141.  00:7716  CD C8 75                    call getSlotPage1
     142.  00:7719  DD 67                       ld ixh,a                        ; ixh = current nowind slot
     143.  00:771B  26 80                       ld h,$80
     144.  00:771D  CD 24 00                    call ENASLT
     145.  00:7720  C3 23 B7                    jp .page2
     146.  00:7723                              
     147.  00:7723  (B723)                      PHASE $ + $4000
     148.  00:B723                      .page2:
     149.  00:B723  3A 42 F3                    ld a,(RAMAD1)                   ; enable RAM in page 1
     150.  00:B726  26 40                       ld h,$40
     151.  00:B728  CD 24 00                    call ENASLT
     152.  00:B72B                              
     153.  00:B72B  CD 9E B8                    call readSectors01 
     154.  00:B72E                              ; TODO: carry checken?----------------------------------------------!!!!!!!!!!!!!!!
     155.  00:B72E                              
     156.  00:B72E  DD 7C                       ld a,ixh                        ; enable nowind in page 1 
     157.  00:B730  26 40                       ld h,$40
     158.  00:B732  CD 24 00                    call ENASLT
     159.  00:B735  C3 38 77                    jp .page1        
     160.  00:B738                      
     161.  00:B738  (7738)                      DEPHASE
     162.  00:7738                      .page1:
     163.  00:7738  3A 00 80                    ld a,(usb2)
     164.  00:773B  DD 67                       ld ixh,a
     165.  00:773D  F1                          pop af
     166.  00:773E  26 80                       ld h,$80
     167.  00:7740  CD 24 00                    call ENASLT                     ; restore page 2
     168.  00:7743  DD 7C                       ld a,ixh
     169.  00:7745  B7                          or a
     170.  00:7746  FB                          ei
     171.  00:7747  C8                          ret z                           ; nothing more to read
     172.  00:7748                                      
     173.  00:7748                      .page2and3:                     
     174.  00:7748                              DEBUGMESSAGE "read23"
     174.  00:7748                    >         ifdef DEBUG
     174.  00:7748  52                >         ld d,d
     174.  00:7749  18 06             >         jr .skip
     174.  00:774B  72 65 61 64 32 33 >         db string
     174.  00:7751                    > .skip:
     174.  00:7751                    >         endif
     175.  00:7751  CD 6D 75                    call enableNowindPage0
     176.  00:7754  FD E5                       push iy
     177.  00:7756  CD F1 78                    call readSectors23
     178.  00:7759  FD E1                       pop iy
     179.  00:775B  C3 78 75                    jp restorePage0
     180.  00:775E                      
     181.  00:775E                      dskioWrite:
     182.  00:775E                              DEBUGMESSAGE "dskwrite"
     182.  00:775E                    >         ifdef DEBUG
     182.  00:775E  52                >         ld d,d
     182.  00:775F  18 08             >         jr .skip
     182.  00:7761                    >         db string
     182.  00:7761  64 73 6B 77 72 69 74 65 
     182.  00:7769                    > .skip:
     182.  00:7769                    >         endif
     183.  00:7769  07                          rlca
     184.  00:776A  38 3E                       jr c,.page2and3        
     185.  00:776C                              
     186.  00:776C                              ;call enableNowindPage2 (todo: make common routine?) 
     187.  00:776C  CD D3 75                    call getSlotPage2               ; save current slot page 2
     188.  00:776F  DD 67                       ld ixh,a
     189.  00:7771  CD C8 75                    call getSlotPage1
     190.  00:7774  DD 6F                       ld ixl,a
     191.  00:7776  26 80                       ld h,$80
     192.  00:7778  CD 24 00                    call ENASLT                     ; nowind in page 2
     193.  00:777B  C3 7E B7                    jp .page2
     194.  00:777E                      
     195.  00:777E  (B77E)                      PHASE $ + $4000
     196.  00:B77E                      .page2:
     197.  00:B77E  3A 42 F3                    ld a,(RAMAD1)
     198.  00:B781  26 40                       ld h,$40
     199.  00:B783  CD 24 00                    call ENASLT                     ; ram in page 1
     200.  00:B786                              
     201.  00:B786  CD CC B8                    call writeLoop01
     202.  00:B789  F5                          push af
     203.  00:B78A                              
     204.  00:B78A  DD 7D                       ld a,ixl
     205.  00:B78C  26 40                       ld h,$40
     206.  00:B78E  CD 24 00                    call ENASLT                     ; restore nowind in page 1
     207.  00:B791  C3 94 77                    jp .page1
     208.  00:B794                              
     209.  00:B794  (7794)                      DEPHASE
     210.  00:7794                      .page1:
     211.  00:7794  DD 7C                       ld a,ixh
     212.  00:7796  26 80                       ld h,$80
     213.  00:7798  CD 24 00                    call ENASLT
     214.  00:779B  F1                          pop af
     215.  00:779C  D8                          ret c                           ; return error (error code in a)
     216.  00:779D  E8                          ret pe                          ; host returns 0xfe when data for page 2/3 is available
     217.  00:779E                              DEBUGMESSAGE "doorgaan!"
     217.  00:779E                    >         ifdef DEBUG
     217.  00:779E  52                >         ld d,d
     217.  00:779F  18 09             >         jr .skip
     217.  00:77A1                    >         db string
     217.  00:77A1  64 6F 6F 72 67 61 61 6E 21 
     217.  00:77AA                    > .skip:
     217.  00:77AA                    >         endif
     218.  00:77AA                              
     219.  00:77AA                      .page2and3:
     220.  00:77AA                              DEBUGMESSAGE "page2and3"
     220.  00:77AA                    >         ifdef DEBUG
     220.  00:77AA  52                >         ld d,d
     220.  00:77AB  18 09             >         jr .skip
     220.  00:77AD                    >         db string
     220.  00:77AD  70 61 67 65 32 61 6E 64 33 
     220.  00:77B6                    > .skip:
     220.  00:77B6                    >         endif
     221.  00:77B6  CD 6D 75                    call enableNowindPage0
     222.  00:77B9  CD BF 77                    call .writeLoop23
     223.  00:77BC  C3 78 75                    jp restorePage0
     224.  00:77BF                              
     225.  00:77BF                      .writeLoop23:
     226.  00:77BF                              DEBUGMESSAGE "writeLoop23"
     226.  00:77BF                    >         ifdef DEBUG
     226.  00:77BF  52                >         ld d,d
     226.  00:77C0  18 0B             >         jr .skip
     226.  00:77C2                    >         db string
     226.  00:77C2  77 72 69 74 65 4C 6F 6F 70 32 33 
     226.  00:77CD                    > .skip:
     226.  00:77CD                    >         endif
     227.  00:77CD                              
     228.  00:77CD  26 20                       ld h,HIGH usbrd
     229.  00:77CF  CD EE 73                    call getHeader
     230.  00:77D2  D8                          ret c                           ; exit (not ready)
     231.  00:77D3  B7                          or a
     232.  00:77D4  F8                          ret m                           ; exit (no error)
     233.  00:77D5  20 18                       jr nz,.error
     234.  00:77D7                      
     235.  00:77D7                              DEBUGMESSAGE "send23"
     235.  00:77D7                    >         ifdef DEBUG
     235.  00:77D7  52                >         ld d,d
     235.  00:77D8  18 06             >         jr .skip
     235.  00:77DA  73 65 6E 64 32 33 >         db string
     235.  00:77E0                    > .skip:
     235.  00:77E0                    >         endif
     236.  00:77E0  5E                          ld e,(hl)                       ; address
     237.  00:77E1  56                          ld d,(hl)
     238.  00:77E2  4E                          ld c,(hl)                       ; number of bytes        
     239.  00:77E3  46                          ld b,(hl)
     240.  00:77E4  7E                          ld a,(hl)                       ; block sequence number
     241.  00:77E5                              
     242.  00:77E5                              ;DEBUGDUMPREGISTERS
     243.  00:77E5  EB                          ex de,hl
     244.  00:77E6  11 00 40                    ld de,usbwr
     245.  00:77E9  12                          ld (de),a                       ; mark block begin
     246.  00:77EA  ED B0                       ldir
     247.  00:77EC  12                          ld (de),a                       ; mark block end
     248.  00:77ED  18 D0                       jr .writeLoop23
     249.  00:77EF                      
     250.  00:77EF  37                  .error: scf
     251.  00:77F0  7E                          ld a,(hl)                       ; get error code
     252.  00:77F1  C9                          ret
     253.  00:77F2                      
     254.  00:77F2                                     
     255.  00:77F2                      DSKCHG:
     256.  00:77F2                      ; Input     A   Drive number
     257.  00:77F2                      ;           B   0
     258.  00:77F2                      ;           C   Media descriptor (previous)
     259.  00:77F2                      ;           HL  Base address of DPB
     260.  00:77F2                      ; Output    B   1   Disk unchanged
     261.  00:77F2                      ;               0   Unknown (DPB is updated)
     262.  00:77F2                      ;               -1  Disk changed (DPB is updated)
     263.  00:77F2                      ;           F   Carry set when not succesfull
     264.  00:77F2                      ;           A   Error code
     265.  00:77F2                      
     266.  00:77F2                              DEBUGMESSAGE "DSKCHG"
     266.  00:77F2                    >         ifdef DEBUG
     266.  00:77F2  52                >         ld d,d
     266.  00:77F3  18 06             >         jr .skip
     266.  00:77F5  44 53 4B 43 48 47 >         db string
     266.  00:77FB                    > .skip:
     266.  00:77FB                    >         endif
     267.  00:77FB  F5                          push af
     268.  00:77FC  CD E0 76                    call checkWorkArea
     269.  00:77FF  CA BD 7C                    jp z,ROMDISK_DSKCHG
     270.  00:7802  F1                          pop af       
     271.  00:7803                      
     272.  00:7803  E5                          push hl
     273.  00:7804  CD DC 73                    call sendRegisters
     274.  00:7807  36 81                       ld (hl),C_DSKCHG
     275.  00:7809  CD 6D 75                    call enableNowindPage0
     276.  00:780C  26 20                       ld h,HIGH usbrd
     277.  00:780E  CD EE 73                    call getHeader
     278.  00:7811  4E                          ld c,(hl)               ; media descriptor (when disk was changed)
     279.  00:7812  F5                          push af
     280.  00:7813  C5                          push bc
     281.  00:7814  CD 78 75                    call restorePage0
     282.  00:7817  C1                          pop bc
     283.  00:7818  F1                          pop af
     284.  00:7819  E1                          pop hl
     285.  00:781A  D8                          ret c           ; not ready
     286.  00:781B  B7                          or a
     287.  00:781C  06 01                       ld b,1
     288.  00:781E  C8                          ret z           ; not changed
     289.  00:781F  41                          ld b,c
     290.  00:7820  CD 29 78                    call GETDPB
     291.  00:7823  3E 0A                       ld a,10
     292.  00:7825  D8                          ret c
     293.  00:7826  06 FF                       ld b,255
     294.  00:7828  C9                          ret
     295.  00:7829                      
     296.  00:7829                      GETDPB:
     297.  00:7829                      ; Input     A   Drive number
     298.  00:7829                      ;           B   Media descriptor (first byte of FAT)
     299.  00:7829                      ;           C   Previous media descriptor (does not seem to be used in other drivers)
     300.  00:7829                      ;           HL  Base address of HL
     301.  00:7829                      ; Output    DPB for specified drive in [HL+1]..[HL+18]
     302.  00:7829                      
     303.  00:7829                              DEBUGMESSAGE "GETDPB"
     303.  00:7829                    >         ifdef DEBUG
     303.  00:7829  52                >         ld d,d
     303.  00:782A  18 06             >         jr .skip
     303.  00:782C  47 45 54 44 50 42 >         db string
     303.  00:7832                    > .skip:
     303.  00:7832                    >         endif
     304.  00:7832  EB                          ex de,hl
     305.  00:7833  13                          inc de
     306.  00:7834  67                          ld h,a
     307.  00:7835  78                          ld a,b
     308.  00:7836  FE F0                       cp $f0
     309.  00:7838  7C                          ld a,h
     310.  00:7839  28 24                       jr z,.hddImage
     311.  00:783B                              
     312.  00:783B                              MESSAGE "ROM GETDPB"
     312.  00:783B  CD 1C 74          >         call sendMessage
     312.  00:783E                    >         db string
     312.  00:783E  52 4F 4D 20 47 45 54 44 50 42 
     312.  00:7848  00                > .skip2: nop
     313.  00:7849                      
     314.  00:7849  78                          ld a,b
     315.  00:784A  D6 F8                       sub $f8
     316.  00:784C  D8                          ret c                           ; not supported in msxdos1
     317.  00:784D  07                          rlca                            ; 2x
     318.  00:784E  4F                          ld c,a
     319.  00:784F  07                          rlca                            ; 4x
     320.  00:7850  07                          rlca                            ; 8x
     321.  00:7851  07                          rlca                            ; 16x
     322.  00:7852  81                          add a,c                         ; 18x
     323.  00:7853  4F                          ld c,a
     324.  00:7854  06 00                       ld b,0        
     325.  00:7856  21 CE 7B                    ld hl,supportedMedia
     326.  00:7859  09                          add hl,bc
     327.  00:785A  0E 12                       ld c,18
     328.  00:785C  ED B0                       ldir
     329.  00:785E  C9                          ret
     330.  00:785F                      
     331.  00:785F                      .hddImage:
     332.  00:785F                              DEBUGMESSAGE ".hddImage"
     332.  00:785F                    >         ifdef DEBUG
     332.  00:785F  52                >         ld d,d
     332.  00:7860  18 09             >         jr .skip
     332.  00:7862                    >         db string
     332.  00:7862  2E 68 64 64 49 6D 61 67 65 
     332.  00:786B                    > .skip:
     332.  00:786B                    >         endif
     333.  00:786B                                      MESSAGE "HOST GETDPB"
     333.  00:786B  CD 1C 74          >         call sendMessage
     333.  00:786E                    >         db string
     333.  00:786E  48 4F 53 54 20 47 45 54 44 50 42 
     333.  00:7879  00                > .skip2: nop
     334.  00:787A  CD DC 73                    call sendRegisters
     335.  00:787D  36 82                       ld (hl),C_GETDPB
     336.  00:787F  CD 6D 75                    call enableNowindPage0
     337.  00:7882  26 20                       ld h,HIGH usbrd
     338.  00:7884  CD EE 73                    call getHeader
     339.  00:7887  38 09                       jr c,.exit                      ; not ready
     340.  00:7889  5F                          ld e,a                          ; destination
     341.  00:788A  56                          ld d,(hl)
     342.  00:788B  01 12 00                    ld bc,18
     343.  00:788E                              DEBUGDUMPREGISTERS
     343.  00:788E                    >         ifdef DEBUG
     343.  00:788E  ED 07             >         db $ed,7
     343.  00:7890                    >         endif
     343.  00:7890                    >         
     343.  00:7890                    >         ifdef USBDEBUG
     343.  00:7890                    ~         assert ($ < $8000)
     343.  00:7890                    ~         call sendCpuInfo
     343.  00:7890                    ~         endif
     344.  00:7890  ED B0                       ldir
     345.  00:7892                              ;DB $ed, $0a       
     346.  00:7892  C3 78 75            .exit:  jp restorePage0        
     347.  00:7895                      
     348.  00:7895                      CHOICE:
     349.  00:7895                              ;DEBUGMESSAGE "CHOICE"
     350.  00:7895                              ifdef MSXDOS2
     351.  00:7895                    ~         ld hl,.noFormat
     352.  00:7895                    ~         else
     353.  00:7895  21 00 00                    ld hl,0                         ; no choice
     354.  00:7898                              endif
     355.  00:7898  C9                          ret
     356.  00:7899                      
     357.  00:7899                      .noFormat:
     358.  00:7899  00                          db 0
     359.  00:789A                      
     360.  00:789A                      DSKFMT:
     361.  00:789A  37                          scf
     362.  00:789B  3E 10                       ld a,16                         ; other error
     363.  00:789D  C9                          ret
     364.  00:789E                              
     365.  00:789E  (B89E)                      PHASE $ + $4000
     366.  00:B89E                              
     367.  00:B89E                      readSectors01:
     368.  00:B89E                              DEBUGMESSAGE "readSectors01"
     368.  00:B89E                    >         ifdef DEBUG
     368.  00:B89E  52                >         ld d,d
     368.  00:B89F  18 0D             >         jr .skip
     368.  00:B8A1                    >         db string
     368.  00:B8A1  72 65 61 64 53 65 63 74 6F 72 73 30 31 
     368.  00:B8AE                    > .skip:
     368.  00:B8AE                    >         endif
     369.  00:B8AE  26 80                       ld h,HIGH usb2
     370.  00:B8B0  CD EE B3                    call getHeader + $4000                                  
     371.  00:B8B3  D8                          ret c                           ; carry means timeout, no carry: A == 0 means slow transfer, A == 1 means exit, A == 2 means fast transfer                                      
     372.  00:B8B4  3D                          dec a
     373.  00:B8B5  C8                          ret z
     374.  00:B8B6  FA C0 B8                    jp m,.slowTransfer                              
     375.  00:B8B9  CD 32 B9                    call reverseTransfer + $4000
     376.  00:B8BC  70                          ld (hl),b
     377.  00:B8BD  71                          ld (hl),c
     378.  00:B8BE  18 DE                       jr readSectors01
     379.  00:B8C0                      
     380.  00:B8C0                      .slowTransfer:
     381.  00:B8C0  5E                          ld e,(hl)                       ; transfer address
     382.  00:B8C1  56                          ld d,(hl)
     383.  00:B8C2  4E                          ld c,(hl)                       ; transfer amount 
     384.  00:B8C3  46                          ld b,(hl)
     385.  00:B8C4  ED B0                       ldir        
     386.  00:B8C6                              
     387.  00:B8C6  56                          ld d,(hl)                       ; BUG in emulator (byte direct terugschrijven, geeft 'rukkert!')
     388.  00:B8C7  7E                          ld a,(hl)
     389.  00:B8C8  72                          ld (hl),d                       ; return end marker ($af, $0f)
     390.  00:B8C9  77                          ld (hl),a
     391.  00:B8CA  18 D2                       jr readSectors01
     392.  00:B8CC                      
     393.  00:B8CC                      writeLoop01:
     394.  00:B8CC  26 80                       ld h,HIGH usb2
     395.  00:B8CE  CD EE B3                    call getHeader + $4000
     396.  00:B8D1  D8                          ret c                           ; exit (not ready)
     397.  00:B8D2  B7                          or a
     398.  00:B8D3  F8                          ret m                           ; exit (no error)
     399.  00:B8D4  20 18                       jr nz,.error
     400.  00:B8D6                      
     401.  00:B8D6                              DEBUGMESSAGE "send01"
     401.  00:B8D6                    >         ifdef DEBUG
     401.  00:B8D6  52                >         ld d,d
     401.  00:B8D7  18 06             >         jr .skip
     401.  00:B8D9  73 65 6E 64 30 31 >         db string
     401.  00:B8DF                    > .skip:
     401.  00:B8DF                    >         endif
     402.  00:B8DF  5E                          ld e,(hl)                       ; address
     403.  00:B8E0  56                          ld d,(hl)
     404.  00:B8E1  4E                          ld c,(hl)                       ; number of bytes        
     405.  00:B8E2  46                          ld b,(hl)
     406.  00:B8E3  7E                          ld a,(hl)                       ; block sequence number
     407.  00:B8E4                      
     408.  00:B8E4  EB                          ex de,hl
     409.  00:B8E5  11 00 80                    ld de,usb2
     410.  00:B8E8  12                          ld (de),a                       ; mark block begin
     411.  00:B8E9  ED B0                       ldir
     412.  00:B8EB  12                          ld (de),a                       ; mark block end
     413.  00:B8EC  18 DE                       jr writeLoop01
     414.  00:B8EE                      
     415.  00:B8EE  37                  .error: scf
     416.  00:B8EF  7E                          ld a,(hl)                       ; get error code
     417.  00:B8F0  C9                          ret
     418.  00:B8F1                      
     419.  00:B8F1  (78F1)                      DEPHASE
     420.  00:78F1                       
     421.  00:78F1                      readSectors23:
     422.  00:78F1                              DEBUGMESSAGE "readSectors23"
     422.  00:78F1                    >         ifdef DEBUG
     422.  00:78F1  52                >         ld d,d
     422.  00:78F2  18 0D             >         jr .skip
     422.  00:78F4                    >         db string
     422.  00:78F4  72 65 61 64 53 65 63 74 6F 72 73 32 33 
     422.  00:7901                    > .skip:
     422.  00:7901                    >         endif
     423.  00:7901  26 20                       ld h,HIGH usbrd
     424.  00:7903  CD EE 73                    call getHeader
     425.  00:7906  D8                          ret c
     426.  00:7907  3D                          dec a
     427.  00:7908  C8                          ret z                           ; no more data
     428.  00:7909  FA 15 79                    jp m,.slowTransfer        
     429.  00:790C  CD 32 79                    call reverseTransfer
     430.  00:790F  26 40                       ld h,HIGH usbwr 
     431.  00:7911  70                          ld (hl),b
     432.  00:7912  71                          ld (hl),c
     433.  00:7913  18 DC                       jr readSectors23
     434.  00:7915                      
     435.  00:7915                      .slowTransfer:
     436.  00:7915                              DEBUGMESSAGE "slowtransfer"
     436.  00:7915                    >         ifdef DEBUG
     436.  00:7915  52                >         ld d,d
     436.  00:7916  18 0C             >         jr .skip
     436.  00:7918                    >         db string
     436.  00:7918  73 6C 6F 77 74 72 61 6E 73 66 65 72 
     436.  00:7924                    > .skip:
     436.  00:7924                    >         endif
     437.  00:7924  5E                          ld e,(hl)                       ; transfer address
     438.  00:7925  56                          ld d,(hl)
     439.  00:7926  4E                          ld c,(hl)                       ; transfer amount 
     440.  00:7927  46                          ld b,(hl)
     441.  00:7928  ED B0                       ldir
     442.  00:792A  56                          ld d,(hl)
     443.  00:792B  7E                          ld a,(hl)
     444.  00:792C  26 40                       ld h,HIGH usbwr
     445.  00:792E  72                          ld (hl),d                       ; return end marker ($af, $0f)
     446.  00:792F  77                          ld (hl),a
     447.  00:7930  18 BF                       jr readSectors23
     448.  00:7932                                     
     449.  00:7932                      reverseTransfer:
     450.  00:7932  FD 21 00 00                 ld iy,0                         ; save stack pointer
     451.  00:7936  FD 39                       add iy,sp
     452.  00:7938  5E                          ld e,(hl)                       ; transfer address
     453.  00:7939  56                          ld d,(hl)
     454.  00:793A  EB                          ex de,hl
     455.  00:793B  F9                          ld sp,hl
     456.  00:793C  EB                          ex de,hl
     457.  00:793D  46                          ld b,(hl)                       ; number of loops       
     458.  00:793E                      .loop:
     459.  00:793E                              repeat 32                       ; blocks of 64 bytes hardcoded (NowindHost.cpp)
     460.  00:793E                    <         ld d,(hl)
     461.  00:793E                    <         ld e,(hl)
     462.  00:793E                    <         push de
     463.  00:793E                    <         endrepeat
     463.  00:793E  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     463.  00:794E  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     463.  00:795E  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     463.  00:796E  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     463.  00:797E  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     463.  00:798E  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     464.  00:799E  10 9E                       djnz .loop
     465.  00:79A0                              
     466.  00:79A0  FD F9                       ld sp,iy                        ; restore stack pointer
     467.  00:79A2  46                          ld b,(hl)                       ; return end marker
     468.  00:79A3  4E                          ld c,(hl)
     469.  00:79A4  C9                          ret
     470.  00:79A5                            
     471.  00:79A5                      OEMSTA:
     472.  00:79A5  E5                          push hl
     473.  00:79A6  21 B3 79                    ld hl,.statement
     474.  00:79A9  CD B0 73                    call findStatementName
     475.  00:79AC  5E                          ld e,(hl)
     476.  00:79AD  23                          inc hl
     477.  00:79AE  56                          ld d,(hl)
     478.  00:79AF  E1                          pop hl        
     479.  00:79B0  D8                          ret c
     480.  00:79B1  D5                          push de
     481.  00:79B2  C9                          ret
     482.  00:79B3                      
     483.  00:79B3                      .statement:
     484.  00:79B3  49 4D 41 47 45 00           db "IMAGE",0
     485.  00:79B9  C6 79                       dw changeImage
     486.  00:79BB                              db "VSTREAM",0
     486.  00:79BB  56 53 54 52 45 41 4D 00 
     487.  00:79C3  F3 79                       dw videoStream
     488.  00:79C5  00                          db 0
     489.  00:79C6                      
     490.  00:79C6                      ; send arguments, command, filename, end with ":"
     491.  00:79C6                      changeImage:
     492.  00:79C6                              DEBUGMESSAGE "changeImage"
     492.  00:79C6                    >         ifdef DEBUG
     492.  00:79C6  52                >         ld d,d
     492.  00:79C7  18 0B             >         jr .skip
     492.  00:79C9                    >         db string
     492.  00:79C9  63 68 61 6E 67 65 49 6D 61 67 65 
     492.  00:79D4                    > .skip:
     492.  00:79D4                    >         endif
     493.  00:79D4  E5                          push hl
     494.  00:79D5  CD DC 73                    call sendRegisters
     495.  00:79D8  36 91                       ld (hl),C_CHANGEIMAGE
     496.  00:79DA  E1                          pop hl
     497.  00:79DB                              
     498.  00:79DB                      call_exit:
     499.  00:79DB                              DEBUGMESSAGE "call_exit"
     499.  00:79DB                    >         ifdef DEBUG
     499.  00:79DB  52                >         ld d,d
     499.  00:79DC  18 09             >         jr .skip
     499.  00:79DE                    >         db string
     499.  00:79DE  63 61 6C 6C 5F 65 78 69 74 
     499.  00:79E7                    > .skip:
     499.  00:79E7                    >         endif
     500.  00:79E7  7E                  .loop:  ld a,(hl)
     501.  00:79E8  32 00 40                    ld (usbwr),a
     502.  00:79EB  FE 3A                       cp ":"
     503.  00:79ED  C8                          ret z
     504.  00:79EE  B7                          or a
     505.  00:79EF  C8                          ret z
     506.  00:79F0  23                          inc hl
     507.  00:79F1  18 F4                       jr .loop
     508.  00:79F3                              
     509.  00:79F3                      videoStream: 
     510.  00:79F3  E5                          push hl
     511.  00:79F4                              include "vram.asm"
       1:  00:79F4                              
       2:  00:79F4                      vramDump:
       3:  00:79F4  F3                          di
       4:  00:79F5  CD 6D 75                    call enableNowindPage0
       5:  00:79F8                      
       6:  00:79F8  3E 02                       ld a,2
       7:  00:79FA  D3 99                       out ($99),a
       8:  00:79FC  3E 8F                       ld a,$80+15             ; status register pointer at S#2
       9:  00:79FE  D3 99                       out ($99),a
      10:  00:7A00                      
      11:  00:7A00                      evenFrame:
      12:  00:7A00                              ; vram address 0x0000
      13:  00:7A00                              
      14:  00:7A00                              ;xor a
      15:  00:7A00                              ;out ($99),a
      16:  00:7A00                              ;ld a,$80+2
      17:  00:7A00                              ;out ($99),a
      18:  00:7A00                              
      19:  00:7A00  3E 03                       ld a,%00000011                 ; pattern generator table
      20:  00:7A02  D3 99                       out ($99),a
      21:  00:7A04  3E 84                       ld a,$80+4
      22:  00:7A06  D3 99                       out ($99),a
      23:  00:7A08                      
      24:  00:7A08  AF                          xor a                   ; color table high
      25:  00:7A09  D3 99                       out ($99),a
      26:  00:7A0B  3E 8A                       ld a,$80+10
      27:  00:7A0D  D3 99                       out ($99),a
      28:  00:7A0F                              
      29:  00:7A0F  3E 04                       ld a,%00000100          ; vram access at 0x10000
      30:  00:7A11  CD A5 7B                    call setVramAccessPointer
      31:  00:7A14  CD 3D 7A                    call tranferframe
      32:  00:7A17  CD B3 7B                    call waitForRetrace
      33:  00:7A1A  CD 57 7B                    call changeColors
      34:  00:7A1D                      
      35:  00:7A1D                      oddFrame:
      36:  00:7A1D                              ; vram address 0x10000
      37:  00:7A1D                      
      38:  00:7A1D                              ;ld a,%01000000
      39:  00:7A1D                              ;out ($99),a
      40:  00:7A1D                              ;ld a,$80+2
      41:  00:7A1D                              ;out ($99),a
      42:  00:7A1D                      
      43:  00:7A1D  3E 23                       ld a,%00100011          ; pattern generator table
      44:  00:7A1F  D3 99                       out ($99),a
      45:  00:7A21  3E 84                       ld a,$80+4
      46:  00:7A23  D3 99                       out ($99),a
      47:  00:7A25                      
      48:  00:7A25  3E 64                       ld a,00000100           ; color table high
      49:  00:7A27  D3 99                       out ($99),a
      50:  00:7A29  3E 8A                       ld a,$80+10
      51:  00:7A2B  D3 99                       out ($99),a
      52:  00:7A2D                      
      53:  00:7A2D  AF                          xor a
      54:  00:7A2E  CD A5 7B                    call setVramAccessPointer
      55:  00:7A31  CD 3D 7A                    call tranferframe
      56:  00:7A34  CD B3 7B                    call waitForRetrace
      57:  00:7A37  CD 57 7B                    call changeColors
      58:  00:7A3A  C3 00 7A                    jp evenFrame
      59:  00:7A3D                      
      60:  00:7A3D                      tranferframe:
      61:  00:7A3D  CD DC 73                    call sendRegisters
      62:  00:7A40  36 FF                       ld (hl),255
      63:  00:7A42                                      
      64:  00:7A42  21 00 20                    ld hl,usbrd
      65:  00:7A45  CD EE 73                    call getHeader
      66:  00:7A48                              
      67:  00:7A48  16 70                       ld d,112                        ; 224x64 is 1 screen 2 page of data ($3800)
      68:  00:7A4A                      write_more:        
      69:  00:7A4A  21 00 20                    ld hl,usbrd
      70:  00:7A4D  01 98 00                    ld bc,$0098
      71:  00:7A50                              repeat 128
      72:  00:7A50                    <         outi
      73:  00:7A50                    <         endrepeat
      73:  00:7A50  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A60  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A70  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A80  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A90  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AA0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AB0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AC0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AD0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AE0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AF0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7B00  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7B10  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7B20  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7B30  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7B40  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      74:  00:7B50                      
      75:  00:7B50  15                          dec d
      76:  00:7B51  7A                          ld a,d
      77:  00:7B52  B7                          or a
      78:  00:7B53  C2 4A 7A                    jp nz,write_more
      79:  00:7B56  C9                          ret             
      80:  00:7B57                      
      81:  00:7B57                      changeColors:
      82:  00:7B57  AF                          xor a                   ; set color register pointer to zero
      83:  00:7B58  D3 99                       out ($99),a
      84:  00:7B5A  3E 90                       ld a,$80+16
      85:  00:7B5C  D3 99                       out ($99),a
      86:  00:7B5E                              
      87:  00:7B5E  21 00 20                    ld hl,usbrd
      88:  00:7B61  01 9A 00                    ld bc,$009A             ; write to color register
      89:  00:7B64                      
      90:  00:7B64                              repeat 32
      91:  00:7B64                    <         outi
      92:  00:7B64                    <         endrepeat               
      92:  00:7B64  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B74  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B84  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B94  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      93:  00:7BA4  C9                          ret
      94:  00:7BA5                      
      95:  00:7BA5                              
      96:  00:7BA5                      setVramAccessPointer:
      97:  00:7BA5  D3 99                       out ($99),a
      98:  00:7BA7  3E 8E                       ld a,$80+14
      99:  00:7BA9  D3 99                       out ($99),a
     100:  00:7BAB  AF                          xor a
     101:  00:7BAC  D3 99                       out ($99),a
     102:  00:7BAE  3E 40                       ld a,%01000000          ; vram write
     103:  00:7BB0  D3 99                       out ($99),a
     104:  00:7BB2  C9                          ret
     105:  00:7BB3                      
     106:  00:7BB3                      waitForRetrace:
     107:  00:7BB3  DB 99                       in a,($99)
     108:  00:7BB5  CB 77                       bit 6,a
     109:  00:7BB7  20 FA                       jr nz,waitForRetrace       
     110:  00:7BB9                      .lp2:        
     111:  00:7BB9  DB 99                       in a,($99)
     112:  00:7BBB  CB 77                       bit 6,a
     113:  00:7BBD  28 FA                       jr z,.lp2       
     114:  00:7BBF  C9                          ret
     115:  00:7BC0                                      
     116:  00:7BC0                              ; just let it go... 
     512.  00:7BC0  E1                          pop hl
     513.  00:7BC1  C3 DB 79                    jp call_exit
     514.  00:7BC4                              
     515.  00:7BC4                      ; hl points to text
     516.  00:7BC4                      printVdpText2:
     517.  00:7BC4  F5                                                  push af
     518.  00:7BC5  7E                  .loop:  ld a,(hl)
     519.  00:7BC6  D3 98                                               out ($98),a 
     520.  00:7BC8  23                                                  inc hl
     521.  00:7BC9  B7                                                  or a
     522.  00:7BCA  20 F9                                               jr nz,.loop
     523.  00:7BCC  F1                                                  pop af
     524.  00:7BCD  C9                                                  ret
     525.  00:7BCE                              
     526.  00:7BCE                      supportedMedia:
     527.  00:7BCE                                      
     528.  00:7BCE                      .f8:    MAKEDPB $f8, 512, 2, 112, 1 * 80 * 9, 2, 2      ; 360 kB (1 side * 80 tracks * 9 tracks/sector)
     528.  00:7BCE  (00:0001)         > .firfat equ 1
     528.  00:7BCE  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     528.  00:7BCE  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     528.  00:7BCE                    >         if sectorSize = 512
     528.  00:7BCE  (00:0004)         > .shft   equ 4
     528.  00:7BCE                    >         elseif sectorSize = 256
     528.  00:7BCE                    ~ .shft   equ 3
     528.  00:7BCE                    ~         endif
     528.  00:7BCE                    >         
     528.  00:7BCE  F8                >         db media
     528.  00:7BCF  00 02             >         dw sectorSize
     528.  00:7BD1  0F 04             >         db (sectorSize/32)-1, .shft
     528.  00:7BD3  01                >         db sectorsPerCluster-1
     528.  00:7BD4  02                >         db sectorsPerCluster
     528.  00:7BD5  01 00             >         dw .firfat
     528.  00:7BD7  02 70             >         db fatCount, maxEnt
     528.  00:7BD9  0C 00             >         dw .firrec
     528.  00:7BDB  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     528.  00:7BDD  02                >         db fatSiz
     528.  00:7BDE  05 00             >         dw .firdir
     529.  00:7BE0                      .def:   MAKEDPB $f9, 512, 2, 112, 2 * 80 * 9, 3, 2      ; 720 kB
     529.  00:7BE0  (00:0001)         > .firfat equ 1
     529.  00:7BE0  (00:0007)         > .firdir equ .firfat+(fatCount*fatSiz)
     529.  00:7BE0  (00:000E)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     529.  00:7BE0                    >         if sectorSize = 512
     529.  00:7BE0  (00:0004)         > .shft   equ 4
     529.  00:7BE0                    >         elseif sectorSize = 256
     529.  00:7BE0                    ~ .shft   equ 3
     529.  00:7BE0                    ~         endif
     529.  00:7BE0                    >         
     529.  00:7BE0  F9                >         db media
     529.  00:7BE1  00 02             >         dw sectorSize
     529.  00:7BE3  0F 04             >         db (sectorSize/32)-1, .shft
     529.  00:7BE5  01                >         db sectorsPerCluster-1
     529.  00:7BE6  02                >         db sectorsPerCluster
     529.  00:7BE7  01 00             >         dw .firfat
     529.  00:7BE9  02 70             >         db fatCount, maxEnt
     529.  00:7BEB  0E 00             >         dw .firrec
     529.  00:7BED  CA 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     529.  00:7BEF  03                >         db fatSiz
     529.  00:7BF0  07 00             >         dw .firdir
     530.  00:7BF2                              MAKEDPB $fa, 512, 2, 112, 1 * 80 * 8, 1, 2      ; 320 kB
     530.  00:7BF2  (00:0001)         > .firfat equ 1
     530.  00:7BF2  (00:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     530.  00:7BF2  (00:000A)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     530.  00:7BF2                    >         if sectorSize = 512
     530.  00:7BF2  (00:0004)         > .shft   equ 4
     530.  00:7BF2                    >         elseif sectorSize = 256
     530.  00:7BF2                    ~ .shft   equ 3
     530.  00:7BF2                    ~         endif
     530.  00:7BF2                    >         
     530.  00:7BF2  FA                >         db media
     530.  00:7BF3  00 02             >         dw sectorSize
     530.  00:7BF5  0F 04             >         db (sectorSize/32)-1, .shft
     530.  00:7BF7  01                >         db sectorsPerCluster-1
     530.  00:7BF8  02                >         db sectorsPerCluster
     530.  00:7BF9  01 00             >         dw .firfat
     530.  00:7BFB  02 70             >         db fatCount, maxEnt
     530.  00:7BFD  0A 00             >         dw .firrec
     530.  00:7BFF  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     530.  00:7C01  01                >         db fatSiz
     530.  00:7C02  03 00             >         dw .firdir
     531.  00:7C04                              MAKEDPB $fb, 512, 2, 112, 2 * 80 * 8, 2, 2      ; 640 kB
     531.  00:7C04  (00:0001)         > .firfat equ 1
     531.  00:7C04  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     531.  00:7C04  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     531.  00:7C04                    >         if sectorSize = 512
     531.  00:7C04  (00:0004)         > .shft   equ 4
     531.  00:7C04                    >         elseif sectorSize = 256
     531.  00:7C04                    ~ .shft   equ 3
     531.  00:7C04                    ~         endif
     531.  00:7C04                    >         
     531.  00:7C04  FB                >         db media
     531.  00:7C05  00 02             >         dw sectorSize
     531.  00:7C07  0F 04             >         db (sectorSize/32)-1, .shft
     531.  00:7C09  01                >         db sectorsPerCluster-1
     531.  00:7C0A  02                >         db sectorsPerCluster
     531.  00:7C0B  01 00             >         dw .firfat
     531.  00:7C0D  02 70             >         db fatCount, maxEnt
     531.  00:7C0F  0C 00             >         dw .firrec
     531.  00:7C11  7B 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     531.  00:7C13  02                >         db fatSiz
     531.  00:7C14  05 00             >         dw .firdir
     532.  00:7C16                              MAKEDPB $fc, 512, 1, 64,  1 * 40 * 9, 2, 2      ; 180 kB
     532.  00:7C16  (00:0001)         > .firfat equ 1
     532.  00:7C16  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     532.  00:7C16  (00:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     532.  00:7C16                    >         if sectorSize = 512
     532.  00:7C16  (00:0004)         > .shft   equ 4
     532.  00:7C16                    >         elseif sectorSize = 256
     532.  00:7C16                    ~ .shft   equ 3
     532.  00:7C16                    ~         endif
     532.  00:7C16                    >         
     532.  00:7C16  FC                >         db media
     532.  00:7C17  00 02             >         dw sectorSize
     532.  00:7C19  0F 04             >         db (sectorSize/32)-1, .shft
     532.  00:7C1B  00                >         db sectorsPerCluster-1
     532.  00:7C1C  01                >         db sectorsPerCluster
     532.  00:7C1D  01 00             >         dw .firfat
     532.  00:7C1F  02 40             >         db fatCount, maxEnt
     532.  00:7C21  09 00             >         dw .firrec
     532.  00:7C23  60 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     532.  00:7C25  02                >         db fatSiz
     532.  00:7C26  05 00             >         dw .firdir
     533.  00:7C28                              MAKEDPB $fd, 512, 2, 112, 2 * 40 * 9, 2, 2      ; 360 kB
     533.  00:7C28  (00:0001)         > .firfat equ 1
     533.  00:7C28  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     533.  00:7C28  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     533.  00:7C28                    >         if sectorSize = 512
     533.  00:7C28  (00:0004)         > .shft   equ 4
     533.  00:7C28                    >         elseif sectorSize = 256
     533.  00:7C28                    ~ .shft   equ 3
     533.  00:7C28                    ~         endif
     533.  00:7C28                    >         
     533.  00:7C28  FD                >         db media
     533.  00:7C29  00 02             >         dw sectorSize
     533.  00:7C2B  0F 04             >         db (sectorSize/32)-1, .shft
     533.  00:7C2D  01                >         db sectorsPerCluster-1
     533.  00:7C2E  02                >         db sectorsPerCluster
     533.  00:7C2F  01 00             >         dw .firfat
     533.  00:7C31  02 70             >         db fatCount, maxEnt
     533.  00:7C33  0C 00             >         dw .firrec
     533.  00:7C35  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     533.  00:7C37  02                >         db fatSiz
     533.  00:7C38  05 00             >         dw .firdir
     534.  00:7C3A                              MAKEDPB $fe, 512, 1, 64,  1 * 40 * 8, 1, 2      ; 160 kB
     534.  00:7C3A  (00:0001)         > .firfat equ 1
     534.  00:7C3A  (00:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     534.  00:7C3A  (00:0007)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     534.  00:7C3A                    >         if sectorSize = 512
     534.  00:7C3A  (00:0004)         > .shft   equ 4
     534.  00:7C3A                    >         elseif sectorSize = 256
     534.  00:7C3A                    ~ .shft   equ 3
     534.  00:7C3A                    ~         endif
     534.  00:7C3A                    >         
     534.  00:7C3A  FE                >         db media
     534.  00:7C3B  00 02             >         dw sectorSize
     534.  00:7C3D  0F 04             >         db (sectorSize/32)-1, .shft
     534.  00:7C3F  00                >         db sectorsPerCluster-1
     534.  00:7C40  01                >         db sectorsPerCluster
     534.  00:7C41  01 00             >         dw .firfat
     534.  00:7C43  02 40             >         db fatCount, maxEnt
     534.  00:7C45  07 00             >         dw .firrec
     534.  00:7C47  3A 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     534.  00:7C49  01                >         db fatSiz
     534.  00:7C4A  03 00             >         dw .firdir
     535.  00:7C4C                              MAKEDPB $ff, 512, 2, 112, 2 * 40 * 8, 1, 1      ; 320 kB
     535.  00:7C4C  (00:0001)         > .firfat equ 1
     535.  00:7C4C  (00:0002)         > .firdir equ .firfat+(fatCount*fatSiz)
     535.  00:7C4C  (00:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     535.  00:7C4C                    >         if sectorSize = 512
     535.  00:7C4C  (00:0004)         > .shft   equ 4
     535.  00:7C4C                    >         elseif sectorSize = 256
     535.  00:7C4C                    ~ .shft   equ 3
     535.  00:7C4C                    ~         endif
     535.  00:7C4C                    >         
     535.  00:7C4C  FF                >         db media
     535.  00:7C4D  00 02             >         dw sectorSize
     535.  00:7C4F  0F 04             >         db (sectorSize/32)-1, .shft
     535.  00:7C51  01                >         db sectorsPerCluster-1
     535.  00:7C52  02                >         db sectorsPerCluster
     535.  00:7C53  01 00             >         dw .firfat
     535.  00:7C55  01 70             >         db fatCount, maxEnt
     535.  00:7C57  09 00             >         dw .firrec
     535.  00:7C59  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     535.  00:7C5B  01                >         db fatSiz
     535.  00:7C5C  02 00             >         dw .firdir
     536.  00:7C5E                      
     537.  00:7C5E                      ; WARNING: in some cases DEFDPB-1 is expected!
     538.  00:7C5E  (00:7BE0)           DEFDPB  equ supportedMedia.def
     115   00:7C5E                              include "romdisk.asm"
       1.  00:7C5E                                      define  ROMDSKBANK 5                    ; romdisk starts in bank 5
       2.  00:7C5E                                      define  ROMDSKLAST (FLASHROMSIZE/16)-1
       3.  00:7C5E                      
       4.  00:7C5E                      
       5.  00:7C5E                      ROMDISK_DSKIO:
       6.  00:7C5E                              DEBUGMESSAGE "R_DSKIO"
       6.  00:7C5E                    >         ifdef DEBUG
       6.  00:7C5E  52                >         ld d,d
       6.  00:7C5F  18 07             >         jr .skip
       6.  00:7C61                    >         db string
       6.  00:7C61  52 5F 44 53 4B 49 4F 
       6.  00:7C68                    > .skip:
       6.  00:7C68                    >         endif
       7.  00:7C68  F1                          pop af
       8.  00:7C69  3E 00                       ld a,0
       9.  00:7C6B  D8                          ret c                           ; write protected
      10.  00:7C6C                              
      11.  00:7C6C  EB                          ex de,hl
      12.  00:7C6D  C5                  .loop:  push bc
      13.  00:7C6E  E5                          push hl        
      14.  00:7C6F                              
      15.  00:7C6F  CB 7A                       bit 7,d
      16.  00:7C71  20 1C                       jr nz,.directCopy
      17.  00:7C73  7A                          ld a,d
      18.  00:7C74  FE 3E                       cp $3e        
      19.  00:7C76  38 17                       jr c,.directCopy
      20.  00:7C78                      
      21.  00:7C78  CD 9B 7C                    call .findSector
      22.  00:7C7B  D5                          push de
      23.  00:7C7C  ED 5B 4D F3                 ld de,($f34d)        
      24.  00:7C80  CD F4 7F                    call copyFromBank
      25.  00:7C83  D1                          pop de
      26.  00:7C84  01 00 02                    ld bc,512
      27.  00:7C87  2A 4D F3                    ld hl,($f34d)
      28.  00:7C8A  CD 6E F3                    call XFER
      29.  00:7C8D  18 06                       jr .nextSector           
      30.  00:7C8F                                    
      31.  00:7C8F                      .directCopy:                
      32.  00:7C8F  CD 9B 7C                    call .findSector  
      33.  00:7C92  CD F4 7F                    call copyFromBank
      34.  00:7C95                      .nextSector:
      35.  00:7C95  E1                          pop hl
      36.  00:7C96  23                          inc hl
      37.  00:7C97  C1                          pop bc
      38.  00:7C98  10 D3                       djnz .loop
      39.  00:7C9A  C9                          ret
      40.  00:7C9B                      
      41.  00:7C9B                      .findSector:        
      42.  00:7C9B  7D                          ld a,l                          ; determine bank
      43.  00:7C9C  E6 E0                       and %11100000
      44.  00:7C9E  B4                          or h
      45.  00:7C9F  07                          rlca
      46.  00:7CA0  07                          rlca
      47.  00:7CA1  07                          rlca
      48.  00:7CA2  47                          ld b,a
      49.  00:7CA3                      
      50.  00:7CA3  7D                          ld a,l
      51.  00:7CA4  E6 1F                       and 31
      52.  00:7CA6  4F                          ld c,a
      53.  00:7CA7  3E FF                       ld a,ROMDSKLAST                 ; banks with b0..5=0 reside in the last bank
      54.  00:7CA9  28 05                       jr z,.skip
      55.  00:7CAB                      
      56.  00:7CAB  78                          ld a,b
      57.  00:7CAC  C6 05                       add ROMDSKBANK
      58.  00:7CAE  41                          ld b,c
      59.  00:7CAF  05                          dec b
      60.  00:7CB0  4F                  .skip:  ld c,a
      61.  00:7CB1  78                          ld a,b
      62.  00:7CB2  07                          rlca
      63.  00:7CB3  C6 41                       add $41                         ; disk images starts at $4100
      64.  00:7CB5  67                          ld h,a
      65.  00:7CB6  2E 00                       ld l,0
      66.  00:7CB8  79                          ld a,c
      67.  00:7CB9  01 00 02                    ld bc,512
      68.  00:7CBC  C9                          ret
      69.  00:7CBD                                                               
      70.  00:7CBD                      ROMDISK_DSKCHG:
      71.  00:7CBD                              ;DEBUGMESSAGE "ROM_DSKCHG"
      72.  00:7CBD  F1                          pop af
      73.  00:7CBE  A7                          and a
      74.  00:7CBF  06 01                       ld b,1                          ; not changed
      75.  00:7CC1  C9                          ret
      76.  00:7CC2                      
      77.  00:7CC2                      ROMDISK_GETDPB:
      78.  00:7CC2                              ; not implemented (standard mediadescriptor as used)
      79.  00:7CC2                              
      80.  00:7CC2                      ROMDISK_DSKFMT:
      81.  00:7CC2                              ; not implemented (no disk can be formatted)
      82.  00:7CC2                              
     116   00:7CC2                              include "flashWriter.asm"               ; todo: remove load from pc
       1.  00:7CC2                      ; flashWriter.asm
       2.  00:7CC2                      ; Flashes and erases the AMD29F040/M29F032-D
       3.  00:7CC2                           
       4.  00:7CC2                      flashWriter:
       5.  00:7CC2                              ;DEBUGMESSAGE "flashWriter"
       6.  00:7CC2  3E 03                       ld a,3
       7.  00:7CC4  CD 41 01                    call SNSMAT
       8.  00:7CC7  E6 08                       and 8
       9.  00:7CC9  C0                          ret nz
      10.  00:7CCA                              
      11.  00:7CCA  CD 8E 72                    call PRINTTEXT
      12.  00:7CCD                              db 10,13," FlashROM",10,13," "
      12.  00:7CCD  0A 0D 20 46 6C 61 73 68 52 4F 4D 0A 0D 20 
      13.  00:7CDB  2E (33)                     ds 33,"."
      14.  00:7CFC  0D 20 00                    db 13," ",0
      15.  00:7CFF                              
      16.  00:7CFF  CD C8 75                    call getSlotPage1
      17.  00:7D02  CD 81 75                    call enableSlotPage0
      18.  00:7D05                      
      19.  00:7D05  21 12 7D                    ld hl,.source
      20.  00:7D08  11 00 C0                    ld de,$c000
      21.  00:7D0B  D5                          push de
      22.  00:7D0C  01 DB 00                    ld bc,flasherEnd - $c000
      23.  00:7D0F  ED B0                       ldir
      24.  00:7D11  C9                          ret
      25.  00:7D12                              
      26.  00:7D12                      .source:     
      27.  00:7D12  (C000)                      PHASE $c000  
      28.  00:C000                              
      29.  00:C000                      waitForHeader:
      30.  00:C000  26 20                       ld h,HIGH usbrd
      31.  00:C002  7E                          ld a,(hl)
      32.  00:C003  FE BB               .chkbb: cp $bb
      33.  00:C005  20 F9                       jr nz,waitForHeader
      34.  00:C007  7E                          ld a,(hl)
      35.  00:C008  FE 55                       cp $55
      36.  00:C00A  20 F7                       jr nz,.chkbb       
      37.  00:C00C                      
      38.  00:C00C  7E                          ld a,(hl)
      39.  00:C00D  FE A2                       cp $a2
      40.  00:C00F  CA A9 C0                    jp z,verifyFlash
      41.  00:C012  FE A3                       cp $a3
      42.  00:C014  28 6E                       jr z,writeFlash
      43.  00:C016  FE A4                       cp $a4
      44.  00:C018  28 52                       jr z,chipErase
      45.  00:C01A  FE A5                       cp $a5
      46.  00:C01C  28 1C                       jr z,eraseSector
      47.  00:C01E  FE A6                       cp $a6
      48.  00:C020  28 02                       jr z,autoselectMode
      49.  00:C022                      
      50.  00:C022  20 DC                       jr nz,waitForHeader
      51.  00:C024                          
      52.  00:C024                      autoselectMode:
      53.  00:C024  3E 90                       ld a,$90
      54.  00:C026  CD CC C0                    call writeCommandSequence
      55.  00:C029                      
      56.  00:C029  2A 00 40                    ld hl,($4000)
      57.  00:C02C  EB                          ex de,hl
      58.  00:C02D  26 40                       ld h,HIGH usbwr
      59.  00:C02F  36 AA                       ld (hl),$aa
      60.  00:C031  36 55                       ld (hl),$55
      61.  00:C033  73                          ld (hl),e                       ; manufacturer ID (0x01 = AMD)
      62.  00:C034  72                          ld (hl),d                       ; device ID (0xA4 = AM29F040, 0x41 = AM29F032B)
      63.  00:C035                      
      64.  00:C035  CD 66 C0                    call writeResetCommand
      65.  00:C038  18 C6                       jr waitForHeader
      66.  00:C03A                      
      67.  00:C03A                      eraseSector:
      68.  00:C03A                              ;DEBUGMESSAGE "sector erase"
      69.  00:C03A  3E 65                       ld a,"e"
      70.  00:C03C  D3 98                       out ($98),a
      71.  00:C03E                      
      72.  00:C03E  7E                          ld a,(hl)                       ; get sector number 0..63
      73.  00:C03F  CB 27                       sla a
      74.  00:C041  CB 27                       sla a
      75.  00:C043  32 01 60                    ld (mapper),a                   ; select sector
      76.  00:C046                      
      77.  00:C046  3E 80                       ld a,$80
      78.  00:C048  CD CC C0                    call writeCommandSequence
      79.  00:C04B  3E 30                       ld a,$30        
      80.  00:C04D  CD CC C0                    call writeCommandSequence
      81.  00:C050                      
      82.  00:C050  CD 56 C0                    call waitForCommandToComplete
      83.  00:C053  C3 BD C0                    jp acknowledge
      84.  00:C056                              
      85.  00:C056                      waitForCommandToComplete:
      86.  00:C056  7E                          ld a,(hl)
      87.  00:C057  46                          ld b,(hl)
      88.  00:C058  A8                          xor b
      89.  00:C059  E6 40                       and %01000000                   ; check toggle bit I (DQ6)
      90.  00:C05B  C8                          ret z                           ; operation complete
      91.  00:C05C                              
      92.  00:C05C  78                          ld a,b
      93.  00:C05D  E6 20                       and %00100000                   ; timing limits exceeded? (DQ5)
      94.  00:C05F  28 F5                       jr z,waitForCommandToComplete
      95.  00:C061                      
      96.  00:C061  CD 66 C0                    call writeResetCommand
      97.  00:C064  78                          ld a,b
      98.  00:C065  C9                          ret
      99.  00:C066                      
     100.  00:C066                      writeResetCommand:
     101.  00:C066  3E F0                       ld a,$f0                        ; write RESET command
     102.  00:C068  32 00 00                    ld (0),a
     103.  00:C06B  C9                          ret
     104.  00:C06C                      
     105.  00:C06C                      chipErase:
     106.  00:C06C                              ;DEBUGMESSAGE "chip erase"
     107.  00:C06C  3E 45                       ld a,"E"
     108.  00:C06E  D3 98                       out ($98),a
     109.  00:C070                      
     110.  00:C070  3E 80                       ld a,$80
     111.  00:C072  CD CC C0                    call writeCommandSequence
     112.  00:C075  3E 10                       ld a,$10
     113.  00:C077  CD CC C0                    call writeCommandSequence
     114.  00:C07A                      
     115.  00:C07A  3A 00 40            .wait:  ld a,($4000)                    ; read DQ7 (data# polling) 
     116.  00:C07D  07                          rlca
     117.  00:C07E  30 FA                       jr nc,.wait        
     118.  00:C080  3E 01                       ld a,1
     119.  00:C082  18 39                       jr acknowledge
     120.  00:C084                      
     121.  00:C084                      
     122.  00:C084                      writeFlash:
     123.  00:C084                              ;DEBUGMESSAGE "write"
     124.  00:C084  5E                          ld e,(hl)                       ; address
     125.  00:C085  56                          ld d,(hl)
     126.  00:C086                      
     127.  00:C086  7A                          ld a,d
     128.  00:C087  B3                          or e
     129.  00:C088  CC C7 C0                    call z,updateBar
     130.  00:C08B                      
     131.  00:C08B  7E                          ld a,(hl)                       ; bank
     132.  00:C08C  32 01 60                    ld (mapper),a
     133.  00:C08F  26 40                       ld h,$40
     134.  00:C091                              
     135.  00:C091  06 80                       ld b,128                        ; data is written in blocks of 128 bytes
     136.  00:C093  3E A0               .loop:  ld a,$a0
     137.  00:C095  CD CC C0                    call writeCommandSequence
     138.  00:C098  3A 00 20                    ld a,(usbrd)
     139.  00:C09B  12                          ld (de),a                       ; write data to flash
     140.  00:C09C  13                          inc de
     141.  00:C09D                      
     142.  00:C09D  7E                  .wait:  ld  a,(hl)                      ; write complete?
     143.  00:C09E  AE                          xor (hl)
     144.  00:C09F  E6 40                       and %01000000
     145.  00:C0A1  20 FA                       jr  nz,.wait
     146.  00:C0A3  10 EE                       djnz .loop
     147.  00:C0A5                              
     148.  00:C0A5  3E 02                       ld a,2
     149.  00:C0A7  18 14                       jr acknowledge        
     150.  00:C0A9                              
     151.  00:C0A9                      verifyFlash:
     152.  00:C0A9                              ;DEBUGMESSAGE "verify"
     153.  00:C0A9  21 00 20                    ld hl,usbrd
     154.  00:C0AC  5E                          ld e,(hl)                       ; address
     155.  00:C0AD  56                          ld d,(hl)
     156.  00:C0AE  7E                          ld a,(hl)                       ; bank
     157.  00:C0AF  32 01 60                    ld (mapper),a
     158.  00:C0B2                      
     159.  00:C0B2  06 80                       ld b,128
     160.  00:C0B4  1A                  .loop:  ld a,(de)
     161.  00:C0B5  32 00 40                    ld (usbwr),a
     162.  00:C0B8  13                          inc de
     163.  00:C0B9  10 F9                       djnz .loop
     164.  00:C0BB                      
     165.  00:C0BB  3E 03                       ld a,3
     166.  00:C0BD                      acknowledge:        
     167.  00:C0BD  26 40                       ld h,HIGH usbwr
     168.  00:C0BF  36 AA                       ld (hl),$aa
     169.  00:C0C1  36 55                       ld (hl),$55
     170.  00:C0C3  77                          ld (hl),a
     171.  00:C0C4  C3 00 C0                    jp waitForHeader
     172.  00:C0C7                      
     173.  00:C0C7                      updateBar:
     174.  00:C0C7  3E 77                       ld a,"w"  
     175.  00:C0C9  D3 98                       out ($98),a
     176.  00:C0CB  C9                          ret
     177.  00:C0CC                      
     178.  00:C0CC                      writeCommandSequence:
     179.  00:C0CC  F5                          push af
     180.  00:C0CD  3E AA                       ld a,$aa
     181.  00:C0CF  32 55 05                    ld ($0555),a
     182.  00:C0D2  2F                          cpl
     183.  00:C0D3  32 AA 02                    ld ($02aa),a
     184.  00:C0D6  F1                          pop af
     185.  00:C0D7  32 55 05                    ld ($0555),a
     186.  00:C0DA  C9                          ret
     187.  00:C0DB                              
     188.  00:C0DB                      flasherEnd:
     189.  00:C0DB  (7DED)                      DEPHASE
     117   00:7DED                              include "device.asm"
       1.  00:7DED                      ; device.asm
       2.  00:7DED                      ; implements a basic now: device
       3.  00:7DED                          
       4.  00:7DED                      device:
       5.  00:7DED  E5                          push hl
       6.  00:7DEE  21 FF 7D                    ld hl,deviceFunctions
       7.  00:7DF1  0F                          rrca
       8.  00:7DF2  3C                          inc a
       9.  00:7DF3  07                          rlca
      10.  00:7DF4  85                          add a,l
      11.  00:7DF5  6F                          ld l,a
      12.  00:7DF6  30 01                       jr nc,.nocy
      13.  00:7DF8  24                          inc h  
      14.  00:7DF9  7E                  .nocy:  ld a,(hl)
      15.  00:7DFA  23                          inc hl
      16.  00:7DFB  66                          ld h,(hl)
      17.  00:7DFC  6F                          ld l,a
      18.  00:7DFD  E3                          ex (sp),hl
      19.  00:7DFE  C9                          ret
      20.  00:7DFF                      
      21.  00:7DFF                      deviceFunctions:
      22.  00:7DFF  15 7E                       dw identifyDevice               ; 0xff
      23.  00:7E01  35 7E                       dw open                         ;  0
      24.  00:7E03  6D 7E                       dw close                        ;  2
      25.  00:7E05  73 7E                       dw randomIO                     ;  4
      26.  00:7E07  77 7E                       dw write                        ;  6
      27.  00:7E09  7D 7E                       dw read                         ;  8
      28.  00:7E0B  D3 7E                       dw loc                          ; 10
      29.  00:7E0D  E5 7E                       dw lof                          ; 12
      30.  00:7E0F  B1 7E                       dw eof                          ; 14
      31.  00:7E11  E5 7E                       dw fpos                         ; 16
      32.  00:7E13  E5 7E                       dw putback                      ; 18
      33.  00:7E15                                
      34.  00:7E15                      identifyDevice:
      35.  00:7E15                              DEBUGMESSAGE "identifyDevice"
      35.  00:7E15                    >         ifdef DEBUG
      35.  00:7E15  52                >         ld d,d
      35.  00:7E16  18 0E             >         jr .skip
      35.  00:7E18                    >         db string
      35.  00:7E18  69 64 65 6E 74 69 66 79 44 65 76 69 63 65 
      35.  00:7E26                    > .skip:
      35.  00:7E26                    >         endif
      36.  00:7E26  21 2E 7E                    ld hl,deviceNameList
      37.  00:7E29  CD B0 73                    call findStatementName
      38.  00:7E2C  7E                          ld a,(hl)                       ; device number
      39.  00:7E2D  C9                          ret                             ; carry is set when invalid device name
      40.  00:7E2E                              
      41.  00:7E2E                      deviceNameList:
      42.  00:7E2E  4E 4F 57 00 00 00           db "NOW",0,0,0                  ; name, end marker, device number, dummy
      43.  00:7E34                              ;db "STDIN",0,1,0
      44.  00:7E34  00                          db 0
      45.  00:7E35                      
      46.  00:7E35                      ; Input     D   Global device code
      47.  00:7E35                      ;           E   File mode    
      48.  00:7E35                      ;           HL  address fcb
      49.  00:7E35                      open:
      50.  00:7E35                      ;        DEBUGMESSAGE "open"
      51.  00:7E35                      ;        DEBUGDUMPMEMHL 9
      52.  00:7E35  22 64 F8                    ld (PTRFIL),hl
      53.  00:7E38  CD DC 73                    call sendRegisters
      54.  00:7E3B  36 88                       ld (hl),C_DEVICEOPEN
      55.  00:7E3D  EB                          ex de,hl
      56.  00:7E3E  01 0B 00                    ld bc,11
      57.  00:7E41  21 66 F8                    ld hl,FILNAM
      58.  00:7E44  ED B0                       ldir
      59.  00:7E46                      
      60.  00:7E46  CD 6D 75                    call enableNowindPage0
      61.  00:7E49  26 20                       ld h,HIGH usbrd
      62.  00:7E4B  CD EE 73                    call getHeader
      63.  00:7E4E  38 0C                       jr c,deviceIoError              ; time out?
      64.  00:7E50  B7                          or a
      65.  00:7E51  20 0B                       jr nz,openError
      66.  00:7E53                      
      67.  00:7E53  5E                          ld e,(hl)                       ; update fcb (including buffer)
      68.  00:7E54  56                          ld d,(hl)
      69.  00:7E55  4E                          ld c,(hl)
      70.  00:7E56  46                          ld b,(hl)
      71.  00:7E57  ED B0                       ldir
      72.  00:7E59  C3 78 75                    jp restorePage0        
      73.  00:7E5C                      
      74.  00:7E5C                      deviceIoError:
      75.  00:7E5C  3E 13                       ld a,19
      76.  00:7E5E                      
      77.  00:7E5E                      openError:
      78.  00:7E5E  CD 78 75                    call restorePage0
      79.  00:7E61  5F                          ld e,a
      80.  00:7E62                      
      81.  00:7E62                      basicError:
      82.  00:7E62  DD 21 6F 40                 ld ix,$406f
      83.  00:7E66  FD 2A C0 FC                 ld iy,(EXPTBL-1)
      84.  00:7E6A  C3 1C 00                    jp CALSLT
      85.  00:7E6D                                      
      86.  00:7E6D                      close:
      87.  00:7E6D                      ;        DEBUGMESSAGE "close"
      88.  00:7E6D  CD DC 73                    call sendRegisters
      89.  00:7E70  36 89                       ld (hl),C_DEVICECLOSE
      90.  00:7E72  C9                          ret
      91.  00:7E73                              
      92.  00:7E73                      randomIO:
      93.  00:7E73                      ;        DEBUGMESSAGE "randomIO"
      94.  00:7E73  1E 3D                       ld e,61                         ; bad file mode
      95.  00:7E75  18 EB                       jr basicError
      96.  00:7E77                      
      97.  00:7E77                      write:
      98.  00:7E77                      ;        DEBUGMESSAGE "write"
      99.  00:7E77  CD DC 73                    call sendRegisters
     100.  00:7E7A  36 8B                       ld (hl),C_DEVICEWRITE
     101.  00:7E7C  C9                          ret        
     102.  00:7E7D                      
     103.  00:7E7D                      read:
     104.  00:7E7D                      ;        DEBUGMESSAGE "read"
     105.  00:7E7D  11 06 00                    ld de,6
     106.  00:7E80  19                          add hl,de
     107.  00:7E81  E5                          push hl
     108.  00:7E82  5E                          ld e,(hl)
     109.  00:7E83  23                          inc hl
     110.  00:7E84  23                          inc hl
     111.  00:7E85  23                          inc hl
     112.  00:7E86  19                          add hl,de
     113.  00:7E87  7E                          ld a,(hl)
     114.  00:7E88  E1                          pop hl
     115.  00:7E89  FE 1A                       cp $1a
     116.  00:7E8B  37                          scf
     117.  00:7E8C  C8                          ret z                           ; end of file
     118.  00:7E8D  3F                          ccf
     119.  00:7E8E  34                          inc (hl)                        ; increment position
     120.  00:7E8F  C0                          ret nz                          ; buffer empty?
     121.  00:7E90                              
     122.  00:7E90  F5                          push af
     123.  00:7E91  2B                          dec hl
     124.  00:7E92  34                          inc (hl)                        ; increment position (high)        
     125.  00:7E93  11 FB FF                    ld de,-5
     126.  00:7E96  19                          add hl,de
     127.  00:7E97  CD DC 73                    call sendRegisters
     128.  00:7E9A  36 8C                       ld (hl),C_DEVICEREAD
     129.  00:7E9C  CD 6D 75                    call enableNowindPage0
     130.  00:7E9F  26 20                       ld h,HIGH usbrd
     131.  00:7EA1  CD EE 73                    call getHeader
     132.  00:7EA4  38 B6                       jr c,deviceIoError
     133.  00:7EA6                      
     134.  00:7EA6  5E                          ld e,(hl)
     135.  00:7EA7  56                          ld d,(hl)
     136.  00:7EA8  4E                          ld c,(hl)
     137.  00:7EA9  46                          ld b,(hl)
     138.  00:7EAA  ED B0                       ldir                            ; update fcb buffer
     139.  00:7EAC  CD 78 75                    call restorePage0
     140.  00:7EAF  F1                          pop af                          ; return last character
     141.  00:7EB0  C9                          ret
     142.  00:7EB1                      
     143.  00:7EB1                      eof:
     144.  00:7EB1                      ;        DEBUGMESSAGE "eof"
     145.  00:7EB1  7E                          ld a,(hl)
     146.  00:7EB2  FE 01                       cp 1                            ; input mode?        
     147.  00:7EB4  1E 3D                       ld e,61                         ; bad file mode
     148.  00:7EB6  C2 62 7E                    jp nz,basicError
     149.  00:7EB9                                      
     150.  00:7EB9  11 06 00                    ld de,6
     151.  00:7EBC  19                          add hl,de
     152.  00:7EBD  5E                          ld e,(hl)
     153.  00:7EBE  23                          inc hl
     154.  00:7EBF  23                          inc hl
     155.  00:7EC0  23                          inc hl
     156.  00:7EC1  19                          add hl,de
     157.  00:7EC2  7E                          ld a,(hl)
     158.  00:7EC3  ED 62                       sbc hl,hl
     159.  00:7EC5  FE 1A                       cp $1a        
     160.  00:7EC7  20 01                       jr nz,.skip
     161.  00:7EC9  2B                          dec hl
     162.  00:7ECA  22 F8 F7            .skip:  ld (DAC+2),hl
     163.  00:7ECD  3E 02                       ld a,2
     164.  00:7ECF  32 63 F6                    ld (VALTYP),a
     165.  00:7ED2  C9                          ret
     166.  00:7ED3                      
     167.  00:7ED3                      loc:
     168.  00:7ED3  E5                          push hl
     169.  00:7ED4  FD E1                       pop iy
     170.  00:7ED6  FD 6E 06                    ld l,(iy+6)
     171.  00:7ED9  FD 66 05                    ld h,(iy+5)
     172.  00:7EDC                      ;        DEBUGASSERT
     173.  00:7EDC  22 F8 F7                    ld (DAC+2),hl
     174.  00:7EDF  3E 02                       ld a,2
     175.  00:7EE1  32 63 F6                    ld (VALTYP),a
     176.  00:7EE4  C9                          ret
     177.  00:7EE5                              
     178.  00:7EE5                      putback:
     179.  00:7EE5                      ;        DEBUGMESSAGE "putback"
     180.  00:7EE5                      ;        push hl
     181.  00:7EE5                      ;        pop iy
     182.  00:7EE5                      ;        ld (iy+3),c
     183.  00:7EE5                      ;        DEBUGASSERT
     184.  00:7EE5                      ;        ret
     185.  00:7EE5                      
     186.  00:7EE5                      lof:
     187.  00:7EE5                      fpos:
     188.  00:7EE5                              DEBUGMESSAGE "no support!"
     188.  00:7EE5                    >         ifdef DEBUG
     188.  00:7EE5  52                >         ld d,d
     188.  00:7EE6  18 0B             >         jr .skip
     188.  00:7EE8                    >         db string
     188.  00:7EE8  6E 6F 20 73 75 70 70 6F 72 74 21 
     188.  00:7EF3                    > .skip:
     188.  00:7EF3                    >         endif
     189.  00:7EF3                      
     190.  00:7EF3                      illegalFunctionCall:
     191.  00:7EF3  1E 05                       ld e,5
     192.  00:7EF5  C3 62 7E                    jp basicError
     193.  00:7EF8                      
     194.  00:7EF8                      ;FCB for DISK BASIC
     195.  00:7EF8                      ; +0 FL.MOD     file mode
     196.  00:7EF8                      ; +1 FL.FCA     Pointer to FCB for BDOS (low)
     197.  00:7EF8                      ; +2 FL.LCA     Pointer to FCB for BDOS (high)
     198.  00:7EF8                      ; +3 FL.LSA     Back up character
     199.  00:7EF8                      ; +4 FL.DSK     device number
     200.  00:7EF8                      ; +5 FL.SLB
     201.  00:7EF8                      ; +6 FL.BPS     Position in FL.BUF
     202.  00:7EF8                      ; +7 FL.FLG     Holds various information
     203.  00:7EF8                      ; +8 FL.OPS     Pseudo head position
     204.  00:7EF8                      ; +9 FL.BUF     256-byte file buffer
     205.  00:7EF8                      
     206.  00:7EF8                      ; device codes
     207.  00:7EF8                      ;          SS0           SS1           SS2           SS3
     208.  00:7EF8                      ;    ---------------------------------------------------------
     209.  00:7EF8                      ;    | 00 04 08 0C | 10 14 18 1C | 20 24 28 2C | 30 34 38 3C | PS0
     210.  00:7EF8                      ;    ---------------------------------------------------------
     211.  00:7EF8                      ;    | 40 44 48 4C | 50 54 58 5C | 60 64 68 6C | 70 74 78 7C | PS1
     212.  00:7EF8                      ;    ---------------------------------------------------------
     213.  00:7EF8                      ;    | 80 84 88 8C | 90 94 98 9C | A0 A4 A8 AC | B0 B4 B8 BC | PS2
     214.  00:7EF8                      ;    ---------------------------------------------------------
     215.  00:7EF8                      ;    | C0 C4 C8 CC | D0 D4 D8 DC | E0 E4 E8 EC | F0 F4 F8 FC | PS3
     216.  00:7EF8                      ;    ---------------------------------------------------------
     217.  00:7EF8                      
     218.  00:7EF8                      ; fileModes
     219.  00:7EF8                      ; FOR INPUT (01H)
     220.  00:7EF8                      ; FOR OUTPUT (02H)
     221.  00:7EF8                      ; FOR APPEND (08H)
     222.  00:7EF8                      ; random mode (04H)
     223.  00:7EF8                      
     224.  00:7EF8                      ; maximum number of files open: MAXFILES=15
     225.  00:7EF8                              
     226.  00:7EF8                      ; File Control Block
     227.  00:7EF8                      ;       0     1     2     3     4     5     6     7     8
     228.  00:7EF8                      ;    -------------------------------------------------------
     229.  00:7EF8                      ;    | Mod | 00H | 00H | 00H | DEV | 00H | POS | 00H | PPS |
     230.  00:7EF8                      ;    -------------------------------------------------------
     231.  00:7EF8                      ;                  err? bckup       posHi 
     232.  00:7EF8                      ; followed by a 256 byte buffer
     118   00:7EF8                      
     119   00:7EF8  FF (252)                    ds $8000-(endCopyFromBank-copyFromBank)-$, $ff
     120   00:7FF4                      
     121   00:7FF4                      ; bank switching and data transfer
     122   00:7FF4                      copyFromBank:
     123   00:7FF4  32 01 60                    ld (mapper),a
     124   00:7FF7  ED B0                       ldir
     125   00:7FF9                      enableBank0:
     126   00:7FF9  AF                          xor a
     127   00:7FFA                      switchBank:
     128   00:7FFA  F5                          push af
     129   00:7FFB  32 01 60                    ld (mapper),a
     130   00:7FFE  F1                          pop af
     131   00:7FFF  C9                          ret
     132   00:8000                      endCopyFromBank:
     133   00:8000                      
     134   00:8000  (01)                        page 1
     135   01:4000  (C000)                      incbin "..\roms\MSXDOS22.ROM", $4000, 3 * $4000
     136   01!0000                              PATCH $4093, mapper
     136   01!0000                    >         code ! address
     136   01:4093  01 60             >         dw word
     137   01:4095                              PATCH $8093, mapper
     137   01:4095                    >         code ! address
     137   01:8093  01 60             >         dw word
     138   01:8095                              PATCH $C093, mapper
     138   01:8095                    >         code ! address
     138   01:C093  01 60             >         dw word
     139   01:C095                      
     140   01:C095                              ; areas not used in MSXDOS22.ROM
     141   01:C095                              ; bank 1: 0x5CA0 - 0x7FFF (9056 bytes)
     142   01:C095                              ; bank 2: 0x7F30 - 0x7FFF (208 bytes)
     143   01:C095                              ; bank 3: 0x7E70 - 0x7FFF (400 bytes)
     144   01:C095                      
     145   01:C095                      ; insert MSXDOS1
     146   01:C095  (02)                        page 2
     147   02:4000                              module  MSXDOS1_PART
     148   02:4000                      
     149   02:4000                              define  MSXDOSVER 1
     150   02:4000                      ;       define  ROMINIT $576f
     151   02:4000                              define  PRINTTEXT $5f86
     152   02:4000                      
     153   02:4000  (3405)                      incbin "..\roms\DISK.ROM", 0, $7405-$4000
     154   02:7405                                      
     155   02:7405                              PATCH $4006, device
     155   02:7405                    >         code ! address
     155   02:4006  8D 7E             >         dw word
     156   02:4008                      
     157   02:4008                              code ! $4010
     158   02:4010  C3 8F 77                    jp DSKIO
     159   02:4013  C3 92 78                    jp DSKCHG
     160   02:4016  C3 C9 78                    jp GETDPB
     161   02:4019  C3 35 79                    jp CHOICE
     162   02:401C  C3 3A 79                    jp DSKFMT
     163   02:401F  00 00 00                    db 0,0,0                        ; no DRVOFF
     164   02:4022                              
     165   02:4022                              PATCH $5770, INIHRD
     165   02:4022                    >         code ! address
     165   02:5770  AD 76             >         dw word
     166   02:5772                              PATCH $57aa, $f380 + MYSIZE
     166   02:5772                    >         code ! address
     166   02:57AA  88 F3             >         dw word
     167   02:57AC                              PATCH $581e, MYSIZE
     167   02:57AC                    >         code ! address
     167   02:581E  08 00             >         dw word
     168   02:5820                              PATCH $582f, SECLEN
     168   02:5820                    >         code ! address
     168   02:582F  00 02             >         dw word
     169   02:5831                              PATCH $5851, DRIVES
     169   02:5831                    >         code ! address
     169   02:5851  D0 76             >         dw word
     170   02:5853                              PATCH $5884, DEFDPB - 1
     170   02:5853                    >         code ! address
     170   02:5884  7F 7C             >         dw word
     171   02:5886                              PATCH $5890, INIENV
     171   02:5886                    >         code ! address
     171   02:5890  39 77             >         dw word
     172   02:5892                              PATCH $5ae8, DEFDPB             ; different address in some roms
     172   02:5892                    >         code ! address
     172   02:5AE8  80 7C             >         dw word
     173   02:5AEA                              PATCH $65af, OEMSTA
     173   02:5AEA                    >         code ! address
     173   02:65AF  45 7A             >         dw word
     174   02:65B1                              PATCH $5809, initDiskBasic      ; HRUNC
     174   02:65B1                    >         code ! address
     174   02:5809  38 74             >         dw word
     175   02:580B                              
     176   02:580B                              ;PATCH $5b9a, getHostDate        ; get date from host when no clockchip found (different 5b95)
     177   02:580B                      
     178   02:580B                                      ifdef BDOS_NOWIND
     179   02:580B                    ~         
     180   02:580B                    ~                 ; just patching the BDOS hook will not work; not everybody uses the hook
     181   02:580B                    ~         ;PATCH $5d20, BDOSNW                                              ; overwrite the standard BDOS hook "DW $56D3" with BDOSNW
     182   02:580B                    ~                 
     183   02:580B                    ~         ; even patching the BDOS jump table will not work; internal calls (even in command.com) bypass it
     184   02:580B                    ~         ; jump table patches
     185   02:580B                    ~         ;PATCH $572b, BDOS_0FH_J                                  ; overwrite specific function 0Fh in jump table
     186   02:580B                    ~         ;PATCH $572f, BDOS_11H_J                                  ; overwrite specific function 11h in jump table
     187   02:580B                    ~         ;PATCH $5731, BDOS_12H_J                                  ; overwrite specific function 12h in jump table
     188   02:580B                    ~                 
     189   02:580B                    ~         ; these patches are at the start of the routine themselves, the addresses are more or less "standardized" 
     190   02:580B                    ~         ; over several brands of diskroms       
     191   02:580B                    ~         ; in-routine patches
     192   02:580B                    ~         PATCH $4463, BDOS_0FH                                     ; overwrite function 0Fh itself!
     193   02:580B                    ~         PATCH $4fb9, BDOS_11H                             ; overwrite function 11h itself!
     194   02:580B                    ~         PATCH $5007, BDOS_12H                             ; overwrite function 12h itself!
     195   02:580B                    ~                 
     196   02:580B                    ~         endif
     197   02:580B                                                      
     198   02:580B                              code ! $595d
     199   02:595D  21 D2 74                    ld hl,newAUX                    ; redirect AUX to host  
     200   02:5960  11 27 F3                    ld de,$f327
     201   02:5963  01 0A 00                    ld bc,10
     202   02:5966  ED B0                       ldir
     203   02:5968  00                          nop
     204   02:5969  00                          nop
     205   02:596A  00                          nop
     206   02:596B  00                          nop                             ; do not remove!
     207   02:596C                              
     208   02:596C                              code @ $7405
     209   02:7405                      
     210   02:7405                              include "common.asm"
       1.  02:7405                      ; Nowind specific
       2.  02:7405                      
       3.  02:7405                      nowindInit:
       4.  02:7405                              ;DEBUGMESSAGE "nowindInit"
       5.  02:7405  3A F8 FA                    ld a,($faf8)                                                                            ; moet volgens bifi ld a,($2d) zijn, $faf8 is op msx1 deel van de rs232 area?
       6.  02:7408  B7                          or a 
       7.  02:7409  F5                          push af
       8.  02:740A  CC 5F 00                    call z,CHGMOD                   ; SCREEN 0 for MSX1
       9.  02:740D  F1                          pop af
      10.  02:740E  DD 21 85 01                 ld ix,SDFSCR                    ; restore screen mode from clockchip
      11.  02:7412  C4 5F 01                    call nz,EXTROM
      12.  02:7415                                      
      13.  02:7415  CD 86 5F                    call PRINTTEXT
      14.  02:7418                              ifndef DEBUG
      15.  02:7418                    ~         db "Nowind USB Diskrom!",0
      16.  02:7418                    ~         else
      17.  02:7418                              db "Nowind USB Diskrom! [debug]",0
      17.  02:7418  4E 6F 77 69 6E 64 20 55 53 42 20 44 69 73 6B 72 
      17.  02:7428  6F 6D 21 20 5B 64 65 62 75 67 5D 00 
      18.  02:7434                              endif
      19.  02:7434                      
      20.  02:7434                              ; call insertBootCode
      21.  02:7434  CD 62 7D                    call flashWriter
      22.  02:7437  C9                          ret
      23.  02:7438                      
      24.  02:7438                      initDiskBasic:
      25.  02:7438                              DEBUGMESSAGE "initDiskBasic"
      25.  02:7438                    >         ifdef DEBUG
      25.  02:7438  52                >         ld d,d
      25.  02:7439  18 0D             >         jr .skip
      25.  02:743B                    >         db string
      25.  02:743B  69 6E 69 74 44 69 73 6B 42 61 73 69 63 
      25.  02:7448                    > .skip:
      25.  02:7448                    >         endif
      26.  02:7448  21 99 FD                    ld hl,DEVICE
      27.  02:744B  CB BE                       res 7,(hl)
      28.  02:744D                              
      29.  02:744D                              if MSXDOSVER = 1 
      30.  02:744D  C3 97 58                    jp $5897
      31.  02:7450                              else
      32.  02:7450                    ~         jp $495b
      33.  02:7450                    ~         endif
      34.  02:7450                      
      35.  02:7450                      ; search call statement or device name
      36.  02:7450                      findStatementName:
      37.  02:7450                              DEBUGMESSAGE "findStatementName"
      37.  02:7450                    >         ifdef DEBUG
      37.  02:7450  52                >         ld d,d
      37.  02:7451  18 11             >         jr .skip
      37.  02:7453                    >         db string
      37.  02:7453  66 69 6E 64 53 74 61 74 65 6D 65 6E 74 4E 61 6D 
      37.  02:7463  65 
      37.  02:7464                    > .skip:
      37.  02:7464                    >         endif
      38.  02:7464  11 89 FD                    ld de,PROCNM
      39.  02:7467  1A                  .loop:  ld a,(de)
      40.  02:7468  BE                          cp (hl)
      41.  02:7469  20 06                       jr nz,.nextStatement
      42.  02:746B  23                          inc hl
      43.  02:746C  B7                          or a
      44.  02:746D  C8                          ret z                           ; name found
      45.  02:746E  13                          inc de
      46.  02:746F  18 F6                       jr .loop        
      47.  02:7471                      .nextStatement:
      48.  02:7471  AF                          xor a
      49.  02:7472  4F                          ld c,a
      50.  02:7473  ED B1                       cpir
      51.  02:7475  23                          inc hl
      52.  02:7476  23                          inc hl
      53.  02:7477  B6                          or (hl)
      54.  02:7478  20 D6                       jr nz,findStatementName        
      55.  02:747A  37                          scf                             ; not found
      56.  02:747B  C9                          ret
      57.  02:747C                      
      58.  02:747C                      sendRegisters:
      59.  02:747C  F5                          push af
      60.  02:747D  7C                          ld a,h
      61.  02:747E  26 40                       ld h,HIGH usbwr
      62.  02:7480  36 AF                       ld (hl),$af      ; send header
      63.  02:7482  36 05                       ld (hl),$05      ;
      64.  02:7484  71                          ld (hl),c
      65.  02:7485  70                          ld (hl),b
      66.  02:7486  73                          ld (hl),e
      67.  02:7487  72                          ld (hl),d
      68.  02:7488  75                          ld (hl),l
      69.  02:7489  77                          ld (hl),a        ; send register h
      70.  02:748A  D1                          pop de
      71.  02:748B  73                          ld (hl),e        ; send register f
      72.  02:748C  72                          ld (hl),d        ; send register a
      73.  02:748D  C9                          ret
      74.  02:748E                              
      75.  02:748E                      getHeader:
      76.  02:748E  06 FF                       ld b,HIGH 65535                 ; 42000 * 60 states ~ 0,7 sec (time out)
      77.  02:7490  7E                  .loop:  ld a,(hl)
      78.  02:7491  FE AF               .chkaf: cp $af
      79.  02:7493  28 20                       jr z,.chk05
      80.  02:7495  0B                          dec bc
      81.  02:7496  78                          ld a,b
      82.  02:7497  B1                          or c
      83.  02:7498  20 F6                       jr nz,.loop
      84.  02:749A                              DEBUGMESSAGE "getHeader Timed out!"
      84.  02:749A                    >         ifdef DEBUG
      84.  02:749A  52                >         ld d,d
      84.  02:749B  18 14             >         jr .skip
      84.  02:749D                    >         db string
      84.  02:749D  67 65 74 48 65 61 64 65 72 20 54 69 6D 65 64 20 
      84.  02:74AD  6F 75 74 21 
      84.  02:74B1                    > .skip:
      84.  02:74B1                    >         endif
      85.  02:74B1  3E 02                       ld a,2                          ; not ready
      86.  02:74B3  37                          scf
      87.  02:74B4  C9                          ret
      88.  02:74B5                      
      89.  02:74B5  7E                  .chk05: ld a,(hl)
      90.  02:74B6  FE 05                       cp $05
      91.  02:74B8  20 D7                       jr nz,.chkaf
      92.  02:74BA  7E                          ld a,(hl)
      93.  02:74BB  C9                          ret
      94.  02:74BC                      
      95.  02:74BC                      sendMessage:
      96.  02:74BC                              ;DEBUGMESSAGE "sendMsg"
      97.  02:74BC  E3                          ex (sp),hl
      98.  02:74BD  F5                          push af
      99.  02:74BE  D5                          push de
     100.  02:74BF  E5                          push hl        
     101.  02:74C0  CD 7C 74                    call sendRegisters
     102.  02:74C3  36 90                       ld (hl),C_MESSAGE
     103.  02:74C5  E1                          pop hl
     104.  02:74C6  7E                  .loop:  ld a,(hl)
     105.  02:74C7  23                          inc hl
     106.  02:74C8  32 00 40                    ld (usbwr),a
     107.  02:74CB  B7                          or a
     108.  02:74CC  20 F8                       jr nz,.loop
     109.  02:74CE  D1                          pop de
     110.  02:74CF  F1                          pop af
     111.  02:74D0  E3                          ex (sp),hl
     112.  02:74D1  C9                          ret
     113.  02:74D2                              
     114.  02:74D2                      ; AUX device
     115.  02:74D2                              
     116.  02:74D2  C3 DC 74            newAUX: jp AUXin
     117.  02:74D5  00                          nop
     118.  02:74D6  00                          nop
     119.  02:74D7  C3 21 75                    jp AUXout
     120.  02:74DA  00                          nop
     121.  02:74DB  00                          nop
     122.  02:74DC                      
     123.  02:74DC                      AUXin:  DEBUGMESSAGE "AUX in"
     123.  02:74DC                    >         ifdef DEBUG
     123.  02:74DC  52                >         ld d,d
     123.  02:74DD  18 06             >         jr .skip
     123.  02:74DF  41 55 58 20 69 6E >         db string
     123.  02:74E5                    > .skip:
     123.  02:74E5                    >         endif
     124.  02:74E5  E5                          push hl
     125.  02:74E6  D5                          push de
     126.  02:74E7  C5                          push bc
     127.  02:74E8  CD 7C 74                    call sendRegisters
     128.  02:74EB  36 8E                       ld (hl),C_AUXIN
     129.  02:74ED  CD 0D 76                    call enableNowindPage0
     130.  02:74F0  26 20                       ld h,HIGH usbrd
     131.  02:74F2  CD 8E 74                    call getHeader
     132.  02:74F5  D2 10 75                    jp nc,.getCharacter
     133.  02:74F8                              
     134.  02:74F8                              DEBUGMESSAGE "not connected"
     134.  02:74F8                    >         ifdef DEBUG
     134.  02:74F8  52                >         ld d,d
     134.  02:74F9  18 0D             >         jr .skip
     134.  02:74FB                    >         db string
     134.  02:74FB  6E 6F 74 20 63 6F 6E 6E 65 63 74 65 64 
     134.  02:7508                    > .skip:
     134.  02:7508                    >         endif
     135.  02:7508  3E 1A                       ld a,$1a                        ; eof
     136.  02:750A  C1                  .exit:  pop bc
     137.  02:750B  D1                          pop de
     138.  02:750C  E1                          pop hl
     139.  02:750D  C3 18 76                    jp restorePage0        
     140.  02:7510                                    
     141.  02:7510                      .getCharacter:
     142.  02:7510                              DEBUGMESSAGE "getChar"
     142.  02:7510                    >         ifdef DEBUG
     142.  02:7510  52                >         ld d,d
     142.  02:7511  18 07             >         jr .skip
     142.  02:7513                    >         db string
     142.  02:7513  67 65 74 43 68 61 72 
     142.  02:751A                    > .skip:
     142.  02:751A                    >         endif
     143.  02:751A  CD 8E 74                    call getHeader
     144.  02:751D  38 F1                       jr c,.getCharacter
     145.  02:751F  18 E9                       jr .exit
     146.  02:7521                      
     147.  02:7521                      
     148.  02:7521                      AUXout: DEBUGMESSAGE "AUX out"
     148.  02:7521                    >         ifdef DEBUG
     148.  02:7521  52                >         ld d,d
     148.  02:7522  18 07             >         jr .skip
     148.  02:7524                    >         db string
     148.  02:7524  41 55 58 20 6F 75 74 
     148.  02:752B                    > .skip:
     148.  02:752B                    >         endif
     149.  02:752B                              DEBUGDUMPREGISTERS
     149.  02:752B                    >         ifdef DEBUG
     149.  02:752B  ED 07             >         db $ed,7
     149.  02:752D                    >         endif
     149.  02:752D                    >         
     149.  02:752D                    >         ifdef USBDEBUG
     149.  02:752D                    ~         assert ($ < $8000)
     149.  02:752D                    ~         call sendCpuInfo
     149.  02:752D                    ~         endif
     150.  02:752D  E5                          push hl
     151.  02:752E  D5                          push de
     152.  02:752F                      ;        push bc
     153.  02:752F                      ;        ld a,(RAMAD1) ; TODO: WTF???
     154.  02:752F                      ;        call RDSLT
     155.  02:752F  F5                          push af        
     156.  02:7530  CD 7C 74                    call sendRegisters
     157.  02:7533  36 8F                       ld (hl),C_AUXOUT
     158.  02:7535  F1                          pop af
     159.  02:7536                      ;        pop bc
     160.  02:7536  D1                          pop de
     161.  02:7537  E1                          pop hl
     162.  02:7538  C9                          ret
     163.  02:7539                      
     164.  02:7539                      ;insertBootCode:
     165.  02:7539                      ;        DEBUGMESSAGE "BOOTCODE"
     166.  02:7539                      ;        call sendRegisters
     167.  02:7539                      ;        ld (hl),C_BOOTCODE
     168.  02:7539                      ;        call enableNowindPage0
     169.  02:7539                      ;        call getHeader
     170.  02:7539                      ;        jp c,restorePage0
     171.  02:7539                              
     172.  02:7539                      ;        DEBUGMESSAGE "BOOTCODE"
     173.  02:7539                      ;        jp restorePage0
     174.  02:7539                      
     175.  02:7539                      ; send 32 bytes starting from address specified by DE to the usb
     176.  02:7539                      sdendFCB:
     177.  02:7539  D5                          push de
     178.  02:753A  C5                          push bc
     179.  02:753B                              
     180.  02:753B  06 20                       ld b,32
     181.  02:753D  1A                  .loop:  ld a,(de)
     182.  02:753E  32 00 40                    ld (usbwr),a
     183.  02:7541  13                          inc de
     184.  02:7542  10 F9                       djnz .loop
     185.  02:7544  C1                          pop bc
     186.  02:7545  D1                          pop de
     187.  02:7546  C9                          ret
     188.  02:7547                      
     189.  02:7547                      ; receive 32 bytes and write to the address specified by DE 
     190.  02:7547                      receiveFCB:
     191.  02:7547  D5                          push de
     192.  02:7548  C5                          push bc
     193.  02:7549                              
     194.  02:7549  06 20                       ld b,32
     195.  02:754B  3A 00 20            .loop:  ld a,(usbrd)
     196.  02:754E  32 00 40                    ld (usbwr),a                    ; loop back
     197.  02:7551  12                          ld (de),a
     198.  02:7552  13                          inc de
     199.  02:7553  10 F6                       djnz .loop
     200.  02:7555  C1                          pop bc
     201.  02:7556  D1                          pop de
     202.  02:7557  C9                          ret
     203.  02:7558                              
     211   02:7558                              include "extendedBios.asm"
       1.  02:7558                      
       2.  02:7558                      installExtendedBios:
       3.  02:7558                      
       4.  02:7558                              ; Called from INIENV, so EXTBIO hook is already initialized
       5.  02:7558                      
       6.  02:7558                              DEBUGMESSAGE "extbio"
       6.  02:7558                    >         ifdef DEBUG
       6.  02:7558  52                >         ld d,d
       6.  02:7559  18 06             >         jr .skip
       6.  02:755B  65 78 74 62 69 6F >         db string
       6.  02:7561                    > .skip:
       6.  02:7561                    >         endif
       7.  02:7561  CD 98 76                    call getEntrySLTWRK             ; save previous EXTBIO hook
       8.  02:7564  23                          inc hl
       9.  02:7565  EB                          ex de,hl        
      10.  02:7566  21 CA FF                    ld hl,EXTBIO
      11.  02:7569  01 05 00                    ld bc,5
      12.  02:756C  ED B0                       ldir
      13.  02:756E                              
      14.  02:756E  E5                          push hl                         ; determine device number
      15.  02:756F  AF                          xor a
      16.  02:7570  11 01 4E                    ld de,$4e01
      17.  02:7573  CD CA FF                    call EXTBIO
      18.  02:7576  E1                          pop hl
      19.  02:7577  77                          ld (hl),a
      20.  02:7578                                      
      21.  02:7578  CD 2D 40                    call GETSLT                     ; install new EXTBIO hook
      22.  02:757B  2E F7                       ld l,$f7
      23.  02:757D  67                          ld h,a
      24.  02:757E  22 CA FF                    ld (EXTBIO),hl
      25.  02:7581  21 8D 75                    ld hl,extendedBios
      26.  02:7584  22 CC FF                    ld (EXTBIO+2),hl
      27.  02:7587  3E C9                       ld a,$c9
      28.  02:7589  32 CE FF                    ld (EXTBIO+4),a    
      29.  02:758C  C9                          ret
      30.  02:758D                      
      31.  02:758D                      extendedBios:
      32.  02:758D                              ; broadcast (0x00) not implemented
      33.  02:758D                              ; system exclusive (0xff) not implemented
      34.  02:758D                      
      35.  02:758D  FB                          ei
      36.  02:758E  F5                          push af
      37.  02:758F  7A                          ld a,d
      38.  02:7590  FE 4E                       cp $4e
      39.  02:7592  28 0E                       jr z,determineFunction
      40.  02:7594                      .exit:
      41.  02:7594  E5                          push hl
      42.  02:7595  C5                          push bc
      43.  02:7596  CD 98 76                    call getEntrySLTWRK
      44.  02:7599  2C                          inc l                           ; previous EXTBIO hook 
      45.  02:759A  E5                          push hl
      46.  02:759B  DD E1                       pop ix
      47.  02:759D  C1                          pop bc        
      48.  02:759E  E1                          pop hl
      49.  02:759F  F1                          pop af
      50.  02:75A0  DD E9                       jp (ix)                         ; process other EXTBIO handles
      51.  02:75A2                      
      52.  02:75A2                      determineFunction:
      53.  02:75A2  E5                          push hl
      54.  02:75A3  21 AE D9                    ld hl,functionTable - 2 * $4e00
      55.  02:75A6  19                          add hl,de
      56.  02:75A7  19                          add hl,de
      57.  02:75A8  7E                          ld a,(hl)
      58.  02:75A9  23                          inc hl
      59.  02:75AA  66                          ld h,(hl)
      60.  02:75AB  6F                          ld l,a
      61.  02:75AC  E3                          ex (sp),hl
      62.  02:75AD  C9                          ret
      63.  02:75AE                      
      64.  02:75AE                      functionTable:
      65.  02:75AE  B4 75                       dw getNowindSlot
      66.  02:75B0  D0 75                       dw numberOfDevices
      67.  02:75B2  E7 75                       dw debugMessage
      68.  02:75B4                      
      69.  02:75B4                      getNowindSlot:               
      70.  02:75B4                              DEBUGMESSAGE "getNowindSlot"
      70.  02:75B4                    >         ifdef DEBUG
      70.  02:75B4  52                >         ld d,d
      70.  02:75B5  18 0D             >         jr .skip
      70.  02:75B7                    >         db string
      70.  02:75B7  67 65 74 4E 6F 77 69 6E 64 53 6C 6F 74 
      70.  02:75C4                    > .skip:
      70.  02:75C4                    >         endif
      71.  02:75C4  F1                          pop af
      72.  02:75C5  3D                          dec a
      73.  02:75C6  F5                          push af
      74.  02:75C7  F2 94 75                    jp p,extendedBios.exit         ; not this device
      75.  02:75CA                              
      76.  02:75CA  F1                          pop af
      77.  02:75CB  CD 68 76                    call getSlotPage1
      78.  02:75CE  37                          scf
      79.  02:75CF  C9                          ret
      80.  02:75D0                              
      81.  02:75D0                      numberOfDevices:
      82.  02:75D0                              DEBUGMESSAGE "numberOfDevices"
      82.  02:75D0                    >         ifdef DEBUG
      82.  02:75D0  52                >         ld d,d
      82.  02:75D1  18 0F             >         jr .skip
      82.  02:75D3                    >         db string
      82.  02:75D3  6E 75 6D 62 65 72 4F 66 44 65 76 69 63 65 73 
      82.  02:75E2                    > .skip:
      82.  02:75E2                    >         endif
      83.  02:75E2  F1                          pop af
      84.  02:75E3  3C                          inc a
      85.  02:75E4  F5                          push af
      86.  02:75E5  18 AD                       jr extendedBios.exit
      87.  02:75E7                              
      88.  02:75E7                      debugMessage:
      89.  02:75E7                              DEBUGMESSAGE "debugMessage"
      89.  02:75E7                    >         ifdef DEBUG
      89.  02:75E7  52                >         ld d,d
      89.  02:75E8  18 0C             >         jr .skip
      89.  02:75EA                    >         db string
      89.  02:75EA  64 65 62 75 67 4D 65 73 73 61 67 65 
      89.  02:75F6                    > .skip:
      89.  02:75F6                    >         endif
      90.  02:75F6  F1                          pop af
      91.  02:75F7  3D                          dec a
      92.  02:75F8  F5                          push af
      93.  02:75F9  F2 94 75                    jp p,extendedBios.exit
      94.  02:75FC                      
      95.  02:75FC  E5                          push hl
      96.  02:75FD  CD 7C 74                    call sendRegisters
      97.  02:7600  36 90                       ld (hl),C_MESSAGE
      98.  02:7602  E1                          pop hl
      99.  02:7603  7E                  .loop:  ld a,(hl)
     100.  02:7604  23                          inc hl
     101.  02:7605  32 00 40                    ld (usbwr),a
     102.  02:7608  B7                          or a
     103.  02:7609  20 F8                       jr nz,.loop
     104.  02:760B                              
     105.  02:760B  F1                          pop af        
     106.  02:760C  C9                          ret
     212   02:760D                              include "slotRoutines.asm"
       1.  02:760D                      ; These routines are used for slot selection
       2.  02:760D                      
       3.  02:760D                      ; function: enabled the selected slot of page 1 in page 0
       4.  02:760D                      ; in: none
       5.  02:760D                      ; out: ixh = previous slot selection for page 0
       6.  02:760D                      ; unchanged: d, iy
       7.  02:760D                      ; requirements: stack available
       8.  02:760D                      enableNowindPage0:
       9.  02:760D  CD 5D 76                    call getSlotPage0
      10.  02:7610  DD 67                       ld ixh,a
      11.  02:7612  CD 68 76                    call getSlotPage1
      12.  02:7615  C3 21 76                    jp enableSlotPage0       
      13.  02:7618                      
      14.  02:7618                      restorePage0:
      15.  02:7618  F5                          push af
      16.  02:7619  DD 7C                       ld a,ixh
      17.  02:761B  CD 21 76                    call enableSlotPage0
      18.  02:761E  FB                          ei
      19.  02:761F  F1                          pop af
      20.  02:7620  C9                          ret
      21.  02:7621                      
      22.  02:7621                      enableSlotPage0:
      23.  02:7621                              ; HL and D remain unchanged
      24.  02:7621                              ; enableSlotPage0 can be called in page 1 and 2 (no absolute jumps)
      25.  02:7621                      
      26.  02:7621                              ;DEBUGMESSAGE "enasltP0"
      27.  02:7621  5F                          ld e,a                          ; store slotcode for further use
      28.  02:7622  E6 03                       and 3
      29.  02:7624  4F                          ld c,a                          ; new primary slot in c  
      30.  02:7625  CB 7B                       bit 7,e
      31.  02:7627  F3                          di
      32.  02:7628  20 08                       jr nz,.expanded
      33.  02:762A                      
      34.  02:762A  DB A8                       in a,($a8)
      35.  02:762C  E6 FC                       and %11111100
      36.  02:762E  B1                          or c                            ; enable new primary slot in page 0
      37.  02:762F  D3 A8                       out ($a8),a
      38.  02:7631  C9                          ret
      39.  02:7632                              
      40.  02:7632                      .expanded:
      41.  02:7632  7B                          ld a,e                          ; store secondary slot in e
      42.  02:7633  E6 0C                       and %00001100     
      43.  02:7635  0F                          rrca
      44.  02:7636  0F                          rrca
      45.  02:7637  5F                          ld e,a
      46.  02:7638                      
      47.  02:7638  DB A8                       in a,($a8)
      48.  02:763A  E6 FC                       and %11111100
      49.  02:763C  B1                          or c                            ; new primary slot in page 0
      50.  02:763D  47                          ld b,a                          ; used to restore
      51.  02:763E  17                          rla
      52.  02:763F  A7                          and a                           ; (reset carry)
      53.  02:7640  17                          rla
      54.  02:7641  B1                          or c                            ; new primary slot in page 3
      55.  02:7642  0F                          rrca
      56.  02:7643  0F                          rrca
      57.  02:7644  D3 A8                       out ($a8),a
      58.  02:7646                      
      59.  02:7646  3A FF FF                    ld a,(-1)                       ; write secondary slot register
      60.  02:7649  2F                          cpl
      61.  02:764A  E6 FC                       and %11111100
      62.  02:764C  B3                          or e                            ; apply new secondary slot for page 0
      63.  02:764D  32 FF FF                    ld (-1),a
      64.  02:7650  5F                          ld e,a                          ; store secondary slot register (for SLTTBL)
      65.  02:7651                      
      66.  02:7651  78                          ld a,b                          ; restore primary slot page 3
      67.  02:7652  D3 A8                       out ($a8),a
      68.  02:7654                      
      69.  02:7654  3E C5                       ld a,LOW SLTTBL                 ; update SLTTBL
      70.  02:7656  81                          add c                           ; add primary slot
      71.  02:7657  4F                          ld c,a
      72.  02:7658  06 FC                       ld b,HIGH SLTTBL
      73.  02:765A  7B                          ld a,e                          ; restore secondary slot register
      74.  02:765B  02                          ld (bc),a
      75.  02:765C  C9                          ret
      76.  02:765D                      
      77.  02:765D                      ; These routines determine the current slot and subslot of a page.
      78.  02:765D                      
      79.  02:765D                      getSlotPage0:
      80.  02:765D                              ;DEBUGMESSAGE "getsltP0"
      81.  02:765D  DB A8                       in a,($a8)
      82.  02:765F  CD 82 76                    call expanded
      83.  02:7662  07                          rlca
      84.  02:7663  07                          rlca
      85.  02:7664  E6 0C                       and %00001100           ; keep subSlot
      86.  02:7666  B1                          or c                    ; add mainSlot and expanded bit
      87.  02:7667  C9                          ret
      88.  02:7668                                      
      89.  02:7668                      getSlotPage1:
      90.  02:7668                      ;        DEBUGMESSAGE "getsltP1"
      91.  02:7668  DB A8                       in a,($a8)
      92.  02:766A  0F                          rrca
      93.  02:766B  0F                          rrca
      94.  02:766C  CD 82 76                    call expanded
      95.  02:766F  E6 0C                       and %00001100           ; keep subSlot
      96.  02:7671  B1                          or c                    ; add mainSlot and expanded bit
      97.  02:7672  C9                          ret        
      98.  02:7673                                      
      99.  02:7673                      getSlotPage2:
     100.  02:7673                      ;        DEBUGMESSAGE "getsltP2"
     101.  02:7673  DB A8                       in a,($a8)
     102.  02:7675  0F                          rrca
     103.  02:7676  0F                          rrca
     104.  02:7677  0F                          rrca
     105.  02:7678  0F                          rrca
     106.  02:7679  CD 82 76                    call expanded
     107.  02:767C  0F                          rrca
     108.  02:767D  0F                          rrca
     109.  02:767E  E6 0C                       and %00001100           ; keep subSlot
     110.  02:7680  B1                          or c                    ; add mainSlot and expanded bit
     111.  02:7681  C9                          ret
     112.  02:7682                      
     113.  02:7682                      ;expanded:        
     114.  02:7682                      ;        ld hl,EXPTBL - $0300
     115.  02:7682                      ;        ld b,3
     116.  02:7682                      ;        and b
     117.  02:7682                      ;        ld c,a
     118.  02:7682                      ;        add hl,bc      
     119.  02:7682                      ;        
     120.  02:7682                      ;        or (hl)        ; BUGGIE!!!! (a will be used again!)
     121.  02:7682                      ;        ret p                           ; return when slot is not expanded
     122.  02:7682                      ;        
     123.  02:7682                      ;        ld c,a
     124.  02:7682                      ;        ld a,4
     125.  02:7682                      ;        add a,l
     126.  02:7682                      ;        ld l,a
     127.  02:7682                      ;        ld a,(hl)
     128.  02:7682                      ;        ret
     129.  02:7682                      
     130.  02:7682                      expanded:        
     131.  02:7682  21 C1 F9                    ld hl,EXPTBL - $0300
     132.  02:7685  06 03                       ld b,3
     133.  02:7687  A0                          and b
     134.  02:7688  4F                          ld c,a
     135.  02:7689  09                          add hl,bc
     136.  02:768A  CB 7E                       bit 7,(hl)
     137.  02:768C  28 08                       jr z,notExpanded
     138.  02:768E                      
     139.  02:768E  CB F9                       set 7,c
     140.  02:7690  2C                          inc l
     141.  02:7691  2C                          inc l
     142.  02:7692  2C                          inc l
     143.  02:7693  2C                          inc l
     144.  02:7694  7E                          ld a,(hl)
     145.  02:7695  C9                          ret        
     146.  02:7696                      
     147.  02:7696                      notExpanded:
     148.  02:7696  C1                          pop bc
     149.  02:7697  C9                          ret
     150.  02:7698                      
     151.  02:7698                      getEntrySLTWRK:
     152.  02:7698  CD 68 76                    call getSlotPage1
     153.  02:769B  21 09 FD                    ld hl,SLTWRK
     154.  02:769E  4F                          ld c,a
     155.  02:769F  0F                          rrca
     156.  02:76A0  0F                          rrca
     157.  02:76A1  0F                          rrca
     158.  02:76A2  E6 60                       and %01100000           ; main slot x 32
     159.  02:76A4  47                          ld b,a
     160.  02:76A5  79                          ld a,c
     161.  02:76A6  07                          rlca
     162.  02:76A7  E6 18                       and %00011000           ; sub slot x 8
     163.  02:76A9  80                          add b
     164.  02:76AA  85                          add l
     165.  02:76AB  6F                          ld l,a
     166.  02:76AC  C9                          ret
     167.  02:76AD                      
     213   02:76AD                              include "nowindDriver.asm"
       1.  02:76AD  (02:0008)           MYSIZE          equ 8                   ; size of work area (not used, some programs write here to stop drives spinning)
       2.  02:76AD  (02:0200)           SECLEN          equ 512                 ; sector size
       3.  02:76AD                      
       4.  02:76AD                      ; SLTWRK entry
       5.  02:76AD                      ; +0    rom drive number
       6.  02:76AD                      ; +1..5 previous EXTBIO
       7.  02:76AD                      ; +6    not used
       8.  02:76AD                      ; +7    not used
       9.  02:76AD                      
      10.  02:76AD                             
      11.  02:76AD                      ; if this is defined we tell DOS2.3 that we _are DOS2.3 also, so
      12.  02:76AD                      ; it does not try to override our initilazations 
      13.  02:76AD                      
      14.  02:76AD                      define  PRETEND_2B_DOS23
      15.  02:76AD                              
      16.  02:76AD                      INIHRD: 
      17.  02:76AD                              DEBUGMESSAGE "INIHRD"        
      17.  02:76AD                    >         ifdef DEBUG
      17.  02:76AD  52                >         ld d,d
      17.  02:76AE  18 06             >         jr .skip
      17.  02:76B0  49 4E 49 48 52 44 >         db string
      17.  02:76B6                    > .skip:
      17.  02:76B6                    >         endif
      18.  02:76B6                              
      19.  02:76B6                      ;        call getWorkArea
      20.  02:76B6                      ;        DEBUGDUMPREGISTERS
      21.  02:76B6                                                      
      22.  02:76B6  CD 0D 76                    call enableNowindPage0                  ; clear hostToMSXFifo by reading 4Kb of random data
      23.  02:76B9  01 00 10                    ld bc,4096
      24.  02:76BC  3A 00 20            .loop:  ld a,(usbrd)
      25.  02:76BF  0B                          dec bc
      26.  02:76C0  78                          ld a,b
      27.  02:76C1  B1                          or c
      28.  02:76C2  20 F8                       jr nz,.loop
      29.  02:76C4  CD 18 76                    call restorePage0
      30.  02:76C7                              
      31.  02:76C7  26 40                       ld h,HIGH usbwr
      32.  02:76C9  36 AF                       ld (hl),$af                     ; INIHRD command
      33.  02:76CB  36 FF                       ld (hl),$ff
      34.  02:76CD  C3 05 74                    jp nowindInit
      35.  02:76D0                      
      36.  02:76D0                      DRIVES:
      37.  02:76D0                              DEBUGMESSAGE "DRIVES"
      37.  02:76D0                    >         ifdef DEBUG
      37.  02:76D0  52                >         ld d,d
      37.  02:76D1  18 06             >         jr .skip
      37.  02:76D3  44 52 49 56 45 53 >         db string
      37.  02:76D9                    > .skip:
      37.  02:76D9                    >         endif
      38.  02:76D9  F5                          push af                         ; A, BC and DE should be preserved!
      39.  02:76DA  C5                          push bc
      40.  02:76DB  D5                          push de
      41.  02:76DC  3A 99 FD                    ld a,(DEVICE)
      42.  02:76DF  CD 7C 74                    call sendRegisters
      43.  02:76E2  36 85                       ld (hl),C_DRIVES
      44.  02:76E4  CD 0D 76                    call enableNowindPage0
      45.  02:76E7  26 20                       ld h,HIGH usbrd
      46.  02:76E9  CD 8E 74                    call getHeader
      47.  02:76EC  2E 02                       ld l,2                          ; default 2 drives
      48.  02:76EE  38 2C                       jr c,.notconnected
      49.  02:76F0                      
      50.  02:76F0                              PRINTVDPTEXT " Host connected."
      50.  02:76F0                    >         
      50.  02:76F0  E5                >         push hl
      50.  02:76F1  21 FA 76          >         ld hl,.text
      50.  02:76F4  CD 64 7C          >         call printVdpText2
      50.  02:76F7  E1                >         pop hl
      50.  02:76F8  18 11             >         jr .skip
      50.  02:76FA                    > .text   db string
      50.  02:76FA  20 48 6F 73 74 20 63 6F 6E 6E 65 63 74 65 64 2E 
      50.  02:770A  00                >         db 0
      50.  02:770B                    > .skip:
      51.  02:770B                                                      
      52.  02:770B  32 3F F3                    ld (LASTDRV),a                  ; install phantom drives (CRTL key)?
      53.  02:770E  7E                          ld a,(hl)                       ; allow other drives (SHIFT key)?
      54.  02:770F  32 99 FD                    ld (DEVICE),a
      55.  02:7712  6E                          ld l,(hl)                       ; number of drives
      56.  02:7713  E5                  .exit:  push hl  
      57.  02:7714  CD 18 76                    call restorePage0
      58.  02:7717  E1                          pop hl
      59.  02:7718  D1                          pop de
      60.  02:7719  C1                          pop bc
      61.  02:771A  F1                          pop af
      62.  02:771B  C9                          ret
      63.  02:771C                              
      64.  02:771C                      .notconnected:
      65.  02:771C                              PRINTVDPTEXT " Host timed out!"            
      65.  02:771C                    >         
      65.  02:771C  E5                >         push hl
      65.  02:771D  21 26 77          >         ld hl,.text
      65.  02:7720  CD 64 7C          >         call printVdpText2
      65.  02:7723  E1                >         pop hl
      65.  02:7724  18 11             >         jr .skip
      65.  02:7726                    > .text   db string
      65.  02:7726  20 48 6F 73 74 20 74 69 6D 65 64 20 6F 75 74 21 
      65.  02:7736  00                >         db 0
      65.  02:7737                    > .skip:
      66.  02:7737  18 DA                       jr .exit
      67.  02:7739                      
      68.  02:7739                      
      69.  02:7739                      INIENV:
      70.  02:7739                      ; Interrupt handler can be installed here and
      71.  02:7739                      ; work area can be initialized when it was requested
      72.  02:7739                              DEBUGMESSAGE "INIENV"
      72.  02:7739                    >         ifdef DEBUG
      72.  02:7739  52                >         ld d,d
      72.  02:773A  18 06             >         jr .skip
      72.  02:773C  49 4E 49 45 4E 56 >         db string
      72.  02:7742                    > .skip:
      72.  02:7742                    >         endif
      73.  02:7742                      
      74.  02:7742                              ifdef PRETEND_2B_DOS23
      75.  02:7742                              DEBUGMESSAGE "Lie about being DOS v2.31"
      75.  02:7742                    >         ifdef DEBUG
      75.  02:7742  52                >         ld d,d
      75.  02:7743  18 19             >         jr .skip
      75.  02:7745                    >         db string
      75.  02:7745  4C 69 65 20 61 62 6F 75 74 20 62 65 69 6E 67 20 
      75.  02:7755  44 4F 53 20 76 32 2E 33 31 
      75.  02:775E                    > .skip:
      75.  02:775E                    >         endif
      76.  02:775E  3E 23                       ld a,$23
      77.  02:7760  32 13 F3                    ld ($f313),a
      78.  02:7763                              endif
      79.  02:7763                              
      80.  02:7763  CD 58 75                    call installExtendedBios
      81.  02:7766  CD 7C 74                    call sendRegisters
      82.  02:7769  36 86                       ld (hl),C_INIENV
      83.  02:776B  CD 0D 76                    call enableNowindPage0
      84.  02:776E  26 20                       ld h,HIGH usbrd
      85.  02:7770  CD 8E 74                    call getHeader
      86.  02:7773  F5                          push af
      87.  02:7774                      ;        push ix
      88.  02:7774                      ;        call GETWRK
      89.  02:7774                      ;        pop ix
      90.  02:7774  CD 98 76                    call getEntrySLTWRK
      91.  02:7777  F1                          pop af
      92.  02:7778  36 00                       ld (hl),0                       ; romdisk in drive A: (default)          
      93.  02:777A  38 01                       jr c,.exit
      94.  02:777C  77                          ld (hl),a                       ; store romdisk drive number (255 = no romdisk)
      95.  02:777D  C3 18 76            .exit:  jp restorePage0
      96.  02:7780                      
      97.  02:7780                      checkWorkArea:
      98.  02:7780  3E 01                       ld a,1
      99.  02:7782  A7                          and a
     100.  02:7783  C9                          ret
     101.  02:7784                              
     102.  02:7784  C5                          push bc
     103.  02:7785  E5                          push hl
     104.  02:7786  F5                          push af
     105.  02:7787                      ;        call GETWRK
     106.  02:7787  CD 98 76                    call getEntrySLTWRK
     107.  02:778A  F1                          pop af
     108.  02:778B  BE                          cp (hl)
     109.  02:778C  E1                          pop hl
     110.  02:778D  C1                          pop bc
     111.  02:778E  C9                          ret        
     112.  02:778F                      
     113.  02:778F                      DSKIO: 
     114.  02:778F                      ; Input     F   Carry for set for write, reset for read
     115.  02:778F                      ;           A   Drive number
     116.  02:778F                      ;           B   Number of sectors to read/write
     117.  02:778F                      ;           C   Media descriptor
     118.  02:778F                      ;           DE  Logical sector number
     119.  02:778F                      ;           HL  Transfer address
     120.  02:778F                      ; Output    F   Carry set when not succesfull
     121.  02:778F                      ;           A   Error code
     122.  02:778F                      ;           B   Number of remaining sectors (TODO: check! even without error?)
     123.  02:778F                      
     124.  02:778F                              DEBUGMESSAGE "DSKIO"
     124.  02:778F                    >         ifdef DEBUG
     124.  02:778F  52                >         ld d,d
     124.  02:7790  18 05             >         jr .skip
     124.  02:7792  44 53 4B 49 4F    >         db string
     124.  02:7797                    > .skip:
     124.  02:7797                    >         endif
     125.  02:7797  F5                          push af
     126.  02:7798  CD 80 77                    call checkWorkArea
     127.  02:779B  CA FE 7C                    jp z,ROMDISK_DSKIO
     128.  02:779E  F1                          pop af
     129.  02:779F                      
     130.  02:779F  CD 7C 74                    call sendRegisters
     131.  02:77A2  36 80                       ld (hl),C_DSKIO
     132.  02:77A4  38 58                       jr c,dskioWrite                 ; read or write?
     133.  02:77A6                             
     134.  02:77A6                      dskioRead:
     135.  02:77A6  07                          rlca                            ; < 0x8000 ?
     136.  02:77A7  38 3F                       jr c,.page2and3
     137.  02:77A9                      
     138.  02:77A9                              DEBUGMESSAGE "read01"
     138.  02:77A9                    >         ifdef DEBUG
     138.  02:77A9  52                >         ld d,d
     138.  02:77AA  18 06             >         jr .skip
     138.  02:77AC  72 65 61 64 30 31 >         db string
     138.  02:77B2                    > .skip:
     138.  02:77B2                    >         endif
     139.  02:77B2  CD 73 76                    call getSlotPage2               ; enable nowind in page 2
     140.  02:77B5  F5                          push af
     141.  02:77B6  CD 68 76                    call getSlotPage1
     142.  02:77B9  DD 67                       ld ixh,a                        ; ixh = current nowind slot
     143.  02:77BB  26 80                       ld h,$80
     144.  02:77BD  CD 24 00                    call ENASLT
     145.  02:77C0  C3 C3 B7                    jp .page2
     146.  02:77C3                              
     147.  02:77C3  (B7C3)                      PHASE $ + $4000
     148.  02:B7C3                      .page2:
     149.  02:B7C3  3A 42 F3                    ld a,(RAMAD1)                   ; enable RAM in page 1
     150.  02:B7C6  26 40                       ld h,$40
     151.  02:B7C8  CD 24 00                    call ENASLT
     152.  02:B7CB                              
     153.  02:B7CB  CD 3E B9                    call readSectors01 
     154.  02:B7CE                              ; TODO: carry checken?----------------------------------------------!!!!!!!!!!!!!!!
     155.  02:B7CE                              
     156.  02:B7CE  DD 7C                       ld a,ixh                        ; enable nowind in page 1 
     157.  02:B7D0  26 40                       ld h,$40
     158.  02:B7D2  CD 24 00                    call ENASLT
     159.  02:B7D5  C3 D8 77                    jp .page1        
     160.  02:B7D8                      
     161.  02:B7D8  (77D8)                      DEPHASE
     162.  02:77D8                      .page1:
     163.  02:77D8  3A 00 80                    ld a,(usb2)
     164.  02:77DB  DD 67                       ld ixh,a
     165.  02:77DD  F1                          pop af
     166.  02:77DE  26 80                       ld h,$80
     167.  02:77E0  CD 24 00                    call ENASLT                     ; restore page 2
     168.  02:77E3  DD 7C                       ld a,ixh
     169.  02:77E5  B7                          or a
     170.  02:77E6  FB                          ei
     171.  02:77E7  C8                          ret z                           ; nothing more to read
     172.  02:77E8                                      
     173.  02:77E8                      .page2and3:                     
     174.  02:77E8                              DEBUGMESSAGE "read23"
     174.  02:77E8                    >         ifdef DEBUG
     174.  02:77E8  52                >         ld d,d
     174.  02:77E9  18 06             >         jr .skip
     174.  02:77EB  72 65 61 64 32 33 >         db string
     174.  02:77F1                    > .skip:
     174.  02:77F1                    >         endif
     175.  02:77F1  CD 0D 76                    call enableNowindPage0
     176.  02:77F4  FD E5                       push iy
     177.  02:77F6  CD 91 79                    call readSectors23
     178.  02:77F9  FD E1                       pop iy
     179.  02:77FB  C3 18 76                    jp restorePage0
     180.  02:77FE                      
     181.  02:77FE                      dskioWrite:
     182.  02:77FE                              DEBUGMESSAGE "dskwrite"
     182.  02:77FE                    >         ifdef DEBUG
     182.  02:77FE  52                >         ld d,d
     182.  02:77FF  18 08             >         jr .skip
     182.  02:7801                    >         db string
     182.  02:7801  64 73 6B 77 72 69 74 65 
     182.  02:7809                    > .skip:
     182.  02:7809                    >         endif
     183.  02:7809  07                          rlca
     184.  02:780A  38 3E                       jr c,.page2and3        
     185.  02:780C                              
     186.  02:780C                              ;call enableNowindPage2 (todo: make common routine?) 
     187.  02:780C  CD 73 76                    call getSlotPage2               ; save current slot page 2
     188.  02:780F  DD 67                       ld ixh,a
     189.  02:7811  CD 68 76                    call getSlotPage1
     190.  02:7814  DD 6F                       ld ixl,a
     191.  02:7816  26 80                       ld h,$80
     192.  02:7818  CD 24 00                    call ENASLT                     ; nowind in page 2
     193.  02:781B  C3 1E B8                    jp .page2
     194.  02:781E                      
     195.  02:781E  (B81E)                      PHASE $ + $4000
     196.  02:B81E                      .page2:
     197.  02:B81E  3A 42 F3                    ld a,(RAMAD1)
     198.  02:B821  26 40                       ld h,$40
     199.  02:B823  CD 24 00                    call ENASLT                     ; ram in page 1
     200.  02:B826                              
     201.  02:B826  CD 6C B9                    call writeLoop01
     202.  02:B829  F5                          push af
     203.  02:B82A                              
     204.  02:B82A  DD 7D                       ld a,ixl
     205.  02:B82C  26 40                       ld h,$40
     206.  02:B82E  CD 24 00                    call ENASLT                     ; restore nowind in page 1
     207.  02:B831  C3 34 78                    jp .page1
     208.  02:B834                              
     209.  02:B834  (7834)                      DEPHASE
     210.  02:7834                      .page1:
     211.  02:7834  DD 7C                       ld a,ixh
     212.  02:7836  26 80                       ld h,$80
     213.  02:7838  CD 24 00                    call ENASLT
     214.  02:783B  F1                          pop af
     215.  02:783C  D8                          ret c                           ; return error (error code in a)
     216.  02:783D  E8                          ret pe                          ; host returns 0xfe when data for page 2/3 is available
     217.  02:783E                              DEBUGMESSAGE "doorgaan!"
     217.  02:783E                    >         ifdef DEBUG
     217.  02:783E  52                >         ld d,d
     217.  02:783F  18 09             >         jr .skip
     217.  02:7841                    >         db string
     217.  02:7841  64 6F 6F 72 67 61 61 6E 21 
     217.  02:784A                    > .skip:
     217.  02:784A                    >         endif
     218.  02:784A                              
     219.  02:784A                      .page2and3:
     220.  02:784A                              DEBUGMESSAGE "page2and3"
     220.  02:784A                    >         ifdef DEBUG
     220.  02:784A  52                >         ld d,d
     220.  02:784B  18 09             >         jr .skip
     220.  02:784D                    >         db string
     220.  02:784D  70 61 67 65 32 61 6E 64 33 
     220.  02:7856                    > .skip:
     220.  02:7856                    >         endif
     221.  02:7856  CD 0D 76                    call enableNowindPage0
     222.  02:7859  CD 5F 78                    call .writeLoop23
     223.  02:785C  C3 18 76                    jp restorePage0
     224.  02:785F                              
     225.  02:785F                      .writeLoop23:
     226.  02:785F                              DEBUGMESSAGE "writeLoop23"
     226.  02:785F                    >         ifdef DEBUG
     226.  02:785F  52                >         ld d,d
     226.  02:7860  18 0B             >         jr .skip
     226.  02:7862                    >         db string
     226.  02:7862  77 72 69 74 65 4C 6F 6F 70 32 33 
     226.  02:786D                    > .skip:
     226.  02:786D                    >         endif
     227.  02:786D                              
     228.  02:786D  26 20                       ld h,HIGH usbrd
     229.  02:786F  CD 8E 74                    call getHeader
     230.  02:7872  D8                          ret c                           ; exit (not ready)
     231.  02:7873  B7                          or a
     232.  02:7874  F8                          ret m                           ; exit (no error)
     233.  02:7875  20 18                       jr nz,.error
     234.  02:7877                      
     235.  02:7877                              DEBUGMESSAGE "send23"
     235.  02:7877                    >         ifdef DEBUG
     235.  02:7877  52                >         ld d,d
     235.  02:7878  18 06             >         jr .skip
     235.  02:787A  73 65 6E 64 32 33 >         db string
     235.  02:7880                    > .skip:
     235.  02:7880                    >         endif
     236.  02:7880  5E                          ld e,(hl)                       ; address
     237.  02:7881  56                          ld d,(hl)
     238.  02:7882  4E                          ld c,(hl)                       ; number of bytes        
     239.  02:7883  46                          ld b,(hl)
     240.  02:7884  7E                          ld a,(hl)                       ; block sequence number
     241.  02:7885                              
     242.  02:7885                              ;DEBUGDUMPREGISTERS
     243.  02:7885  EB                          ex de,hl
     244.  02:7886  11 00 40                    ld de,usbwr
     245.  02:7889  12                          ld (de),a                       ; mark block begin
     246.  02:788A  ED B0                       ldir
     247.  02:788C  12                          ld (de),a                       ; mark block end
     248.  02:788D  18 D0                       jr .writeLoop23
     249.  02:788F                      
     250.  02:788F  37                  .error: scf
     251.  02:7890  7E                          ld a,(hl)                       ; get error code
     252.  02:7891  C9                          ret
     253.  02:7892                      
     254.  02:7892                                     
     255.  02:7892                      DSKCHG:
     256.  02:7892                      ; Input     A   Drive number
     257.  02:7892                      ;           B   0
     258.  02:7892                      ;           C   Media descriptor (previous)
     259.  02:7892                      ;           HL  Base address of DPB
     260.  02:7892                      ; Output    B   1   Disk unchanged
     261.  02:7892                      ;               0   Unknown (DPB is updated)
     262.  02:7892                      ;               -1  Disk changed (DPB is updated)
     263.  02:7892                      ;           F   Carry set when not succesfull
     264.  02:7892                      ;           A   Error code
     265.  02:7892                      
     266.  02:7892                              DEBUGMESSAGE "DSKCHG"
     266.  02:7892                    >         ifdef DEBUG
     266.  02:7892  52                >         ld d,d
     266.  02:7893  18 06             >         jr .skip
     266.  02:7895  44 53 4B 43 48 47 >         db string
     266.  02:789B                    > .skip:
     266.  02:789B                    >         endif
     267.  02:789B  F5                          push af
     268.  02:789C  CD 80 77                    call checkWorkArea
     269.  02:789F  CA 5D 7D                    jp z,ROMDISK_DSKCHG
     270.  02:78A2  F1                          pop af       
     271.  02:78A3                      
     272.  02:78A3  E5                          push hl
     273.  02:78A4  CD 7C 74                    call sendRegisters
     274.  02:78A7  36 81                       ld (hl),C_DSKCHG
     275.  02:78A9  CD 0D 76                    call enableNowindPage0
     276.  02:78AC  26 20                       ld h,HIGH usbrd
     277.  02:78AE  CD 8E 74                    call getHeader
     278.  02:78B1  4E                          ld c,(hl)               ; media descriptor (when disk was changed)
     279.  02:78B2  F5                          push af
     280.  02:78B3  C5                          push bc
     281.  02:78B4  CD 18 76                    call restorePage0
     282.  02:78B7  C1                          pop bc
     283.  02:78B8  F1                          pop af
     284.  02:78B9  E1                          pop hl
     285.  02:78BA  D8                          ret c           ; not ready
     286.  02:78BB  B7                          or a
     287.  02:78BC  06 01                       ld b,1
     288.  02:78BE  C8                          ret z           ; not changed
     289.  02:78BF  41                          ld b,c
     290.  02:78C0  CD C9 78                    call GETDPB
     291.  02:78C3  3E 0A                       ld a,10
     292.  02:78C5  D8                          ret c
     293.  02:78C6  06 FF                       ld b,255
     294.  02:78C8  C9                          ret
     295.  02:78C9                      
     296.  02:78C9                      GETDPB:
     297.  02:78C9                      ; Input     A   Drive number
     298.  02:78C9                      ;           B   Media descriptor (first byte of FAT)
     299.  02:78C9                      ;           C   Previous media descriptor (does not seem to be used in other drivers)
     300.  02:78C9                      ;           HL  Base address of HL
     301.  02:78C9                      ; Output    DPB for specified drive in [HL+1]..[HL+18]
     302.  02:78C9                      
     303.  02:78C9                              DEBUGMESSAGE "GETDPB"
     303.  02:78C9                    >         ifdef DEBUG
     303.  02:78C9  52                >         ld d,d
     303.  02:78CA  18 06             >         jr .skip
     303.  02:78CC  47 45 54 44 50 42 >         db string
     303.  02:78D2                    > .skip:
     303.  02:78D2                    >         endif
     304.  02:78D2  EB                          ex de,hl
     305.  02:78D3  13                          inc de
     306.  02:78D4  67                          ld h,a
     307.  02:78D5  78                          ld a,b
     308.  02:78D6  FE F0                       cp $f0
     309.  02:78D8  7C                          ld a,h
     310.  02:78D9  28 24                       jr z,.hddImage
     311.  02:78DB                              
     312.  02:78DB                              MESSAGE "ROM GETDPB"
     312.  02:78DB  CD BC 74          >         call sendMessage
     312.  02:78DE                    >         db string
     312.  02:78DE  52 4F 4D 20 47 45 54 44 50 42 
     312.  02:78E8  00                > .skip2: nop
     313.  02:78E9                      
     314.  02:78E9  78                          ld a,b
     315.  02:78EA  D6 F8                       sub $f8
     316.  02:78EC  D8                          ret c                           ; not supported in msxdos1
     317.  02:78ED  07                          rlca                            ; 2x
     318.  02:78EE  4F                          ld c,a
     319.  02:78EF  07                          rlca                            ; 4x
     320.  02:78F0  07                          rlca                            ; 8x
     321.  02:78F1  07                          rlca                            ; 16x
     322.  02:78F2  81                          add a,c                         ; 18x
     323.  02:78F3  4F                          ld c,a
     324.  02:78F4  06 00                       ld b,0        
     325.  02:78F6  21 6E 7C                    ld hl,supportedMedia
     326.  02:78F9  09                          add hl,bc
     327.  02:78FA  0E 12                       ld c,18
     328.  02:78FC  ED B0                       ldir
     329.  02:78FE  C9                          ret
     330.  02:78FF                      
     331.  02:78FF                      .hddImage:
     332.  02:78FF                              DEBUGMESSAGE ".hddImage"
     332.  02:78FF                    >         ifdef DEBUG
     332.  02:78FF  52                >         ld d,d
     332.  02:7900  18 09             >         jr .skip
     332.  02:7902                    >         db string
     332.  02:7902  2E 68 64 64 49 6D 61 67 65 
     332.  02:790B                    > .skip:
     332.  02:790B                    >         endif
     333.  02:790B                                      MESSAGE "HOST GETDPB"
     333.  02:790B  CD BC 74          >         call sendMessage
     333.  02:790E                    >         db string
     333.  02:790E  48 4F 53 54 20 47 45 54 44 50 42 
     333.  02:7919  00                > .skip2: nop
     334.  02:791A  CD 7C 74                    call sendRegisters
     335.  02:791D  36 82                       ld (hl),C_GETDPB
     336.  02:791F  CD 0D 76                    call enableNowindPage0
     337.  02:7922  26 20                       ld h,HIGH usbrd
     338.  02:7924  CD 8E 74                    call getHeader
     339.  02:7927  38 09                       jr c,.exit                      ; not ready
     340.  02:7929  5F                          ld e,a                          ; destination
     341.  02:792A  56                          ld d,(hl)
     342.  02:792B  01 12 00                    ld bc,18
     343.  02:792E                              DEBUGDUMPREGISTERS
     343.  02:792E                    >         ifdef DEBUG
     343.  02:792E  ED 07             >         db $ed,7
     343.  02:7930                    >         endif
     343.  02:7930                    >         
     343.  02:7930                    >         ifdef USBDEBUG
     343.  02:7930                    ~         assert ($ < $8000)
     343.  02:7930                    ~         call sendCpuInfo
     343.  02:7930                    ~         endif
     344.  02:7930  ED B0                       ldir
     345.  02:7932                              ;DB $ed, $0a       
     346.  02:7932  C3 18 76            .exit:  jp restorePage0        
     347.  02:7935                      
     348.  02:7935                      CHOICE:
     349.  02:7935                              ;DEBUGMESSAGE "CHOICE"
     350.  02:7935                              ifdef MSXDOS2
     351.  02:7935                    ~         ld hl,.noFormat
     352.  02:7935                    ~         else
     353.  02:7935  21 00 00                    ld hl,0                         ; no choice
     354.  02:7938                              endif
     355.  02:7938  C9                          ret
     356.  02:7939                      
     357.  02:7939                      .noFormat:
     358.  02:7939  00                          db 0
     359.  02:793A                      
     360.  02:793A                      DSKFMT:
     361.  02:793A  37                          scf
     362.  02:793B  3E 10                       ld a,16                         ; other error
     363.  02:793D  C9                          ret
     364.  02:793E                              
     365.  02:793E  (B93E)                      PHASE $ + $4000
     366.  02:B93E                              
     367.  02:B93E                      readSectors01:
     368.  02:B93E                              DEBUGMESSAGE "readSectors01"
     368.  02:B93E                    >         ifdef DEBUG
     368.  02:B93E  52                >         ld d,d
     368.  02:B93F  18 0D             >         jr .skip
     368.  02:B941                    >         db string
     368.  02:B941  72 65 61 64 53 65 63 74 6F 72 73 30 31 
     368.  02:B94E                    > .skip:
     368.  02:B94E                    >         endif
     369.  02:B94E  26 80                       ld h,HIGH usb2
     370.  02:B950  CD 8E B4                    call getHeader + $4000                                  
     371.  02:B953  D8                          ret c                           ; carry means timeout, no carry: A == 0 means slow transfer, A == 1 means exit, A == 2 means fast transfer                                      
     372.  02:B954  3D                          dec a
     373.  02:B955  C8                          ret z
     374.  02:B956  FA 60 B9                    jp m,.slowTransfer                              
     375.  02:B959  CD D2 B9                    call reverseTransfer + $4000
     376.  02:B95C  70                          ld (hl),b
     377.  02:B95D  71                          ld (hl),c
     378.  02:B95E  18 DE                       jr readSectors01
     379.  02:B960                      
     380.  02:B960                      .slowTransfer:
     381.  02:B960  5E                          ld e,(hl)                       ; transfer address
     382.  02:B961  56                          ld d,(hl)
     383.  02:B962  4E                          ld c,(hl)                       ; transfer amount 
     384.  02:B963  46                          ld b,(hl)
     385.  02:B964  ED B0                       ldir        
     386.  02:B966                              
     387.  02:B966  56                          ld d,(hl)                       ; BUG in emulator (byte direct terugschrijven, geeft 'rukkert!')
     388.  02:B967  7E                          ld a,(hl)
     389.  02:B968  72                          ld (hl),d                       ; return end marker ($af, $0f)
     390.  02:B969  77                          ld (hl),a
     391.  02:B96A  18 D2                       jr readSectors01
     392.  02:B96C                      
     393.  02:B96C                      writeLoop01:
     394.  02:B96C  26 80                       ld h,HIGH usb2
     395.  02:B96E  CD 8E B4                    call getHeader + $4000
     396.  02:B971  D8                          ret c                           ; exit (not ready)
     397.  02:B972  B7                          or a
     398.  02:B973  F8                          ret m                           ; exit (no error)
     399.  02:B974  20 18                       jr nz,.error
     400.  02:B976                      
     401.  02:B976                              DEBUGMESSAGE "send01"
     401.  02:B976                    >         ifdef DEBUG
     401.  02:B976  52                >         ld d,d
     401.  02:B977  18 06             >         jr .skip
     401.  02:B979  73 65 6E 64 30 31 >         db string
     401.  02:B97F                    > .skip:
     401.  02:B97F                    >         endif
     402.  02:B97F  5E                          ld e,(hl)                       ; address
     403.  02:B980  56                          ld d,(hl)
     404.  02:B981  4E                          ld c,(hl)                       ; number of bytes        
     405.  02:B982  46                          ld b,(hl)
     406.  02:B983  7E                          ld a,(hl)                       ; block sequence number
     407.  02:B984                      
     408.  02:B984  EB                          ex de,hl
     409.  02:B985  11 00 80                    ld de,usb2
     410.  02:B988  12                          ld (de),a                       ; mark block begin
     411.  02:B989  ED B0                       ldir
     412.  02:B98B  12                          ld (de),a                       ; mark block end
     413.  02:B98C  18 DE                       jr writeLoop01
     414.  02:B98E                      
     415.  02:B98E  37                  .error: scf
     416.  02:B98F  7E                          ld a,(hl)                       ; get error code
     417.  02:B990  C9                          ret
     418.  02:B991                      
     419.  02:B991  (7991)                      DEPHASE
     420.  02:7991                       
     421.  02:7991                      readSectors23:
     422.  02:7991                              DEBUGMESSAGE "readSectors23"
     422.  02:7991                    >         ifdef DEBUG
     422.  02:7991  52                >         ld d,d
     422.  02:7992  18 0D             >         jr .skip
     422.  02:7994                    >         db string
     422.  02:7994  72 65 61 64 53 65 63 74 6F 72 73 32 33 
     422.  02:79A1                    > .skip:
     422.  02:79A1                    >         endif
     423.  02:79A1  26 20                       ld h,HIGH usbrd
     424.  02:79A3  CD 8E 74                    call getHeader
     425.  02:79A6  D8                          ret c
     426.  02:79A7  3D                          dec a
     427.  02:79A8  C8                          ret z                           ; no more data
     428.  02:79A9  FA B5 79                    jp m,.slowTransfer        
     429.  02:79AC  CD D2 79                    call reverseTransfer
     430.  02:79AF  26 40                       ld h,HIGH usbwr 
     431.  02:79B1  70                          ld (hl),b
     432.  02:79B2  71                          ld (hl),c
     433.  02:79B3  18 DC                       jr readSectors23
     434.  02:79B5                      
     435.  02:79B5                      .slowTransfer:
     436.  02:79B5                              DEBUGMESSAGE "slowtransfer"
     436.  02:79B5                    >         ifdef DEBUG
     436.  02:79B5  52                >         ld d,d
     436.  02:79B6  18 0C             >         jr .skip
     436.  02:79B8                    >         db string
     436.  02:79B8  73 6C 6F 77 74 72 61 6E 73 66 65 72 
     436.  02:79C4                    > .skip:
     436.  02:79C4                    >         endif
     437.  02:79C4  5E                          ld e,(hl)                       ; transfer address
     438.  02:79C5  56                          ld d,(hl)
     439.  02:79C6  4E                          ld c,(hl)                       ; transfer amount 
     440.  02:79C7  46                          ld b,(hl)
     441.  02:79C8  ED B0                       ldir
     442.  02:79CA  56                          ld d,(hl)
     443.  02:79CB  7E                          ld a,(hl)
     444.  02:79CC  26 40                       ld h,HIGH usbwr
     445.  02:79CE  72                          ld (hl),d                       ; return end marker ($af, $0f)
     446.  02:79CF  77                          ld (hl),a
     447.  02:79D0  18 BF                       jr readSectors23
     448.  02:79D2                                     
     449.  02:79D2                      reverseTransfer:
     450.  02:79D2  FD 21 00 00                 ld iy,0                         ; save stack pointer
     451.  02:79D6  FD 39                       add iy,sp
     452.  02:79D8  5E                          ld e,(hl)                       ; transfer address
     453.  02:79D9  56                          ld d,(hl)
     454.  02:79DA  EB                          ex de,hl
     455.  02:79DB  F9                          ld sp,hl
     456.  02:79DC  EB                          ex de,hl
     457.  02:79DD  46                          ld b,(hl)                       ; number of loops       
     458.  02:79DE                      .loop:
     459.  02:79DE                              repeat 32                       ; blocks of 64 bytes hardcoded (NowindHost.cpp)
     460.  02:79DE                    <         ld d,(hl)
     461.  02:79DE                    <         ld e,(hl)
     462.  02:79DE                    <         push de
     463.  02:79DE                    <         endrepeat
     463.  02:79DE  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     463.  02:79EE  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     463.  02:79FE  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     463.  02:7A0E  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     463.  02:7A1E  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     463.  02:7A2E  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     464.  02:7A3E  10 9E                       djnz .loop
     465.  02:7A40                              
     466.  02:7A40  FD F9                       ld sp,iy                        ; restore stack pointer
     467.  02:7A42  46                          ld b,(hl)                       ; return end marker
     468.  02:7A43  4E                          ld c,(hl)
     469.  02:7A44  C9                          ret
     470.  02:7A45                            
     471.  02:7A45                      OEMSTA:
     472.  02:7A45  E5                          push hl
     473.  02:7A46  21 53 7A                    ld hl,.statement
     474.  02:7A49  CD 50 74                    call findStatementName
     475.  02:7A4C  5E                          ld e,(hl)
     476.  02:7A4D  23                          inc hl
     477.  02:7A4E  56                          ld d,(hl)
     478.  02:7A4F  E1                          pop hl        
     479.  02:7A50  D8                          ret c
     480.  02:7A51  D5                          push de
     481.  02:7A52  C9                          ret
     482.  02:7A53                      
     483.  02:7A53                      .statement:
     484.  02:7A53  49 4D 41 47 45 00           db "IMAGE",0
     485.  02:7A59  66 7A                       dw changeImage
     486.  02:7A5B                              db "VSTREAM",0
     486.  02:7A5B  56 53 54 52 45 41 4D 00 
     487.  02:7A63  93 7A                       dw videoStream
     488.  02:7A65  00                          db 0
     489.  02:7A66                      
     490.  02:7A66                      ; send arguments, command, filename, end with ":"
     491.  02:7A66                      changeImage:
     492.  02:7A66                              DEBUGMESSAGE "changeImage"
     492.  02:7A66                    >         ifdef DEBUG
     492.  02:7A66  52                >         ld d,d
     492.  02:7A67  18 0B             >         jr .skip
     492.  02:7A69                    >         db string
     492.  02:7A69  63 68 61 6E 67 65 49 6D 61 67 65 
     492.  02:7A74                    > .skip:
     492.  02:7A74                    >         endif
     493.  02:7A74  E5                          push hl
     494.  02:7A75  CD 7C 74                    call sendRegisters
     495.  02:7A78  36 91                       ld (hl),C_CHANGEIMAGE
     496.  02:7A7A  E1                          pop hl
     497.  02:7A7B                              
     498.  02:7A7B                      call_exit:
     499.  02:7A7B                              DEBUGMESSAGE "call_exit"
     499.  02:7A7B                    >         ifdef DEBUG
     499.  02:7A7B  52                >         ld d,d
     499.  02:7A7C  18 09             >         jr .skip
     499.  02:7A7E                    >         db string
     499.  02:7A7E  63 61 6C 6C 5F 65 78 69 74 
     499.  02:7A87                    > .skip:
     499.  02:7A87                    >         endif
     500.  02:7A87  7E                  .loop:  ld a,(hl)
     501.  02:7A88  32 00 40                    ld (usbwr),a
     502.  02:7A8B  FE 3A                       cp ":"
     503.  02:7A8D  C8                          ret z
     504.  02:7A8E  B7                          or a
     505.  02:7A8F  C8                          ret z
     506.  02:7A90  23                          inc hl
     507.  02:7A91  18 F4                       jr .loop
     508.  02:7A93                              
     509.  02:7A93                      videoStream: 
     510.  02:7A93  E5                          push hl
     511.  02:7A94                              include "vram.asm"
       1:  02:7A94                              
       2:  02:7A94                      vramDump:
       3:  02:7A94  F3                          di
       4:  02:7A95  CD 0D 76                    call enableNowindPage0
       5:  02:7A98                      
       6:  02:7A98  3E 02                       ld a,2
       7:  02:7A9A  D3 99                       out ($99),a
       8:  02:7A9C  3E 8F                       ld a,$80+15             ; status register pointer at S#2
       9:  02:7A9E  D3 99                       out ($99),a
      10:  02:7AA0                      
      11:  02:7AA0                      evenFrame:
      12:  02:7AA0                              ; vram address 0x0000
      13:  02:7AA0                              
      14:  02:7AA0                              ;xor a
      15:  02:7AA0                              ;out ($99),a
      16:  02:7AA0                              ;ld a,$80+2
      17:  02:7AA0                              ;out ($99),a
      18:  02:7AA0                              
      19:  02:7AA0  3E 03                       ld a,%00000011                 ; pattern generator table
      20:  02:7AA2  D3 99                       out ($99),a
      21:  02:7AA4  3E 84                       ld a,$80+4
      22:  02:7AA6  D3 99                       out ($99),a
      23:  02:7AA8                      
      24:  02:7AA8  AF                          xor a                   ; color table high
      25:  02:7AA9  D3 99                       out ($99),a
      26:  02:7AAB  3E 8A                       ld a,$80+10
      27:  02:7AAD  D3 99                       out ($99),a
      28:  02:7AAF                              
      29:  02:7AAF  3E 04                       ld a,%00000100          ; vram access at 0x10000
      30:  02:7AB1  CD 45 7C                    call setVramAccessPointer
      31:  02:7AB4  CD DD 7A                    call tranferframe
      32:  02:7AB7  CD 53 7C                    call waitForRetrace
      33:  02:7ABA  CD F7 7B                    call changeColors
      34:  02:7ABD                      
      35:  02:7ABD                      oddFrame:
      36:  02:7ABD                              ; vram address 0x10000
      37:  02:7ABD                      
      38:  02:7ABD                              ;ld a,%01000000
      39:  02:7ABD                              ;out ($99),a
      40:  02:7ABD                              ;ld a,$80+2
      41:  02:7ABD                              ;out ($99),a
      42:  02:7ABD                      
      43:  02:7ABD  3E 23                       ld a,%00100011          ; pattern generator table
      44:  02:7ABF  D3 99                       out ($99),a
      45:  02:7AC1  3E 84                       ld a,$80+4
      46:  02:7AC3  D3 99                       out ($99),a
      47:  02:7AC5                      
      48:  02:7AC5  3E 64                       ld a,00000100           ; color table high
      49:  02:7AC7  D3 99                       out ($99),a
      50:  02:7AC9  3E 8A                       ld a,$80+10
      51:  02:7ACB  D3 99                       out ($99),a
      52:  02:7ACD                      
      53:  02:7ACD  AF                          xor a
      54:  02:7ACE  CD 45 7C                    call setVramAccessPointer
      55:  02:7AD1  CD DD 7A                    call tranferframe
      56:  02:7AD4  CD 53 7C                    call waitForRetrace
      57:  02:7AD7  CD F7 7B                    call changeColors
      58:  02:7ADA  C3 A0 7A                    jp evenFrame
      59:  02:7ADD                      
      60:  02:7ADD                      tranferframe:
      61:  02:7ADD  CD 7C 74                    call sendRegisters
      62:  02:7AE0  36 FF                       ld (hl),255
      63:  02:7AE2                                      
      64:  02:7AE2  21 00 20                    ld hl,usbrd
      65:  02:7AE5  CD 8E 74                    call getHeader
      66:  02:7AE8                              
      67:  02:7AE8  16 70                       ld d,112                        ; 224x64 is 1 screen 2 page of data ($3800)
      68:  02:7AEA                      write_more:        
      69:  02:7AEA  21 00 20                    ld hl,usbrd
      70:  02:7AED  01 98 00                    ld bc,$0098
      71:  02:7AF0                              repeat 128
      72:  02:7AF0                    <         outi
      73:  02:7AF0                    <         endrepeat
      73:  02:7AF0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B00  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B10  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B20  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B30  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B40  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B50  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B60  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B70  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B80  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B90  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BA0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BB0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BC0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BD0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BE0  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      74:  02:7BF0                      
      75:  02:7BF0  15                          dec d
      76:  02:7BF1  7A                          ld a,d
      77:  02:7BF2  B7                          or a
      78:  02:7BF3  C2 EA 7A                    jp nz,write_more
      79:  02:7BF6  C9                          ret             
      80:  02:7BF7                      
      81:  02:7BF7                      changeColors:
      82:  02:7BF7  AF                          xor a                   ; set color register pointer to zero
      83:  02:7BF8  D3 99                       out ($99),a
      84:  02:7BFA  3E 90                       ld a,$80+16
      85:  02:7BFC  D3 99                       out ($99),a
      86:  02:7BFE                              
      87:  02:7BFE  21 00 20                    ld hl,usbrd
      88:  02:7C01  01 9A 00                    ld bc,$009A             ; write to color register
      89:  02:7C04                      
      90:  02:7C04                              repeat 32
      91:  02:7C04                    <         outi
      92:  02:7C04                    <         endrepeat               
      92:  02:7C04  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  02:7C14  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  02:7C24  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  02:7C34  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      93:  02:7C44  C9                          ret
      94:  02:7C45                      
      95:  02:7C45                              
      96:  02:7C45                      setVramAccessPointer:
      97:  02:7C45  D3 99                       out ($99),a
      98:  02:7C47  3E 8E                       ld a,$80+14
      99:  02:7C49  D3 99                       out ($99),a
     100:  02:7C4B  AF                          xor a
     101:  02:7C4C  D3 99                       out ($99),a
     102:  02:7C4E  3E 40                       ld a,%01000000          ; vram write
     103:  02:7C50  D3 99                       out ($99),a
     104:  02:7C52  C9                          ret
     105:  02:7C53                      
     106:  02:7C53                      waitForRetrace:
     107:  02:7C53  DB 99                       in a,($99)
     108:  02:7C55  CB 77                       bit 6,a
     109:  02:7C57  20 FA                       jr nz,waitForRetrace       
     110:  02:7C59                      .lp2:        
     111:  02:7C59  DB 99                       in a,($99)
     112:  02:7C5B  CB 77                       bit 6,a
     113:  02:7C5D  28 FA                       jr z,.lp2       
     114:  02:7C5F  C9                          ret
     115:  02:7C60                                      
     116:  02:7C60                              ; just let it go... 
     512.  02:7C60  E1                          pop hl
     513.  02:7C61  C3 7B 7A                    jp call_exit
     514.  02:7C64                              
     515.  02:7C64                      ; hl points to text
     516.  02:7C64                      printVdpText2:
     517.  02:7C64  F5                                                  push af
     518.  02:7C65  7E                  .loop:  ld a,(hl)
     519.  02:7C66  D3 98                                               out ($98),a 
     520.  02:7C68  23                                                  inc hl
     521.  02:7C69  B7                                                  or a
     522.  02:7C6A  20 F9                                               jr nz,.loop
     523.  02:7C6C  F1                                                  pop af
     524.  02:7C6D  C9                                                  ret
     525.  02:7C6E                              
     526.  02:7C6E                      supportedMedia:
     527.  02:7C6E                                      
     528.  02:7C6E                      .f8:    MAKEDPB $f8, 512, 2, 112, 1 * 80 * 9, 2, 2      ; 360 kB (1 side * 80 tracks * 9 tracks/sector)
     528.  02:7C6E  (02:0001)         > .firfat equ 1
     528.  02:7C6E  (02:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     528.  02:7C6E  (02:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     528.  02:7C6E                    >         if sectorSize = 512
     528.  02:7C6E  (02:0004)         > .shft   equ 4
     528.  02:7C6E                    >         elseif sectorSize = 256
     528.  02:7C6E                    ~ .shft   equ 3
     528.  02:7C6E                    ~         endif
     528.  02:7C6E                    >         
     528.  02:7C6E  F8                >         db media
     528.  02:7C6F  00 02             >         dw sectorSize
     528.  02:7C71  0F 04             >         db (sectorSize/32)-1, .shft
     528.  02:7C73  01                >         db sectorsPerCluster-1
     528.  02:7C74  02                >         db sectorsPerCluster
     528.  02:7C75  01 00             >         dw .firfat
     528.  02:7C77  02 70             >         db fatCount, maxEnt
     528.  02:7C79  0C 00             >         dw .firrec
     528.  02:7C7B  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     528.  02:7C7D  02                >         db fatSiz
     528.  02:7C7E  05 00             >         dw .firdir
     529.  02:7C80                      .def:   MAKEDPB $f9, 512, 2, 112, 2 * 80 * 9, 3, 2      ; 720 kB
     529.  02:7C80  (02:0001)         > .firfat equ 1
     529.  02:7C80  (02:0007)         > .firdir equ .firfat+(fatCount*fatSiz)
     529.  02:7C80  (02:000E)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     529.  02:7C80                    >         if sectorSize = 512
     529.  02:7C80  (02:0004)         > .shft   equ 4
     529.  02:7C80                    >         elseif sectorSize = 256
     529.  02:7C80                    ~ .shft   equ 3
     529.  02:7C80                    ~         endif
     529.  02:7C80                    >         
     529.  02:7C80  F9                >         db media
     529.  02:7C81  00 02             >         dw sectorSize
     529.  02:7C83  0F 04             >         db (sectorSize/32)-1, .shft
     529.  02:7C85  01                >         db sectorsPerCluster-1
     529.  02:7C86  02                >         db sectorsPerCluster
     529.  02:7C87  01 00             >         dw .firfat
     529.  02:7C89  02 70             >         db fatCount, maxEnt
     529.  02:7C8B  0E 00             >         dw .firrec
     529.  02:7C8D  CA 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     529.  02:7C8F  03                >         db fatSiz
     529.  02:7C90  07 00             >         dw .firdir
     530.  02:7C92                              MAKEDPB $fa, 512, 2, 112, 1 * 80 * 8, 1, 2      ; 320 kB
     530.  02:7C92  (02:0001)         > .firfat equ 1
     530.  02:7C92  (02:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     530.  02:7C92  (02:000A)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     530.  02:7C92                    >         if sectorSize = 512
     530.  02:7C92  (02:0004)         > .shft   equ 4
     530.  02:7C92                    >         elseif sectorSize = 256
     530.  02:7C92                    ~ .shft   equ 3
     530.  02:7C92                    ~         endif
     530.  02:7C92                    >         
     530.  02:7C92  FA                >         db media
     530.  02:7C93  00 02             >         dw sectorSize
     530.  02:7C95  0F 04             >         db (sectorSize/32)-1, .shft
     530.  02:7C97  01                >         db sectorsPerCluster-1
     530.  02:7C98  02                >         db sectorsPerCluster
     530.  02:7C99  01 00             >         dw .firfat
     530.  02:7C9B  02 70             >         db fatCount, maxEnt
     530.  02:7C9D  0A 00             >         dw .firrec
     530.  02:7C9F  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     530.  02:7CA1  01                >         db fatSiz
     530.  02:7CA2  03 00             >         dw .firdir
     531.  02:7CA4                              MAKEDPB $fb, 512, 2, 112, 2 * 80 * 8, 2, 2      ; 640 kB
     531.  02:7CA4  (02:0001)         > .firfat equ 1
     531.  02:7CA4  (02:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     531.  02:7CA4  (02:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     531.  02:7CA4                    >         if sectorSize = 512
     531.  02:7CA4  (02:0004)         > .shft   equ 4
     531.  02:7CA4                    >         elseif sectorSize = 256
     531.  02:7CA4                    ~ .shft   equ 3
     531.  02:7CA4                    ~         endif
     531.  02:7CA4                    >         
     531.  02:7CA4  FB                >         db media
     531.  02:7CA5  00 02             >         dw sectorSize
     531.  02:7CA7  0F 04             >         db (sectorSize/32)-1, .shft
     531.  02:7CA9  01                >         db sectorsPerCluster-1
     531.  02:7CAA  02                >         db sectorsPerCluster
     531.  02:7CAB  01 00             >         dw .firfat
     531.  02:7CAD  02 70             >         db fatCount, maxEnt
     531.  02:7CAF  0C 00             >         dw .firrec
     531.  02:7CB1  7B 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     531.  02:7CB3  02                >         db fatSiz
     531.  02:7CB4  05 00             >         dw .firdir
     532.  02:7CB6                              MAKEDPB $fc, 512, 1, 64,  1 * 40 * 9, 2, 2      ; 180 kB
     532.  02:7CB6  (02:0001)         > .firfat equ 1
     532.  02:7CB6  (02:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     532.  02:7CB6  (02:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     532.  02:7CB6                    >         if sectorSize = 512
     532.  02:7CB6  (02:0004)         > .shft   equ 4
     532.  02:7CB6                    >         elseif sectorSize = 256
     532.  02:7CB6                    ~ .shft   equ 3
     532.  02:7CB6                    ~         endif
     532.  02:7CB6                    >         
     532.  02:7CB6  FC                >         db media
     532.  02:7CB7  00 02             >         dw sectorSize
     532.  02:7CB9  0F 04             >         db (sectorSize/32)-1, .shft
     532.  02:7CBB  00                >         db sectorsPerCluster-1
     532.  02:7CBC  01                >         db sectorsPerCluster
     532.  02:7CBD  01 00             >         dw .firfat
     532.  02:7CBF  02 40             >         db fatCount, maxEnt
     532.  02:7CC1  09 00             >         dw .firrec
     532.  02:7CC3  60 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     532.  02:7CC5  02                >         db fatSiz
     532.  02:7CC6  05 00             >         dw .firdir
     533.  02:7CC8                              MAKEDPB $fd, 512, 2, 112, 2 * 40 * 9, 2, 2      ; 360 kB
     533.  02:7CC8  (02:0001)         > .firfat equ 1
     533.  02:7CC8  (02:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     533.  02:7CC8  (02:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     533.  02:7CC8                    >         if sectorSize = 512
     533.  02:7CC8  (02:0004)         > .shft   equ 4
     533.  02:7CC8                    >         elseif sectorSize = 256
     533.  02:7CC8                    ~ .shft   equ 3
     533.  02:7CC8                    ~         endif
     533.  02:7CC8                    >         
     533.  02:7CC8  FD                >         db media
     533.  02:7CC9  00 02             >         dw sectorSize
     533.  02:7CCB  0F 04             >         db (sectorSize/32)-1, .shft
     533.  02:7CCD  01                >         db sectorsPerCluster-1
     533.  02:7CCE  02                >         db sectorsPerCluster
     533.  02:7CCF  01 00             >         dw .firfat
     533.  02:7CD1  02 70             >         db fatCount, maxEnt
     533.  02:7CD3  0C 00             >         dw .firrec
     533.  02:7CD5  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     533.  02:7CD7  02                >         db fatSiz
     533.  02:7CD8  05 00             >         dw .firdir
     534.  02:7CDA                              MAKEDPB $fe, 512, 1, 64,  1 * 40 * 8, 1, 2      ; 160 kB
     534.  02:7CDA  (02:0001)         > .firfat equ 1
     534.  02:7CDA  (02:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     534.  02:7CDA  (02:0007)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     534.  02:7CDA                    >         if sectorSize = 512
     534.  02:7CDA  (02:0004)         > .shft   equ 4
     534.  02:7CDA                    >         elseif sectorSize = 256
     534.  02:7CDA                    ~ .shft   equ 3
     534.  02:7CDA                    ~         endif
     534.  02:7CDA                    >         
     534.  02:7CDA  FE                >         db media
     534.  02:7CDB  00 02             >         dw sectorSize
     534.  02:7CDD  0F 04             >         db (sectorSize/32)-1, .shft
     534.  02:7CDF  00                >         db sectorsPerCluster-1
     534.  02:7CE0  01                >         db sectorsPerCluster
     534.  02:7CE1  01 00             >         dw .firfat
     534.  02:7CE3  02 40             >         db fatCount, maxEnt
     534.  02:7CE5  07 00             >         dw .firrec
     534.  02:7CE7  3A 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     534.  02:7CE9  01                >         db fatSiz
     534.  02:7CEA  03 00             >         dw .firdir
     535.  02:7CEC                              MAKEDPB $ff, 512, 2, 112, 2 * 40 * 8, 1, 1      ; 320 kB
     535.  02:7CEC  (02:0001)         > .firfat equ 1
     535.  02:7CEC  (02:0002)         > .firdir equ .firfat+(fatCount*fatSiz)
     535.  02:7CEC  (02:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     535.  02:7CEC                    >         if sectorSize = 512
     535.  02:7CEC  (02:0004)         > .shft   equ 4
     535.  02:7CEC                    >         elseif sectorSize = 256
     535.  02:7CEC                    ~ .shft   equ 3
     535.  02:7CEC                    ~         endif
     535.  02:7CEC                    >         
     535.  02:7CEC  FF                >         db media
     535.  02:7CED  00 02             >         dw sectorSize
     535.  02:7CEF  0F 04             >         db (sectorSize/32)-1, .shft
     535.  02:7CF1  01                >         db sectorsPerCluster-1
     535.  02:7CF2  02                >         db sectorsPerCluster
     535.  02:7CF3  01 00             >         dw .firfat
     535.  02:7CF5  01 70             >         db fatCount, maxEnt
     535.  02:7CF7  09 00             >         dw .firrec
     535.  02:7CF9  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     535.  02:7CFB  01                >         db fatSiz
     535.  02:7CFC  02 00             >         dw .firdir
     536.  02:7CFE                      
     537.  02:7CFE                      ; WARNING: in some cases DEFDPB-1 is expected!
     538.  02:7CFE  (02:7C80)           DEFDPB  equ supportedMedia.def
     214   02:7CFE                              include "romdisk.asm"
       1.  02:7CFE                                      define  ROMDSKBANK 5                    ; romdisk starts in bank 5
       2.  02:7CFE                                      define  ROMDSKLAST (FLASHROMSIZE/16)-1
       3.  02:7CFE                      
       4.  02:7CFE                      
       5.  02:7CFE                      ROMDISK_DSKIO:
       6.  02:7CFE                              DEBUGMESSAGE "R_DSKIO"
       6.  02:7CFE                    >         ifdef DEBUG
       6.  02:7CFE  52                >         ld d,d
       6.  02:7CFF  18 07             >         jr .skip
       6.  02:7D01                    >         db string
       6.  02:7D01  52 5F 44 53 4B 49 4F 
       6.  02:7D08                    > .skip:
       6.  02:7D08                    >         endif
       7.  02:7D08  F1                          pop af
       8.  02:7D09  3E 00                       ld a,0
       9.  02:7D0B  D8                          ret c                           ; write protected
      10.  02:7D0C                              
      11.  02:7D0C  EB                          ex de,hl
      12.  02:7D0D  C5                  .loop:  push bc
      13.  02:7D0E  E5                          push hl        
      14.  02:7D0F                              
      15.  02:7D0F  CB 7A                       bit 7,d
      16.  02:7D11  20 1C                       jr nz,.directCopy
      17.  02:7D13  7A                          ld a,d
      18.  02:7D14  FE 3E                       cp $3e        
      19.  02:7D16  38 17                       jr c,.directCopy
      20.  02:7D18                      
      21.  02:7D18  CD 3B 7D                    call .findSector
      22.  02:7D1B  D5                          push de
      23.  02:7D1C  ED 5B 4D F3                 ld de,($f34d)        
      24.  02:7D20  CD F4 7F                    call copyFromBank
      25.  02:7D23  D1                          pop de
      26.  02:7D24  01 00 02                    ld bc,512
      27.  02:7D27  2A 4D F3                    ld hl,($f34d)
      28.  02:7D2A  CD 6E F3                    call XFER
      29.  02:7D2D  18 06                       jr .nextSector           
      30.  02:7D2F                                    
      31.  02:7D2F                      .directCopy:                
      32.  02:7D2F  CD 3B 7D                    call .findSector  
      33.  02:7D32  CD F4 7F                    call copyFromBank
      34.  02:7D35                      .nextSector:
      35.  02:7D35  E1                          pop hl
      36.  02:7D36  23                          inc hl
      37.  02:7D37  C1                          pop bc
      38.  02:7D38  10 D3                       djnz .loop
      39.  02:7D3A  C9                          ret
      40.  02:7D3B                      
      41.  02:7D3B                      .findSector:        
      42.  02:7D3B  7D                          ld a,l                          ; determine bank
      43.  02:7D3C  E6 E0                       and %11100000
      44.  02:7D3E  B4                          or h
      45.  02:7D3F  07                          rlca
      46.  02:7D40  07                          rlca
      47.  02:7D41  07                          rlca
      48.  02:7D42  47                          ld b,a
      49.  02:7D43                      
      50.  02:7D43  7D                          ld a,l
      51.  02:7D44  E6 1F                       and 31
      52.  02:7D46  4F                          ld c,a
      53.  02:7D47  3E FF                       ld a,ROMDSKLAST                 ; banks with b0..5=0 reside in the last bank
      54.  02:7D49  28 05                       jr z,.skip
      55.  02:7D4B                      
      56.  02:7D4B  78                          ld a,b
      57.  02:7D4C  C6 05                       add ROMDSKBANK
      58.  02:7D4E  41                          ld b,c
      59.  02:7D4F  05                          dec b
      60.  02:7D50  4F                  .skip:  ld c,a
      61.  02:7D51  78                          ld a,b
      62.  02:7D52  07                          rlca
      63.  02:7D53  C6 41                       add $41                         ; disk images starts at $4100
      64.  02:7D55  67                          ld h,a
      65.  02:7D56  2E 00                       ld l,0
      66.  02:7D58  79                          ld a,c
      67.  02:7D59  01 00 02                    ld bc,512
      68.  02:7D5C  C9                          ret
      69.  02:7D5D                                                               
      70.  02:7D5D                      ROMDISK_DSKCHG:
      71.  02:7D5D                              ;DEBUGMESSAGE "ROM_DSKCHG"
      72.  02:7D5D  F1                          pop af
      73.  02:7D5E  A7                          and a
      74.  02:7D5F  06 01                       ld b,1                          ; not changed
      75.  02:7D61  C9                          ret
      76.  02:7D62                      
      77.  02:7D62                      ROMDISK_GETDPB:
      78.  02:7D62                              ; not implemented (standard mediadescriptor as used)
      79.  02:7D62                              
      80.  02:7D62                      ROMDISK_DSKFMT:
      81.  02:7D62                              ; not implemented (no disk can be formatted)
      82.  02:7D62                              
     215   02:7D62                              include "flashWriter.asm"
       1.  02:7D62                      ; flashWriter.asm
       2.  02:7D62                      ; Flashes and erases the AMD29F040/M29F032-D
       3.  02:7D62                           
       4.  02:7D62                      flashWriter:
       5.  02:7D62                              ;DEBUGMESSAGE "flashWriter"
       6.  02:7D62  3E 03                       ld a,3
       7.  02:7D64  CD 41 01                    call SNSMAT
       8.  02:7D67  E6 08                       and 8
       9.  02:7D69  C0                          ret nz
      10.  02:7D6A                              
      11.  02:7D6A  CD 86 5F                    call PRINTTEXT
      12.  02:7D6D                              db 10,13," FlashROM",10,13," "
      12.  02:7D6D  0A 0D 20 46 6C 61 73 68 52 4F 4D 0A 0D 20 
      13.  02:7D7B  2E (33)                     ds 33,"."
      14.  02:7D9C  0D 20 00                    db 13," ",0
      15.  02:7D9F                              
      16.  02:7D9F  CD 68 76                    call getSlotPage1
      17.  02:7DA2  CD 21 76                    call enableSlotPage0
      18.  02:7DA5                      
      19.  02:7DA5  21 B2 7D                    ld hl,.source
      20.  02:7DA8  11 00 C0                    ld de,$c000
      21.  02:7DAB  D5                          push de
      22.  02:7DAC  01 DB 00                    ld bc,flasherEnd - $c000
      23.  02:7DAF  ED B0                       ldir
      24.  02:7DB1  C9                          ret
      25.  02:7DB2                              
      26.  02:7DB2                      .source:     
      27.  02:7DB2  (C000)                      PHASE $c000  
      28.  02:C000                              
      29.  02:C000                      waitForHeader:
      30.  02:C000  26 20                       ld h,HIGH usbrd
      31.  02:C002  7E                          ld a,(hl)
      32.  02:C003  FE BB               .chkbb: cp $bb
      33.  02:C005  20 F9                       jr nz,waitForHeader
      34.  02:C007  7E                          ld a,(hl)
      35.  02:C008  FE 55                       cp $55
      36.  02:C00A  20 F7                       jr nz,.chkbb       
      37.  02:C00C                      
      38.  02:C00C  7E                          ld a,(hl)
      39.  02:C00D  FE A2                       cp $a2
      40.  02:C00F  CA A9 C0                    jp z,verifyFlash
      41.  02:C012  FE A3                       cp $a3
      42.  02:C014  28 6E                       jr z,writeFlash
      43.  02:C016  FE A4                       cp $a4
      44.  02:C018  28 52                       jr z,chipErase
      45.  02:C01A  FE A5                       cp $a5
      46.  02:C01C  28 1C                       jr z,eraseSector
      47.  02:C01E  FE A6                       cp $a6
      48.  02:C020  28 02                       jr z,autoselectMode
      49.  02:C022                      
      50.  02:C022  20 DC                       jr nz,waitForHeader
      51.  02:C024                          
      52.  02:C024                      autoselectMode:
      53.  02:C024  3E 90                       ld a,$90
      54.  02:C026  CD CC C0                    call writeCommandSequence
      55.  02:C029                      
      56.  02:C029  2A 00 40                    ld hl,($4000)
      57.  02:C02C  EB                          ex de,hl
      58.  02:C02D  26 40                       ld h,HIGH usbwr
      59.  02:C02F  36 AA                       ld (hl),$aa
      60.  02:C031  36 55                       ld (hl),$55
      61.  02:C033  73                          ld (hl),e                       ; manufacturer ID (0x01 = AMD)
      62.  02:C034  72                          ld (hl),d                       ; device ID (0xA4 = AM29F040, 0x41 = AM29F032B)
      63.  02:C035                      
      64.  02:C035  CD 66 C0                    call writeResetCommand
      65.  02:C038  18 C6                       jr waitForHeader
      66.  02:C03A                      
      67.  02:C03A                      eraseSector:
      68.  02:C03A                              ;DEBUGMESSAGE "sector erase"
      69.  02:C03A  3E 65                       ld a,"e"
      70.  02:C03C  D3 98                       out ($98),a
      71.  02:C03E                      
      72.  02:C03E  7E                          ld a,(hl)                       ; get sector number 0..63
      73.  02:C03F  CB 27                       sla a
      74.  02:C041  CB 27                       sla a
      75.  02:C043  32 01 60                    ld (mapper),a                   ; select sector
      76.  02:C046                      
      77.  02:C046  3E 80                       ld a,$80
      78.  02:C048  CD CC C0                    call writeCommandSequence
      79.  02:C04B  3E 30                       ld a,$30        
      80.  02:C04D  CD CC C0                    call writeCommandSequence
      81.  02:C050                      
      82.  02:C050  CD 56 C0                    call waitForCommandToComplete
      83.  02:C053  C3 BD C0                    jp acknowledge
      84.  02:C056                              
      85.  02:C056                      waitForCommandToComplete:
      86.  02:C056  7E                          ld a,(hl)
      87.  02:C057  46                          ld b,(hl)
      88.  02:C058  A8                          xor b
      89.  02:C059  E6 40                       and %01000000                   ; check toggle bit I (DQ6)
      90.  02:C05B  C8                          ret z                           ; operation complete
      91.  02:C05C                              
      92.  02:C05C  78                          ld a,b
      93.  02:C05D  E6 20                       and %00100000                   ; timing limits exceeded? (DQ5)
      94.  02:C05F  28 F5                       jr z,waitForCommandToComplete
      95.  02:C061                      
      96.  02:C061  CD 66 C0                    call writeResetCommand
      97.  02:C064  78                          ld a,b
      98.  02:C065  C9                          ret
      99.  02:C066                      
     100.  02:C066                      writeResetCommand:
     101.  02:C066  3E F0                       ld a,$f0                        ; write RESET command
     102.  02:C068  32 00 00                    ld (0),a
     103.  02:C06B  C9                          ret
     104.  02:C06C                      
     105.  02:C06C                      chipErase:
     106.  02:C06C                              ;DEBUGMESSAGE "chip erase"
     107.  02:C06C  3E 45                       ld a,"E"
     108.  02:C06E  D3 98                       out ($98),a
     109.  02:C070                      
     110.  02:C070  3E 80                       ld a,$80
     111.  02:C072  CD CC C0                    call writeCommandSequence
     112.  02:C075  3E 10                       ld a,$10
     113.  02:C077  CD CC C0                    call writeCommandSequence
     114.  02:C07A                      
     115.  02:C07A  3A 00 40            .wait:  ld a,($4000)                    ; read DQ7 (data# polling) 
     116.  02:C07D  07                          rlca
     117.  02:C07E  30 FA                       jr nc,.wait        
     118.  02:C080  3E 01                       ld a,1
     119.  02:C082  18 39                       jr acknowledge
     120.  02:C084                      
     121.  02:C084                      
     122.  02:C084                      writeFlash:
     123.  02:C084                              ;DEBUGMESSAGE "write"
     124.  02:C084  5E                          ld e,(hl)                       ; address
     125.  02:C085  56                          ld d,(hl)
     126.  02:C086                      
     127.  02:C086  7A                          ld a,d
     128.  02:C087  B3                          or e
     129.  02:C088  CC C7 C0                    call z,updateBar
     130.  02:C08B                      
     131.  02:C08B  7E                          ld a,(hl)                       ; bank
     132.  02:C08C  32 01 60                    ld (mapper),a
     133.  02:C08F  26 40                       ld h,$40
     134.  02:C091                              
     135.  02:C091  06 80                       ld b,128                        ; data is written in blocks of 128 bytes
     136.  02:C093  3E A0               .loop:  ld a,$a0
     137.  02:C095  CD CC C0                    call writeCommandSequence
     138.  02:C098  3A 00 20                    ld a,(usbrd)
     139.  02:C09B  12                          ld (de),a                       ; write data to flash
     140.  02:C09C  13                          inc de
     141.  02:C09D                      
     142.  02:C09D  7E                  .wait:  ld  a,(hl)                      ; write complete?
     143.  02:C09E  AE                          xor (hl)
     144.  02:C09F  E6 40                       and %01000000
     145.  02:C0A1  20 FA                       jr  nz,.wait
     146.  02:C0A3  10 EE                       djnz .loop
     147.  02:C0A5                              
     148.  02:C0A5  3E 02                       ld a,2
     149.  02:C0A7  18 14                       jr acknowledge        
     150.  02:C0A9                              
     151.  02:C0A9                      verifyFlash:
     152.  02:C0A9                              ;DEBUGMESSAGE "verify"
     153.  02:C0A9  21 00 20                    ld hl,usbrd
     154.  02:C0AC  5E                          ld e,(hl)                       ; address
     155.  02:C0AD  56                          ld d,(hl)
     156.  02:C0AE  7E                          ld a,(hl)                       ; bank
     157.  02:C0AF  32 01 60                    ld (mapper),a
     158.  02:C0B2                      
     159.  02:C0B2  06 80                       ld b,128
     160.  02:C0B4  1A                  .loop:  ld a,(de)
     161.  02:C0B5  32 00 40                    ld (usbwr),a
     162.  02:C0B8  13                          inc de
     163.  02:C0B9  10 F9                       djnz .loop
     164.  02:C0BB                      
     165.  02:C0BB  3E 03                       ld a,3
     166.  02:C0BD                      acknowledge:        
     167.  02:C0BD  26 40                       ld h,HIGH usbwr
     168.  02:C0BF  36 AA                       ld (hl),$aa
     169.  02:C0C1  36 55                       ld (hl),$55
     170.  02:C0C3  77                          ld (hl),a
     171.  02:C0C4  C3 00 C0                    jp waitForHeader
     172.  02:C0C7                      
     173.  02:C0C7                      updateBar:
     174.  02:C0C7  3E 77                       ld a,"w"  
     175.  02:C0C9  D3 98                       out ($98),a
     176.  02:C0CB  C9                          ret
     177.  02:C0CC                      
     178.  02:C0CC                      writeCommandSequence:
     179.  02:C0CC  F5                          push af
     180.  02:C0CD  3E AA                       ld a,$aa
     181.  02:C0CF  32 55 05                    ld ($0555),a
     182.  02:C0D2  2F                          cpl
     183.  02:C0D3  32 AA 02                    ld ($02aa),a
     184.  02:C0D6  F1                          pop af
     185.  02:C0D7  32 55 05                    ld ($0555),a
     186.  02:C0DA  C9                          ret
     187.  02:C0DB                              
     188.  02:C0DB                      flasherEnd:
     189.  02:C0DB  (7E8D)                      DEPHASE
     216   02:7E8D                              include "device.asm"
       1.  02:7E8D                      ; device.asm
       2.  02:7E8D                      ; implements a basic now: device
       3.  02:7E8D                          
       4.  02:7E8D                      device:
       5.  02:7E8D  E5                          push hl
       6.  02:7E8E  21 9F 7E                    ld hl,deviceFunctions
       7.  02:7E91  0F                          rrca
       8.  02:7E92  3C                          inc a
       9.  02:7E93  07                          rlca
      10.  02:7E94  85                          add a,l
      11.  02:7E95  6F                          ld l,a
      12.  02:7E96  30 01                       jr nc,.nocy
      13.  02:7E98  24                          inc h  
      14.  02:7E99  7E                  .nocy:  ld a,(hl)
      15.  02:7E9A  23                          inc hl
      16.  02:7E9B  66                          ld h,(hl)
      17.  02:7E9C  6F                          ld l,a
      18.  02:7E9D  E3                          ex (sp),hl
      19.  02:7E9E  C9                          ret
      20.  02:7E9F                      
      21.  02:7E9F                      deviceFunctions:
      22.  02:7E9F  B5 7E                       dw identifyDevice               ; 0xff
      23.  02:7EA1  D5 7E                       dw open                         ;  0
      24.  02:7EA3  0D 7F                       dw close                        ;  2
      25.  02:7EA5  13 7F                       dw randomIO                     ;  4
      26.  02:7EA7  17 7F                       dw write                        ;  6
      27.  02:7EA9  1D 7F                       dw read                         ;  8
      28.  02:7EAB  73 7F                       dw loc                          ; 10
      29.  02:7EAD  85 7F                       dw lof                          ; 12
      30.  02:7EAF  51 7F                       dw eof                          ; 14
      31.  02:7EB1  85 7F                       dw fpos                         ; 16
      32.  02:7EB3  85 7F                       dw putback                      ; 18
      33.  02:7EB5                                
      34.  02:7EB5                      identifyDevice:
      35.  02:7EB5                              DEBUGMESSAGE "identifyDevice"
      35.  02:7EB5                    >         ifdef DEBUG
      35.  02:7EB5  52                >         ld d,d
      35.  02:7EB6  18 0E             >         jr .skip
      35.  02:7EB8                    >         db string
      35.  02:7EB8  69 64 65 6E 74 69 66 79 44 65 76 69 63 65 
      35.  02:7EC6                    > .skip:
      35.  02:7EC6                    >         endif
      36.  02:7EC6  21 CE 7E                    ld hl,deviceNameList
      37.  02:7EC9  CD 50 74                    call findStatementName
      38.  02:7ECC  7E                          ld a,(hl)                       ; device number
      39.  02:7ECD  C9                          ret                             ; carry is set when invalid device name
      40.  02:7ECE                              
      41.  02:7ECE                      deviceNameList:
      42.  02:7ECE  4E 4F 57 00 00 00           db "NOW",0,0,0                  ; name, end marker, device number, dummy
      43.  02:7ED4                              ;db "STDIN",0,1,0
      44.  02:7ED4  00                          db 0
      45.  02:7ED5                      
      46.  02:7ED5                      ; Input     D   Global device code
      47.  02:7ED5                      ;           E   File mode    
      48.  02:7ED5                      ;           HL  address fcb
      49.  02:7ED5                      open:
      50.  02:7ED5                      ;        DEBUGMESSAGE "open"
      51.  02:7ED5                      ;        DEBUGDUMPMEMHL 9
      52.  02:7ED5  22 64 F8                    ld (PTRFIL),hl
      53.  02:7ED8  CD 7C 74                    call sendRegisters
      54.  02:7EDB  36 88                       ld (hl),C_DEVICEOPEN
      55.  02:7EDD  EB                          ex de,hl
      56.  02:7EDE  01 0B 00                    ld bc,11
      57.  02:7EE1  21 66 F8                    ld hl,FILNAM
      58.  02:7EE4  ED B0                       ldir
      59.  02:7EE6                      
      60.  02:7EE6  CD 0D 76                    call enableNowindPage0
      61.  02:7EE9  26 20                       ld h,HIGH usbrd
      62.  02:7EEB  CD 8E 74                    call getHeader
      63.  02:7EEE  38 0C                       jr c,deviceIoError              ; time out?
      64.  02:7EF0  B7                          or a
      65.  02:7EF1  20 0B                       jr nz,openError
      66.  02:7EF3                      
      67.  02:7EF3  5E                          ld e,(hl)                       ; update fcb (including buffer)
      68.  02:7EF4  56                          ld d,(hl)
      69.  02:7EF5  4E                          ld c,(hl)
      70.  02:7EF6  46                          ld b,(hl)
      71.  02:7EF7  ED B0                       ldir
      72.  02:7EF9  C3 18 76                    jp restorePage0        
      73.  02:7EFC                      
      74.  02:7EFC                      deviceIoError:
      75.  02:7EFC  3E 13                       ld a,19
      76.  02:7EFE                      
      77.  02:7EFE                      openError:
      78.  02:7EFE  CD 18 76                    call restorePage0
      79.  02:7F01  5F                          ld e,a
      80.  02:7F02                      
      81.  02:7F02                      basicError:
      82.  02:7F02  DD 21 6F 40                 ld ix,$406f
      83.  02:7F06  FD 2A C0 FC                 ld iy,(EXPTBL-1)
      84.  02:7F0A  C3 1C 00                    jp CALSLT
      85.  02:7F0D                                      
      86.  02:7F0D                      close:
      87.  02:7F0D                      ;        DEBUGMESSAGE "close"
      88.  02:7F0D  CD 7C 74                    call sendRegisters
      89.  02:7F10  36 89                       ld (hl),C_DEVICECLOSE
      90.  02:7F12  C9                          ret
      91.  02:7F13                              
      92.  02:7F13                      randomIO:
      93.  02:7F13                      ;        DEBUGMESSAGE "randomIO"
      94.  02:7F13  1E 3D                       ld e,61                         ; bad file mode
      95.  02:7F15  18 EB                       jr basicError
      96.  02:7F17                      
      97.  02:7F17                      write:
      98.  02:7F17                      ;        DEBUGMESSAGE "write"
      99.  02:7F17  CD 7C 74                    call sendRegisters
     100.  02:7F1A  36 8B                       ld (hl),C_DEVICEWRITE
     101.  02:7F1C  C9                          ret        
     102.  02:7F1D                      
     103.  02:7F1D                      read:
     104.  02:7F1D                      ;        DEBUGMESSAGE "read"
     105.  02:7F1D  11 06 00                    ld de,6
     106.  02:7F20  19                          add hl,de
     107.  02:7F21  E5                          push hl
     108.  02:7F22  5E                          ld e,(hl)
     109.  02:7F23  23                          inc hl
     110.  02:7F24  23                          inc hl
     111.  02:7F25  23                          inc hl
     112.  02:7F26  19                          add hl,de
     113.  02:7F27  7E                          ld a,(hl)
     114.  02:7F28  E1                          pop hl
     115.  02:7F29  FE 1A                       cp $1a
     116.  02:7F2B  37                          scf
     117.  02:7F2C  C8                          ret z                           ; end of file
     118.  02:7F2D  3F                          ccf
     119.  02:7F2E  34                          inc (hl)                        ; increment position
     120.  02:7F2F  C0                          ret nz                          ; buffer empty?
     121.  02:7F30                              
     122.  02:7F30  F5                          push af
     123.  02:7F31  2B                          dec hl
     124.  02:7F32  34                          inc (hl)                        ; increment position (high)        
     125.  02:7F33  11 FB FF                    ld de,-5
     126.  02:7F36  19                          add hl,de
     127.  02:7F37  CD 7C 74                    call sendRegisters
     128.  02:7F3A  36 8C                       ld (hl),C_DEVICEREAD
     129.  02:7F3C  CD 0D 76                    call enableNowindPage0
     130.  02:7F3F  26 20                       ld h,HIGH usbrd
     131.  02:7F41  CD 8E 74                    call getHeader
     132.  02:7F44  38 B6                       jr c,deviceIoError
     133.  02:7F46                      
     134.  02:7F46  5E                          ld e,(hl)
     135.  02:7F47  56                          ld d,(hl)
     136.  02:7F48  4E                          ld c,(hl)
     137.  02:7F49  46                          ld b,(hl)
     138.  02:7F4A  ED B0                       ldir                            ; update fcb buffer
     139.  02:7F4C  CD 18 76                    call restorePage0
     140.  02:7F4F  F1                          pop af                          ; return last character
     141.  02:7F50  C9                          ret
     142.  02:7F51                      
     143.  02:7F51                      eof:
     144.  02:7F51                      ;        DEBUGMESSAGE "eof"
     145.  02:7F51  7E                          ld a,(hl)
     146.  02:7F52  FE 01                       cp 1                            ; input mode?        
     147.  02:7F54  1E 3D                       ld e,61                         ; bad file mode
     148.  02:7F56  C2 02 7F                    jp nz,basicError
     149.  02:7F59                                      
     150.  02:7F59  11 06 00                    ld de,6
     151.  02:7F5C  19                          add hl,de
     152.  02:7F5D  5E                          ld e,(hl)
     153.  02:7F5E  23                          inc hl
     154.  02:7F5F  23                          inc hl
     155.  02:7F60  23                          inc hl
     156.  02:7F61  19                          add hl,de
     157.  02:7F62  7E                          ld a,(hl)
     158.  02:7F63  ED 62                       sbc hl,hl
     159.  02:7F65  FE 1A                       cp $1a        
     160.  02:7F67  20 01                       jr nz,.skip
     161.  02:7F69  2B                          dec hl
     162.  02:7F6A  22 F8 F7            .skip:  ld (DAC+2),hl
     163.  02:7F6D  3E 02                       ld a,2
     164.  02:7F6F  32 63 F6                    ld (VALTYP),a
     165.  02:7F72  C9                          ret
     166.  02:7F73                      
     167.  02:7F73                      loc:
     168.  02:7F73  E5                          push hl
     169.  02:7F74  FD E1                       pop iy
     170.  02:7F76  FD 6E 06                    ld l,(iy+6)
     171.  02:7F79  FD 66 05                    ld h,(iy+5)
     172.  02:7F7C                      ;        DEBUGASSERT
     173.  02:7F7C  22 F8 F7                    ld (DAC+2),hl
     174.  02:7F7F  3E 02                       ld a,2
     175.  02:7F81  32 63 F6                    ld (VALTYP),a
     176.  02:7F84  C9                          ret
     177.  02:7F85                              
     178.  02:7F85                      putback:
     179.  02:7F85                      ;        DEBUGMESSAGE "putback"
     180.  02:7F85                      ;        push hl
     181.  02:7F85                      ;        pop iy
     182.  02:7F85                      ;        ld (iy+3),c
     183.  02:7F85                      ;        DEBUGASSERT
     184.  02:7F85                      ;        ret
     185.  02:7F85                      
     186.  02:7F85                      lof:
     187.  02:7F85                      fpos:
     188.  02:7F85                              DEBUGMESSAGE "no support!"
     188.  02:7F85                    >         ifdef DEBUG
     188.  02:7F85  52                >         ld d,d
     188.  02:7F86  18 0B             >         jr .skip
     188.  02:7F88                    >         db string
     188.  02:7F88  6E 6F 20 73 75 70 70 6F 72 74 21 
     188.  02:7F93                    > .skip:
     188.  02:7F93                    >         endif
     189.  02:7F93                      
     190.  02:7F93                      illegalFunctionCall:
     191.  02:7F93  1E 05                       ld e,5
     192.  02:7F95  C3 02 7F                    jp basicError
     193.  02:7F98                      
     194.  02:7F98                      ;FCB for DISK BASIC
     195.  02:7F98                      ; +0 FL.MOD     file mode
     196.  02:7F98                      ; +1 FL.FCA     Pointer to FCB for BDOS (low)
     197.  02:7F98                      ; +2 FL.LCA     Pointer to FCB for BDOS (high)
     198.  02:7F98                      ; +3 FL.LSA     Back up character
     199.  02:7F98                      ; +4 FL.DSK     device number
     200.  02:7F98                      ; +5 FL.SLB
     201.  02:7F98                      ; +6 FL.BPS     Position in FL.BUF
     202.  02:7F98                      ; +7 FL.FLG     Holds various information
     203.  02:7F98                      ; +8 FL.OPS     Pseudo head position
     204.  02:7F98                      ; +9 FL.BUF     256-byte file buffer
     205.  02:7F98                      
     206.  02:7F98                      ; device codes
     207.  02:7F98                      ;          SS0           SS1           SS2           SS3
     208.  02:7F98                      ;    ---------------------------------------------------------
     209.  02:7F98                      ;    | 00 04 08 0C | 10 14 18 1C | 20 24 28 2C | 30 34 38 3C | PS0
     210.  02:7F98                      ;    ---------------------------------------------------------
     211.  02:7F98                      ;    | 40 44 48 4C | 50 54 58 5C | 60 64 68 6C | 70 74 78 7C | PS1
     212.  02:7F98                      ;    ---------------------------------------------------------
     213.  02:7F98                      ;    | 80 84 88 8C | 90 94 98 9C | A0 A4 A8 AC | B0 B4 B8 BC | PS2
     214.  02:7F98                      ;    ---------------------------------------------------------
     215.  02:7F98                      ;    | C0 C4 C8 CC | D0 D4 D8 DC | E0 E4 E8 EC | F0 F4 F8 FC | PS3
     216.  02:7F98                      ;    ---------------------------------------------------------
     217.  02:7F98                      
     218.  02:7F98                      ; fileModes
     219.  02:7F98                      ; FOR INPUT (01H)
     220.  02:7F98                      ; FOR OUTPUT (02H)
     221.  02:7F98                      ; FOR APPEND (08H)
     222.  02:7F98                      ; random mode (04H)
     223.  02:7F98                      
     224.  02:7F98                      ; maximum number of files open: MAXFILES=15
     225.  02:7F98                              
     226.  02:7F98                      ; File Control Block
     227.  02:7F98                      ;       0     1     2     3     4     5     6     7     8
     228.  02:7F98                      ;    -------------------------------------------------------
     229.  02:7F98                      ;    | Mod | 00H | 00H | 00H | DEV | 00H | POS | 00H | PPS |
     230.  02:7F98                      ;    -------------------------------------------------------
     231.  02:7F98                      ;                  err? bckup       posHi 
     232.  02:7F98                      ; followed by a 256 byte buffer
     217   02:7F98                              
     218   02:7F98                              ifdef BDOS_NOWIND
     219   02:7F98                    ~         include "nowindbdos.asm"
     220   02:7F98                    ~         endif
     221   02:7F98                              
     222   02:7F98  FF (92)                    ds $8000-(endCopyFromBank-copyFromBank)-$, $ff
     223   02:7FF4                      
     224   02:7FF4                      ; bank switching and data transfer
     225   02:7FF4                      copyFromBank:
     226   02:7FF4  32 01 60                    ld (mapper),a
     227   02:7FF7  ED B0                       ldir
     228   02:7FF9                      enableBank0:
     229   02:7FF9  AF                          xor a
     230   02:7FFA  F5                          push af
     231   02:7FFB  32 01 60                    ld (mapper),a
     232   02:7FFE  F1                          pop af
     233   02:7FFF  C9                          ret
     234   02:8000                      endCopyFromBank:
     235   02:8000                      
     236   02:8000  (03)                        page 3
     237   03:0000  BA (442368)                 ds (512-80)*1024, $ba
     238   03!C000                      

    LABELS
-------------------------------------------------
00:0000000C X RDSLT
00:00000014 X WRSLT
00:0000001C   CALSLT
00:00000024   ENASLT
00:0000005F   CHGMOD
00:00000141   SNSMAT
00:0000015F   EXTROM
00:00000185   SDFSCR
00:0000F33F   LASTDRV
00:0000F342   RAMAD1
00:0000F36E   XFER
00:0000F663   VALTYP
00:0000F7F6   DAC
00:0000F864   PTRFIL
00:0000F866   FILNAM
00:0000FCC1   EXPTBL
00:0000FCC5   SLTTBL
00:0000FCC9 X SLTATR
00:0000FD09   SLTWRK
00:0000FD89   PROCNM
00:0000FD99   DEVICE
00:0000FFCA   EXTBIO
00:0000402D   GETSLT
00:0000FECB X H.RUNC
00:00004000   usbwr
00:00002000   usbrd
00:00008000   usb2
00:00006001   mapper
00:00000080   C_DSKIO
00:00000081   C_DSKCHG
00:00000082   C_GETDPB
00:00000083 X C_CHOICE
00:00000084 X C_DSKFMT
00:00000085   C_DRIVES
00:00000086   C_INIENV
00:00000087 X C_SETDATE
00:00000088   C_DEVICEOPEN
00:00000089   C_DEVICECLOSE
00:0000008A X C_DEVICERNDIO
00:0000008B   C_DEVICEWRITE
00:0000008C   C_DEVICEREAD
00:0000008D X C_DEVICEEOF
00:0000008E   C_AUXIN
00:0000008F   C_AUXOUT
00:00000090   C_MESSAGE
00:00000091   C_CHANGEIMAGE
00:00000092   C_GETDOSVERSION
00:00000093   C_CMDREQUEST
00:000072F0   MSXDOS2_PART.getBootArgs
00:00007305   MSXDOS2_PART.getBootArgs.loop
00:00007328   MSXDOS2_PART.noCommand
00:0000735C   MSXDOS2_PART.bootMSXDOS1
00:00007365   MSXDOS2_PART.nowindInit
00:00007398   MSXDOS2_PART.initDiskBasic
00:000073B0   MSXDOS2_PART.findStatementName
00:000073C7   MSXDOS2_PART.findStatementName.loop
00:000073D1   MSXDOS2_PART.findStatementName.nextStatement
00:000073DC   MSXDOS2_PART.sendRegisters
00:000073EE   MSXDOS2_PART.getHeader
00:000073F0   MSXDOS2_PART.getHeader.loop
00:000073F1   MSXDOS2_PART.getHeader.chkaf
00:00007415   MSXDOS2_PART.getHeader.chk05
00:0000741C   MSXDOS2_PART.sendMessage
00:00007426   MSXDOS2_PART.sendMessage.loop
00:00007432   MSXDOS2_PART.newAUX
00:0000743C   MSXDOS2_PART.AUXin
00:0000746A   MSXDOS2_PART.AUXin.exit
00:00007470   MSXDOS2_PART.AUXin.getCharacter
00:00007481   MSXDOS2_PART.AUXout
00:00007499 X MSXDOS2_PART.sdendFCB
00:0000749D   MSXDOS2_PART.sdendFCB.loop
00:000074A7 X MSXDOS2_PART.receiveFCB
00:000074AB   MSXDOS2_PART.receiveFCB.loop
00:000074B8   MSXDOS2_PART.installExtendedBios
00:000074ED   MSXDOS2_PART.extendedBios
00:000074F4   MSXDOS2_PART.extendedBios.exit
00:00007502   MSXDOS2_PART.determineFunction
00:0000750E   MSXDOS2_PART.functionTable
00:00007514   MSXDOS2_PART.getNowindSlot
00:00007530   MSXDOS2_PART.numberOfDevices
00:00007547   MSXDOS2_PART.debugMessage
00:00007563   MSXDOS2_PART.debugMessage.loop
00:0000756D   MSXDOS2_PART.enableNowindPage0
00:00007578   MSXDOS2_PART.restorePage0
00:00007581   MSXDOS2_PART.enableSlotPage0
00:00007592   MSXDOS2_PART.enableSlotPage0.expanded
00:000075BD   MSXDOS2_PART.getSlotPage0
00:000075C8   MSXDOS2_PART.getSlotPage1
00:000075D3   MSXDOS2_PART.getSlotPage2
00:000075E2   MSXDOS2_PART.expanded
00:000075F6   MSXDOS2_PART.notExpanded
00:000075F8   MSXDOS2_PART.getEntrySLTWRK
00:00000008   MSXDOS2_PART.MYSIZE
00:00000200   MSXDOS2_PART.SECLEN
00:0000760D   MSXDOS2_PART.INIHRD
00:0000761C   MSXDOS2_PART.INIHRD.loop
00:00007630   MSXDOS2_PART.DRIVES
00:00007673   MSXDOS2_PART.DRIVES.exit
00:0000767C   MSXDOS2_PART.DRIVES.notconnected
00:00007699   MSXDOS2_PART.INIENV
00:000076DD   MSXDOS2_PART.INIENV.exit
00:000076E0   MSXDOS2_PART.checkWorkArea
00:000076EF   MSXDOS2_PART.DSKIO
00:00007706 X MSXDOS2_PART.dskioRead
00:0000B723   MSXDOS2_PART.dskioRead.page2
00:00007738   MSXDOS2_PART.dskioRead.page1
00:00007748   MSXDOS2_PART.dskioRead.page2and3
00:0000775E   MSXDOS2_PART.dskioWrite
00:0000B77E   MSXDOS2_PART.dskioWrite.page2
00:00007794   MSXDOS2_PART.dskioWrite.page1
00:000077AA   MSXDOS2_PART.dskioWrite.page2and3
00:000077BF   MSXDOS2_PART.dskioWrite.writeLoop23
00:000077EF   MSXDOS2_PART.dskioWrite.error
00:000077F2   MSXDOS2_PART.DSKCHG
00:00007829   MSXDOS2_PART.GETDPB
00:0000785F   MSXDOS2_PART.GETDPB.hddImage
00:00007892   MSXDOS2_PART.GETDPB.exit
00:00007895   MSXDOS2_PART.CHOICE
00:00007899 X MSXDOS2_PART.CHOICE.noFormat
00:0000789A   MSXDOS2_PART.DSKFMT
00:0000B89E   MSXDOS2_PART.readSectors01
00:0000B8C0   MSXDOS2_PART.readSectors01.slowTransfer
00:0000B8CC   MSXDOS2_PART.writeLoop01
00:0000B8EE   MSXDOS2_PART.writeLoop01.error
00:000078F1   MSXDOS2_PART.readSectors23
00:00007915   MSXDOS2_PART.readSectors23.slowTransfer
00:00007932   MSXDOS2_PART.reverseTransfer
00:0000793E   MSXDOS2_PART.reverseTransfer.loop
00:000079A5   MSXDOS2_PART.OEMSTA
00:000079B3   MSXDOS2_PART.OEMSTA.statement
00:000079C6   MSXDOS2_PART.changeImage
00:000079DB   MSXDOS2_PART.call_exit
00:000079E7   MSXDOS2_PART.call_exit.loop
00:000079F3   MSXDOS2_PART.videoStream
00:000079F4 X MSXDOS2_PART.vramDump
00:00007A00   MSXDOS2_PART.evenFrame
00:00007A1D X MSXDOS2_PART.oddFrame
00:00007A3D   MSXDOS2_PART.tranferframe
00:00007A4A   MSXDOS2_PART.write_more
00:00007B57   MSXDOS2_PART.changeColors
00:00007BA5   MSXDOS2_PART.setVramAccessPointer
00:00007BB3   MSXDOS2_PART.waitForRetrace
00:00007BB9   MSXDOS2_PART.waitForRetrace.lp2
00:00007BC4   MSXDOS2_PART.printVdpText2
00:00007BC5   MSXDOS2_PART.printVdpText2.loop
00:00007BCE   MSXDOS2_PART.supportedMedia
00:00007BCE X MSXDOS2_PART.supportedMedia.f8
00:00007BE0   MSXDOS2_PART.supportedMedia.def
00:00007BE0   MSXDOS2_PART.DEFDPB
00:00007C5E   MSXDOS2_PART.ROMDISK_DSKIO
00:00007C6D   MSXDOS2_PART.ROMDISK_DSKIO.loop
00:00007C8F   MSXDOS2_PART.ROMDISK_DSKIO.directCopy
00:00007C95   MSXDOS2_PART.ROMDISK_DSKIO.nextSector
00:00007C9B   MSXDOS2_PART.ROMDISK_DSKIO.findSector
00:00007CB0   MSXDOS2_PART.ROMDISK_DSKIO.skip
00:00007CBD   MSXDOS2_PART.ROMDISK_DSKCHG
00:00007CC2 X MSXDOS2_PART.ROMDISK_GETDPB
00:00007CC2 X MSXDOS2_PART.ROMDISK_DSKFMT
00:00007CC2   MSXDOS2_PART.flashWriter
00:00007D12   MSXDOS2_PART.flashWriter.source
00:0000C000   MSXDOS2_PART.waitForHeader
00:0000C003   MSXDOS2_PART.waitForHeader.chkbb
00:0000C024   MSXDOS2_PART.autoselectMode
00:0000C03A   MSXDOS2_PART.eraseSector
00:0000C056   MSXDOS2_PART.waitForCommandToComplete
00:0000C066   MSXDOS2_PART.writeResetCommand
00:0000C06C   MSXDOS2_PART.chipErase
00:0000C07A   MSXDOS2_PART.chipErase.wait
00:0000C084   MSXDOS2_PART.writeFlash
00:0000C093   MSXDOS2_PART.writeFlash.loop
00:0000C09D   MSXDOS2_PART.writeFlash.wait
00:0000C0A9   MSXDOS2_PART.verifyFlash
00:0000C0B4   MSXDOS2_PART.verifyFlash.loop
00:0000C0BD   MSXDOS2_PART.acknowledge
00:0000C0C7   MSXDOS2_PART.updateBar
00:0000C0CC   MSXDOS2_PART.writeCommandSequence
00:0000C0DB   MSXDOS2_PART.flasherEnd
00:00007DED   MSXDOS2_PART.device
00:00007DF9   MSXDOS2_PART.device.nocy
00:00007DFF   MSXDOS2_PART.deviceFunctions
00:00007E15   MSXDOS2_PART.identifyDevice
00:00007E2E   MSXDOS2_PART.deviceNameList
00:00007E35   MSXDOS2_PART.open
00:00007E5C   MSXDOS2_PART.deviceIoError
00:00007E5E   MSXDOS2_PART.openError
00:00007E62   MSXDOS2_PART.basicError
00:00007E6D   MSXDOS2_PART.close
00:00007E73   MSXDOS2_PART.randomIO
00:00007E77   MSXDOS2_PART.write
00:00007E7D   MSXDOS2_PART.read
00:00007EB1   MSXDOS2_PART.eof
00:00007ECA   MSXDOS2_PART.eof.skip
00:00007ED3   MSXDOS2_PART.loc
00:00007EE5   MSXDOS2_PART.putback
00:00007EE5   MSXDOS2_PART.lof
00:00007EE5   MSXDOS2_PART.fpos
00:00007EF3 X MSXDOS2_PART.illegalFunctionCall
00:00007FF4   MSXDOS2_PART.copyFromBank
00:00007FF9 X MSXDOS2_PART.enableBank0
00:00007FFA   MSXDOS2_PART.switchBank
00:00008000   MSXDOS2_PART.endCopyFromBank
02:00007405   MSXDOS1_PART.nowindInit
02:00007438   MSXDOS1_PART.initDiskBasic
02:00007450   MSXDOS1_PART.findStatementName
02:00007467   MSXDOS1_PART.findStatementName.loop
02:00007471   MSXDOS1_PART.findStatementName.nextStatement
02:0000747C   MSXDOS1_PART.sendRegisters
02:0000748E   MSXDOS1_PART.getHeader
02:00007490   MSXDOS1_PART.getHeader.loop
02:00007491   MSXDOS1_PART.getHeader.chkaf
02:000074B5   MSXDOS1_PART.getHeader.chk05
02:000074BC   MSXDOS1_PART.sendMessage
02:000074C6   MSXDOS1_PART.sendMessage.loop
02:000074D2   MSXDOS1_PART.newAUX
02:000074DC   MSXDOS1_PART.AUXin
02:0000750A   MSXDOS1_PART.AUXin.exit
02:00007510   MSXDOS1_PART.AUXin.getCharacter
02:00007521   MSXDOS1_PART.AUXout
02:00007539 X MSXDOS1_PART.sdendFCB
02:0000753D   MSXDOS1_PART.sdendFCB.loop
02:00007547 X MSXDOS1_PART.receiveFCB
02:0000754B   MSXDOS1_PART.receiveFCB.loop
02:00007558   MSXDOS1_PART.installExtendedBios
02:0000758D   MSXDOS1_PART.extendedBios
02:00007594   MSXDOS1_PART.extendedBios.exit
02:000075A2   MSXDOS1_PART.determineFunction
02:000075AE   MSXDOS1_PART.functionTable
02:000075B4   MSXDOS1_PART.getNowindSlot
02:000075D0   MSXDOS1_PART.numberOfDevices
02:000075E7   MSXDOS1_PART.debugMessage
02:00007603   MSXDOS1_PART.debugMessage.loop
02:0000760D   MSXDOS1_PART.enableNowindPage0
02:00007618   MSXDOS1_PART.restorePage0
02:00007621   MSXDOS1_PART.enableSlotPage0
02:00007632   MSXDOS1_PART.enableSlotPage0.expanded
02:0000765D   MSXDOS1_PART.getSlotPage0
02:00007668   MSXDOS1_PART.getSlotPage1
02:00007673   MSXDOS1_PART.getSlotPage2
02:00007682   MSXDOS1_PART.expanded
02:00007696   MSXDOS1_PART.notExpanded
02:00007698   MSXDOS1_PART.getEntrySLTWRK
02:00000008   MSXDOS1_PART.MYSIZE
02:00000200   MSXDOS1_PART.SECLEN
02:000076AD   MSXDOS1_PART.INIHRD
02:000076BC   MSXDOS1_PART.INIHRD.loop
02:000076D0   MSXDOS1_PART.DRIVES
02:00007713   MSXDOS1_PART.DRIVES.exit
02:0000771C   MSXDOS1_PART.DRIVES.notconnected
02:00007739   MSXDOS1_PART.INIENV
02:0000777D   MSXDOS1_PART.INIENV.exit
02:00007780   MSXDOS1_PART.checkWorkArea
02:0000778F   MSXDOS1_PART.DSKIO
02:000077A6 X MSXDOS1_PART.dskioRead
02:0000B7C3   MSXDOS1_PART.dskioRead.page2
02:000077D8   MSXDOS1_PART.dskioRead.page1
02:000077E8   MSXDOS1_PART.dskioRead.page2and3
02:000077FE   MSXDOS1_PART.dskioWrite
02:0000B81E   MSXDOS1_PART.dskioWrite.page2
02:00007834   MSXDOS1_PART.dskioWrite.page1
02:0000784A   MSXDOS1_PART.dskioWrite.page2and3
02:0000785F   MSXDOS1_PART.dskioWrite.writeLoop23
02:0000788F   MSXDOS1_PART.dskioWrite.error
02:00007892   MSXDOS1_PART.DSKCHG
02:000078C9   MSXDOS1_PART.GETDPB
02:000078FF   MSXDOS1_PART.GETDPB.hddImage
02:00007932   MSXDOS1_PART.GETDPB.exit
02:00007935   MSXDOS1_PART.CHOICE
02:00007939 X MSXDOS1_PART.CHOICE.noFormat
02:0000793A   MSXDOS1_PART.DSKFMT
02:0000B93E   MSXDOS1_PART.readSectors01
02:0000B960   MSXDOS1_PART.readSectors01.slowTransfer
02:0000B96C   MSXDOS1_PART.writeLoop01
02:0000B98E   MSXDOS1_PART.writeLoop01.error
02:00007991   MSXDOS1_PART.readSectors23
02:000079B5   MSXDOS1_PART.readSectors23.slowTransfer
02:000079D2   MSXDOS1_PART.reverseTransfer
02:000079DE   MSXDOS1_PART.reverseTransfer.loop
02:00007A45   MSXDOS1_PART.OEMSTA
02:00007A53   MSXDOS1_PART.OEMSTA.statement
02:00007A66   MSXDOS1_PART.changeImage
02:00007A7B   MSXDOS1_PART.call_exit
02:00007A87   MSXDOS1_PART.call_exit.loop
02:00007A93   MSXDOS1_PART.videoStream
02:00007A94 X MSXDOS1_PART.vramDump
02:00007AA0   MSXDOS1_PART.evenFrame
02:00007ABD X MSXDOS1_PART.oddFrame
02:00007ADD   MSXDOS1_PART.tranferframe
02:00007AEA   MSXDOS1_PART.write_more
02:00007BF7   MSXDOS1_PART.changeColors
02:00007C45   MSXDOS1_PART.setVramAccessPointer
02:00007C53   MSXDOS1_PART.waitForRetrace
02:00007C59   MSXDOS1_PART.waitForRetrace.lp2
02:00007C64   MSXDOS1_PART.printVdpText2
02:00007C65   MSXDOS1_PART.printVdpText2.loop
02:00007C6E   MSXDOS1_PART.supportedMedia
02:00007C6E X MSXDOS1_PART.supportedMedia.f8
02:00007C80   MSXDOS1_PART.supportedMedia.def
02:00007C80   MSXDOS1_PART.DEFDPB
02:00007CFE   MSXDOS1_PART.ROMDISK_DSKIO
02:00007D0D   MSXDOS1_PART.ROMDISK_DSKIO.loop
02:00007D2F   MSXDOS1_PART.ROMDISK_DSKIO.directCopy
02:00007D35   MSXDOS1_PART.ROMDISK_DSKIO.nextSector
02:00007D3B   MSXDOS1_PART.ROMDISK_DSKIO.findSector
02:00007D50   MSXDOS1_PART.ROMDISK_DSKIO.skip
02:00007D5D   MSXDOS1_PART.ROMDISK_DSKCHG
02:00007D62 X MSXDOS1_PART.ROMDISK_GETDPB
02:00007D62 X MSXDOS1_PART.ROMDISK_DSKFMT
02:00007D62   MSXDOS1_PART.flashWriter
02:00007DB2   MSXDOS1_PART.flashWriter.source
02:0000C000   MSXDOS1_PART.waitForHeader
02:0000C003   MSXDOS1_PART.waitForHeader.chkbb
02:0000C024   MSXDOS1_PART.autoselectMode
02:0000C03A   MSXDOS1_PART.eraseSector
02:0000C056   MSXDOS1_PART.waitForCommandToComplete
02:0000C066   MSXDOS1_PART.writeResetCommand
02:0000C06C   MSXDOS1_PART.chipErase
02:0000C07A   MSXDOS1_PART.chipErase.wait
02:0000C084   MSXDOS1_PART.writeFlash
02:0000C093   MSXDOS1_PART.writeFlash.loop
02:0000C09D   MSXDOS1_PART.writeFlash.wait
02:0000C0A9   MSXDOS1_PART.verifyFlash
02:0000C0B4   MSXDOS1_PART.verifyFlash.loop
02:0000C0BD   MSXDOS1_PART.acknowledge
02:0000C0C7   MSXDOS1_PART.updateBar
02:0000C0CC   MSXDOS1_PART.writeCommandSequence
02:0000C0DB   MSXDOS1_PART.flasherEnd
02:00007E8D   MSXDOS1_PART.device
02:00007E99   MSXDOS1_PART.device.nocy
02:00007E9F   MSXDOS1_PART.deviceFunctions
02:00007EB5   MSXDOS1_PART.identifyDevice
02:00007ECE   MSXDOS1_PART.deviceNameList
02:00007ED5   MSXDOS1_PART.open
02:00007EFC   MSXDOS1_PART.deviceIoError
02:00007EFE   MSXDOS1_PART.openError
02:00007F02   MSXDOS1_PART.basicError
02:00007F0D   MSXDOS1_PART.close
02:00007F13   MSXDOS1_PART.randomIO
02:00007F17   MSXDOS1_PART.write
02:00007F1D   MSXDOS1_PART.read
02:00007F51   MSXDOS1_PART.eof
02:00007F6A   MSXDOS1_PART.eof.skip
02:00007F73   MSXDOS1_PART.loc
02:00007F85   MSXDOS1_PART.putback
02:00007F85   MSXDOS1_PART.lof
02:00007F85   MSXDOS1_PART.fpos
02:00007F93 X MSXDOS1_PART.illegalFunctionCall
02:00007FF4   MSXDOS1_PART.copyFromBank
02:00007FF9 X MSXDOS1_PART.enableBank0
02:00008000   MSXDOS1_PART.endCopyFromBank


 Output: d:\project\nowindlibraries\msxsrc\nowind.out
-------------------------------------------------

 Page: 00
  Org: 00000000  Size: *  Used: 00000000

    No output

 Output: nowind.rom
-------------------------------------------------

 Page: 00
  Org: 00004000  Size: 00004000  Used: 00004000

   Address   Length Align   Label
   00004000   13040         
   000072F0    3344     @   MSXDOS2_PART.getBootArgs

  Overlay parts:
   Address   Length Align  Label
   00004006       2     @  
   00004010      18     @  
   00004093       2     @  
   000047D7       2     @  
   00004881       1     @  
   00004884       1     @  
   0000488D       2     @  
   0000489F       2     @  
   000048B9       2     @  
   000048EB       2     @  
   000048F7       2     @  
   000049A3      16     @  
   00005797       2     @  

 Page: 01
  Org: 00004000  Size: 0000C000  Used: 0000C000

   Address   Length Align   Label
   00004000   49152         

  Overlay parts:
   Address   Length Align  Label
   00004093       2     @  
   00008093       2     @  
   0000C093       2     @  

 Page: 02
  Org: 00004000  Size: 00004000  Used: 00004000

   Address   Length Align   Label
   00004000   13317         
   00007405    3067     @   MSXDOS1_PART.nowindInit

  Overlay parts:
   Address   Length Align  Label
   00004006       2     @  
   00004010      18     @  
   00005770       2     @  
   000057AA       2     @  
   00005809       2     @  
   0000581E       2     @  
   0000582F       2     @  
   00005851       2     @  
   00005884       2     @  
   00005890       2     @  
   0000595D      15     @  
   00005AE8       2     @  
   000065AF       2     @  

 Page: 03
  Org: 00000000  Size: 0006C000  Used: 0006C000

   Address   Length Align   Label
   00000000  442368         

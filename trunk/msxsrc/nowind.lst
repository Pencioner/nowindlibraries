Sjasm Z80 Assembler v0.4 BETA 6 - www.xl2s.tk             [2010.02.05 - 20:38:48]

nowind.asm
Errors: 0

       1   00:0000                              define  DEBUG
       2   00:0000                              
       3   00:0000                      	;define	NOWINDVERSION_FIRSTBATCH			; our handmade first batch
       4   00:0000                      	define	NOWINDVERSION_SUNRISE				; sunrise first batch
       5   00:0000                      		        
       6   00:0000                      	ifdef	NOWINDVERSION_FIRSTBATCH
       7   00:0000                    ~ 	define	FLASHROMSIZE 512
       8   00:0000                    ~ 	endif
       9   00:0000                      		
      10   00:0000                      	ifdef	NOWINDVERSION_SUNRISE
      11   00:0000                      	define	FLASHROMSIZE 4096
      12   00:0000                      	endif
      13   00:0000                      
      14   00:0000                      		
      15   00:0000                      	output	"nowind.rom"
      16   00:0000                      	include "labels.asm"
       1.  00:0000                      ; BIOS routines
       2.  00:0000  (00:000C)           RDSLT           equ $000c
       3.  00:0000  (00:0014)           WRSLT           equ $0014
       4.  00:0000  (00:001C)           CALSLT          equ $001c
       5.  00:0000  (00:0024)           ENASLT          equ $0024
       6.  00:0000  (00:005F)           CHGMOD          equ $005f
       7.  00:0000  (00:0141)           SNSMAT          equ $0141
       8.  00:0000  (00:015F)           EXTROM          equ $015f
       9.  00:0000  (00:0185)           SDFSCR          equ $0185               ; restore screen parameters from clockchip (in SUBROM)
      10.  00:0000                      
      11.  00:0000                      ; BIOS variables (really?)
      12.  00:0000  (00:F33F)           LASTDRV         equ $f33f               ; stores CTRL-key status during boot
      13.  00:0000  (00:F342)           RAMAD1          equ $f342
      14.  00:0000  (00:F36E)           XFER            equ $f36e
      15.  00:0000                      
      16.  00:0000  (00:F663)           VALTYP          equ $f663
      17.  00:0000  (00:F7F6)           DAC             equ $f7f6
      18.  00:0000  (00:F864)           PTRFIL          equ $f864
      19.  00:0000  (00:F866)           FILNAM          equ $f866
      20.  00:0000                      
      21.  00:0000  (00:FCC1)           EXPTBL          equ $fcc1
      22.  00:0000  (00:FCC5)           SLTTBL          equ $fcc5
      23.  00:0000  (00:FCC9)           SLTATR          equ $fcc9
      24.  00:0000  (00:FD09)           SLTWRK          equ $fd09
      25.  00:0000  (00:FD89)           PROCNM          equ $fd89
      26.  00:0000  (00:FD99)           DEVICE          equ $fd99
      27.  00:0000  (00:FFCA)           EXTBIO          equ $ffca
      28.  00:0000                      
      29.  00:0000                      ; Diskrom routines
      30.  00:0000  (00:402D)           GETSLT          equ $402d
      31.  00:0000                               
      32.  00:0000                      ; Hooks
      33.  00:0000  (00:FECB)           H.RUNC          equ $fecb               ; Intercepted by diskrom
      34.  00:0000                      
      35.  00:0000                      ; Nowind hardware addresses
      36.  00:0000  (00:4000)           usbwr           equ $4000               ; 0x4000..0x5fff
      37.  00:0000  (00:2000)           usbrd           equ $2000               ; 0x2000..0x3fff
      38.  00:0000  (00:8000)           usb2            equ $8000               ; 0x8000..0x9fff (read and write)
      39.  00:0000  (00:6001)           mapper          equ $6001               ; 0x6001..0x7fff (odd numbers only)
      40.  00:0000                      
      41.  00:0000                      ; Host commands
      42.  00:0000  (00:0080)           C_DSKIO         equ $80
      43.  00:0000  (00:0081)           C_DSKCHG        equ $81
      44.  00:0000  (00:0082)           C_GETDPB        equ $82
      45.  00:0000  (00:0083)           C_CHOICE        equ $83
      46.  00:0000  (00:0084)           C_DSKFMT        equ $84
      47.  00:0000  (00:0085)           C_DRIVES        equ $85
      48.  00:0000  (00:0086)           C_INIENV        equ $86
      49.  00:0000  (00:0087)           C_SETDATE       equ $87
      50.  00:0000  (00:0088)           C_DEVICEOPEN    equ $88
      51.  00:0000  (00:0089)           C_DEVICECLOSE   equ $89
      52.  00:0000  (00:008A)           C_DEVICERNDIO   equ $8a
      53.  00:0000  (00:008B)           C_DEVICEWRITE   equ $8b
      54.  00:0000  (00:008C)           C_DEVICEREAD    equ $8c
      55.  00:0000  (00:008D)           C_DEVICEEOF     equ $8d
      56.  00:0000  (00:008E)           C_AUXIN         equ $8e
      57.  00:0000  (00:008F)           C_AUXOUT        equ $8f
      58.  00:0000  (00:0090)           C_MESSAGE       equ $90
      59.  00:0000  (00:0091)           C_CHANGEIMAGE   equ $91
      60.  00:0000  (00:0092)           C_BOOTARGS      equ $92
      61.  00:0000  (00:0093)           C_CMDREQUEST    equ $93
      62.  00:0000                      
      63.  00:0000                      ; BDOS commands 0x0F- 0x37 can just use their original command code in register C
      64.  00:0000                      
      65.  00:0000                      ; PATCH       
      66.  00:0000                              macro PATCH address, word
      67.  00:0000                    <         code ! address
      68.  00:0000                    <         dw word
      69.  00:0000                    <         endmacro
      70.  00:0000                      
      71.  00:0000                      ; DEBUGMESSAGE
      72.  00:0000                              macro DEBUGMESSAGE string
      73.  00:0000                    <         ifdef DEBUG
      74.  00:0000                    <         ld d,d
      75.  00:0000                    <         jr .skip
      76.  00:0000                    <         db string
      77.  00:0000                    < .skip:  
      78.  00:0000                    <         endif
      79.  00:0000                    <         endmacro
      80.  00:0000                      
      81.  00:0000                      ; MESSAGE
      82.  00:0000                              macro MESSAGE string
      83.  00:0000                    <         call sendMessage
      84.  00:0000                    <         db string
      85.  00:0000                    < .skip2: nop
      86.  00:0000                    <         endmacro
      87.  00:0000                      
      88.  00:0000                      ; DEBUGDUMPREGISTERS
      89.  00:0000                              macro DEBUGDUMPREGISTERS
      90.  00:0000                    <         ifdef DEBUG
      91.  00:0000                    <         db $ed,7
      92.  00:0000                    <         endif
      93.  00:0000                    <         
      94.  00:0000                    <         ifdef USBDEBUG
      95.  00:0000                    <         assert ($ < $8000)
      96.  00:0000                    <         call sendCpuInfo
      97.  00:0000                    <         endif
      98.  00:0000                    <         endmacro
      99.  00:0000                      
     100.  00:0000                      ; MAKEDPB macro
     101.  00:0000                              macro MAKEDPB media, sectorSize, sectorsPerCluster, maxEnt, maxSector, fatSiz, fatCount
     102.  00:0000                    < .firfat equ 1
     103.  00:0000                    < .firdir equ .firfat+(fatCount*fatSiz)
     104.  00:0000                    < .firrec equ .firdir+(maxEnt/(sectorSize/32))
     105.  00:0000                    <         if sectorSize = 512
     106.  00:0000                    < .shft   equ 4
     107.  00:0000                    <         elseif sectorSize = 256
     108.  00:0000                    < .shft   equ 3
     109.  00:0000                    <         endif
     110.  00:0000                    <         
     111.  00:0000                    <         db media                                        ; media descriptor
     112.  00:0000                    <         dw sectorSize                                   ; sector size
     113.  00:0000                    <         db (sectorSize/32)-1, .shft                     ; dirmsk
     114.  00:0000                    <         db sectorsPerCluster-1                          ; clusmsk 
     115.  00:0000                    <         db sectorsPerCluster                            ; clusshft (TODO: only correct for 1 and 2 sec/clus)         
     116.  00:0000                    <         dw .firfat
     117.  00:0000                    <         db fatCount, maxEnt
     118.  00:0000                    <         dw .firrec
     119.  00:0000                    <         dw (maxSector-.firrec)/sectorsPerCluster+1      ; maxclus
     120.  00:0000                    <         db fatSiz
     121.  00:0000                    <         dw .firdir
     122.  00:0000                    <         endmacro
     123.  00:0000                      
     124.  00:0000                      
     125.  00:0000                      ; ROMHEADER macro
     126.  00:0000                              macro romheader r   
     127.  00:0000                    < .addr := $4000        
     128.  00:0000                    <         repeat r
     129.  00:0000                    <         code ! .addr
     130.  00:0000                    < 
     131.  00:0000                    <         org $4000
     132.  00:0000                    <         db "AB"
     133.  00:0000                    <         dw .init
     134.  00:0000                    <         ds 12,0
     135.  00:0000                    < 
     136.  00:0000                    <         call .redir                     ; DSKIO
     137.  00:0000                    <         call .redir                     ; DSKCHG
     138.  00:0000                    <         call .redir                     ; GETDPB
     139.  00:0000                    <         call .redir                     ; CHOICE
     140.  00:0000                    <         call .redir                     ; DSKFMT
     141.  00:0000                    <         ds 3,0                          ; DRVOFF
     142.  00:0000                    < 
     143.  00:0000                    <         code ! .addr + $3fe7
     144.  00:0000                    <         org $7fe7
     145.  00:0000                    <         
     146.  00:0000                    < .init:  ld hl,romInit
     147.  00:0000                    <         push hl
     148.  00:0000                    <         jr .enableBank0        
     149.  00:0000                    < 
     150.  00:0000                    < .redir: ex (sp),hl
     151.  00:0000                    <         dec hl
     152.  00:0000                    <         dec hl
     153.  00:0000                    <         dec hl
     154.  00:0000                    <         ex (sp),hl
     155.  00:0000                    <         jr .enableBank0
     156.  00:0000                    < 
     157.  00:0000                    <         ld (mapper),a                   ; copyFromBank
     158.  00:0000                    <         ldir
     159.  00:0000                    < .enableBank0:
     160.  00:0000                    <         push af                         ; enable bank 0 (no registers changed)
     161.  00:0000                    <         xor a
     162.  00:0000                    <         ld (mapper),a
     163.  00:0000                    <         pop af
     164.  00:0000                    <         ret
     165.  00:0000                    <         
     166.  00:0000                    < .@addr := .addr + $4000
     167.  00:0000                    <         endrepeat
     168.  00:0000                    <         endmacro
     169.  00:0000                      
     170.  00:0000                      ; MACRO debugdisasm
     171.  00:0000                              macro DEBUGDISASM
     172.  00:0000                    <         db $ed, $0b
     173.  00:0000                    <         endmacro
     174.  00:0000                              
     175.  00:0000                      ; MACRO debugdisasmoff
     176.  00:0000                              macro DEBUGDISASMOFF
     177.  00:0000                    <         db $ed, $0c
     178.  00:0000                    <         endmacro        
     179.  00:0000                      
     180.  00:0000                      ; MACRO breakpoint
     181.  00:0000                              macro BREAKPOINT
     182.  00:0000                    <         ld b,b
     183.  00:0000                    <         jr $+2
     184.  00:0000                    <         endmacro
     185.  00:0000                      
     186.  00:0000                              
     187.  00:0000                              macro PRINTVDPTEXT string
     188.  00:0000                    <         
     189.  00:0000                    <         push hl
     190.  00:0000                    <         ld hl,.text 
     191.  00:0000                    <         call printVdpText2
     192.  00:0000                    <         pop hl
     193.  00:0000                    <         jr .skip
     194.  00:0000                    < .text   db string
     195.  00:0000                    <         db 0
     196.  00:0000                    < .skip:
     197.  00:0000                    <         endmacro
      17   00:0000                      
      18   00:0000                              defpage 0, $4000, $4000						; MSXDOS2 bank 0
      19   00:0000                              defpage 1, $4000, 3 * $4000					; MSXDOS2 bank 1..3
      20   00:0000                              defpage 2, $4000, $4000						; MSXDOS1
      21   00:0000                              defpage 3, 0, (512-80)*1024
      22   00:0000                      		
      23   00:0000                      ; insert MSXDOS2
      24   00:0000  (00)                        page 0
      25   00:4000                      	module	MSXDOS2_PART
      26   00:4000                      		
      27   00:4000                      	define 	MSXDOSVER 2
      28   00:4000                      	define	ROMINIT $47d6
      29   00:4000                      	define	PRINTTEXT $728e
      30   00:4000                      		
      31   00:4000  (32F0)                      incbin "..\roms\MSXDOS22.ROM", 0, $72f0-$4000
      32   00:72F0                                      
      33   00:72F0                              PATCH $4006, device
      33   00:72F0                    >         code ! address
      33   00:4006  94 7D             >         dw word
      34   00:4008                      
      35   00:4008                              code ! $4010
      36   00:4010  C3 96 76                    jp DSKIO
      37   00:4013  C3 99 77                    jp DSKCHG
      38   00:4016  C3 D0 77                    jp GETDPB
      39   00:4019  C3 3C 78                    jp CHOICE
      40   00:401C  C3 41 78                    jp DSKFMT
      41   00:401F  00 00 00                    db 0,0,0                        ; no DRVOFF
      42   00:4022                              
      43   00:4022                              PATCH $47d7, getBootArgs
      43   00:4022                    >         code ! address
      43   00:47D7  F0 72             >         dw word
      44   00:47D9                      ;        PATCH $47dd, 0                  ; do not check for MSX1
      45   00:47D9                              PATCH $488d, MYSIZE
      45   00:47D9                    >         code ! address
      45   00:488D  08 00             >         dw word
      46   00:488F                              PATCH $489f, SECLEN
      46   00:488F                    >         code ! address
      46   00:489F  00 02             >         dw word
      47   00:48A1                              PATCH $48b9, DRIVES
      47   00:48A1                    >         code ! address
      47   00:48B9  DB 75             >         dw word
      48   00:48BB                              PATCH $48eb, DEFDPB - 1
      48   00:48BB                    >         code ! address
      48   00:48EB  86 7B             >         dw word
      49   00:48ED                              PATCH $48f7, INIENV
      49   00:48ED                    >         code ! address
      49   00:48F7  44 76             >         dw word
      50   00:48F9                              PATCH $5797, OEMSTA
      50   00:48F9                    >         code ! address
      50   00:5797  4C 79             >         dw word
      51   00:5799                      
      52   00:5799                              PATCH $4093, mapper
      52   00:5799                    >         code ! address
      52   00:4093  01 60             >         dw word
      53   00:4095                      
      54   00:4095                              code ! $4881
      55   00:4881  43                          db LOW initDiskBasic
      56   00:4882                              code ! $4884
      57   00:4884  73                          db HIGH initDiskBasic
      58   00:4885                       
      59   00:4885                              code ! $49a3
      60   00:49A3  21 DD 73                    ld hl,newAUX                    ; redirect AUX to host  
      61   00:49A6  11 27 F3                    ld de,$f327
      62   00:49A9  01 0A 00                    ld bc,10
      63   00:49AC  ED B0                       ldir
      64   00:49AE  00                          nop
      65   00:49AF  00                          nop
      66   00:49B0  00                          nop
      67   00:49B1  00                          nop
      68   00:49B2  00                          nop                             ; nops needed to override existing code!
      69   00:49B3                              
      70   00:49B3                              code @ $72f0
      71   00:72F0                                      
      72   00:72F0                      getBootArgs:
      73   00:72F0  CD 87 73                    call sendRegisters
      74   00:72F3  36 92                       ld (hl),C_BOOTARGS
      75   00:72F5  CD 18 75                    call enableNowindPage0
      76   00:72F8  26 20                       ld h,HIGH usbrd
      77   00:72FA  CD 99 73                    call getHeader
      78   00:72FD                      
      79   00:72FD  CD 23 75                    call restorePage0
      80   00:7300  DA B8 75                    jp c,INIHRD                     ; no reply (host not connected?)
      81   00:7303                              
      82   00:7303  A7                          and a
      83   00:7304  CA B8 75                    jp z,INIHRD                     ; boot MSXDOS1
      84   00:7307                      
      85   00:7307  21 6F 57                    ld hl,$576f                     ; boot MSXDOS2
      86   00:730A  E5                          push hl
      87   00:730B  3E 04                       ld a,4
      88   00:730D  C3 FA 7F                    jp switchBank
      89   00:7310                                              
      90   00:7310                              include "common.asm"
       1.  00:7310                      ; Nowind specific
       2.  00:7310                      
       3.  00:7310                      nowindInit:
       4.  00:7310                              ;DEBUGMESSAGE "nowindInit"
       5.  00:7310  3A F8 FA                    ld a,($faf8)										; moet volgens bifi ld a,($2d) zijn, $faf8 is op msx1 deel van de rs232 area?
       6.  00:7313  B7                          or a 
       7.  00:7314  F5                          push af
       8.  00:7315  CC 5F 00                    call z,CHGMOD                   ; SCREEN 0 for MSX1
       9.  00:7318  F1                          pop af
      10.  00:7319  DD 21 85 01                 ld ix,SDFSCR                    ; restore screen mode from clockchip
      11.  00:731D  C4 5F 01                    call nz,EXTROM
      12.  00:7320                                      
      13.  00:7320  CD 8E 72                    call PRINTTEXT
      14.  00:7323                              ifndef DEBUG
      15.  00:7323                    ~         db "Nowind USB Diskrom!",0
      16.  00:7323                    ~         else
      17.  00:7323                              db "Nowind USB Diskrom! [debug]",0
      17.  00:7323  4E 6F 77 69 6E 64 20 55 53 42 20 44 69 73 6B 72 
      17.  00:7333  6F 6D 21 20 5B 64 65 62 75 67 5D 00 
      18.  00:733F                              endif
      19.  00:733F                      
      20.  00:733F                              ; call insertBootCode
      21.  00:733F  CD 69 7C                    call flashWriter
      22.  00:7342  C9                          ret
      23.  00:7343                      
      24.  00:7343                      initDiskBasic:
      25.  00:7343                              DEBUGMESSAGE "initDiskBasic"
      25.  00:7343                    >         ifdef DEBUG
      25.  00:7343  52                >         ld d,d
      25.  00:7344  18 0D             >         jr .skip
      25.  00:7346                    >         db string
      25.  00:7346  69 6E 69 74 44 69 73 6B 42 61 73 69 63 
      25.  00:7353                    > .skip:
      25.  00:7353                    >         endif
      26.  00:7353  21 99 FD                    ld hl,DEVICE
      27.  00:7356  CB BE                       res 7,(hl)
      28.  00:7358                              
      29.  00:7358                              if MSXDOSVER = 1 
      30.  00:7358                    ~         jp $5897
      31.  00:7358                    ~         else
      32.  00:7358  C3 5B 49                    jp $495b
      33.  00:735B                              endif
      34.  00:735B                      
      35.  00:735B                      ; search call statement or device name
      36.  00:735B                      findStatementName:
      37.  00:735B                              DEBUGMESSAGE "findStatementName"
      37.  00:735B                    >         ifdef DEBUG
      37.  00:735B  52                >         ld d,d
      37.  00:735C  18 11             >         jr .skip
      37.  00:735E                    >         db string
      37.  00:735E  66 69 6E 64 53 74 61 74 65 6D 65 6E 74 4E 61 6D 
      37.  00:736E  65 
      37.  00:736F                    > .skip:
      37.  00:736F                    >         endif
      38.  00:736F  11 89 FD                    ld de,PROCNM
      39.  00:7372  1A                  .loop:  ld a,(de)
      40.  00:7373  BE                          cp (hl)
      41.  00:7374  20 06                       jr nz,.nextStatement
      42.  00:7376  23                          inc hl
      43.  00:7377  B7                          or a
      44.  00:7378  C8                          ret z                           ; name found
      45.  00:7379  13                          inc de
      46.  00:737A  18 F6                       jr .loop        
      47.  00:737C                      .nextStatement:
      48.  00:737C  AF                          xor a
      49.  00:737D  4F                          ld c,a
      50.  00:737E  ED B1                       cpir
      51.  00:7380  23                          inc hl
      52.  00:7381  23                          inc hl
      53.  00:7382  B6                          or (hl)
      54.  00:7383  20 D6                       jr nz,findStatementName        
      55.  00:7385  37                          scf                             ; not found
      56.  00:7386  C9                          ret
      57.  00:7387                      
      58.  00:7387                      sendRegisters:
      59.  00:7387  F5                          push af
      60.  00:7388  7C                          ld a,h
      61.  00:7389  26 40                       ld h,HIGH usbwr
      62.  00:738B  36 AF                       ld (hl),$af                     ; header
      63.  00:738D  36 05                       ld (hl),$05
      64.  00:738F  71                          ld (hl),c
      65.  00:7390  70                          ld (hl),b
      66.  00:7391  73                          ld (hl),e
      67.  00:7392  72                          ld (hl),d
      68.  00:7393  75                          ld (hl),l
      69.  00:7394  77                          ld (hl),a                       ; register h
      70.  00:7395  D1                          pop de
      71.  00:7396  73                          ld (hl),e                       ; register f
      72.  00:7397  72                          ld (hl),d                       ; register a
      73.  00:7398  C9                          ret
      74.  00:7399                              
      75.  00:7399                      getHeader:
      76.  00:7399  06 FF                       ld b,HIGH 65535                 ; 42000 * 60 states ~ 0,7 sec (time out)
      77.  00:739B  7E                  .loop:  ld a,(hl)
      78.  00:739C  FE AF               .chkaf: cp $af
      79.  00:739E  28 20                       jr z,.chk05
      80.  00:73A0  0B                          dec bc
      81.  00:73A1  78                          ld a,b
      82.  00:73A2  B1                          or c
      83.  00:73A3  20 F6                       jr nz,.loop
      84.  00:73A5                              DEBUGMESSAGE "getHeader Timed out!"
      84.  00:73A5                    >         ifdef DEBUG
      84.  00:73A5  52                >         ld d,d
      84.  00:73A6  18 14             >         jr .skip
      84.  00:73A8                    >         db string
      84.  00:73A8  67 65 74 48 65 61 64 65 72 20 54 69 6D 65 64 20 
      84.  00:73B8  6F 75 74 21 
      84.  00:73BC                    > .skip:
      84.  00:73BC                    >         endif
      85.  00:73BC  3E 02                       ld a,2                          ; not ready
      86.  00:73BE  37                          scf
      87.  00:73BF  C9                          ret
      88.  00:73C0                      
      89.  00:73C0  7E                  .chk05: ld a,(hl)
      90.  00:73C1  FE 05                       cp $05
      91.  00:73C3  20 D7                       jr nz,.chkaf
      92.  00:73C5  7E                          ld a,(hl)
      93.  00:73C6  C9                          ret
      94.  00:73C7                      
      95.  00:73C7                      sendMessage:
      96.  00:73C7                              ;DEBUGMESSAGE "sendMsg"
      97.  00:73C7  E3                          ex (sp),hl
      98.  00:73C8  F5                          push af
      99.  00:73C9  D5                          push de
     100.  00:73CA  E5                          push hl        
     101.  00:73CB  CD 87 73                    call sendRegisters
     102.  00:73CE  36 90                       ld (hl),C_MESSAGE
     103.  00:73D0  E1                          pop hl
     104.  00:73D1  7E                  .loop:  ld a,(hl)
     105.  00:73D2  23                          inc hl
     106.  00:73D3  32 00 40                    ld (usbwr),a
     107.  00:73D6  B7                          or a
     108.  00:73D7  20 F8                       jr nz,.loop
     109.  00:73D9  D1                          pop de
     110.  00:73DA  F1                          pop af
     111.  00:73DB  E3                          ex (sp),hl
     112.  00:73DC  C9                          ret
     113.  00:73DD                              
     114.  00:73DD                      ; AUX device
     115.  00:73DD                              
     116.  00:73DD  C3 E7 73            newAUX: jp AUXin
     117.  00:73E0  00                          nop
     118.  00:73E1  00                          nop
     119.  00:73E2  C3 2C 74                    jp AUXout
     120.  00:73E5  00                          nop
     121.  00:73E6  00                          nop
     122.  00:73E7                      
     123.  00:73E7                      AUXin:  DEBUGMESSAGE "AUX in"
     123.  00:73E7                    >         ifdef DEBUG
     123.  00:73E7  52                >         ld d,d
     123.  00:73E8  18 06             >         jr .skip
     123.  00:73EA  41 55 58 20 69 6E >         db string
     123.  00:73F0                    > .skip:
     123.  00:73F0                    >         endif
     124.  00:73F0  E5                          push hl
     125.  00:73F1  D5                          push de
     126.  00:73F2  C5                          push bc
     127.  00:73F3  CD 87 73                    call sendRegisters
     128.  00:73F6  36 8E                       ld (hl),C_AUXIN
     129.  00:73F8  CD 18 75                    call enableNowindPage0
     130.  00:73FB  26 20                       ld h,HIGH usbrd
     131.  00:73FD  CD 99 73                    call getHeader
     132.  00:7400  D2 1B 74                    jp nc,.getCharacter
     133.  00:7403                              
     134.  00:7403                              DEBUGMESSAGE "not connected"
     134.  00:7403                    >         ifdef DEBUG
     134.  00:7403  52                >         ld d,d
     134.  00:7404  18 0D             >         jr .skip
     134.  00:7406                    >         db string
     134.  00:7406  6E 6F 74 20 63 6F 6E 6E 65 63 74 65 64 
     134.  00:7413                    > .skip:
     134.  00:7413                    >         endif
     135.  00:7413  3E 1A                       ld a,$1a                        ; eof
     136.  00:7415  C1                  .exit:  pop bc
     137.  00:7416  D1                          pop de
     138.  00:7417  E1                          pop hl
     139.  00:7418  C3 23 75                    jp restorePage0        
     140.  00:741B                                    
     141.  00:741B                      .getCharacter:
     142.  00:741B                              DEBUGMESSAGE "getChar"
     142.  00:741B                    >         ifdef DEBUG
     142.  00:741B  52                >         ld d,d
     142.  00:741C  18 07             >         jr .skip
     142.  00:741E                    >         db string
     142.  00:741E  67 65 74 43 68 61 72 
     142.  00:7425                    > .skip:
     142.  00:7425                    >         endif
     143.  00:7425  CD 99 73                    call getHeader
     144.  00:7428  38 F1                       jr c,.getCharacter
     145.  00:742A  18 E9                       jr .exit
     146.  00:742C                      
     147.  00:742C                      
     148.  00:742C                      AUXout: DEBUGMESSAGE "AUX out"
     148.  00:742C                    >         ifdef DEBUG
     148.  00:742C  52                >         ld d,d
     148.  00:742D  18 07             >         jr .skip
     148.  00:742F                    >         db string
     148.  00:742F  41 55 58 20 6F 75 74 
     148.  00:7436                    > .skip:
     148.  00:7436                    >         endif
     149.  00:7436                              DEBUGDUMPREGISTERS
     149.  00:7436                    >         ifdef DEBUG
     149.  00:7436  ED 07             >         db $ed,7
     149.  00:7438                    >         endif
     149.  00:7438                    >         
     149.  00:7438                    >         ifdef USBDEBUG
     149.  00:7438                    ~         assert ($ < $8000)
     149.  00:7438                    ~         call sendCpuInfo
     149.  00:7438                    ~         endif
     150.  00:7438  E5                          push hl
     151.  00:7439  D5                          push de
     152.  00:743A                      ;        push bc
     153.  00:743A                      ;        ld a,(RAMAD1) ; TODO: WTF???
     154.  00:743A                      ;        call RDSLT
     155.  00:743A  F5                          push af        
     156.  00:743B  CD 87 73                    call sendRegisters
     157.  00:743E  36 8F                       ld (hl),C_AUXOUT
     158.  00:7440  F1                          pop af
     159.  00:7441                      ;        pop bc
     160.  00:7441  D1                          pop de
     161.  00:7442  E1                          pop hl
     162.  00:7443  C9                          ret
     163.  00:7444                      
     164.  00:7444                      ;insertBootCode:
     165.  00:7444                      ;        DEBUGMESSAGE "BOOTCODE"
     166.  00:7444                      ;        call sendRegisters
     167.  00:7444                      ;        ld (hl),C_BOOTCODE
     168.  00:7444                      ;        call enableNowindPage0
     169.  00:7444                      ;        call getHeader
     170.  00:7444                      ;        jp c,restorePage0
     171.  00:7444                              
     172.  00:7444                      ;        DEBUGMESSAGE "BOOTCODE"
     173.  00:7444                      ;        jp restorePage0
     174.  00:7444                      
     175.  00:7444                      ; send 32 bytes starting from address specified by DE to the usb
     176.  00:7444                      sdendFCB:
     177.  00:7444  D5                          push de
     178.  00:7445  C5                          push bc
     179.  00:7446                              
     180.  00:7446  06 20                       ld b,32
     181.  00:7448  1A                  .loop:  ld a,(de)
     182.  00:7449  32 00 40                    ld (usbwr),a
     183.  00:744C  13                          inc de
     184.  00:744D  10 F9                       djnz .loop
     185.  00:744F  C1                          pop bc
     186.  00:7450  D1                          pop de
     187.  00:7451  C9                          ret
     188.  00:7452                      
     189.  00:7452                      ; receive 32 bytes and write to the address specified by DE 
     190.  00:7452                      receiveFCB:
     191.  00:7452  D5                          push de
     192.  00:7453  C5                          push bc
     193.  00:7454                              
     194.  00:7454  06 20                       ld b,32
     195.  00:7456  3A 00 20            .loop:  ld a,(usbrd)
     196.  00:7459  32 00 40            	ld (usbwr),a			; loop back
     197.  00:745C  12                          ld (de),a
     198.  00:745D  13                          inc de
     199.  00:745E  10 F6                       djnz .loop
     200.  00:7460  C1                          pop bc
     201.  00:7461  D1                          pop de
     202.  00:7462  C9                          ret
     203.  00:7463                              
      91   00:7463                              include "extendedBios.asm"
       1.  00:7463                      
       2.  00:7463                      installExtendedBios:
       3.  00:7463                      
       4.  00:7463                              ; Called from INIENV, so EXTBIO hook is already initialized
       5.  00:7463                      
       6.  00:7463                              DEBUGMESSAGE "extbio"
       6.  00:7463                    >         ifdef DEBUG
       6.  00:7463  52                >         ld d,d
       6.  00:7464  18 06             >         jr .skip
       6.  00:7466  65 78 74 62 69 6F >         db string
       6.  00:746C                    > .skip:
       6.  00:746C                    >         endif
       7.  00:746C  CD A3 75                    call getEntrySLTWRK             ; save previous EXTBIO hook
       8.  00:746F  23                          inc hl
       9.  00:7470  EB                          ex de,hl        
      10.  00:7471  21 CA FF                    ld hl,EXTBIO
      11.  00:7474  01 05 00                    ld bc,5
      12.  00:7477  ED B0                       ldir
      13.  00:7479                              
      14.  00:7479  E5                          push hl                         ; determine device number
      15.  00:747A  AF                          xor a
      16.  00:747B  11 01 4E                    ld de,$4e01
      17.  00:747E  CD CA FF                    call EXTBIO
      18.  00:7481  E1                          pop hl
      19.  00:7482  77                          ld (hl),a
      20.  00:7483                                      
      21.  00:7483  CD 2D 40                    call GETSLT                     ; install new EXTBIO hook
      22.  00:7486  2E F7                       ld l,$f7
      23.  00:7488  67                          ld h,a
      24.  00:7489  22 CA FF                    ld (EXTBIO),hl
      25.  00:748C  21 98 74                    ld hl,extendedBios
      26.  00:748F  22 CC FF                    ld (EXTBIO+2),hl
      27.  00:7492  3E C9                       ld a,$c9
      28.  00:7494  32 CE FF                    ld (EXTBIO+4),a    
      29.  00:7497  C9                          ret
      30.  00:7498                      
      31.  00:7498                      extendedBios:
      32.  00:7498                              ; broadcast (0x00) not implemented
      33.  00:7498                              ; system exclusive (0xff) not implemented
      34.  00:7498                      
      35.  00:7498  FB                          ei
      36.  00:7499  F5                          push af
      37.  00:749A  7A                          ld a,d
      38.  00:749B  FE 4E                       cp $4e
      39.  00:749D  28 0E                       jr z,determineFunction
      40.  00:749F                      .exit:
      41.  00:749F  E5                          push hl
      42.  00:74A0  C5                          push bc
      43.  00:74A1  CD A3 75                    call getEntrySLTWRK
      44.  00:74A4  2C                          inc l                           ; previous EXTBIO hook 
      45.  00:74A5  E5                          push hl
      46.  00:74A6  DD E1                       pop ix
      47.  00:74A8  C1                          pop bc        
      48.  00:74A9  E1                          pop hl
      49.  00:74AA  F1                          pop af
      50.  00:74AB  DD E9                       jp (ix)                         ; process other EXTBIO handles
      51.  00:74AD                      
      52.  00:74AD                      determineFunction:
      53.  00:74AD  E5                          push hl
      54.  00:74AE  21 B9 D8                    ld hl,functionTable - 2 * $4e00
      55.  00:74B1  19                          add hl,de
      56.  00:74B2  19                          add hl,de
      57.  00:74B3  7E                          ld a,(hl)
      58.  00:74B4  23                          inc hl
      59.  00:74B5  66                          ld h,(hl)
      60.  00:74B6  6F                          ld l,a
      61.  00:74B7  E3                          ex (sp),hl
      62.  00:74B8  C9                          ret
      63.  00:74B9                      
      64.  00:74B9                      functionTable:
      65.  00:74B9  BF 74                       dw getNowindSlot
      66.  00:74BB  DB 74                       dw numberOfDevices
      67.  00:74BD  F2 74                       dw debugMessage
      68.  00:74BF                      
      69.  00:74BF                      getNowindSlot:               
      70.  00:74BF                              DEBUGMESSAGE "getNowindSlot"
      70.  00:74BF                    >         ifdef DEBUG
      70.  00:74BF  52                >         ld d,d
      70.  00:74C0  18 0D             >         jr .skip
      70.  00:74C2                    >         db string
      70.  00:74C2  67 65 74 4E 6F 77 69 6E 64 53 6C 6F 74 
      70.  00:74CF                    > .skip:
      70.  00:74CF                    >         endif
      71.  00:74CF  F1                          pop af
      72.  00:74D0  3D                          dec a
      73.  00:74D1  F5                          push af
      74.  00:74D2  F2 9F 74                    jp p,extendedBios.exit         ; not this device
      75.  00:74D5                              
      76.  00:74D5  F1                          pop af
      77.  00:74D6  CD 73 75                    call getSlotPage1
      78.  00:74D9  37                          scf
      79.  00:74DA  C9                          ret
      80.  00:74DB                              
      81.  00:74DB                      numberOfDevices:
      82.  00:74DB                              DEBUGMESSAGE "numberOfDevices"
      82.  00:74DB                    >         ifdef DEBUG
      82.  00:74DB  52                >         ld d,d
      82.  00:74DC  18 0F             >         jr .skip
      82.  00:74DE                    >         db string
      82.  00:74DE  6E 75 6D 62 65 72 4F 66 44 65 76 69 63 65 73 
      82.  00:74ED                    > .skip:
      82.  00:74ED                    >         endif
      83.  00:74ED  F1                          pop af
      84.  00:74EE  3C                          inc a
      85.  00:74EF  F5                          push af
      86.  00:74F0  18 AD                       jr extendedBios.exit
      87.  00:74F2                              
      88.  00:74F2                      debugMessage:
      89.  00:74F2                              DEBUGMESSAGE "debugMessage"
      89.  00:74F2                    >         ifdef DEBUG
      89.  00:74F2  52                >         ld d,d
      89.  00:74F3  18 0C             >         jr .skip
      89.  00:74F5                    >         db string
      89.  00:74F5  64 65 62 75 67 4D 65 73 73 61 67 65 
      89.  00:7501                    > .skip:
      89.  00:7501                    >         endif
      90.  00:7501  F1                          pop af
      91.  00:7502  3D                          dec a
      92.  00:7503  F5                          push af
      93.  00:7504  F2 9F 74                    jp p,extendedBios.exit
      94.  00:7507                      
      95.  00:7507  E5                          push hl
      96.  00:7508  CD 87 73                    call sendRegisters
      97.  00:750B  36 90                       ld (hl),C_MESSAGE
      98.  00:750D  E1                          pop hl
      99.  00:750E  7E                  .loop:  ld a,(hl)
     100.  00:750F  23                          inc hl
     101.  00:7510  32 00 40                    ld (usbwr),a
     102.  00:7513  B7                          or a
     103.  00:7514  20 F8                       jr nz,.loop
     104.  00:7516                              
     105.  00:7516  F1                          pop af        
     106.  00:7517  C9                          ret
      92   00:7518                              include "slotRoutines.asm"
       1.  00:7518                      ; These routines are used for slot selection
       2.  00:7518                      
       3.  00:7518                      enableNowindPage0:
       4.  00:7518  CD 68 75                    call getSlotPage0
       5.  00:751B  DD 67                       ld ixh,a
       6.  00:751D  CD 73 75                    call getSlotPage1
       7.  00:7520  C3 2C 75                    jp enableSlotPage0       
       8.  00:7523                      
       9.  00:7523                      restorePage0:
      10.  00:7523  F5                          push af
      11.  00:7524  DD 7C                       ld a,ixh
      12.  00:7526  CD 2C 75                    call enableSlotPage0
      13.  00:7529  FB                          ei
      14.  00:752A  F1                          pop af
      15.  00:752B  C9                          ret
      16.  00:752C                      
      17.  00:752C                      enableSlotPage0:
      18.  00:752C                              ; HL and D remain unchanged
      19.  00:752C                              ; enableSlotPage0 can be called in page 1 and 2 (no absolute jumps)
      20.  00:752C                      
      21.  00:752C                              ;DEBUGMESSAGE "enasltP0"
      22.  00:752C  5F                          ld e,a                          ; store slotcode for further use
      23.  00:752D  E6 03                       and 3
      24.  00:752F  4F                          ld c,a                          ; new primary slot in c  
      25.  00:7530  CB 7B                       bit 7,e
      26.  00:7532  F3                          di
      27.  00:7533  20 08                       jr nz,.expanded
      28.  00:7535                      
      29.  00:7535  DB A8                       in a,($a8)
      30.  00:7537  E6 FC                       and %11111100
      31.  00:7539  B1                          or c                            ; enable new primary slot in page 0
      32.  00:753A  D3 A8                       out ($a8),a
      33.  00:753C  C9                          ret
      34.  00:753D                              
      35.  00:753D                      .expanded:
      36.  00:753D  7B                          ld a,e                          ; store secondary slot in e
      37.  00:753E  E6 0C                       and %00001100     
      38.  00:7540  0F                          rrca
      39.  00:7541  0F                          rrca
      40.  00:7542  5F                          ld e,a
      41.  00:7543                      
      42.  00:7543  DB A8                       in a,($a8)
      43.  00:7545  E6 FC                       and %11111100
      44.  00:7547  B1                          or c                            ; new primary slot in page 0
      45.  00:7548  47                          ld b,a                          ; used to restore
      46.  00:7549  17                          rla
      47.  00:754A  A7                          and a                           ; (reset carry)
      48.  00:754B  17                          rla
      49.  00:754C  B1                          or c                            ; new primary slot in page 3
      50.  00:754D  0F                          rrca
      51.  00:754E  0F                          rrca
      52.  00:754F  D3 A8                       out ($a8),a
      53.  00:7551                      
      54.  00:7551  3A FF FF                    ld a,(-1)                       ; write secondary slot register
      55.  00:7554  2F                          cpl
      56.  00:7555  E6 FC                       and %11111100
      57.  00:7557  B3                          or e                            ; apply new secondary slot for page 0
      58.  00:7558  32 FF FF                    ld (-1),a
      59.  00:755B  5F                          ld e,a                          ; store secondary slot register (for SLTTBL)
      60.  00:755C                      
      61.  00:755C  78                          ld a,b                          ; restore primary slot page 3
      62.  00:755D  D3 A8                       out ($a8),a
      63.  00:755F                      
      64.  00:755F  3E C5                       ld a,LOW SLTTBL                 ; update SLTTBL
      65.  00:7561  81                          add c                           ; add primary slot
      66.  00:7562  4F                          ld c,a
      67.  00:7563  06 FC                       ld b,HIGH SLTTBL
      68.  00:7565  7B                          ld a,e                          ; restore secondary slot register
      69.  00:7566  02                          ld (bc),a
      70.  00:7567  C9                          ret
      71.  00:7568                      
      72.  00:7568                      ; These routines determine the current slot and subslot of a page.
      73.  00:7568                      
      74.  00:7568                      getSlotPage0:
      75.  00:7568                              ;DEBUGMESSAGE "getsltP0"
      76.  00:7568  DB A8                       in a,($a8)
      77.  00:756A  CD 8D 75                    call expanded
      78.  00:756D  07                          rlca
      79.  00:756E  07                          rlca
      80.  00:756F  E6 0C                       and %00001100           ; keep subSlot
      81.  00:7571  B1                          or c                    ; add mainSlot and expanded bit
      82.  00:7572  C9                          ret
      83.  00:7573                                      
      84.  00:7573                      getSlotPage1:
      85.  00:7573                      ;        DEBUGMESSAGE "getsltP1"
      86.  00:7573  DB A8                       in a,($a8)
      87.  00:7575  0F                          rrca
      88.  00:7576  0F                          rrca
      89.  00:7577  CD 8D 75                    call expanded
      90.  00:757A  E6 0C                       and %00001100           ; keep subSlot
      91.  00:757C  B1                          or c                    ; add mainSlot and expanded bit
      92.  00:757D  C9                          ret        
      93.  00:757E                                      
      94.  00:757E                      getSlotPage2:
      95.  00:757E                      ;        DEBUGMESSAGE "getsltP2"
      96.  00:757E  DB A8                       in a,($a8)
      97.  00:7580  0F                          rrca
      98.  00:7581  0F                          rrca
      99.  00:7582  0F                          rrca
     100.  00:7583  0F                          rrca
     101.  00:7584  CD 8D 75                    call expanded
     102.  00:7587  0F                          rrca
     103.  00:7588  0F                          rrca
     104.  00:7589  E6 0C                       and %00001100           ; keep subSlot
     105.  00:758B  B1                          or c                    ; add mainSlot and expanded bit
     106.  00:758C  C9                          ret
     107.  00:758D                      
     108.  00:758D                      ;expanded:        
     109.  00:758D                      ;        ld hl,EXPTBL - $0300
     110.  00:758D                      ;        ld b,3
     111.  00:758D                      ;        and b
     112.  00:758D                      ;        ld c,a
     113.  00:758D                      ;        add hl,bc      
     114.  00:758D                      ;        
     115.  00:758D                      ;        or (hl)        ; BUGGIE!!!! (a will be used again!)
     116.  00:758D                      ;        ret p                           ; return when slot is not expanded
     117.  00:758D                      ;        
     118.  00:758D                      ;        ld c,a
     119.  00:758D                      ;        ld a,4
     120.  00:758D                      ;        add a,l
     121.  00:758D                      ;        ld l,a
     122.  00:758D                      ;        ld a,(hl)
     123.  00:758D                      ;        ret
     124.  00:758D                      
     125.  00:758D                      expanded:        
     126.  00:758D  21 C1 F9                    ld hl,EXPTBL - $0300
     127.  00:7590  06 03                       ld b,3
     128.  00:7592  A0                          and b
     129.  00:7593  4F                          ld c,a
     130.  00:7594  09                          add hl,bc
     131.  00:7595  CB 7E                       bit 7,(hl)
     132.  00:7597  28 08                       jr z,notExpanded
     133.  00:7599                      
     134.  00:7599  CB F9                       set 7,c
     135.  00:759B  2C                          inc l
     136.  00:759C  2C                          inc l
     137.  00:759D  2C                          inc l
     138.  00:759E  2C                          inc l
     139.  00:759F  7E                          ld a,(hl)
     140.  00:75A0  C9                          ret        
     141.  00:75A1                      
     142.  00:75A1                      notExpanded:
     143.  00:75A1  C1                          pop bc
     144.  00:75A2  C9                          ret
     145.  00:75A3                      
     146.  00:75A3                      getEntrySLTWRK:
     147.  00:75A3  CD 73 75                    call getSlotPage1
     148.  00:75A6  21 09 FD                    ld hl,SLTWRK
     149.  00:75A9  4F                          ld c,a
     150.  00:75AA  0F                          rrca
     151.  00:75AB  0F                          rrca
     152.  00:75AC  0F                          rrca
     153.  00:75AD  E6 60                       and %01100000           ; main slot x 32
     154.  00:75AF  47                          ld b,a
     155.  00:75B0  79                          ld a,c
     156.  00:75B1  07                          rlca
     157.  00:75B2  E6 18                       and %00011000           ; sub slot x 8
     158.  00:75B4  80                          add b
     159.  00:75B5  85                          add l
     160.  00:75B6  6F                          ld l,a
     161.  00:75B7  C9                          ret
     162.  00:75B8                      
      93   00:75B8                              include "nowindDriver.asm"
       1.  00:75B8  (00:0008)           MYSIZE          equ 8                   ; size of work area (not used, some programs write here to stop drives spinning)
       2.  00:75B8  (00:0200)           SECLEN          equ 512                 ; sector size
       3.  00:75B8                      
       4.  00:75B8                      ; SLTWRK entry
       5.  00:75B8                      ; +0    rom drive number
       6.  00:75B8                      ; +1..5 previous EXTBIO
       7.  00:75B8                      ; +6    not used
       8.  00:75B8                      ; +7    not used
       9.  00:75B8                      
      10.  00:75B8                             
      11.  00:75B8                      ; if this is defined we tell DOS2.3 that we _are DOS2.3 also, so
      12.  00:75B8                      ; it does not try to override our initilazations 
      13.  00:75B8                      
      14.  00:75B8                      define  PRETEND_2B_DOS23
      15.  00:75B8                              
      16.  00:75B8                      INIHRD: 
      17.  00:75B8                              DEBUGMESSAGE "INIHRD"        
      17.  00:75B8                    >         ifdef DEBUG
      17.  00:75B8  52                >         ld d,d
      17.  00:75B9  18 06             >         jr .skip
      17.  00:75BB  49 4E 49 48 52 44 >         db string
      17.  00:75C1                    > .skip:
      17.  00:75C1                    >         endif
      18.  00:75C1                              
      19.  00:75C1                      ;        call getWorkArea
      20.  00:75C1                      ;        DEBUGDUMPREGISTERS
      21.  00:75C1                                                      
      22.  00:75C1  CD 18 75                    call enableNowindPage0                  ; clear hostToMSXFifo by reading 4Kb of random data
      23.  00:75C4  01 00 10                    ld bc,4096
      24.  00:75C7  3A 00 20            .loop:  ld a,(usbrd)
      25.  00:75CA  0B                          dec bc
      26.  00:75CB  78                          ld a,b
      27.  00:75CC  B1                          or c
      28.  00:75CD  20 F8                       jr nz,.loop
      29.  00:75CF  CD 23 75                    call restorePage0
      30.  00:75D2                              
      31.  00:75D2  26 40                       ld h,HIGH usbwr
      32.  00:75D4  36 AF                       ld (hl),$af                     ; INIHRD command
      33.  00:75D6  36 FF                       ld (hl),$ff
      34.  00:75D8  C3 10 73                    jp nowindInit
      35.  00:75DB                      
      36.  00:75DB                      DRIVES:
      37.  00:75DB                              DEBUGMESSAGE "DRIVES"
      37.  00:75DB                    >         ifdef DEBUG
      37.  00:75DB  52                >         ld d,d
      37.  00:75DC  18 06             >         jr .skip
      37.  00:75DE  44 52 49 56 45 53 >         db string
      37.  00:75E4                    > .skip:
      37.  00:75E4                    >         endif
      38.  00:75E4  F5                          push af                         ; A, BC and DE should be preserved!
      39.  00:75E5  C5                          push bc
      40.  00:75E6  D5                          push de
      41.  00:75E7  3A 99 FD                    ld a,(DEVICE)
      42.  00:75EA  CD 87 73                    call sendRegisters
      43.  00:75ED  36 85                       ld (hl),C_DRIVES
      44.  00:75EF  CD 18 75                    call enableNowindPage0
      45.  00:75F2  26 20                       ld h,HIGH usbrd
      46.  00:75F4  CD 99 73                    call getHeader
      47.  00:75F7  2E 02                       ld l,2                          ; default 2 drives
      48.  00:75F9  38 2C                       jr c,.notconnected
      49.  00:75FB                      
      50.  00:75FB                              PRINTVDPTEXT " Host connected."
      50.  00:75FB                    >         
      50.  00:75FB  E5                >         push hl
      50.  00:75FC  21 05 76          >         ld hl,.text
      50.  00:75FF  CD 6B 7B          >         call printVdpText2
      50.  00:7602  E1                >         pop hl
      50.  00:7603  18 11             >         jr .skip
      50.  00:7605                    > .text   db string
      50.  00:7605  20 48 6F 73 74 20 63 6F 6E 6E 65 63 74 65 64 2E 
      50.  00:7615  00                >         db 0
      50.  00:7616                    > .skip:
      51.  00:7616                                                      
      52.  00:7616  32 3F F3                    ld (LASTDRV),a                  ; install phantom drives (CRTL key)?
      53.  00:7619  7E                          ld a,(hl)                       ; allow other drives (SHIFT key)?
      54.  00:761A  32 99 FD                    ld (DEVICE),a
      55.  00:761D  6E                          ld l,(hl)                       ; number of drives
      56.  00:761E  E5                  .exit:  push hl  
      57.  00:761F  CD 23 75                    call restorePage0
      58.  00:7622  E1                          pop hl
      59.  00:7623  D1                          pop de
      60.  00:7624  C1                          pop bc
      61.  00:7625  F1                          pop af
      62.  00:7626  C9                          ret
      63.  00:7627                              
      64.  00:7627                      .notconnected:
      65.  00:7627                              PRINTVDPTEXT " Host timed out!"            
      65.  00:7627                    >         
      65.  00:7627  E5                >         push hl
      65.  00:7628  21 31 76          >         ld hl,.text
      65.  00:762B  CD 6B 7B          >         call printVdpText2
      65.  00:762E  E1                >         pop hl
      65.  00:762F  18 11             >         jr .skip
      65.  00:7631                    > .text   db string
      65.  00:7631  20 48 6F 73 74 20 74 69 6D 65 64 20 6F 75 74 21 
      65.  00:7641  00                >         db 0
      65.  00:7642                    > .skip:
      66.  00:7642  18 DA                       jr .exit
      67.  00:7644                      
      68.  00:7644                      
      69.  00:7644                      INIENV:
      70.  00:7644                      ; Interrupt handler can be installed here and
      71.  00:7644                      ; work area can be initialized when it was requested
      72.  00:7644                              DEBUGMESSAGE "INIENV"
      72.  00:7644                    >         ifdef DEBUG
      72.  00:7644  52                >         ld d,d
      72.  00:7645  18 06             >         jr .skip
      72.  00:7647  49 4E 49 45 4E 56 >         db string
      72.  00:764D                    > .skip:
      72.  00:764D                    >         endif
      73.  00:764D                      
      74.  00:764D                              ifdef PRETEND_2B_DOS23
      75.  00:764D                              DEBUGMESSAGE "Lie about being DOS v2.31"
      75.  00:764D                    >         ifdef DEBUG
      75.  00:764D  52                >         ld d,d
      75.  00:764E  18 19             >         jr .skip
      75.  00:7650                    >         db string
      75.  00:7650  4C 69 65 20 61 62 6F 75 74 20 62 65 69 6E 67 20 
      75.  00:7660  44 4F 53 20 76 32 2E 33 31 
      75.  00:7669                    > .skip:
      75.  00:7669                    >         endif
      76.  00:7669  3E 23                       ld a,$23
      77.  00:766B  32 13 F3                    ld ($f313),a
      78.  00:766E                              endif
      79.  00:766E                              
      80.  00:766E  CD 63 74                    call installExtendedBios
      81.  00:7671  CD 87 73                    call sendRegisters
      82.  00:7674  36 86                       ld (hl),C_INIENV
      83.  00:7676  CD 18 75                    call enableNowindPage0
      84.  00:7679  26 20                       ld h,HIGH usbrd
      85.  00:767B  CD 99 73                    call getHeader
      86.  00:767E  F5                          push af
      87.  00:767F                      ;        push ix
      88.  00:767F                      ;        call GETWRK
      89.  00:767F                      ;        pop ix
      90.  00:767F  CD A3 75                    call getEntrySLTWRK
      91.  00:7682  F1                          pop af
      92.  00:7683  36 00                       ld (hl),0                       ; romdisk in drive A: (default)          
      93.  00:7685  38 01                       jr c,.exit
      94.  00:7687  77                          ld (hl),a                       ; store romdisk drive number (255 = no romdisk)
      95.  00:7688  C3 23 75            .exit:  jp restorePage0
      96.  00:768B                      
      97.  00:768B                      checkWorkArea:
      98.  00:768B  C5                          push bc
      99.  00:768C  E5                          push hl
     100.  00:768D  F5                          push af
     101.  00:768E                      ;        call GETWRK
     102.  00:768E  CD A3 75                    call getEntrySLTWRK
     103.  00:7691  F1                          pop af
     104.  00:7692  BE                          cp (hl)
     105.  00:7693  E1                          pop hl
     106.  00:7694  C1                          pop bc
     107.  00:7695  C9                          ret        
     108.  00:7696                      
     109.  00:7696                      DSKIO: 
     110.  00:7696                      ; Input     F   Carry for set for write, reset for read
     111.  00:7696                      ;           A   Drive number
     112.  00:7696                      ;           B   Number of sectors to read/write
     113.  00:7696                      ;           C   Media descriptor
     114.  00:7696                      ;           DE  Logical sector number
     115.  00:7696                      ;           HL  Transfer address
     116.  00:7696                      ; Output    F   Carry set when not succesfull
     117.  00:7696                      ;           A   Error code
     118.  00:7696                      ;           B   Number of remaining sectors (TODO: check! even without error?)
     119.  00:7696                      
     120.  00:7696                              DEBUGMESSAGE "DSKIO"
     120.  00:7696                    >         ifdef DEBUG
     120.  00:7696  52                >         ld d,d
     120.  00:7697  18 05             >         jr .skip
     120.  00:7699  44 53 4B 49 4F    >         db string
     120.  00:769E                    > .skip:
     120.  00:769E                    >         endif
     121.  00:769E  F5                          push af
     122.  00:769F  CD 8B 76                    call checkWorkArea
     123.  00:76A2  CA 05 7C                    jp z,ROMDISK_DSKIO
     124.  00:76A5  F1                          pop af
     125.  00:76A6                      
     126.  00:76A6  CD 87 73                    call sendRegisters
     127.  00:76A9  36 80                       ld (hl),C_DSKIO
     128.  00:76AB  38 58                       jr c,dskioWrite                 ; read or write?
     129.  00:76AD                             
     130.  00:76AD                      dskioRead:
     131.  00:76AD  07                          rlca                            ; < 0x8000 ?
     132.  00:76AE  38 3F                       jr c,.page2and3
     133.  00:76B0                      
     134.  00:76B0                              DEBUGMESSAGE "read01"
     134.  00:76B0                    >         ifdef DEBUG
     134.  00:76B0  52                >         ld d,d
     134.  00:76B1  18 06             >         jr .skip
     134.  00:76B3  72 65 61 64 30 31 >         db string
     134.  00:76B9                    > .skip:
     134.  00:76B9                    >         endif
     135.  00:76B9  CD 7E 75                    call getSlotPage2               ; enable nowind in page 2
     136.  00:76BC  F5                          push af
     137.  00:76BD  CD 73 75                    call getSlotPage1
     138.  00:76C0  DD 67                       ld ixh,a                        ; ixh = current nowind slot
     139.  00:76C2  26 80                       ld h,$80
     140.  00:76C4  CD 24 00                    call ENASLT
     141.  00:76C7  C3 CA B6                    jp .page2
     142.  00:76CA                              
     143.  00:76CA  (B6CA)                      PHASE $ + $4000
     144.  00:B6CA                      .page2:
     145.  00:B6CA  3A 42 F3                    ld a,(RAMAD1)                   ; enable RAM in page 1
     146.  00:B6CD  26 40                       ld h,$40
     147.  00:B6CF  CD 24 00                    call ENASLT
     148.  00:B6D2                              
     149.  00:B6D2  CD 45 B8                    call readSectors01 
     150.  00:B6D5                              ; TODO: carry checken?----------------------------------------------!!!!!!!!!!!!!!!
     151.  00:B6D5                              
     152.  00:B6D5  DD 7C                       ld a,ixh                        ; enable nowind in page 1 
     153.  00:B6D7  26 40                       ld h,$40
     154.  00:B6D9  CD 24 00                    call ENASLT
     155.  00:B6DC  C3 DF 76                    jp .page1        
     156.  00:B6DF                      
     157.  00:B6DF  (76DF)                      DEPHASE
     158.  00:76DF                      .page1:
     159.  00:76DF  3A 00 80                    ld a,(usb2)
     160.  00:76E2  DD 67                       ld ixh,a
     161.  00:76E4  F1                          pop af
     162.  00:76E5  26 80                       ld h,$80
     163.  00:76E7  CD 24 00                    call ENASLT                     ; restore page 2
     164.  00:76EA  DD 7C                       ld a,ixh
     165.  00:76EC  B7                          or a
     166.  00:76ED  FB                          ei
     167.  00:76EE  C8                          ret z                           ; nothing more to read
     168.  00:76EF                                      
     169.  00:76EF                      .page2and3:                     
     170.  00:76EF                              DEBUGMESSAGE "read23"
     170.  00:76EF                    >         ifdef DEBUG
     170.  00:76EF  52                >         ld d,d
     170.  00:76F0  18 06             >         jr .skip
     170.  00:76F2  72 65 61 64 32 33 >         db string
     170.  00:76F8                    > .skip:
     170.  00:76F8                    >         endif
     171.  00:76F8  CD 18 75                    call enableNowindPage0
     172.  00:76FB  FD E5                       push iy
     173.  00:76FD  CD 98 78                    call readSectors23
     174.  00:7700  FD E1                       pop iy
     175.  00:7702  C3 23 75                    jp restorePage0
     176.  00:7705                      
     177.  00:7705                      dskioWrite:
     178.  00:7705                              DEBUGMESSAGE "dskwrite"
     178.  00:7705                    >         ifdef DEBUG
     178.  00:7705  52                >         ld d,d
     178.  00:7706  18 08             >         jr .skip
     178.  00:7708                    >         db string
     178.  00:7708  64 73 6B 77 72 69 74 65 
     178.  00:7710                    > .skip:
     178.  00:7710                    >         endif
     179.  00:7710  07                          rlca
     180.  00:7711  38 3E                       jr c,.page2and3        
     181.  00:7713                              
     182.  00:7713                              ;call enableNowindPage2 (todo: make common routine?) 
     183.  00:7713  CD 7E 75                    call getSlotPage2               ; save current slot page 2
     184.  00:7716  DD 67                       ld ixh,a
     185.  00:7718  CD 73 75                    call getSlotPage1
     186.  00:771B  DD 6F                       ld ixl,a
     187.  00:771D  26 80                       ld h,$80
     188.  00:771F  CD 24 00                    call ENASLT                     ; nowind in page 2
     189.  00:7722  C3 25 B7                    jp .page2
     190.  00:7725                      
     191.  00:7725  (B725)                      PHASE $ + $4000
     192.  00:B725                      .page2:
     193.  00:B725  3A 42 F3                    ld a,(RAMAD1)
     194.  00:B728  26 40                       ld h,$40
     195.  00:B72A  CD 24 00                    call ENASLT                     ; ram in page 1
     196.  00:B72D                              
     197.  00:B72D  CD 73 B8                    call writeLoop01
     198.  00:B730  F5                          push af
     199.  00:B731                              
     200.  00:B731  DD 7D                       ld a,ixl
     201.  00:B733  26 40                       ld h,$40
     202.  00:B735  CD 24 00                    call ENASLT                     ; restore nowind in page 1
     203.  00:B738  C3 3B 77                    jp .page1
     204.  00:B73B                              
     205.  00:B73B  (773B)                      DEPHASE
     206.  00:773B                      .page1:
     207.  00:773B  DD 7C                       ld a,ixh
     208.  00:773D  26 80                       ld h,$80
     209.  00:773F  CD 24 00                    call ENASLT
     210.  00:7742  F1                          pop af
     211.  00:7743  D8                          ret c                           ; return error (error code in a)
     212.  00:7744  E8                          ret pe                          ; host returns 0xfe when data for page 2/3 is available
     213.  00:7745                              DEBUGMESSAGE "doorgaan!"
     213.  00:7745                    >         ifdef DEBUG
     213.  00:7745  52                >         ld d,d
     213.  00:7746  18 09             >         jr .skip
     213.  00:7748                    >         db string
     213.  00:7748  64 6F 6F 72 67 61 61 6E 21 
     213.  00:7751                    > .skip:
     213.  00:7751                    >         endif
     214.  00:7751                              
     215.  00:7751                      .page2and3:
     216.  00:7751                              DEBUGMESSAGE "page2and3"
     216.  00:7751                    >         ifdef DEBUG
     216.  00:7751  52                >         ld d,d
     216.  00:7752  18 09             >         jr .skip
     216.  00:7754                    >         db string
     216.  00:7754  70 61 67 65 32 61 6E 64 33 
     216.  00:775D                    > .skip:
     216.  00:775D                    >         endif
     217.  00:775D  CD 18 75                    call enableNowindPage0
     218.  00:7760  CD 66 77                    call .writeLoop23
     219.  00:7763  C3 23 75                    jp restorePage0
     220.  00:7766                              
     221.  00:7766                      .writeLoop23:
     222.  00:7766                              DEBUGMESSAGE "writeLoop23"
     222.  00:7766                    >         ifdef DEBUG
     222.  00:7766  52                >         ld d,d
     222.  00:7767  18 0B             >         jr .skip
     222.  00:7769                    >         db string
     222.  00:7769  77 72 69 74 65 4C 6F 6F 70 32 33 
     222.  00:7774                    > .skip:
     222.  00:7774                    >         endif
     223.  00:7774                              
     224.  00:7774  26 20                       ld h,HIGH usbrd
     225.  00:7776  CD 99 73                    call getHeader
     226.  00:7779  D8                          ret c                           ; exit (not ready)
     227.  00:777A  B7                          or a
     228.  00:777B  F8                          ret m                           ; exit (no error)
     229.  00:777C  20 18                       jr nz,.error
     230.  00:777E                      
     231.  00:777E                              DEBUGMESSAGE "send23"
     231.  00:777E                    >         ifdef DEBUG
     231.  00:777E  52                >         ld d,d
     231.  00:777F  18 06             >         jr .skip
     231.  00:7781  73 65 6E 64 32 33 >         db string
     231.  00:7787                    > .skip:
     231.  00:7787                    >         endif
     232.  00:7787  5E                          ld e,(hl)                       ; address
     233.  00:7788  56                          ld d,(hl)
     234.  00:7789  4E                          ld c,(hl)                       ; number of bytes        
     235.  00:778A  46                          ld b,(hl)
     236.  00:778B  7E                          ld a,(hl)                       ; block sequence number
     237.  00:778C                              
     238.  00:778C                              ;DEBUGDUMPREGISTERS
     239.  00:778C  EB                          ex de,hl
     240.  00:778D  11 00 40                    ld de,usbwr
     241.  00:7790  12                          ld (de),a                       ; mark block begin
     242.  00:7791  ED B0                       ldir
     243.  00:7793  12                          ld (de),a                       ; mark block end
     244.  00:7794  18 D0                       jr .writeLoop23
     245.  00:7796                      
     246.  00:7796  37                  .error: scf
     247.  00:7797  7E                          ld a,(hl)                       ; get error code
     248.  00:7798  C9                          ret
     249.  00:7799                      
     250.  00:7799                                     
     251.  00:7799                      DSKCHG:
     252.  00:7799                      ; Input     A   Drive number
     253.  00:7799                      ;           B   0
     254.  00:7799                      ;           C   Media descriptor (previous)
     255.  00:7799                      ;           HL  Base address of DPB
     256.  00:7799                      ; Output    B   1   Disk unchanged
     257.  00:7799                      ;               0   Unknown (DPB is updated)
     258.  00:7799                      ;               -1  Disk changed (DPB is updated)
     259.  00:7799                      ;           F   Carry set when not succesfull
     260.  00:7799                      ;           A   Error code
     261.  00:7799                      
     262.  00:7799                              DEBUGMESSAGE "DSKCHG"
     262.  00:7799                    >         ifdef DEBUG
     262.  00:7799  52                >         ld d,d
     262.  00:779A  18 06             >         jr .skip
     262.  00:779C  44 53 4B 43 48 47 >         db string
     262.  00:77A2                    > .skip:
     262.  00:77A2                    >         endif
     263.  00:77A2  F5                          push af
     264.  00:77A3  CD 8B 76                    call checkWorkArea
     265.  00:77A6  CA 64 7C                    jp z,ROMDISK_DSKCHG
     266.  00:77A9  F1                          pop af       
     267.  00:77AA                      
     268.  00:77AA  E5                          push hl
     269.  00:77AB  CD 87 73                    call sendRegisters
     270.  00:77AE  36 81                       ld (hl),C_DSKCHG
     271.  00:77B0  CD 18 75                    call enableNowindPage0
     272.  00:77B3  26 20                       ld h,HIGH usbrd
     273.  00:77B5  CD 99 73                    call getHeader
     274.  00:77B8  4E                          ld c,(hl)               ; media descriptor (when disk was changed)
     275.  00:77B9  F5                          push af
     276.  00:77BA  C5                          push bc
     277.  00:77BB  CD 23 75                    call restorePage0
     278.  00:77BE  C1                          pop bc
     279.  00:77BF  F1                          pop af
     280.  00:77C0  E1                          pop hl
     281.  00:77C1  D8                          ret c           ; not ready
     282.  00:77C2  B7                          or a
     283.  00:77C3  06 01                       ld b,1
     284.  00:77C5  C8                          ret z           ; not changed
     285.  00:77C6  41                          ld b,c
     286.  00:77C7  CD D0 77                    call GETDPB
     287.  00:77CA  3E 0A                       ld a,10
     288.  00:77CC  D8                          ret c
     289.  00:77CD  06 FF                       ld b,255
     290.  00:77CF  C9                          ret
     291.  00:77D0                      
     292.  00:77D0                      GETDPB:
     293.  00:77D0                      ; Input     A   Drive number
     294.  00:77D0                      ;           B   Media descriptor (first byte of FAT)
     295.  00:77D0                      ;           C   Previous media descriptor (does not seem to be used in other drivers)
     296.  00:77D0                      ;           HL  Base address of HL
     297.  00:77D0                      ; Output    DPB for specified drive in [HL+1]..[HL+18]
     298.  00:77D0                      
     299.  00:77D0                              DEBUGMESSAGE "GETDPB"
     299.  00:77D0                    >         ifdef DEBUG
     299.  00:77D0  52                >         ld d,d
     299.  00:77D1  18 06             >         jr .skip
     299.  00:77D3  47 45 54 44 50 42 >         db string
     299.  00:77D9                    > .skip:
     299.  00:77D9                    >         endif
     300.  00:77D9  EB                          ex de,hl
     301.  00:77DA  13                          inc de
     302.  00:77DB  67                          ld h,a
     303.  00:77DC  78                          ld a,b
     304.  00:77DD  FE F0                       cp $f0
     305.  00:77DF  7C                          ld a,h
     306.  00:77E0  28 24                       jr z,.hddImage
     307.  00:77E2                              
     308.  00:77E2                              MESSAGE "ROM GETDPB"
     308.  00:77E2  CD C7 73          >         call sendMessage
     308.  00:77E5                    >         db string
     308.  00:77E5  52 4F 4D 20 47 45 54 44 50 42 
     308.  00:77EF  00                > .skip2: nop
     309.  00:77F0                      
     310.  00:77F0  78                          ld a,b
     311.  00:77F1  D6 F8                       sub $f8
     312.  00:77F3  D8                          ret c                           ; not supported in msxdos1
     313.  00:77F4  07                          rlca                            ; 2x
     314.  00:77F5  4F                          ld c,a
     315.  00:77F6  07                          rlca                            ; 4x
     316.  00:77F7  07                          rlca                            ; 8x
     317.  00:77F8  07                          rlca                            ; 16x
     318.  00:77F9  81                          add a,c                         ; 18x
     319.  00:77FA  4F                          ld c,a
     320.  00:77FB  06 00                       ld b,0        
     321.  00:77FD  21 75 7B                    ld hl,supportedMedia
     322.  00:7800  09                          add hl,bc
     323.  00:7801  0E 12                       ld c,18
     324.  00:7803  ED B0                       ldir
     325.  00:7805  C9                          ret
     326.  00:7806                      
     327.  00:7806                      .hddImage:
     328.  00:7806                              DEBUGMESSAGE ".hddImage"
     328.  00:7806                    >         ifdef DEBUG
     328.  00:7806  52                >         ld d,d
     328.  00:7807  18 09             >         jr .skip
     328.  00:7809                    >         db string
     328.  00:7809  2E 68 64 64 49 6D 61 67 65 
     328.  00:7812                    > .skip:
     328.  00:7812                    >         endif
     329.  00:7812                                      MESSAGE "HOST GETDPB"
     329.  00:7812  CD C7 73          >         call sendMessage
     329.  00:7815                    >         db string
     329.  00:7815  48 4F 53 54 20 47 45 54 44 50 42 
     329.  00:7820  00                > .skip2: nop
     330.  00:7821  CD 87 73                    call sendRegisters
     331.  00:7824  36 82                       ld (hl),C_GETDPB
     332.  00:7826  CD 18 75                    call enableNowindPage0
     333.  00:7829  26 20                       ld h,HIGH usbrd
     334.  00:782B  CD 99 73                    call getHeader
     335.  00:782E  38 09                       jr c,.exit                      ; not ready
     336.  00:7830  5F                          ld e,a                          ; destination
     337.  00:7831  56                          ld d,(hl)
     338.  00:7832  01 12 00                    ld bc,18
     339.  00:7835                              DEBUGDUMPREGISTERS
     339.  00:7835                    >         ifdef DEBUG
     339.  00:7835  ED 07             >         db $ed,7
     339.  00:7837                    >         endif
     339.  00:7837                    >         
     339.  00:7837                    >         ifdef USBDEBUG
     339.  00:7837                    ~         assert ($ < $8000)
     339.  00:7837                    ~         call sendCpuInfo
     339.  00:7837                    ~         endif
     340.  00:7837  ED B0                       ldir
     341.  00:7839                              ;DB $ed, $0a       
     342.  00:7839  C3 23 75            .exit:  jp restorePage0        
     343.  00:783C                      
     344.  00:783C                      CHOICE:
     345.  00:783C                              ;DEBUGMESSAGE "CHOICE"
     346.  00:783C                              ifdef MSXDOS2
     347.  00:783C                    ~         ld hl,.noFormat
     348.  00:783C                    ~         else
     349.  00:783C  21 00 00                    ld hl,0                         ; no choice
     350.  00:783F                              endif
     351.  00:783F  C9                          ret
     352.  00:7840                      
     353.  00:7840                      .noFormat:
     354.  00:7840  00                          db 0
     355.  00:7841                      
     356.  00:7841                      DSKFMT:
     357.  00:7841  37                          scf
     358.  00:7842  3E 10                       ld a,16                         ; other error
     359.  00:7844  C9                          ret
     360.  00:7845                              
     361.  00:7845  (B845)                      PHASE $ + $4000
     362.  00:B845                              
     363.  00:B845                      readSectors01:
     364.  00:B845                              DEBUGMESSAGE "readSectors01"
     364.  00:B845                    >         ifdef DEBUG
     364.  00:B845  52                >         ld d,d
     364.  00:B846  18 0D             >         jr .skip
     364.  00:B848                    >         db string
     364.  00:B848  72 65 61 64 53 65 63 74 6F 72 73 30 31 
     364.  00:B855                    > .skip:
     364.  00:B855                    >         endif
     365.  00:B855  26 80                       ld h,HIGH usb2
     366.  00:B857  CD 99 B3                    call getHeader + $4000                                  
     367.  00:B85A  D8                          ret c                           ; carry means timeout, no carry: A == 0 means slow transfer, A == 1 means exit, A == 2 means fast transfer                                      
     368.  00:B85B  3D                          dec a
     369.  00:B85C  C8                          ret z
     370.  00:B85D  FA 67 B8                    jp m,.slowTransfer                              
     371.  00:B860  CD D9 B8                    call reverseTransfer + $4000
     372.  00:B863  70                          ld (hl),b
     373.  00:B864  71                          ld (hl),c
     374.  00:B865  18 DE                       jr readSectors01
     375.  00:B867                      
     376.  00:B867                      .slowTransfer:
     377.  00:B867  5E                          ld e,(hl)                       ; transfer address
     378.  00:B868  56                          ld d,(hl)
     379.  00:B869  4E                          ld c,(hl)                       ; transfer amount 
     380.  00:B86A  46                          ld b,(hl)
     381.  00:B86B  ED B0                       ldir        
     382.  00:B86D                              
     383.  00:B86D  56                          ld d,(hl)                       ; BUG in emulator (byte direct terugschrijven, geeft 'rukkert!')
     384.  00:B86E  7E                          ld a,(hl)
     385.  00:B86F  72                          ld (hl),d                       ; return end marker ($af, $0f)
     386.  00:B870  77                          ld (hl),a
     387.  00:B871  18 D2                       jr readSectors01
     388.  00:B873                      
     389.  00:B873                      writeLoop01:
     390.  00:B873  26 80                       ld h,HIGH usb2
     391.  00:B875  CD 99 B3                    call getHeader + $4000
     392.  00:B878  D8                          ret c                           ; exit (not ready)
     393.  00:B879  B7                          or a
     394.  00:B87A  F8                          ret m                           ; exit (no error)
     395.  00:B87B  20 18                       jr nz,.error
     396.  00:B87D                      
     397.  00:B87D                              DEBUGMESSAGE "send01"
     397.  00:B87D                    >         ifdef DEBUG
     397.  00:B87D  52                >         ld d,d
     397.  00:B87E  18 06             >         jr .skip
     397.  00:B880  73 65 6E 64 30 31 >         db string
     397.  00:B886                    > .skip:
     397.  00:B886                    >         endif
     398.  00:B886  5E                          ld e,(hl)                       ; address
     399.  00:B887  56                          ld d,(hl)
     400.  00:B888  4E                          ld c,(hl)                       ; number of bytes        
     401.  00:B889  46                          ld b,(hl)
     402.  00:B88A  7E                          ld a,(hl)                       ; block sequence number
     403.  00:B88B                      
     404.  00:B88B  EB                          ex de,hl
     405.  00:B88C  11 00 80                    ld de,usb2
     406.  00:B88F  12                          ld (de),a                       ; mark block begin
     407.  00:B890  ED B0                       ldir
     408.  00:B892  12                          ld (de),a                       ; mark block end
     409.  00:B893  18 DE                       jr writeLoop01
     410.  00:B895                      
     411.  00:B895  37                  .error: scf
     412.  00:B896  7E                          ld a,(hl)                       ; get error code
     413.  00:B897  C9                          ret
     414.  00:B898                      
     415.  00:B898  (7898)                      DEPHASE
     416.  00:7898                       
     417.  00:7898                      readSectors23:
     418.  00:7898                              DEBUGMESSAGE "readSectors23"
     418.  00:7898                    >         ifdef DEBUG
     418.  00:7898  52                >         ld d,d
     418.  00:7899  18 0D             >         jr .skip
     418.  00:789B                    >         db string
     418.  00:789B  72 65 61 64 53 65 63 74 6F 72 73 32 33 
     418.  00:78A8                    > .skip:
     418.  00:78A8                    >         endif
     419.  00:78A8  26 20                       ld h,HIGH usbrd
     420.  00:78AA  CD 99 73                    call getHeader
     421.  00:78AD  D8                          ret c
     422.  00:78AE  3D                          dec a
     423.  00:78AF  C8                          ret z                           ; no more data
     424.  00:78B0  FA BC 78                    jp m,.slowTransfer        
     425.  00:78B3  CD D9 78                    call reverseTransfer
     426.  00:78B6  26 40                       ld h,HIGH usbwr 
     427.  00:78B8  70                          ld (hl),b
     428.  00:78B9  71                          ld (hl),c
     429.  00:78BA  18 DC                       jr readSectors23
     430.  00:78BC                      
     431.  00:78BC                      .slowTransfer:
     432.  00:78BC                              DEBUGMESSAGE "slowtransfer"
     432.  00:78BC                    >         ifdef DEBUG
     432.  00:78BC  52                >         ld d,d
     432.  00:78BD  18 0C             >         jr .skip
     432.  00:78BF                    >         db string
     432.  00:78BF  73 6C 6F 77 74 72 61 6E 73 66 65 72 
     432.  00:78CB                    > .skip:
     432.  00:78CB                    >         endif
     433.  00:78CB  5E                          ld e,(hl)                       ; transfer address
     434.  00:78CC  56                          ld d,(hl)
     435.  00:78CD  4E                          ld c,(hl)                       ; transfer amount 
     436.  00:78CE  46                          ld b,(hl)
     437.  00:78CF  ED B0                       ldir
     438.  00:78D1  56                          ld d,(hl)
     439.  00:78D2  7E                          ld a,(hl)
     440.  00:78D3  26 40                       ld h,HIGH usbwr
     441.  00:78D5  72                          ld (hl),d                       ; return end marker ($af, $0f)
     442.  00:78D6  77                          ld (hl),a
     443.  00:78D7  18 BF                       jr readSectors23
     444.  00:78D9                                     
     445.  00:78D9                      reverseTransfer:
     446.  00:78D9  FD 21 00 00                 ld iy,0                         ; save stack pointer
     447.  00:78DD  FD 39                       add iy,sp
     448.  00:78DF  5E                          ld e,(hl)                       ; transfer address
     449.  00:78E0  56                          ld d,(hl)
     450.  00:78E1  EB                          ex de,hl
     451.  00:78E2  F9                          ld sp,hl
     452.  00:78E3  EB                          ex de,hl
     453.  00:78E4  46                          ld b,(hl)                       ; number of loops       
     454.  00:78E5                      .loop:
     455.  00:78E5                              repeat 32                       ; blocks of 64 bytes hardcoded (NowindHost.cpp)
     456.  00:78E5                    <         ld d,(hl)
     457.  00:78E5                    <         ld e,(hl)
     458.  00:78E5                    <         push de
     459.  00:78E5                    <         endrepeat
     459.  00:78E5  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     459.  00:78F5  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     459.  00:7905  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     459.  00:7915  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     459.  00:7925  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     459.  00:7935  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     460.  00:7945  10 9E                       djnz .loop
     461.  00:7947                              
     462.  00:7947  FD F9                       ld sp,iy                        ; restore stack pointer
     463.  00:7949  46                          ld b,(hl)                       ; return end marker
     464.  00:794A  4E                          ld c,(hl)
     465.  00:794B  C9                          ret
     466.  00:794C                            
     467.  00:794C                      OEMSTA:
     468.  00:794C  E5                          push hl
     469.  00:794D  21 5A 79                    ld hl,.statement
     470.  00:7950  CD 5B 73                    call findStatementName
     471.  00:7953  5E                          ld e,(hl)
     472.  00:7954  23                          inc hl
     473.  00:7955  56                          ld d,(hl)
     474.  00:7956  E1                          pop hl        
     475.  00:7957  D8                          ret c
     476.  00:7958  D5                          push de
     477.  00:7959  C9                          ret
     478.  00:795A                      
     479.  00:795A                      .statement:
     480.  00:795A  49 4D 41 47 45 00           db "IMAGE",0
     481.  00:7960  6D 79                       dw changeImage
     482.  00:7962                              db "VSTREAM",0
     482.  00:7962  56 53 54 52 45 41 4D 00 
     483.  00:796A  9A 79                       dw videoStream
     484.  00:796C  00                          db 0
     485.  00:796D                      
     486.  00:796D                      ; send arguments, command, filename, end with ":"
     487.  00:796D                      changeImage:
     488.  00:796D                              DEBUGMESSAGE "changeImage"
     488.  00:796D                    >         ifdef DEBUG
     488.  00:796D  52                >         ld d,d
     488.  00:796E  18 0B             >         jr .skip
     488.  00:7970                    >         db string
     488.  00:7970  63 68 61 6E 67 65 49 6D 61 67 65 
     488.  00:797B                    > .skip:
     488.  00:797B                    >         endif
     489.  00:797B  E5                          push hl
     490.  00:797C  CD 87 73                    call sendRegisters
     491.  00:797F  36 91                       ld (hl),C_CHANGEIMAGE
     492.  00:7981  E1                          pop hl
     493.  00:7982                              
     494.  00:7982                      call_exit:
     495.  00:7982                              DEBUGMESSAGE "call_exit"
     495.  00:7982                    >         ifdef DEBUG
     495.  00:7982  52                >         ld d,d
     495.  00:7983  18 09             >         jr .skip
     495.  00:7985                    >         db string
     495.  00:7985  63 61 6C 6C 5F 65 78 69 74 
     495.  00:798E                    > .skip:
     495.  00:798E                    >         endif
     496.  00:798E  7E                  .loop:  ld a,(hl)
     497.  00:798F  32 00 40                    ld (usbwr),a
     498.  00:7992  FE 3A                       cp ":"
     499.  00:7994  C8                          ret z
     500.  00:7995  B7                          or a
     501.  00:7996  C8                          ret z
     502.  00:7997  23                          inc hl
     503.  00:7998  18 F4                       jr .loop
     504.  00:799A                              
     505.  00:799A                      videoStream: 
     506.  00:799A  E5                          push hl
     507.  00:799B                              include "vram.asm"
       1:  00:799B                              
       2:  00:799B                      vramDump:
       3:  00:799B  F3                  	di
       4:  00:799C  CD 18 75                    call enableNowindPage0
       5:  00:799F                      
       6:  00:799F  3E 02                       ld a,2
       7:  00:79A1  D3 99                       out ($99),a
       8:  00:79A3  3E 8F                       ld a,$80+15             ; status register pointer at S#2
       9:  00:79A5  D3 99                       out ($99),a
      10:  00:79A7                      
      11:  00:79A7                      evenFrame:
      12:  00:79A7                              ; vram address 0x0000
      13:  00:79A7                              
      14:  00:79A7                              ;xor a
      15:  00:79A7                              ;out ($99),a
      16:  00:79A7                              ;ld a,$80+2
      17:  00:79A7                              ;out ($99),a
      18:  00:79A7                              
      19:  00:79A7  3E 03                       ld a,%00000011                 ; pattern generator table
      20:  00:79A9  D3 99                       out ($99),a
      21:  00:79AB  3E 84                       ld a,$80+4
      22:  00:79AD  D3 99                       out ($99),a
      23:  00:79AF                      
      24:  00:79AF  AF                          xor a                   ; color table high
      25:  00:79B0  D3 99                       out ($99),a
      26:  00:79B2  3E 8A                       ld a,$80+10
      27:  00:79B4  D3 99                       out ($99),a
      28:  00:79B6                              
      29:  00:79B6  3E 04                       ld a,%00000100          ; vram access at 0x10000
      30:  00:79B8  CD 4C 7B                    call setVramAccessPointer
      31:  00:79BB  CD E4 79                    call tranferframe
      32:  00:79BE  CD 5A 7B                    call waitForRetrace
      33:  00:79C1  CD FE 7A                    call changeColors
      34:  00:79C4                      
      35:  00:79C4                      oddFrame:
      36:  00:79C4                              ; vram address 0x10000
      37:  00:79C4                      
      38:  00:79C4                              ;ld a,%01000000
      39:  00:79C4                              ;out ($99),a
      40:  00:79C4                              ;ld a,$80+2
      41:  00:79C4                              ;out ($99),a
      42:  00:79C4                      
      43:  00:79C4  3E 23                       ld a,%00100011          ; pattern generator table
      44:  00:79C6  D3 99                       out ($99),a
      45:  00:79C8  3E 84                       ld a,$80+4
      46:  00:79CA  D3 99                       out ($99),a
      47:  00:79CC                      
      48:  00:79CC  3E 64                       ld a,00000100           ; color table high
      49:  00:79CE  D3 99                       out ($99),a
      50:  00:79D0  3E 8A                       ld a,$80+10
      51:  00:79D2  D3 99                       out ($99),a
      52:  00:79D4                      
      53:  00:79D4  AF                          xor a
      54:  00:79D5  CD 4C 7B                    call setVramAccessPointer
      55:  00:79D8  CD E4 79                    call tranferframe
      56:  00:79DB  CD 5A 7B                    call waitForRetrace
      57:  00:79DE  CD FE 7A                    call changeColors
      58:  00:79E1  C3 A7 79                    jp evenFrame
      59:  00:79E4                      
      60:  00:79E4                      tranferframe:
      61:  00:79E4  CD 87 73                    call sendRegisters
      62:  00:79E7  36 FF                       ld (hl),255
      63:  00:79E9                                      
      64:  00:79E9  21 00 20                    ld hl,usbrd
      65:  00:79EC  CD 99 73                    call getHeader
      66:  00:79EF                              
      67:  00:79EF  16 70                       ld d,112			; 224x64 is 1 screen 2 page of data ($3800)
      68:  00:79F1                      write_more:        
      69:  00:79F1  21 00 20            	ld hl,usbrd
      70:  00:79F4  01 98 00                    ld bc,$0098
      71:  00:79F7                              repeat 128
      72:  00:79F7                    <         outi
      73:  00:79F7                    <         endrepeat
      73:  00:79F7  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A07  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A17  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A27  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A37  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A47  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A57  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A67  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A77  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A87  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7A97  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AA7  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AB7  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AC7  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AD7  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  00:7AE7  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      74:  00:7AF7                      
      75:  00:7AF7  15                          dec d
      76:  00:7AF8  7A                          ld a,d
      77:  00:7AF9  B7                          or a
      78:  00:7AFA  C2 F1 79                    jp nz,write_more
      79:  00:7AFD  C9                          ret		
      80:  00:7AFE                      
      81:  00:7AFE                      changeColors:
      82:  00:7AFE  AF                          xor a			; set color register pointer to zero
      83:  00:7AFF  D3 99                       out ($99),a
      84:  00:7B01  3E 90                       ld a,$80+16
      85:  00:7B03  D3 99                       out ($99),a
      86:  00:7B05                              
      87:  00:7B05  21 00 20                    ld hl,usbrd
      88:  00:7B08  01 9A 00                    ld bc,$009A		; write to color register
      89:  00:7B0B                      
      90:  00:7B0B                              repeat 32
      91:  00:7B0B                    <         outi
      92:  00:7B0B                    <         endrepeat		
      92:  00:7B0B  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B1B  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B2B  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  00:7B3B  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      93:  00:7B4B  C9                          ret
      94:  00:7B4C                      
      95:  00:7B4C                      	
      96:  00:7B4C                      setVramAccessPointer:
      97:  00:7B4C  D3 99                       out ($99),a
      98:  00:7B4E  3E 8E                       ld a,$80+14
      99:  00:7B50  D3 99                       out ($99),a
     100:  00:7B52  AF                          xor a
     101:  00:7B53  D3 99                       out ($99),a
     102:  00:7B55  3E 40                       ld a,%01000000		; vram write
     103:  00:7B57  D3 99                       out ($99),a
     104:  00:7B59  C9                          ret
     105:  00:7B5A                      
     106:  00:7B5A                      waitForRetrace:
     107:  00:7B5A  DB 99                       in a,($99)
     108:  00:7B5C  CB 77                       bit 6,a
     109:  00:7B5E  20 FA                       jr nz,waitForRetrace       
     110:  00:7B60                      .lp2:        
     111:  00:7B60  DB 99                       in a,($99)
     112:  00:7B62  CB 77                       bit 6,a
     113:  00:7B64  28 FA                       jr z,.lp2       
     114:  00:7B66  C9                          ret
     115:  00:7B67                              	
     116:  00:7B67                      	; just let it go... 
     508.  00:7B67  E1                          pop hl
     509.  00:7B68  C3 82 79                    jp call_exit
     510.  00:7B6B                              
     511.  00:7B6B                      ; hl points to text
     512.  00:7B6B                      printVdpText2:
     513.  00:7B6B  F5                                                  push af
     514.  00:7B6C  7E                  .loop:  ld a,(hl)
     515.  00:7B6D  D3 98                                               out ($98),a 
     516.  00:7B6F  23                                                  inc hl
     517.  00:7B70  B7                                                  or a
     518.  00:7B71  20 F9                                               jr nz,.loop
     519.  00:7B73  F1                                                  pop af
     520.  00:7B74  C9                                                  ret
     521.  00:7B75                              
     522.  00:7B75                      supportedMedia:
     523.  00:7B75                                      
     524.  00:7B75                      .f8:    MAKEDPB $f8, 512, 2, 112, 1 * 80 * 9, 2, 2      ; 360 kB (1 side * 80 tracks * 9 tracks/sector)
     524.  00:7B75  (00:0001)         > .firfat equ 1
     524.  00:7B75  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     524.  00:7B75  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     524.  00:7B75                    >         if sectorSize = 512
     524.  00:7B75  (00:0004)         > .shft   equ 4
     524.  00:7B75                    >         elseif sectorSize = 256
     524.  00:7B75                    ~ .shft   equ 3
     524.  00:7B75                    ~         endif
     524.  00:7B75                    >         
     524.  00:7B75  F8                >         db media
     524.  00:7B76  00 02             >         dw sectorSize
     524.  00:7B78  0F 04             >         db (sectorSize/32)-1, .shft
     524.  00:7B7A  01                >         db sectorsPerCluster-1
     524.  00:7B7B  02                >         db sectorsPerCluster
     524.  00:7B7C  01 00             >         dw .firfat
     524.  00:7B7E  02 70             >         db fatCount, maxEnt
     524.  00:7B80  0C 00             >         dw .firrec
     524.  00:7B82  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     524.  00:7B84  02                >         db fatSiz
     524.  00:7B85  05 00             >         dw .firdir
     525.  00:7B87                      .def:   MAKEDPB $f9, 512, 2, 112, 2 * 80 * 9, 3, 2      ; 720 kB
     525.  00:7B87  (00:0001)         > .firfat equ 1
     525.  00:7B87  (00:0007)         > .firdir equ .firfat+(fatCount*fatSiz)
     525.  00:7B87  (00:000E)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     525.  00:7B87                    >         if sectorSize = 512
     525.  00:7B87  (00:0004)         > .shft   equ 4
     525.  00:7B87                    >         elseif sectorSize = 256
     525.  00:7B87                    ~ .shft   equ 3
     525.  00:7B87                    ~         endif
     525.  00:7B87                    >         
     525.  00:7B87  F9                >         db media
     525.  00:7B88  00 02             >         dw sectorSize
     525.  00:7B8A  0F 04             >         db (sectorSize/32)-1, .shft
     525.  00:7B8C  01                >         db sectorsPerCluster-1
     525.  00:7B8D  02                >         db sectorsPerCluster
     525.  00:7B8E  01 00             >         dw .firfat
     525.  00:7B90  02 70             >         db fatCount, maxEnt
     525.  00:7B92  0E 00             >         dw .firrec
     525.  00:7B94  CA 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     525.  00:7B96  03                >         db fatSiz
     525.  00:7B97  07 00             >         dw .firdir
     526.  00:7B99                              MAKEDPB $fa, 512, 2, 112, 1 * 80 * 8, 1, 2      ; 320 kB
     526.  00:7B99  (00:0001)         > .firfat equ 1
     526.  00:7B99  (00:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     526.  00:7B99  (00:000A)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     526.  00:7B99                    >         if sectorSize = 512
     526.  00:7B99  (00:0004)         > .shft   equ 4
     526.  00:7B99                    >         elseif sectorSize = 256
     526.  00:7B99                    ~ .shft   equ 3
     526.  00:7B99                    ~         endif
     526.  00:7B99                    >         
     526.  00:7B99  FA                >         db media
     526.  00:7B9A  00 02             >         dw sectorSize
     526.  00:7B9C  0F 04             >         db (sectorSize/32)-1, .shft
     526.  00:7B9E  01                >         db sectorsPerCluster-1
     526.  00:7B9F  02                >         db sectorsPerCluster
     526.  00:7BA0  01 00             >         dw .firfat
     526.  00:7BA2  02 70             >         db fatCount, maxEnt
     526.  00:7BA4  0A 00             >         dw .firrec
     526.  00:7BA6  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     526.  00:7BA8  01                >         db fatSiz
     526.  00:7BA9  03 00             >         dw .firdir
     527.  00:7BAB                              MAKEDPB $fb, 512, 2, 112, 2 * 80 * 8, 2, 2      ; 640 kB
     527.  00:7BAB  (00:0001)         > .firfat equ 1
     527.  00:7BAB  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     527.  00:7BAB  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     527.  00:7BAB                    >         if sectorSize = 512
     527.  00:7BAB  (00:0004)         > .shft   equ 4
     527.  00:7BAB                    >         elseif sectorSize = 256
     527.  00:7BAB                    ~ .shft   equ 3
     527.  00:7BAB                    ~         endif
     527.  00:7BAB                    >         
     527.  00:7BAB  FB                >         db media
     527.  00:7BAC  00 02             >         dw sectorSize
     527.  00:7BAE  0F 04             >         db (sectorSize/32)-1, .shft
     527.  00:7BB0  01                >         db sectorsPerCluster-1
     527.  00:7BB1  02                >         db sectorsPerCluster
     527.  00:7BB2  01 00             >         dw .firfat
     527.  00:7BB4  02 70             >         db fatCount, maxEnt
     527.  00:7BB6  0C 00             >         dw .firrec
     527.  00:7BB8  7B 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     527.  00:7BBA  02                >         db fatSiz
     527.  00:7BBB  05 00             >         dw .firdir
     528.  00:7BBD                              MAKEDPB $fc, 512, 1, 64,  1 * 40 * 9, 2, 2      ; 180 kB
     528.  00:7BBD  (00:0001)         > .firfat equ 1
     528.  00:7BBD  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     528.  00:7BBD  (00:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     528.  00:7BBD                    >         if sectorSize = 512
     528.  00:7BBD  (00:0004)         > .shft   equ 4
     528.  00:7BBD                    >         elseif sectorSize = 256
     528.  00:7BBD                    ~ .shft   equ 3
     528.  00:7BBD                    ~         endif
     528.  00:7BBD                    >         
     528.  00:7BBD  FC                >         db media
     528.  00:7BBE  00 02             >         dw sectorSize
     528.  00:7BC0  0F 04             >         db (sectorSize/32)-1, .shft
     528.  00:7BC2  00                >         db sectorsPerCluster-1
     528.  00:7BC3  01                >         db sectorsPerCluster
     528.  00:7BC4  01 00             >         dw .firfat
     528.  00:7BC6  02 40             >         db fatCount, maxEnt
     528.  00:7BC8  09 00             >         dw .firrec
     528.  00:7BCA  60 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     528.  00:7BCC  02                >         db fatSiz
     528.  00:7BCD  05 00             >         dw .firdir
     529.  00:7BCF                              MAKEDPB $fd, 512, 2, 112, 2 * 40 * 9, 2, 2      ; 360 kB
     529.  00:7BCF  (00:0001)         > .firfat equ 1
     529.  00:7BCF  (00:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     529.  00:7BCF  (00:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     529.  00:7BCF                    >         if sectorSize = 512
     529.  00:7BCF  (00:0004)         > .shft   equ 4
     529.  00:7BCF                    >         elseif sectorSize = 256
     529.  00:7BCF                    ~ .shft   equ 3
     529.  00:7BCF                    ~         endif
     529.  00:7BCF                    >         
     529.  00:7BCF  FD                >         db media
     529.  00:7BD0  00 02             >         dw sectorSize
     529.  00:7BD2  0F 04             >         db (sectorSize/32)-1, .shft
     529.  00:7BD4  01                >         db sectorsPerCluster-1
     529.  00:7BD5  02                >         db sectorsPerCluster
     529.  00:7BD6  01 00             >         dw .firfat
     529.  00:7BD8  02 70             >         db fatCount, maxEnt
     529.  00:7BDA  0C 00             >         dw .firrec
     529.  00:7BDC  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     529.  00:7BDE  02                >         db fatSiz
     529.  00:7BDF  05 00             >         dw .firdir
     530.  00:7BE1                              MAKEDPB $fe, 512, 1, 64,  1 * 40 * 8, 1, 2      ; 160 kB
     530.  00:7BE1  (00:0001)         > .firfat equ 1
     530.  00:7BE1  (00:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     530.  00:7BE1  (00:0007)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     530.  00:7BE1                    >         if sectorSize = 512
     530.  00:7BE1  (00:0004)         > .shft   equ 4
     530.  00:7BE1                    >         elseif sectorSize = 256
     530.  00:7BE1                    ~ .shft   equ 3
     530.  00:7BE1                    ~         endif
     530.  00:7BE1                    >         
     530.  00:7BE1  FE                >         db media
     530.  00:7BE2  00 02             >         dw sectorSize
     530.  00:7BE4  0F 04             >         db (sectorSize/32)-1, .shft
     530.  00:7BE6  00                >         db sectorsPerCluster-1
     530.  00:7BE7  01                >         db sectorsPerCluster
     530.  00:7BE8  01 00             >         dw .firfat
     530.  00:7BEA  02 40             >         db fatCount, maxEnt
     530.  00:7BEC  07 00             >         dw .firrec
     530.  00:7BEE  3A 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     530.  00:7BF0  01                >         db fatSiz
     530.  00:7BF1  03 00             >         dw .firdir
     531.  00:7BF3                              MAKEDPB $ff, 512, 2, 112, 2 * 40 * 8, 1, 1      ; 320 kB
     531.  00:7BF3  (00:0001)         > .firfat equ 1
     531.  00:7BF3  (00:0002)         > .firdir equ .firfat+(fatCount*fatSiz)
     531.  00:7BF3  (00:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     531.  00:7BF3                    >         if sectorSize = 512
     531.  00:7BF3  (00:0004)         > .shft   equ 4
     531.  00:7BF3                    >         elseif sectorSize = 256
     531.  00:7BF3                    ~ .shft   equ 3
     531.  00:7BF3                    ~         endif
     531.  00:7BF3                    >         
     531.  00:7BF3  FF                >         db media
     531.  00:7BF4  00 02             >         dw sectorSize
     531.  00:7BF6  0F 04             >         db (sectorSize/32)-1, .shft
     531.  00:7BF8  01                >         db sectorsPerCluster-1
     531.  00:7BF9  02                >         db sectorsPerCluster
     531.  00:7BFA  01 00             >         dw .firfat
     531.  00:7BFC  01 70             >         db fatCount, maxEnt
     531.  00:7BFE  09 00             >         dw .firrec
     531.  00:7C00  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     531.  00:7C02  01                >         db fatSiz
     531.  00:7C03  02 00             >         dw .firdir
     532.  00:7C05                      
     533.  00:7C05                      ; WARNING: in some cases DEFDPB-1 is expected!
     534.  00:7C05  (00:7B87)           DEFDPB  equ supportedMedia.def
      94   00:7C05                              include "romdisk.asm"
       1.  00:7C05                      		define	ROMDSKBANK 5			; romdisk starts in bank 5
       2.  00:7C05                      		define	ROMDSKLAST (FLASHROMSIZE/16)-1
       3.  00:7C05                      
       4.  00:7C05                      
       5.  00:7C05                      ROMDISK_DSKIO:
       6.  00:7C05                              DEBUGMESSAGE "R_DSKIO"
       6.  00:7C05                    >         ifdef DEBUG
       6.  00:7C05  52                >         ld d,d
       6.  00:7C06  18 07             >         jr .skip
       6.  00:7C08                    >         db string
       6.  00:7C08  52 5F 44 53 4B 49 4F 
       6.  00:7C0F                    > .skip:
       6.  00:7C0F                    >         endif
       7.  00:7C0F  F1                          pop af
       8.  00:7C10  3E 00                       ld a,0
       9.  00:7C12  D8                          ret c                           ; write protected
      10.  00:7C13                              
      11.  00:7C13  EB                          ex de,hl
      12.  00:7C14  C5                  .loop:  push bc
      13.  00:7C15  E5                          push hl        
      14.  00:7C16                              
      15.  00:7C16  CB 7A                       bit 7,d
      16.  00:7C18  20 1C                       jr nz,.directCopy
      17.  00:7C1A  7A                          ld a,d
      18.  00:7C1B  FE 3E                       cp $3e        
      19.  00:7C1D  38 17                       jr c,.directCopy
      20.  00:7C1F                      
      21.  00:7C1F  CD 42 7C                    call .findSector
      22.  00:7C22  D5                          push de
      23.  00:7C23  ED 5B 4D F3                 ld de,($f34d)        
      24.  00:7C27  CD F4 7F                    call copyFromBank
      25.  00:7C2A  D1                          pop de
      26.  00:7C2B  01 00 02                    ld bc,512
      27.  00:7C2E  2A 4D F3                    ld hl,($f34d)
      28.  00:7C31  CD 6E F3                    call XFER
      29.  00:7C34  18 06                       jr .nextSector           
      30.  00:7C36                                    
      31.  00:7C36                      .directCopy:                
      32.  00:7C36  CD 42 7C                    call .findSector  
      33.  00:7C39  CD F4 7F                    call copyFromBank
      34.  00:7C3C                      .nextSector:
      35.  00:7C3C  E1                          pop hl
      36.  00:7C3D  23                          inc hl
      37.  00:7C3E  C1                          pop bc
      38.  00:7C3F  10 D3                       djnz .loop
      39.  00:7C41  C9                          ret
      40.  00:7C42                      
      41.  00:7C42                      .findSector:        
      42.  00:7C42  7D                          ld a,l                          ; determine bank
      43.  00:7C43  E6 E0                       and %11100000
      44.  00:7C45  B4                          or h
      45.  00:7C46  07                          rlca
      46.  00:7C47  07                          rlca
      47.  00:7C48  07                          rlca
      48.  00:7C49  47                          ld b,a
      49.  00:7C4A                      
      50.  00:7C4A  7D                          ld a,l
      51.  00:7C4B  E6 1F                       and 31
      52.  00:7C4D  4F                          ld c,a
      53.  00:7C4E  3E FF                       ld a,ROMDSKLAST                 ; banks with b0..5=0 reside in the last bank
      54.  00:7C50  28 05                       jr z,.skip
      55.  00:7C52                      
      56.  00:7C52  78                          ld a,b
      57.  00:7C53  C6 05                       add ROMDSKBANK
      58.  00:7C55  41                          ld b,c
      59.  00:7C56  05                          dec b
      60.  00:7C57  4F                  .skip:  ld c,a
      61.  00:7C58  78                          ld a,b
      62.  00:7C59  07                          rlca
      63.  00:7C5A  C6 41                       add $41                         ; disk images starts at $4100
      64.  00:7C5C  67                          ld h,a
      65.  00:7C5D  2E 00                       ld l,0
      66.  00:7C5F  79                          ld a,c
      67.  00:7C60  01 00 02                    ld bc,512
      68.  00:7C63  C9                          ret
      69.  00:7C64                                                               
      70.  00:7C64                      ROMDISK_DSKCHG:
      71.  00:7C64                              ;DEBUGMESSAGE "ROM_DSKCHG"
      72.  00:7C64  F1                          pop af
      73.  00:7C65  A7                          and a
      74.  00:7C66  06 01                       ld b,1                          ; not changed
      75.  00:7C68  C9                          ret
      76.  00:7C69                      
      77.  00:7C69                      ROMDISK_GETDPB:
      78.  00:7C69                              ; not implemented (standard mediadescriptor as used)
      79.  00:7C69                              
      80.  00:7C69                      ROMDISK_DSKFMT:
      81.  00:7C69                              ; not implemented (no disk can be formatted)
      82.  00:7C69                              
      95   00:7C69                              include "flashWriter.asm"		; todo: remove load from pc
       1.  00:7C69                      ; flashWriter.asm
       2.  00:7C69                      ; Flashes and erases the AMD29F040/M29F032-D
       3.  00:7C69                           
       4.  00:7C69                      flashWriter:
       5.  00:7C69                              ;DEBUGMESSAGE "flashWriter"
       6.  00:7C69  3E 03                       ld a,3
       7.  00:7C6B  CD 41 01                    call SNSMAT
       8.  00:7C6E  E6 08                       and 8
       9.  00:7C70  C0                          ret nz
      10.  00:7C71                              
      11.  00:7C71  CD 8E 72                    call PRINTTEXT
      12.  00:7C74                              db 10,13," FlashROM",10,13," "
      12.  00:7C74  0A 0D 20 46 6C 61 73 68 52 4F 4D 0A 0D 20 
      13.  00:7C82  2E (33)                     ds 33,"."
      14.  00:7CA3  0D 20 00                    db 13," ",0
      15.  00:7CA6                              
      16.  00:7CA6  CD 73 75                    call getSlotPage1
      17.  00:7CA9  CD 2C 75                    call enableSlotPage0
      18.  00:7CAC                      
      19.  00:7CAC  21 B9 7C                    ld hl,.source
      20.  00:7CAF  11 00 C0                    ld de,$c000
      21.  00:7CB2  D5                          push de
      22.  00:7CB3  01 DB 00                    ld bc,flasherEnd - $c000
      23.  00:7CB6  ED B0                       ldir
      24.  00:7CB8  C9                          ret
      25.  00:7CB9                              
      26.  00:7CB9                      .source:     
      27.  00:7CB9  (C000)                      PHASE $c000  
      28.  00:C000                              
      29.  00:C000                      waitForHeader:
      30.  00:C000  26 20                       ld h,HIGH usbrd
      31.  00:C002  7E                          ld a,(hl)
      32.  00:C003  FE BB               .chkbb: cp $bb
      33.  00:C005  20 F9                       jr nz,waitForHeader
      34.  00:C007  7E                          ld a,(hl)
      35.  00:C008  FE 55                       cp $55
      36.  00:C00A  20 F7                       jr nz,.chkbb       
      37.  00:C00C                      
      38.  00:C00C  7E                          ld a,(hl)
      39.  00:C00D  FE A2                       cp $a2
      40.  00:C00F  CA A9 C0                    jp z,verifyFlash
      41.  00:C012  FE A3                       cp $a3
      42.  00:C014  28 6E                       jr z,writeFlash
      43.  00:C016  FE A4                       cp $a4
      44.  00:C018  28 52                       jr z,chipErase
      45.  00:C01A  FE A5                       cp $a5
      46.  00:C01C  28 1C                       jr z,eraseSector
      47.  00:C01E  FE A6                       cp $a6
      48.  00:C020  28 02                       jr z,autoselectMode
      49.  00:C022                      
      50.  00:C022  20 DC                       jr nz,waitForHeader
      51.  00:C024                          
      52.  00:C024                      autoselectMode:
      53.  00:C024  3E 90                       ld a,$90
      54.  00:C026  CD CC C0                    call writeCommandSequence
      55.  00:C029                      
      56.  00:C029  2A 00 40                    ld hl,($4000)
      57.  00:C02C  EB                          ex de,hl
      58.  00:C02D  26 40                       ld h,HIGH usbwr
      59.  00:C02F  36 AA                       ld (hl),$aa
      60.  00:C031  36 55                       ld (hl),$55
      61.  00:C033  73                          ld (hl),e                       ; manufacturer ID (0x01 = AMD)
      62.  00:C034  72                          ld (hl),d                       ; device ID (0xA4 = AM29F040, 0x41 = AM29F032B)
      63.  00:C035                      
      64.  00:C035  CD 66 C0                    call writeResetCommand
      65.  00:C038  18 C6                       jr waitForHeader
      66.  00:C03A                      
      67.  00:C03A                      eraseSector:
      68.  00:C03A                              ;DEBUGMESSAGE "sector erase"
      69.  00:C03A  3E 65               	ld a,"e"
      70.  00:C03C  D3 98               	out ($98),a
      71.  00:C03E                      
      72.  00:C03E  7E                          ld a,(hl)                       ; get sector number 0..63
      73.  00:C03F  CB 27                       sla a
      74.  00:C041  CB 27                       sla a
      75.  00:C043  32 01 60                    ld (mapper),a                   ; select sector
      76.  00:C046                      
      77.  00:C046  3E 80                       ld a,$80
      78.  00:C048  CD CC C0                    call writeCommandSequence
      79.  00:C04B  3E 30                       ld a,$30        
      80.  00:C04D  CD CC C0                    call writeCommandSequence
      81.  00:C050                      
      82.  00:C050  CD 56 C0                    call waitForCommandToComplete
      83.  00:C053  C3 BD C0                    jp acknowledge
      84.  00:C056                              
      85.  00:C056                      waitForCommandToComplete:
      86.  00:C056  7E                          ld a,(hl)
      87.  00:C057  46                          ld b,(hl)
      88.  00:C058  A8                          xor b
      89.  00:C059  E6 40                       and %01000000                   ; check toggle bit I (DQ6)
      90.  00:C05B  C8                          ret z                           ; operation complete
      91.  00:C05C                              
      92.  00:C05C  78                          ld a,b
      93.  00:C05D  E6 20                       and %00100000                   ; timing limits exceeded? (DQ5)
      94.  00:C05F  28 F5                       jr z,waitForCommandToComplete
      95.  00:C061                      
      96.  00:C061  CD 66 C0                    call writeResetCommand
      97.  00:C064  78                          ld a,b
      98.  00:C065  C9                          ret
      99.  00:C066                      
     100.  00:C066                      writeResetCommand:
     101.  00:C066  3E F0                       ld a,$f0                        ; write RESET command
     102.  00:C068  32 00 00                    ld (0),a
     103.  00:C06B  C9                          ret
     104.  00:C06C                      
     105.  00:C06C                      chipErase:
     106.  00:C06C                              ;DEBUGMESSAGE "chip erase"
     107.  00:C06C  3E 45               	ld a,"E"
     108.  00:C06E  D3 98               	out ($98),a
     109.  00:C070                      
     110.  00:C070  3E 80                       ld a,$80
     111.  00:C072  CD CC C0                    call writeCommandSequence
     112.  00:C075  3E 10                       ld a,$10
     113.  00:C077  CD CC C0                    call writeCommandSequence
     114.  00:C07A                      
     115.  00:C07A  3A 00 40            .wait:  ld a,($4000)                    ; read DQ7 (data# polling) 
     116.  00:C07D  07                          rlca
     117.  00:C07E  30 FA                       jr nc,.wait        
     118.  00:C080  3E 01                       ld a,1
     119.  00:C082  18 39                       jr acknowledge
     120.  00:C084                      
     121.  00:C084                      
     122.  00:C084                      writeFlash:
     123.  00:C084                              ;DEBUGMESSAGE "write"
     124.  00:C084  5E                          ld e,(hl)                       ; address
     125.  00:C085  56                          ld d,(hl)
     126.  00:C086                      
     127.  00:C086  7A                          ld a,d
     128.  00:C087  B3                          or e
     129.  00:C088  CC C7 C0                    call z,updateBar
     130.  00:C08B                      
     131.  00:C08B  7E                          ld a,(hl)                       ; bank
     132.  00:C08C  32 01 60                    ld (mapper),a
     133.  00:C08F  26 40                       ld h,$40
     134.  00:C091                              
     135.  00:C091  06 80                       ld b,128                        ; data is written in blocks of 128 bytes
     136.  00:C093  3E A0               .loop:  ld a,$a0
     137.  00:C095  CD CC C0                    call writeCommandSequence
     138.  00:C098  3A 00 20                    ld a,(usbrd)
     139.  00:C09B  12                          ld (de),a                       ; write data to flash
     140.  00:C09C  13                          inc de
     141.  00:C09D                      
     142.  00:C09D  7E                  .wait:  ld  a,(hl)                      ; write complete?
     143.  00:C09E  AE                          xor (hl)
     144.  00:C09F  E6 40                       and %01000000
     145.  00:C0A1  20 FA                       jr  nz,.wait
     146.  00:C0A3  10 EE                       djnz .loop
     147.  00:C0A5                              
     148.  00:C0A5  3E 02                       ld a,2
     149.  00:C0A7  18 14                       jr acknowledge        
     150.  00:C0A9                              
     151.  00:C0A9                      verifyFlash:
     152.  00:C0A9                              ;DEBUGMESSAGE "verify"
     153.  00:C0A9  21 00 20                    ld hl,usbrd
     154.  00:C0AC  5E                          ld e,(hl)                       ; address
     155.  00:C0AD  56                          ld d,(hl)
     156.  00:C0AE  7E                          ld a,(hl)                       ; bank
     157.  00:C0AF  32 01 60                    ld (mapper),a
     158.  00:C0B2                      
     159.  00:C0B2  06 80                       ld b,128
     160.  00:C0B4  1A                  .loop:  ld a,(de)
     161.  00:C0B5  32 00 40                    ld (usbwr),a
     162.  00:C0B8  13                          inc de
     163.  00:C0B9  10 F9                       djnz .loop
     164.  00:C0BB                      
     165.  00:C0BB  3E 03                       ld a,3
     166.  00:C0BD                      acknowledge:        
     167.  00:C0BD  26 40                       ld h,HIGH usbwr
     168.  00:C0BF  36 AA                       ld (hl),$aa
     169.  00:C0C1  36 55                       ld (hl),$55
     170.  00:C0C3  77                          ld (hl),a
     171.  00:C0C4  C3 00 C0                    jp waitForHeader
     172.  00:C0C7                      
     173.  00:C0C7                      updateBar:
     174.  00:C0C7  3E 77                       ld a,"w"  
     175.  00:C0C9  D3 98                       out ($98),a
     176.  00:C0CB  C9                          ret
     177.  00:C0CC                      
     178.  00:C0CC                      writeCommandSequence:
     179.  00:C0CC  F5                          push af
     180.  00:C0CD  3E AA                       ld a,$aa
     181.  00:C0CF  32 55 05                    ld ($0555),a
     182.  00:C0D2  2F                          cpl
     183.  00:C0D3  32 AA 02                    ld ($02aa),a
     184.  00:C0D6  F1                          pop af
     185.  00:C0D7  32 55 05                    ld ($0555),a
     186.  00:C0DA  C9                          ret
     187.  00:C0DB                              
     188.  00:C0DB                      flasherEnd:
     189.  00:C0DB  (7D94)                      DEPHASE
      96   00:7D94                              include "device.asm"
       1.  00:7D94                      ; device.asm
       2.  00:7D94                      ; implements a basic now: device
       3.  00:7D94                          
       4.  00:7D94                      device:
       5.  00:7D94  E5                          push hl
       6.  00:7D95  21 A6 7D                    ld hl,deviceFunctions
       7.  00:7D98  0F                          rrca
       8.  00:7D99  3C                          inc a
       9.  00:7D9A  07                          rlca
      10.  00:7D9B  85                          add a,l
      11.  00:7D9C  6F                          ld l,a
      12.  00:7D9D  30 01                       jr nc,.nocy
      13.  00:7D9F  24                          inc h  
      14.  00:7DA0  7E                  .nocy:  ld a,(hl)
      15.  00:7DA1  23                          inc hl
      16.  00:7DA2  66                          ld h,(hl)
      17.  00:7DA3  6F                          ld l,a
      18.  00:7DA4  E3                          ex (sp),hl
      19.  00:7DA5  C9                          ret
      20.  00:7DA6                      
      21.  00:7DA6                      deviceFunctions:
      22.  00:7DA6  BC 7D                       dw identifyDevice               ; 0xff
      23.  00:7DA8  DC 7D                       dw open                         ;  0
      24.  00:7DAA  14 7E                       dw close                        ;  2
      25.  00:7DAC  1A 7E                       dw randomIO                     ;  4
      26.  00:7DAE  1E 7E                       dw write                        ;  6
      27.  00:7DB0  24 7E                       dw read                         ;  8
      28.  00:7DB2  7A 7E                       dw loc                          ; 10
      29.  00:7DB4  8C 7E                       dw lof                          ; 12
      30.  00:7DB6  58 7E                       dw eof                          ; 14
      31.  00:7DB8  8C 7E                       dw fpos                         ; 16
      32.  00:7DBA  8C 7E                       dw putback                      ; 18
      33.  00:7DBC                                
      34.  00:7DBC                      identifyDevice:
      35.  00:7DBC                              DEBUGMESSAGE "identifyDevice"
      35.  00:7DBC                    >         ifdef DEBUG
      35.  00:7DBC  52                >         ld d,d
      35.  00:7DBD  18 0E             >         jr .skip
      35.  00:7DBF                    >         db string
      35.  00:7DBF  69 64 65 6E 74 69 66 79 44 65 76 69 63 65 
      35.  00:7DCD                    > .skip:
      35.  00:7DCD                    >         endif
      36.  00:7DCD  21 D5 7D                    ld hl,deviceNameList
      37.  00:7DD0  CD 5B 73                    call findStatementName
      38.  00:7DD3  7E                          ld a,(hl)                       ; device number
      39.  00:7DD4  C9                          ret                             ; carry is set when invalid device name
      40.  00:7DD5                              
      41.  00:7DD5                      deviceNameList:
      42.  00:7DD5  4E 4F 57 00 00 00           db "NOW",0,0,0                  ; name, end marker, device number, dummy
      43.  00:7DDB                              ;db "STDIN",0,1,0
      44.  00:7DDB  00                          db 0
      45.  00:7DDC                      
      46.  00:7DDC                      ; Input     D   Global device code
      47.  00:7DDC                      ;           E   File mode    
      48.  00:7DDC                      ;           HL  address fcb
      49.  00:7DDC                      open:
      50.  00:7DDC                      ;        DEBUGMESSAGE "open"
      51.  00:7DDC                      ;        DEBUGDUMPMEMHL 9
      52.  00:7DDC  22 64 F8                    ld (PTRFIL),hl
      53.  00:7DDF  CD 87 73                    call sendRegisters
      54.  00:7DE2  36 88                       ld (hl),C_DEVICEOPEN
      55.  00:7DE4  EB                          ex de,hl
      56.  00:7DE5  01 0B 00                    ld bc,11
      57.  00:7DE8  21 66 F8                    ld hl,FILNAM
      58.  00:7DEB  ED B0                       ldir
      59.  00:7DED                      
      60.  00:7DED  CD 18 75                    call enableNowindPage0
      61.  00:7DF0  26 20                       ld h,HIGH usbrd
      62.  00:7DF2  CD 99 73                    call getHeader
      63.  00:7DF5  38 0C                       jr c,deviceIoError              ; time out?
      64.  00:7DF7  B7                          or a
      65.  00:7DF8  20 0B                       jr nz,openError
      66.  00:7DFA                      
      67.  00:7DFA  5E                          ld e,(hl)                       ; update fcb (including buffer)
      68.  00:7DFB  56                          ld d,(hl)
      69.  00:7DFC  4E                          ld c,(hl)
      70.  00:7DFD  46                          ld b,(hl)
      71.  00:7DFE  ED B0                       ldir
      72.  00:7E00  C3 23 75                    jp restorePage0        
      73.  00:7E03                      
      74.  00:7E03                      deviceIoError:
      75.  00:7E03  3E 13                       ld a,19
      76.  00:7E05                      
      77.  00:7E05                      openError:
      78.  00:7E05  CD 23 75                    call restorePage0
      79.  00:7E08  5F                          ld e,a
      80.  00:7E09                      
      81.  00:7E09                      basicError:
      82.  00:7E09  DD 21 6F 40                 ld ix,$406f
      83.  00:7E0D  FD 2A C0 FC                 ld iy,(EXPTBL-1)
      84.  00:7E11  C3 1C 00                    jp CALSLT
      85.  00:7E14                                      
      86.  00:7E14                      close:
      87.  00:7E14                      ;        DEBUGMESSAGE "close"
      88.  00:7E14  CD 87 73                    call sendRegisters
      89.  00:7E17  36 89                       ld (hl),C_DEVICECLOSE
      90.  00:7E19  C9                          ret
      91.  00:7E1A                              
      92.  00:7E1A                      randomIO:
      93.  00:7E1A                      ;        DEBUGMESSAGE "randomIO"
      94.  00:7E1A  1E 3D                       ld e,61                         ; bad file mode
      95.  00:7E1C  18 EB                       jr basicError
      96.  00:7E1E                      
      97.  00:7E1E                      write:
      98.  00:7E1E                      ;        DEBUGMESSAGE "write"
      99.  00:7E1E  CD 87 73                    call sendRegisters
     100.  00:7E21  36 8B                       ld (hl),C_DEVICEWRITE
     101.  00:7E23  C9                          ret        
     102.  00:7E24                      
     103.  00:7E24                      read:
     104.  00:7E24                      ;        DEBUGMESSAGE "read"
     105.  00:7E24  11 06 00                    ld de,6
     106.  00:7E27  19                          add hl,de
     107.  00:7E28  E5                          push hl
     108.  00:7E29  5E                          ld e,(hl)
     109.  00:7E2A  23                          inc hl
     110.  00:7E2B  23                          inc hl
     111.  00:7E2C  23                          inc hl
     112.  00:7E2D  19                          add hl,de
     113.  00:7E2E  7E                          ld a,(hl)
     114.  00:7E2F  E1                          pop hl
     115.  00:7E30  FE 1A                       cp $1a
     116.  00:7E32  37                          scf
     117.  00:7E33  C8                          ret z                           ; end of file
     118.  00:7E34  3F                          ccf
     119.  00:7E35  34                          inc (hl)                        ; increment position
     120.  00:7E36  C0                          ret nz                          ; buffer empty?
     121.  00:7E37                              
     122.  00:7E37  F5                          push af
     123.  00:7E38  2B                          dec hl
     124.  00:7E39  34                          inc (hl)                        ; increment position (high)        
     125.  00:7E3A  11 FB FF                    ld de,-5
     126.  00:7E3D  19                          add hl,de
     127.  00:7E3E  CD 87 73                    call sendRegisters
     128.  00:7E41  36 8C                       ld (hl),C_DEVICEREAD
     129.  00:7E43  CD 18 75                    call enableNowindPage0
     130.  00:7E46  26 20                       ld h,HIGH usbrd
     131.  00:7E48  CD 99 73                    call getHeader
     132.  00:7E4B  38 B6                       jr c,deviceIoError
     133.  00:7E4D                      
     134.  00:7E4D  5E                          ld e,(hl)
     135.  00:7E4E  56                          ld d,(hl)
     136.  00:7E4F  4E                          ld c,(hl)
     137.  00:7E50  46                          ld b,(hl)
     138.  00:7E51  ED B0                       ldir                            ; update fcb buffer
     139.  00:7E53  CD 23 75                    call restorePage0
     140.  00:7E56  F1                          pop af                          ; return last character
     141.  00:7E57  C9                          ret
     142.  00:7E58                      
     143.  00:7E58                      eof:
     144.  00:7E58                      ;        DEBUGMESSAGE "eof"
     145.  00:7E58  7E                          ld a,(hl)
     146.  00:7E59  FE 01                       cp 1                            ; input mode?        
     147.  00:7E5B  1E 3D                       ld e,61                         ; bad file mode
     148.  00:7E5D  C2 09 7E                    jp nz,basicError
     149.  00:7E60                                      
     150.  00:7E60  11 06 00                    ld de,6
     151.  00:7E63  19                          add hl,de
     152.  00:7E64  5E                          ld e,(hl)
     153.  00:7E65  23                          inc hl
     154.  00:7E66  23                          inc hl
     155.  00:7E67  23                          inc hl
     156.  00:7E68  19                          add hl,de
     157.  00:7E69  7E                          ld a,(hl)
     158.  00:7E6A  ED 62                       sbc hl,hl
     159.  00:7E6C  FE 1A                       cp $1a        
     160.  00:7E6E  20 01                       jr nz,.skip
     161.  00:7E70  2B                          dec hl
     162.  00:7E71  22 F8 F7            .skip:  ld (DAC+2),hl
     163.  00:7E74  3E 02                       ld a,2
     164.  00:7E76  32 63 F6                    ld (VALTYP),a
     165.  00:7E79  C9                          ret
     166.  00:7E7A                      
     167.  00:7E7A                      loc:
     168.  00:7E7A  E5                          push hl
     169.  00:7E7B  FD E1                       pop iy
     170.  00:7E7D  FD 6E 06                    ld l,(iy+6)
     171.  00:7E80  FD 66 05                    ld h,(iy+5)
     172.  00:7E83                      ;        DEBUGASSERT
     173.  00:7E83  22 F8 F7                    ld (DAC+2),hl
     174.  00:7E86  3E 02                       ld a,2
     175.  00:7E88  32 63 F6                    ld (VALTYP),a
     176.  00:7E8B  C9                          ret
     177.  00:7E8C                              
     178.  00:7E8C                      putback:
     179.  00:7E8C                      ;        DEBUGMESSAGE "putback"
     180.  00:7E8C                      ;        push hl
     181.  00:7E8C                      ;        pop iy
     182.  00:7E8C                      ;        ld (iy+3),c
     183.  00:7E8C                      ;        DEBUGASSERT
     184.  00:7E8C                      ;        ret
     185.  00:7E8C                      
     186.  00:7E8C                      lof:
     187.  00:7E8C                      fpos:
     188.  00:7E8C                              DEBUGMESSAGE "no support!"
     188.  00:7E8C                    >         ifdef DEBUG
     188.  00:7E8C  52                >         ld d,d
     188.  00:7E8D  18 0B             >         jr .skip
     188.  00:7E8F                    >         db string
     188.  00:7E8F  6E 6F 20 73 75 70 70 6F 72 74 21 
     188.  00:7E9A                    > .skip:
     188.  00:7E9A                    >         endif
     189.  00:7E9A                      
     190.  00:7E9A                      illegalFunctionCall:
     191.  00:7E9A  1E 05                       ld e,5
     192.  00:7E9C  C3 09 7E                    jp basicError
     193.  00:7E9F                      
     194.  00:7E9F                      ;FCB for DISK BASIC
     195.  00:7E9F                      ; +0 FL.MOD     file mode
     196.  00:7E9F                      ; +1 FL.FCA     Pointer to FCB for BDOS (low)
     197.  00:7E9F                      ; +2 FL.LCA     Pointer to FCB for BDOS (high)
     198.  00:7E9F                      ; +3 FL.LSA     Back up character
     199.  00:7E9F                      ; +4 FL.DSK     device number
     200.  00:7E9F                      ; +5 FL.SLB
     201.  00:7E9F                      ; +6 FL.BPS     Position in FL.BUF
     202.  00:7E9F                      ; +7 FL.FLG     Holds various information
     203.  00:7E9F                      ; +8 FL.OPS     Pseudo head position
     204.  00:7E9F                      ; +9 FL.BUF     256-byte file buffer
     205.  00:7E9F                      
     206.  00:7E9F                      ; device codes
     207.  00:7E9F                      ;          SS0           SS1           SS2           SS3
     208.  00:7E9F                      ;    ---------------------------------------------------------
     209.  00:7E9F                      ;    | 00 04 08 0C | 10 14 18 1C | 20 24 28 2C | 30 34 38 3C | PS0
     210.  00:7E9F                      ;    ---------------------------------------------------------
     211.  00:7E9F                      ;    | 40 44 48 4C | 50 54 58 5C | 60 64 68 6C | 70 74 78 7C | PS1
     212.  00:7E9F                      ;    ---------------------------------------------------------
     213.  00:7E9F                      ;    | 80 84 88 8C | 90 94 98 9C | A0 A4 A8 AC | B0 B4 B8 BC | PS2
     214.  00:7E9F                      ;    ---------------------------------------------------------
     215.  00:7E9F                      ;    | C0 C4 C8 CC | D0 D4 D8 DC | E0 E4 E8 EC | F0 F4 F8 FC | PS3
     216.  00:7E9F                      ;    ---------------------------------------------------------
     217.  00:7E9F                      
     218.  00:7E9F                      ; fileModes
     219.  00:7E9F                      ; FOR INPUT (01H)
     220.  00:7E9F                      ; FOR OUTPUT (02H)
     221.  00:7E9F                      ; FOR APPEND (08H)
     222.  00:7E9F                      ; random mode (04H)
     223.  00:7E9F                      
     224.  00:7E9F                      ; maximum number of files open: MAXFILES=15
     225.  00:7E9F                              
     226.  00:7E9F                      ; File Control Block
     227.  00:7E9F                      ;       0     1     2     3     4     5     6     7     8
     228.  00:7E9F                      ;    -------------------------------------------------------
     229.  00:7E9F                      ;    | Mod | 00H | 00H | 00H | DEV | 00H | POS | 00H | PPS |
     230.  00:7E9F                      ;    -------------------------------------------------------
     231.  00:7E9F                      ;                  err? bckup       posHi 
     232.  00:7E9F                      ; followed by a 256 byte buffer
      97   00:7E9F                      
      98   00:7E9F  FF (341)                    ds $8000-(endCopyFromBank-copyFromBank)-$, $ff
      99   00:7FF4                      
     100   00:7FF4                      ; bank switching and data transfer
     101   00:7FF4                      copyFromBank:
     102   00:7FF4  32 01 60                    ld (mapper),a
     103   00:7FF7  ED B0                       ldir
     104   00:7FF9                      enableBank0:
     105   00:7FF9  AF                          xor a
     106   00:7FFA                      switchBank:
     107   00:7FFA  F5                          push af
     108   00:7FFB  32 01 60                    ld (mapper),a
     109   00:7FFE  F1                          pop af
     110   00:7FFF  C9                          ret
     111   00:8000                      endCopyFromBank:
     112   00:8000                      
     113   00:8000  (01)                        page 1
     114   01:4000  (C000)                      incbin "..\roms\MSXDOS22.ROM", $4000, 3 * $4000
     115   01!0000                              PATCH $4093, mapper
     115   01!0000                    >         code ! address
     115   01:4093  01 60             >         dw word
     116   01:4095                              PATCH $8093, mapper
     116   01:4095                    >         code ! address
     116   01:8093  01 60             >         dw word
     117   01:8095                              PATCH $C093, mapper
     117   01:8095                    >         code ! address
     117   01:C093  01 60             >         dw word
     118   01:C095                      
     119   01:C095                              ; areas not used in MSXDOS22.ROM
     120   01:C095                              ; bank 1: 0x5CA0 - 0x7FFF (9056 bytes)
     121   01:C095                              ; bank 2: 0x7F30 - 0x7FFF (208 bytes)
     122   01:C095                              ; bank 3: 0x7E70 - 0x7FFF (400 bytes)
     123   01:C095                      
     124   01:C095                      ; insert MSXDOS1
     125   01:C095  (02)                	page 2
     126   02:4000                      	module	MSXDOS1_PART
     127   02:4000                      
     128   02:4000                      	define 	MSXDOSVER 1
     129   02:4000                      	define	ROMINIT $576f
     130   02:4000                      	define	PRINTTEXT $5f86
     131   02:4000                      
     132   02:4000  (3405)                      incbin "..\roms\DISK.ROM", 0, $7405-$4000
     133   02:7405                                      
     134   02:7405                              PATCH $4006, device
     134   02:7405                    >         code ! address
     134   02:4006  89 7E             >         dw word
     135   02:4008                      
     136   02:4008                              code ! $4010
     137   02:4010  C3 8B 77                    jp DSKIO
     138   02:4013  C3 8E 78                    jp DSKCHG
     139   02:4016  C3 C5 78                    jp GETDPB
     140   02:4019  C3 31 79                    jp CHOICE
     141   02:401C  C3 36 79                    jp DSKFMT
     142   02:401F  00 00 00                    db 0,0,0                        ; no DRVOFF
     143   02:4022                              
     144   02:4022                              PATCH $5770, INIHRD
     144   02:4022                    >         code ! address
     144   02:5770  AD 76             >         dw word
     145   02:5772                              PATCH $57aa, $f380 + MYSIZE
     145   02:5772                    >         code ! address
     145   02:57AA  88 F3             >         dw word
     146   02:57AC                              PATCH $581e, MYSIZE
     146   02:57AC                    >         code ! address
     146   02:581E  08 00             >         dw word
     147   02:5820                              PATCH $582f, SECLEN
     147   02:5820                    >         code ! address
     147   02:582F  00 02             >         dw word
     148   02:5831                              PATCH $5851, DRIVES
     148   02:5831                    >         code ! address
     148   02:5851  D0 76             >         dw word
     149   02:5853                              PATCH $5884, DEFDPB - 1
     149   02:5853                    >         code ! address
     149   02:5884  7B 7C             >         dw word
     150   02:5886                              PATCH $5890, INIENV
     150   02:5886                    >         code ! address
     150   02:5890  39 77             >         dw word
     151   02:5892                              PATCH $5ae8, DEFDPB             ; different address in some roms
     151   02:5892                    >         code ! address
     151   02:5AE8  7C 7C             >         dw word
     152   02:5AEA                              PATCH $65af, OEMSTA
     152   02:5AEA                    >         code ! address
     152   02:65AF  41 7A             >         dw word
     153   02:65B1                      	PATCH $5809, initDiskBasic      ; HRUNC
     153   02:65B1                    >         code ! address
     153   02:5809  38 74             >         dw word
     154   02:580B                              
     155   02:580B                              ;PATCH $5b9a, getHostDate        ; get date from host when no clockchip found (different 5b95)
     156   02:580B                      
     157   02:580B                      		ifdef BDOS_NOWIND
     158   02:580B                    ~ 	
     159   02:580B                    ~ 		; just patching the BDOS hook will not work; not everybody uses the hook
     160   02:580B                    ~         ;PATCH $5d20, BDOSNW						  ; overwrite the standard BDOS hook "DW $56D3" with BDOSNW
     161   02:580B                    ~         	
     162   02:580B                    ~         ; even patching the BDOS jump table will not work; internal calls (even in command.com) bypass it
     163   02:580B                    ~         ; jump table patches
     164   02:580B                    ~         ;PATCH $572b, BDOS_0FH_J				  ; overwrite specific function 0Fh in jump table
     165   02:580B                    ~         ;PATCH $572f, BDOS_11H_J				  ; overwrite specific function 11h in jump table
     166   02:580B                    ~         ;PATCH $5731, BDOS_12H_J				  ; overwrite specific function 12h in jump table
     167   02:580B                    ~         	
     168   02:580B                    ~         ; these patches are at the start of the routine themselves, the addresses are more or less "standardized" 
     169   02:580B                    ~         ; over several brands of diskroms	
     170   02:580B                    ~         ; in-routine patches
     171   02:580B                    ~         PATCH $4463, BDOS_0FH					  ; overwrite function 0Fh itself!
     172   02:580B                    ~         PATCH $4fb9, BDOS_11H 				  ; overwrite function 11h itself!
     173   02:580B                    ~         PATCH $5007, BDOS_12H 				  ; overwrite function 12h itself!
     174   02:580B                    ~         	
     175   02:580B                    ~        	endif
     176   02:580B                      				
     177   02:580B                              code ! $595d
     178   02:595D  21 D2 74                    ld hl,newAUX                    ; redirect AUX to host  
     179   02:5960  11 27 F3                    ld de,$f327
     180   02:5963  01 0A 00                    ld bc,10
     181   02:5966  ED B0                       ldir
     182   02:5968  00                          nop
     183   02:5969  00                          nop
     184   02:596A  00                          nop
     185   02:596B  00                          nop                             ; do not remove!
     186   02:596C                              
     187   02:596C                              code @ $7405
     188   02:7405                      
     189   02:7405                              include "common.asm"
       1.  02:7405                      ; Nowind specific
       2.  02:7405                      
       3.  02:7405                      nowindInit:
       4.  02:7405                              ;DEBUGMESSAGE "nowindInit"
       5.  02:7405  3A F8 FA                    ld a,($faf8)										; moet volgens bifi ld a,($2d) zijn, $faf8 is op msx1 deel van de rs232 area?
       6.  02:7408  B7                          or a 
       7.  02:7409  F5                          push af
       8.  02:740A  CC 5F 00                    call z,CHGMOD                   ; SCREEN 0 for MSX1
       9.  02:740D  F1                          pop af
      10.  02:740E  DD 21 85 01                 ld ix,SDFSCR                    ; restore screen mode from clockchip
      11.  02:7412  C4 5F 01                    call nz,EXTROM
      12.  02:7415                                      
      13.  02:7415  CD 86 5F                    call PRINTTEXT
      14.  02:7418                              ifndef DEBUG
      15.  02:7418                    ~         db "Nowind USB Diskrom!",0
      16.  02:7418                    ~         else
      17.  02:7418                              db "Nowind USB Diskrom! [debug]",0
      17.  02:7418  4E 6F 77 69 6E 64 20 55 53 42 20 44 69 73 6B 72 
      17.  02:7428  6F 6D 21 20 5B 64 65 62 75 67 5D 00 
      18.  02:7434                              endif
      19.  02:7434                      
      20.  02:7434                              ; call insertBootCode
      21.  02:7434  CD 5E 7D                    call flashWriter
      22.  02:7437  C9                          ret
      23.  02:7438                      
      24.  02:7438                      initDiskBasic:
      25.  02:7438                              DEBUGMESSAGE "initDiskBasic"
      25.  02:7438                    >         ifdef DEBUG
      25.  02:7438  52                >         ld d,d
      25.  02:7439  18 0D             >         jr .skip
      25.  02:743B                    >         db string
      25.  02:743B  69 6E 69 74 44 69 73 6B 42 61 73 69 63 
      25.  02:7448                    > .skip:
      25.  02:7448                    >         endif
      26.  02:7448  21 99 FD                    ld hl,DEVICE
      27.  02:744B  CB BE                       res 7,(hl)
      28.  02:744D                              
      29.  02:744D                              if MSXDOSVER = 1 
      30.  02:744D  C3 97 58                    jp $5897
      31.  02:7450                              else
      32.  02:7450                    ~         jp $495b
      33.  02:7450                    ~         endif
      34.  02:7450                      
      35.  02:7450                      ; search call statement or device name
      36.  02:7450                      findStatementName:
      37.  02:7450                              DEBUGMESSAGE "findStatementName"
      37.  02:7450                    >         ifdef DEBUG
      37.  02:7450  52                >         ld d,d
      37.  02:7451  18 11             >         jr .skip
      37.  02:7453                    >         db string
      37.  02:7453  66 69 6E 64 53 74 61 74 65 6D 65 6E 74 4E 61 6D 
      37.  02:7463  65 
      37.  02:7464                    > .skip:
      37.  02:7464                    >         endif
      38.  02:7464  11 89 FD                    ld de,PROCNM
      39.  02:7467  1A                  .loop:  ld a,(de)
      40.  02:7468  BE                          cp (hl)
      41.  02:7469  20 06                       jr nz,.nextStatement
      42.  02:746B  23                          inc hl
      43.  02:746C  B7                          or a
      44.  02:746D  C8                          ret z                           ; name found
      45.  02:746E  13                          inc de
      46.  02:746F  18 F6                       jr .loop        
      47.  02:7471                      .nextStatement:
      48.  02:7471  AF                          xor a
      49.  02:7472  4F                          ld c,a
      50.  02:7473  ED B1                       cpir
      51.  02:7475  23                          inc hl
      52.  02:7476  23                          inc hl
      53.  02:7477  B6                          or (hl)
      54.  02:7478  20 D6                       jr nz,findStatementName        
      55.  02:747A  37                          scf                             ; not found
      56.  02:747B  C9                          ret
      57.  02:747C                      
      58.  02:747C                      sendRegisters:
      59.  02:747C  F5                          push af
      60.  02:747D  7C                          ld a,h
      61.  02:747E  26 40                       ld h,HIGH usbwr
      62.  02:7480  36 AF                       ld (hl),$af                     ; header
      63.  02:7482  36 05                       ld (hl),$05
      64.  02:7484  71                          ld (hl),c
      65.  02:7485  70                          ld (hl),b
      66.  02:7486  73                          ld (hl),e
      67.  02:7487  72                          ld (hl),d
      68.  02:7488  75                          ld (hl),l
      69.  02:7489  77                          ld (hl),a                       ; register h
      70.  02:748A  D1                          pop de
      71.  02:748B  73                          ld (hl),e                       ; register f
      72.  02:748C  72                          ld (hl),d                       ; register a
      73.  02:748D  C9                          ret
      74.  02:748E                              
      75.  02:748E                      getHeader:
      76.  02:748E  06 FF                       ld b,HIGH 65535                 ; 42000 * 60 states ~ 0,7 sec (time out)
      77.  02:7490  7E                  .loop:  ld a,(hl)
      78.  02:7491  FE AF               .chkaf: cp $af
      79.  02:7493  28 20                       jr z,.chk05
      80.  02:7495  0B                          dec bc
      81.  02:7496  78                          ld a,b
      82.  02:7497  B1                          or c
      83.  02:7498  20 F6                       jr nz,.loop
      84.  02:749A                              DEBUGMESSAGE "getHeader Timed out!"
      84.  02:749A                    >         ifdef DEBUG
      84.  02:749A  52                >         ld d,d
      84.  02:749B  18 14             >         jr .skip
      84.  02:749D                    >         db string
      84.  02:749D  67 65 74 48 65 61 64 65 72 20 54 69 6D 65 64 20 
      84.  02:74AD  6F 75 74 21 
      84.  02:74B1                    > .skip:
      84.  02:74B1                    >         endif
      85.  02:74B1  3E 02                       ld a,2                          ; not ready
      86.  02:74B3  37                          scf
      87.  02:74B4  C9                          ret
      88.  02:74B5                      
      89.  02:74B5  7E                  .chk05: ld a,(hl)
      90.  02:74B6  FE 05                       cp $05
      91.  02:74B8  20 D7                       jr nz,.chkaf
      92.  02:74BA  7E                          ld a,(hl)
      93.  02:74BB  C9                          ret
      94.  02:74BC                      
      95.  02:74BC                      sendMessage:
      96.  02:74BC                              ;DEBUGMESSAGE "sendMsg"
      97.  02:74BC  E3                          ex (sp),hl
      98.  02:74BD  F5                          push af
      99.  02:74BE  D5                          push de
     100.  02:74BF  E5                          push hl        
     101.  02:74C0  CD 7C 74                    call sendRegisters
     102.  02:74C3  36 90                       ld (hl),C_MESSAGE
     103.  02:74C5  E1                          pop hl
     104.  02:74C6  7E                  .loop:  ld a,(hl)
     105.  02:74C7  23                          inc hl
     106.  02:74C8  32 00 40                    ld (usbwr),a
     107.  02:74CB  B7                          or a
     108.  02:74CC  20 F8                       jr nz,.loop
     109.  02:74CE  D1                          pop de
     110.  02:74CF  F1                          pop af
     111.  02:74D0  E3                          ex (sp),hl
     112.  02:74D1  C9                          ret
     113.  02:74D2                              
     114.  02:74D2                      ; AUX device
     115.  02:74D2                              
     116.  02:74D2  C3 DC 74            newAUX: jp AUXin
     117.  02:74D5  00                          nop
     118.  02:74D6  00                          nop
     119.  02:74D7  C3 21 75                    jp AUXout
     120.  02:74DA  00                          nop
     121.  02:74DB  00                          nop
     122.  02:74DC                      
     123.  02:74DC                      AUXin:  DEBUGMESSAGE "AUX in"
     123.  02:74DC                    >         ifdef DEBUG
     123.  02:74DC  52                >         ld d,d
     123.  02:74DD  18 06             >         jr .skip
     123.  02:74DF  41 55 58 20 69 6E >         db string
     123.  02:74E5                    > .skip:
     123.  02:74E5                    >         endif
     124.  02:74E5  E5                          push hl
     125.  02:74E6  D5                          push de
     126.  02:74E7  C5                          push bc
     127.  02:74E8  CD 7C 74                    call sendRegisters
     128.  02:74EB  36 8E                       ld (hl),C_AUXIN
     129.  02:74ED  CD 0D 76                    call enableNowindPage0
     130.  02:74F0  26 20                       ld h,HIGH usbrd
     131.  02:74F2  CD 8E 74                    call getHeader
     132.  02:74F5  D2 10 75                    jp nc,.getCharacter
     133.  02:74F8                              
     134.  02:74F8                              DEBUGMESSAGE "not connected"
     134.  02:74F8                    >         ifdef DEBUG
     134.  02:74F8  52                >         ld d,d
     134.  02:74F9  18 0D             >         jr .skip
     134.  02:74FB                    >         db string
     134.  02:74FB  6E 6F 74 20 63 6F 6E 6E 65 63 74 65 64 
     134.  02:7508                    > .skip:
     134.  02:7508                    >         endif
     135.  02:7508  3E 1A                       ld a,$1a                        ; eof
     136.  02:750A  C1                  .exit:  pop bc
     137.  02:750B  D1                          pop de
     138.  02:750C  E1                          pop hl
     139.  02:750D  C3 18 76                    jp restorePage0        
     140.  02:7510                                    
     141.  02:7510                      .getCharacter:
     142.  02:7510                              DEBUGMESSAGE "getChar"
     142.  02:7510                    >         ifdef DEBUG
     142.  02:7510  52                >         ld d,d
     142.  02:7511  18 07             >         jr .skip
     142.  02:7513                    >         db string
     142.  02:7513  67 65 74 43 68 61 72 
     142.  02:751A                    > .skip:
     142.  02:751A                    >         endif
     143.  02:751A  CD 8E 74                    call getHeader
     144.  02:751D  38 F1                       jr c,.getCharacter
     145.  02:751F  18 E9                       jr .exit
     146.  02:7521                      
     147.  02:7521                      
     148.  02:7521                      AUXout: DEBUGMESSAGE "AUX out"
     148.  02:7521                    >         ifdef DEBUG
     148.  02:7521  52                >         ld d,d
     148.  02:7522  18 07             >         jr .skip
     148.  02:7524                    >         db string
     148.  02:7524  41 55 58 20 6F 75 74 
     148.  02:752B                    > .skip:
     148.  02:752B                    >         endif
     149.  02:752B                              DEBUGDUMPREGISTERS
     149.  02:752B                    >         ifdef DEBUG
     149.  02:752B  ED 07             >         db $ed,7
     149.  02:752D                    >         endif
     149.  02:752D                    >         
     149.  02:752D                    >         ifdef USBDEBUG
     149.  02:752D                    ~         assert ($ < $8000)
     149.  02:752D                    ~         call sendCpuInfo
     149.  02:752D                    ~         endif
     150.  02:752D  E5                          push hl
     151.  02:752E  D5                          push de
     152.  02:752F                      ;        push bc
     153.  02:752F                      ;        ld a,(RAMAD1) ; TODO: WTF???
     154.  02:752F                      ;        call RDSLT
     155.  02:752F  F5                          push af        
     156.  02:7530  CD 7C 74                    call sendRegisters
     157.  02:7533  36 8F                       ld (hl),C_AUXOUT
     158.  02:7535  F1                          pop af
     159.  02:7536                      ;        pop bc
     160.  02:7536  D1                          pop de
     161.  02:7537  E1                          pop hl
     162.  02:7538  C9                          ret
     163.  02:7539                      
     164.  02:7539                      ;insertBootCode:
     165.  02:7539                      ;        DEBUGMESSAGE "BOOTCODE"
     166.  02:7539                      ;        call sendRegisters
     167.  02:7539                      ;        ld (hl),C_BOOTCODE
     168.  02:7539                      ;        call enableNowindPage0
     169.  02:7539                      ;        call getHeader
     170.  02:7539                      ;        jp c,restorePage0
     171.  02:7539                              
     172.  02:7539                      ;        DEBUGMESSAGE "BOOTCODE"
     173.  02:7539                      ;        jp restorePage0
     174.  02:7539                      
     175.  02:7539                      ; send 32 bytes starting from address specified by DE to the usb
     176.  02:7539                      sdendFCB:
     177.  02:7539  D5                          push de
     178.  02:753A  C5                          push bc
     179.  02:753B                              
     180.  02:753B  06 20                       ld b,32
     181.  02:753D  1A                  .loop:  ld a,(de)
     182.  02:753E  32 00 40                    ld (usbwr),a
     183.  02:7541  13                          inc de
     184.  02:7542  10 F9                       djnz .loop
     185.  02:7544  C1                          pop bc
     186.  02:7545  D1                          pop de
     187.  02:7546  C9                          ret
     188.  02:7547                      
     189.  02:7547                      ; receive 32 bytes and write to the address specified by DE 
     190.  02:7547                      receiveFCB:
     191.  02:7547  D5                          push de
     192.  02:7548  C5                          push bc
     193.  02:7549                              
     194.  02:7549  06 20                       ld b,32
     195.  02:754B  3A 00 20            .loop:  ld a,(usbrd)
     196.  02:754E  32 00 40            	ld (usbwr),a			; loop back
     197.  02:7551  12                          ld (de),a
     198.  02:7552  13                          inc de
     199.  02:7553  10 F6                       djnz .loop
     200.  02:7555  C1                          pop bc
     201.  02:7556  D1                          pop de
     202.  02:7557  C9                          ret
     203.  02:7558                              
     190   02:7558                              include "extendedBios.asm"
       1.  02:7558                      
       2.  02:7558                      installExtendedBios:
       3.  02:7558                      
       4.  02:7558                              ; Called from INIENV, so EXTBIO hook is already initialized
       5.  02:7558                      
       6.  02:7558                              DEBUGMESSAGE "extbio"
       6.  02:7558                    >         ifdef DEBUG
       6.  02:7558  52                >         ld d,d
       6.  02:7559  18 06             >         jr .skip
       6.  02:755B  65 78 74 62 69 6F >         db string
       6.  02:7561                    > .skip:
       6.  02:7561                    >         endif
       7.  02:7561  CD 98 76                    call getEntrySLTWRK             ; save previous EXTBIO hook
       8.  02:7564  23                          inc hl
       9.  02:7565  EB                          ex de,hl        
      10.  02:7566  21 CA FF                    ld hl,EXTBIO
      11.  02:7569  01 05 00                    ld bc,5
      12.  02:756C  ED B0                       ldir
      13.  02:756E                              
      14.  02:756E  E5                          push hl                         ; determine device number
      15.  02:756F  AF                          xor a
      16.  02:7570  11 01 4E                    ld de,$4e01
      17.  02:7573  CD CA FF                    call EXTBIO
      18.  02:7576  E1                          pop hl
      19.  02:7577  77                          ld (hl),a
      20.  02:7578                                      
      21.  02:7578  CD 2D 40                    call GETSLT                     ; install new EXTBIO hook
      22.  02:757B  2E F7                       ld l,$f7
      23.  02:757D  67                          ld h,a
      24.  02:757E  22 CA FF                    ld (EXTBIO),hl
      25.  02:7581  21 8D 75                    ld hl,extendedBios
      26.  02:7584  22 CC FF                    ld (EXTBIO+2),hl
      27.  02:7587  3E C9                       ld a,$c9
      28.  02:7589  32 CE FF                    ld (EXTBIO+4),a    
      29.  02:758C  C9                          ret
      30.  02:758D                      
      31.  02:758D                      extendedBios:
      32.  02:758D                              ; broadcast (0x00) not implemented
      33.  02:758D                              ; system exclusive (0xff) not implemented
      34.  02:758D                      
      35.  02:758D  FB                          ei
      36.  02:758E  F5                          push af
      37.  02:758F  7A                          ld a,d
      38.  02:7590  FE 4E                       cp $4e
      39.  02:7592  28 0E                       jr z,determineFunction
      40.  02:7594                      .exit:
      41.  02:7594  E5                          push hl
      42.  02:7595  C5                          push bc
      43.  02:7596  CD 98 76                    call getEntrySLTWRK
      44.  02:7599  2C                          inc l                           ; previous EXTBIO hook 
      45.  02:759A  E5                          push hl
      46.  02:759B  DD E1                       pop ix
      47.  02:759D  C1                          pop bc        
      48.  02:759E  E1                          pop hl
      49.  02:759F  F1                          pop af
      50.  02:75A0  DD E9                       jp (ix)                         ; process other EXTBIO handles
      51.  02:75A2                      
      52.  02:75A2                      determineFunction:
      53.  02:75A2  E5                          push hl
      54.  02:75A3  21 AE D9                    ld hl,functionTable - 2 * $4e00
      55.  02:75A6  19                          add hl,de
      56.  02:75A7  19                          add hl,de
      57.  02:75A8  7E                          ld a,(hl)
      58.  02:75A9  23                          inc hl
      59.  02:75AA  66                          ld h,(hl)
      60.  02:75AB  6F                          ld l,a
      61.  02:75AC  E3                          ex (sp),hl
      62.  02:75AD  C9                          ret
      63.  02:75AE                      
      64.  02:75AE                      functionTable:
      65.  02:75AE  B4 75                       dw getNowindSlot
      66.  02:75B0  D0 75                       dw numberOfDevices
      67.  02:75B2  E7 75                       dw debugMessage
      68.  02:75B4                      
      69.  02:75B4                      getNowindSlot:               
      70.  02:75B4                              DEBUGMESSAGE "getNowindSlot"
      70.  02:75B4                    >         ifdef DEBUG
      70.  02:75B4  52                >         ld d,d
      70.  02:75B5  18 0D             >         jr .skip
      70.  02:75B7                    >         db string
      70.  02:75B7  67 65 74 4E 6F 77 69 6E 64 53 6C 6F 74 
      70.  02:75C4                    > .skip:
      70.  02:75C4                    >         endif
      71.  02:75C4  F1                          pop af
      72.  02:75C5  3D                          dec a
      73.  02:75C6  F5                          push af
      74.  02:75C7  F2 94 75                    jp p,extendedBios.exit         ; not this device
      75.  02:75CA                              
      76.  02:75CA  F1                          pop af
      77.  02:75CB  CD 68 76                    call getSlotPage1
      78.  02:75CE  37                          scf
      79.  02:75CF  C9                          ret
      80.  02:75D0                              
      81.  02:75D0                      numberOfDevices:
      82.  02:75D0                              DEBUGMESSAGE "numberOfDevices"
      82.  02:75D0                    >         ifdef DEBUG
      82.  02:75D0  52                >         ld d,d
      82.  02:75D1  18 0F             >         jr .skip
      82.  02:75D3                    >         db string
      82.  02:75D3  6E 75 6D 62 65 72 4F 66 44 65 76 69 63 65 73 
      82.  02:75E2                    > .skip:
      82.  02:75E2                    >         endif
      83.  02:75E2  F1                          pop af
      84.  02:75E3  3C                          inc a
      85.  02:75E4  F5                          push af
      86.  02:75E5  18 AD                       jr extendedBios.exit
      87.  02:75E7                              
      88.  02:75E7                      debugMessage:
      89.  02:75E7                              DEBUGMESSAGE "debugMessage"
      89.  02:75E7                    >         ifdef DEBUG
      89.  02:75E7  52                >         ld d,d
      89.  02:75E8  18 0C             >         jr .skip
      89.  02:75EA                    >         db string
      89.  02:75EA  64 65 62 75 67 4D 65 73 73 61 67 65 
      89.  02:75F6                    > .skip:
      89.  02:75F6                    >         endif
      90.  02:75F6  F1                          pop af
      91.  02:75F7  3D                          dec a
      92.  02:75F8  F5                          push af
      93.  02:75F9  F2 94 75                    jp p,extendedBios.exit
      94.  02:75FC                      
      95.  02:75FC  E5                          push hl
      96.  02:75FD  CD 7C 74                    call sendRegisters
      97.  02:7600  36 90                       ld (hl),C_MESSAGE
      98.  02:7602  E1                          pop hl
      99.  02:7603  7E                  .loop:  ld a,(hl)
     100.  02:7604  23                          inc hl
     101.  02:7605  32 00 40                    ld (usbwr),a
     102.  02:7608  B7                          or a
     103.  02:7609  20 F8                       jr nz,.loop
     104.  02:760B                              
     105.  02:760B  F1                          pop af        
     106.  02:760C  C9                          ret
     191   02:760D                              include "slotRoutines.asm"
       1.  02:760D                      ; These routines are used for slot selection
       2.  02:760D                      
       3.  02:760D                      enableNowindPage0:
       4.  02:760D  CD 5D 76                    call getSlotPage0
       5.  02:7610  DD 67                       ld ixh,a
       6.  02:7612  CD 68 76                    call getSlotPage1
       7.  02:7615  C3 21 76                    jp enableSlotPage0       
       8.  02:7618                      
       9.  02:7618                      restorePage0:
      10.  02:7618  F5                          push af
      11.  02:7619  DD 7C                       ld a,ixh
      12.  02:761B  CD 21 76                    call enableSlotPage0
      13.  02:761E  FB                          ei
      14.  02:761F  F1                          pop af
      15.  02:7620  C9                          ret
      16.  02:7621                      
      17.  02:7621                      enableSlotPage0:
      18.  02:7621                              ; HL and D remain unchanged
      19.  02:7621                              ; enableSlotPage0 can be called in page 1 and 2 (no absolute jumps)
      20.  02:7621                      
      21.  02:7621                              ;DEBUGMESSAGE "enasltP0"
      22.  02:7621  5F                          ld e,a                          ; store slotcode for further use
      23.  02:7622  E6 03                       and 3
      24.  02:7624  4F                          ld c,a                          ; new primary slot in c  
      25.  02:7625  CB 7B                       bit 7,e
      26.  02:7627  F3                          di
      27.  02:7628  20 08                       jr nz,.expanded
      28.  02:762A                      
      29.  02:762A  DB A8                       in a,($a8)
      30.  02:762C  E6 FC                       and %11111100
      31.  02:762E  B1                          or c                            ; enable new primary slot in page 0
      32.  02:762F  D3 A8                       out ($a8),a
      33.  02:7631  C9                          ret
      34.  02:7632                              
      35.  02:7632                      .expanded:
      36.  02:7632  7B                          ld a,e                          ; store secondary slot in e
      37.  02:7633  E6 0C                       and %00001100     
      38.  02:7635  0F                          rrca
      39.  02:7636  0F                          rrca
      40.  02:7637  5F                          ld e,a
      41.  02:7638                      
      42.  02:7638  DB A8                       in a,($a8)
      43.  02:763A  E6 FC                       and %11111100
      44.  02:763C  B1                          or c                            ; new primary slot in page 0
      45.  02:763D  47                          ld b,a                          ; used to restore
      46.  02:763E  17                          rla
      47.  02:763F  A7                          and a                           ; (reset carry)
      48.  02:7640  17                          rla
      49.  02:7641  B1                          or c                            ; new primary slot in page 3
      50.  02:7642  0F                          rrca
      51.  02:7643  0F                          rrca
      52.  02:7644  D3 A8                       out ($a8),a
      53.  02:7646                      
      54.  02:7646  3A FF FF                    ld a,(-1)                       ; write secondary slot register
      55.  02:7649  2F                          cpl
      56.  02:764A  E6 FC                       and %11111100
      57.  02:764C  B3                          or e                            ; apply new secondary slot for page 0
      58.  02:764D  32 FF FF                    ld (-1),a
      59.  02:7650  5F                          ld e,a                          ; store secondary slot register (for SLTTBL)
      60.  02:7651                      
      61.  02:7651  78                          ld a,b                          ; restore primary slot page 3
      62.  02:7652  D3 A8                       out ($a8),a
      63.  02:7654                      
      64.  02:7654  3E C5                       ld a,LOW SLTTBL                 ; update SLTTBL
      65.  02:7656  81                          add c                           ; add primary slot
      66.  02:7657  4F                          ld c,a
      67.  02:7658  06 FC                       ld b,HIGH SLTTBL
      68.  02:765A  7B                          ld a,e                          ; restore secondary slot register
      69.  02:765B  02                          ld (bc),a
      70.  02:765C  C9                          ret
      71.  02:765D                      
      72.  02:765D                      ; These routines determine the current slot and subslot of a page.
      73.  02:765D                      
      74.  02:765D                      getSlotPage0:
      75.  02:765D                              ;DEBUGMESSAGE "getsltP0"
      76.  02:765D  DB A8                       in a,($a8)
      77.  02:765F  CD 82 76                    call expanded
      78.  02:7662  07                          rlca
      79.  02:7663  07                          rlca
      80.  02:7664  E6 0C                       and %00001100           ; keep subSlot
      81.  02:7666  B1                          or c                    ; add mainSlot and expanded bit
      82.  02:7667  C9                          ret
      83.  02:7668                                      
      84.  02:7668                      getSlotPage1:
      85.  02:7668                      ;        DEBUGMESSAGE "getsltP1"
      86.  02:7668  DB A8                       in a,($a8)
      87.  02:766A  0F                          rrca
      88.  02:766B  0F                          rrca
      89.  02:766C  CD 82 76                    call expanded
      90.  02:766F  E6 0C                       and %00001100           ; keep subSlot
      91.  02:7671  B1                          or c                    ; add mainSlot and expanded bit
      92.  02:7672  C9                          ret        
      93.  02:7673                                      
      94.  02:7673                      getSlotPage2:
      95.  02:7673                      ;        DEBUGMESSAGE "getsltP2"
      96.  02:7673  DB A8                       in a,($a8)
      97.  02:7675  0F                          rrca
      98.  02:7676  0F                          rrca
      99.  02:7677  0F                          rrca
     100.  02:7678  0F                          rrca
     101.  02:7679  CD 82 76                    call expanded
     102.  02:767C  0F                          rrca
     103.  02:767D  0F                          rrca
     104.  02:767E  E6 0C                       and %00001100           ; keep subSlot
     105.  02:7680  B1                          or c                    ; add mainSlot and expanded bit
     106.  02:7681  C9                          ret
     107.  02:7682                      
     108.  02:7682                      ;expanded:        
     109.  02:7682                      ;        ld hl,EXPTBL - $0300
     110.  02:7682                      ;        ld b,3
     111.  02:7682                      ;        and b
     112.  02:7682                      ;        ld c,a
     113.  02:7682                      ;        add hl,bc      
     114.  02:7682                      ;        
     115.  02:7682                      ;        or (hl)        ; BUGGIE!!!! (a will be used again!)
     116.  02:7682                      ;        ret p                           ; return when slot is not expanded
     117.  02:7682                      ;        
     118.  02:7682                      ;        ld c,a
     119.  02:7682                      ;        ld a,4
     120.  02:7682                      ;        add a,l
     121.  02:7682                      ;        ld l,a
     122.  02:7682                      ;        ld a,(hl)
     123.  02:7682                      ;        ret
     124.  02:7682                      
     125.  02:7682                      expanded:        
     126.  02:7682  21 C1 F9                    ld hl,EXPTBL - $0300
     127.  02:7685  06 03                       ld b,3
     128.  02:7687  A0                          and b
     129.  02:7688  4F                          ld c,a
     130.  02:7689  09                          add hl,bc
     131.  02:768A  CB 7E                       bit 7,(hl)
     132.  02:768C  28 08                       jr z,notExpanded
     133.  02:768E                      
     134.  02:768E  CB F9                       set 7,c
     135.  02:7690  2C                          inc l
     136.  02:7691  2C                          inc l
     137.  02:7692  2C                          inc l
     138.  02:7693  2C                          inc l
     139.  02:7694  7E                          ld a,(hl)
     140.  02:7695  C9                          ret        
     141.  02:7696                      
     142.  02:7696                      notExpanded:
     143.  02:7696  C1                          pop bc
     144.  02:7697  C9                          ret
     145.  02:7698                      
     146.  02:7698                      getEntrySLTWRK:
     147.  02:7698  CD 68 76                    call getSlotPage1
     148.  02:769B  21 09 FD                    ld hl,SLTWRK
     149.  02:769E  4F                          ld c,a
     150.  02:769F  0F                          rrca
     151.  02:76A0  0F                          rrca
     152.  02:76A1  0F                          rrca
     153.  02:76A2  E6 60                       and %01100000           ; main slot x 32
     154.  02:76A4  47                          ld b,a
     155.  02:76A5  79                          ld a,c
     156.  02:76A6  07                          rlca
     157.  02:76A7  E6 18                       and %00011000           ; sub slot x 8
     158.  02:76A9  80                          add b
     159.  02:76AA  85                          add l
     160.  02:76AB  6F                          ld l,a
     161.  02:76AC  C9                          ret
     162.  02:76AD                      
     192   02:76AD                              include "nowindDriver.asm"
       1.  02:76AD  (02:0008)           MYSIZE          equ 8                   ; size of work area (not used, some programs write here to stop drives spinning)
       2.  02:76AD  (02:0200)           SECLEN          equ 512                 ; sector size
       3.  02:76AD                      
       4.  02:76AD                      ; SLTWRK entry
       5.  02:76AD                      ; +0    rom drive number
       6.  02:76AD                      ; +1..5 previous EXTBIO
       7.  02:76AD                      ; +6    not used
       8.  02:76AD                      ; +7    not used
       9.  02:76AD                      
      10.  02:76AD                             
      11.  02:76AD                      ; if this is defined we tell DOS2.3 that we _are DOS2.3 also, so
      12.  02:76AD                      ; it does not try to override our initilazations 
      13.  02:76AD                      
      14.  02:76AD                      define  PRETEND_2B_DOS23
      15.  02:76AD                              
      16.  02:76AD                      INIHRD: 
      17.  02:76AD                              DEBUGMESSAGE "INIHRD"        
      17.  02:76AD                    >         ifdef DEBUG
      17.  02:76AD  52                >         ld d,d
      17.  02:76AE  18 06             >         jr .skip
      17.  02:76B0  49 4E 49 48 52 44 >         db string
      17.  02:76B6                    > .skip:
      17.  02:76B6                    >         endif
      18.  02:76B6                              
      19.  02:76B6                      ;        call getWorkArea
      20.  02:76B6                      ;        DEBUGDUMPREGISTERS
      21.  02:76B6                                                      
      22.  02:76B6  CD 0D 76                    call enableNowindPage0                  ; clear hostToMSXFifo by reading 4Kb of random data
      23.  02:76B9  01 00 10                    ld bc,4096
      24.  02:76BC  3A 00 20            .loop:  ld a,(usbrd)
      25.  02:76BF  0B                          dec bc
      26.  02:76C0  78                          ld a,b
      27.  02:76C1  B1                          or c
      28.  02:76C2  20 F8                       jr nz,.loop
      29.  02:76C4  CD 18 76                    call restorePage0
      30.  02:76C7                              
      31.  02:76C7  26 40                       ld h,HIGH usbwr
      32.  02:76C9  36 AF                       ld (hl),$af                     ; INIHRD command
      33.  02:76CB  36 FF                       ld (hl),$ff
      34.  02:76CD  C3 05 74                    jp nowindInit
      35.  02:76D0                      
      36.  02:76D0                      DRIVES:
      37.  02:76D0                              DEBUGMESSAGE "DRIVES"
      37.  02:76D0                    >         ifdef DEBUG
      37.  02:76D0  52                >         ld d,d
      37.  02:76D1  18 06             >         jr .skip
      37.  02:76D3  44 52 49 56 45 53 >         db string
      37.  02:76D9                    > .skip:
      37.  02:76D9                    >         endif
      38.  02:76D9  F5                          push af                         ; A, BC and DE should be preserved!
      39.  02:76DA  C5                          push bc
      40.  02:76DB  D5                          push de
      41.  02:76DC  3A 99 FD                    ld a,(DEVICE)
      42.  02:76DF  CD 7C 74                    call sendRegisters
      43.  02:76E2  36 85                       ld (hl),C_DRIVES
      44.  02:76E4  CD 0D 76                    call enableNowindPage0
      45.  02:76E7  26 20                       ld h,HIGH usbrd
      46.  02:76E9  CD 8E 74                    call getHeader
      47.  02:76EC  2E 02                       ld l,2                          ; default 2 drives
      48.  02:76EE  38 2C                       jr c,.notconnected
      49.  02:76F0                      
      50.  02:76F0                              PRINTVDPTEXT " Host connected."
      50.  02:76F0                    >         
      50.  02:76F0  E5                >         push hl
      50.  02:76F1  21 FA 76          >         ld hl,.text
      50.  02:76F4  CD 60 7C          >         call printVdpText2
      50.  02:76F7  E1                >         pop hl
      50.  02:76F8  18 11             >         jr .skip
      50.  02:76FA                    > .text   db string
      50.  02:76FA  20 48 6F 73 74 20 63 6F 6E 6E 65 63 74 65 64 2E 
      50.  02:770A  00                >         db 0
      50.  02:770B                    > .skip:
      51.  02:770B                                                      
      52.  02:770B  32 3F F3                    ld (LASTDRV),a                  ; install phantom drives (CRTL key)?
      53.  02:770E  7E                          ld a,(hl)                       ; allow other drives (SHIFT key)?
      54.  02:770F  32 99 FD                    ld (DEVICE),a
      55.  02:7712  6E                          ld l,(hl)                       ; number of drives
      56.  02:7713  E5                  .exit:  push hl  
      57.  02:7714  CD 18 76                    call restorePage0
      58.  02:7717  E1                          pop hl
      59.  02:7718  D1                          pop de
      60.  02:7719  C1                          pop bc
      61.  02:771A  F1                          pop af
      62.  02:771B  C9                          ret
      63.  02:771C                              
      64.  02:771C                      .notconnected:
      65.  02:771C                              PRINTVDPTEXT " Host timed out!"            
      65.  02:771C                    >         
      65.  02:771C  E5                >         push hl
      65.  02:771D  21 26 77          >         ld hl,.text
      65.  02:7720  CD 60 7C          >         call printVdpText2
      65.  02:7723  E1                >         pop hl
      65.  02:7724  18 11             >         jr .skip
      65.  02:7726                    > .text   db string
      65.  02:7726  20 48 6F 73 74 20 74 69 6D 65 64 20 6F 75 74 21 
      65.  02:7736  00                >         db 0
      65.  02:7737                    > .skip:
      66.  02:7737  18 DA                       jr .exit
      67.  02:7739                      
      68.  02:7739                      
      69.  02:7739                      INIENV:
      70.  02:7739                      ; Interrupt handler can be installed here and
      71.  02:7739                      ; work area can be initialized when it was requested
      72.  02:7739                              DEBUGMESSAGE "INIENV"
      72.  02:7739                    >         ifdef DEBUG
      72.  02:7739  52                >         ld d,d
      72.  02:773A  18 06             >         jr .skip
      72.  02:773C  49 4E 49 45 4E 56 >         db string
      72.  02:7742                    > .skip:
      72.  02:7742                    >         endif
      73.  02:7742                      
      74.  02:7742                              ifdef PRETEND_2B_DOS23
      75.  02:7742                              DEBUGMESSAGE "Lie about being DOS v2.31"
      75.  02:7742                    >         ifdef DEBUG
      75.  02:7742  52                >         ld d,d
      75.  02:7743  18 19             >         jr .skip
      75.  02:7745                    >         db string
      75.  02:7745  4C 69 65 20 61 62 6F 75 74 20 62 65 69 6E 67 20 
      75.  02:7755  44 4F 53 20 76 32 2E 33 31 
      75.  02:775E                    > .skip:
      75.  02:775E                    >         endif
      76.  02:775E  3E 23                       ld a,$23
      77.  02:7760  32 13 F3                    ld ($f313),a
      78.  02:7763                              endif
      79.  02:7763                              
      80.  02:7763  CD 58 75                    call installExtendedBios
      81.  02:7766  CD 7C 74                    call sendRegisters
      82.  02:7769  36 86                       ld (hl),C_INIENV
      83.  02:776B  CD 0D 76                    call enableNowindPage0
      84.  02:776E  26 20                       ld h,HIGH usbrd
      85.  02:7770  CD 8E 74                    call getHeader
      86.  02:7773  F5                          push af
      87.  02:7774                      ;        push ix
      88.  02:7774                      ;        call GETWRK
      89.  02:7774                      ;        pop ix
      90.  02:7774  CD 98 76                    call getEntrySLTWRK
      91.  02:7777  F1                          pop af
      92.  02:7778  36 00                       ld (hl),0                       ; romdisk in drive A: (default)          
      93.  02:777A  38 01                       jr c,.exit
      94.  02:777C  77                          ld (hl),a                       ; store romdisk drive number (255 = no romdisk)
      95.  02:777D  C3 18 76            .exit:  jp restorePage0
      96.  02:7780                      
      97.  02:7780                      checkWorkArea:
      98.  02:7780  C5                          push bc
      99.  02:7781  E5                          push hl
     100.  02:7782  F5                          push af
     101.  02:7783                      ;        call GETWRK
     102.  02:7783  CD 98 76                    call getEntrySLTWRK
     103.  02:7786  F1                          pop af
     104.  02:7787  BE                          cp (hl)
     105.  02:7788  E1                          pop hl
     106.  02:7789  C1                          pop bc
     107.  02:778A  C9                          ret        
     108.  02:778B                      
     109.  02:778B                      DSKIO: 
     110.  02:778B                      ; Input     F   Carry for set for write, reset for read
     111.  02:778B                      ;           A   Drive number
     112.  02:778B                      ;           B   Number of sectors to read/write
     113.  02:778B                      ;           C   Media descriptor
     114.  02:778B                      ;           DE  Logical sector number
     115.  02:778B                      ;           HL  Transfer address
     116.  02:778B                      ; Output    F   Carry set when not succesfull
     117.  02:778B                      ;           A   Error code
     118.  02:778B                      ;           B   Number of remaining sectors (TODO: check! even without error?)
     119.  02:778B                      
     120.  02:778B                              DEBUGMESSAGE "DSKIO"
     120.  02:778B                    >         ifdef DEBUG
     120.  02:778B  52                >         ld d,d
     120.  02:778C  18 05             >         jr .skip
     120.  02:778E  44 53 4B 49 4F    >         db string
     120.  02:7793                    > .skip:
     120.  02:7793                    >         endif
     121.  02:7793  F5                          push af
     122.  02:7794  CD 80 77                    call checkWorkArea
     123.  02:7797  CA FA 7C                    jp z,ROMDISK_DSKIO
     124.  02:779A  F1                          pop af
     125.  02:779B                      
     126.  02:779B  CD 7C 74                    call sendRegisters
     127.  02:779E  36 80                       ld (hl),C_DSKIO
     128.  02:77A0  38 58                       jr c,dskioWrite                 ; read or write?
     129.  02:77A2                             
     130.  02:77A2                      dskioRead:
     131.  02:77A2  07                          rlca                            ; < 0x8000 ?
     132.  02:77A3  38 3F                       jr c,.page2and3
     133.  02:77A5                      
     134.  02:77A5                              DEBUGMESSAGE "read01"
     134.  02:77A5                    >         ifdef DEBUG
     134.  02:77A5  52                >         ld d,d
     134.  02:77A6  18 06             >         jr .skip
     134.  02:77A8  72 65 61 64 30 31 >         db string
     134.  02:77AE                    > .skip:
     134.  02:77AE                    >         endif
     135.  02:77AE  CD 73 76                    call getSlotPage2               ; enable nowind in page 2
     136.  02:77B1  F5                          push af
     137.  02:77B2  CD 68 76                    call getSlotPage1
     138.  02:77B5  DD 67                       ld ixh,a                        ; ixh = current nowind slot
     139.  02:77B7  26 80                       ld h,$80
     140.  02:77B9  CD 24 00                    call ENASLT
     141.  02:77BC  C3 BF B7                    jp .page2
     142.  02:77BF                              
     143.  02:77BF  (B7BF)                      PHASE $ + $4000
     144.  02:B7BF                      .page2:
     145.  02:B7BF  3A 42 F3                    ld a,(RAMAD1)                   ; enable RAM in page 1
     146.  02:B7C2  26 40                       ld h,$40
     147.  02:B7C4  CD 24 00                    call ENASLT
     148.  02:B7C7                              
     149.  02:B7C7  CD 3A B9                    call readSectors01 
     150.  02:B7CA                              ; TODO: carry checken?----------------------------------------------!!!!!!!!!!!!!!!
     151.  02:B7CA                              
     152.  02:B7CA  DD 7C                       ld a,ixh                        ; enable nowind in page 1 
     153.  02:B7CC  26 40                       ld h,$40
     154.  02:B7CE  CD 24 00                    call ENASLT
     155.  02:B7D1  C3 D4 77                    jp .page1        
     156.  02:B7D4                      
     157.  02:B7D4  (77D4)                      DEPHASE
     158.  02:77D4                      .page1:
     159.  02:77D4  3A 00 80                    ld a,(usb2)
     160.  02:77D7  DD 67                       ld ixh,a
     161.  02:77D9  F1                          pop af
     162.  02:77DA  26 80                       ld h,$80
     163.  02:77DC  CD 24 00                    call ENASLT                     ; restore page 2
     164.  02:77DF  DD 7C                       ld a,ixh
     165.  02:77E1  B7                          or a
     166.  02:77E2  FB                          ei
     167.  02:77E3  C8                          ret z                           ; nothing more to read
     168.  02:77E4                                      
     169.  02:77E4                      .page2and3:                     
     170.  02:77E4                              DEBUGMESSAGE "read23"
     170.  02:77E4                    >         ifdef DEBUG
     170.  02:77E4  52                >         ld d,d
     170.  02:77E5  18 06             >         jr .skip
     170.  02:77E7  72 65 61 64 32 33 >         db string
     170.  02:77ED                    > .skip:
     170.  02:77ED                    >         endif
     171.  02:77ED  CD 0D 76                    call enableNowindPage0
     172.  02:77F0  FD E5                       push iy
     173.  02:77F2  CD 8D 79                    call readSectors23
     174.  02:77F5  FD E1                       pop iy
     175.  02:77F7  C3 18 76                    jp restorePage0
     176.  02:77FA                      
     177.  02:77FA                      dskioWrite:
     178.  02:77FA                              DEBUGMESSAGE "dskwrite"
     178.  02:77FA                    >         ifdef DEBUG
     178.  02:77FA  52                >         ld d,d
     178.  02:77FB  18 08             >         jr .skip
     178.  02:77FD                    >         db string
     178.  02:77FD  64 73 6B 77 72 69 74 65 
     178.  02:7805                    > .skip:
     178.  02:7805                    >         endif
     179.  02:7805  07                          rlca
     180.  02:7806  38 3E                       jr c,.page2and3        
     181.  02:7808                              
     182.  02:7808                              ;call enableNowindPage2 (todo: make common routine?) 
     183.  02:7808  CD 73 76                    call getSlotPage2               ; save current slot page 2
     184.  02:780B  DD 67                       ld ixh,a
     185.  02:780D  CD 68 76                    call getSlotPage1
     186.  02:7810  DD 6F                       ld ixl,a
     187.  02:7812  26 80                       ld h,$80
     188.  02:7814  CD 24 00                    call ENASLT                     ; nowind in page 2
     189.  02:7817  C3 1A B8                    jp .page2
     190.  02:781A                      
     191.  02:781A  (B81A)                      PHASE $ + $4000
     192.  02:B81A                      .page2:
     193.  02:B81A  3A 42 F3                    ld a,(RAMAD1)
     194.  02:B81D  26 40                       ld h,$40
     195.  02:B81F  CD 24 00                    call ENASLT                     ; ram in page 1
     196.  02:B822                              
     197.  02:B822  CD 68 B9                    call writeLoop01
     198.  02:B825  F5                          push af
     199.  02:B826                              
     200.  02:B826  DD 7D                       ld a,ixl
     201.  02:B828  26 40                       ld h,$40
     202.  02:B82A  CD 24 00                    call ENASLT                     ; restore nowind in page 1
     203.  02:B82D  C3 30 78                    jp .page1
     204.  02:B830                              
     205.  02:B830  (7830)                      DEPHASE
     206.  02:7830                      .page1:
     207.  02:7830  DD 7C                       ld a,ixh
     208.  02:7832  26 80                       ld h,$80
     209.  02:7834  CD 24 00                    call ENASLT
     210.  02:7837  F1                          pop af
     211.  02:7838  D8                          ret c                           ; return error (error code in a)
     212.  02:7839  E8                          ret pe                          ; host returns 0xfe when data for page 2/3 is available
     213.  02:783A                              DEBUGMESSAGE "doorgaan!"
     213.  02:783A                    >         ifdef DEBUG
     213.  02:783A  52                >         ld d,d
     213.  02:783B  18 09             >         jr .skip
     213.  02:783D                    >         db string
     213.  02:783D  64 6F 6F 72 67 61 61 6E 21 
     213.  02:7846                    > .skip:
     213.  02:7846                    >         endif
     214.  02:7846                              
     215.  02:7846                      .page2and3:
     216.  02:7846                              DEBUGMESSAGE "page2and3"
     216.  02:7846                    >         ifdef DEBUG
     216.  02:7846  52                >         ld d,d
     216.  02:7847  18 09             >         jr .skip
     216.  02:7849                    >         db string
     216.  02:7849  70 61 67 65 32 61 6E 64 33 
     216.  02:7852                    > .skip:
     216.  02:7852                    >         endif
     217.  02:7852  CD 0D 76                    call enableNowindPage0
     218.  02:7855  CD 5B 78                    call .writeLoop23
     219.  02:7858  C3 18 76                    jp restorePage0
     220.  02:785B                              
     221.  02:785B                      .writeLoop23:
     222.  02:785B                              DEBUGMESSAGE "writeLoop23"
     222.  02:785B                    >         ifdef DEBUG
     222.  02:785B  52                >         ld d,d
     222.  02:785C  18 0B             >         jr .skip
     222.  02:785E                    >         db string
     222.  02:785E  77 72 69 74 65 4C 6F 6F 70 32 33 
     222.  02:7869                    > .skip:
     222.  02:7869                    >         endif
     223.  02:7869                              
     224.  02:7869  26 20                       ld h,HIGH usbrd
     225.  02:786B  CD 8E 74                    call getHeader
     226.  02:786E  D8                          ret c                           ; exit (not ready)
     227.  02:786F  B7                          or a
     228.  02:7870  F8                          ret m                           ; exit (no error)
     229.  02:7871  20 18                       jr nz,.error
     230.  02:7873                      
     231.  02:7873                              DEBUGMESSAGE "send23"
     231.  02:7873                    >         ifdef DEBUG
     231.  02:7873  52                >         ld d,d
     231.  02:7874  18 06             >         jr .skip
     231.  02:7876  73 65 6E 64 32 33 >         db string
     231.  02:787C                    > .skip:
     231.  02:787C                    >         endif
     232.  02:787C  5E                          ld e,(hl)                       ; address
     233.  02:787D  56                          ld d,(hl)
     234.  02:787E  4E                          ld c,(hl)                       ; number of bytes        
     235.  02:787F  46                          ld b,(hl)
     236.  02:7880  7E                          ld a,(hl)                       ; block sequence number
     237.  02:7881                              
     238.  02:7881                              ;DEBUGDUMPREGISTERS
     239.  02:7881  EB                          ex de,hl
     240.  02:7882  11 00 40                    ld de,usbwr
     241.  02:7885  12                          ld (de),a                       ; mark block begin
     242.  02:7886  ED B0                       ldir
     243.  02:7888  12                          ld (de),a                       ; mark block end
     244.  02:7889  18 D0                       jr .writeLoop23
     245.  02:788B                      
     246.  02:788B  37                  .error: scf
     247.  02:788C  7E                          ld a,(hl)                       ; get error code
     248.  02:788D  C9                          ret
     249.  02:788E                      
     250.  02:788E                                     
     251.  02:788E                      DSKCHG:
     252.  02:788E                      ; Input     A   Drive number
     253.  02:788E                      ;           B   0
     254.  02:788E                      ;           C   Media descriptor (previous)
     255.  02:788E                      ;           HL  Base address of DPB
     256.  02:788E                      ; Output    B   1   Disk unchanged
     257.  02:788E                      ;               0   Unknown (DPB is updated)
     258.  02:788E                      ;               -1  Disk changed (DPB is updated)
     259.  02:788E                      ;           F   Carry set when not succesfull
     260.  02:788E                      ;           A   Error code
     261.  02:788E                      
     262.  02:788E                              DEBUGMESSAGE "DSKCHG"
     262.  02:788E                    >         ifdef DEBUG
     262.  02:788E  52                >         ld d,d
     262.  02:788F  18 06             >         jr .skip
     262.  02:7891  44 53 4B 43 48 47 >         db string
     262.  02:7897                    > .skip:
     262.  02:7897                    >         endif
     263.  02:7897  F5                          push af
     264.  02:7898  CD 80 77                    call checkWorkArea
     265.  02:789B  CA 59 7D                    jp z,ROMDISK_DSKCHG
     266.  02:789E  F1                          pop af       
     267.  02:789F                      
     268.  02:789F  E5                          push hl
     269.  02:78A0  CD 7C 74                    call sendRegisters
     270.  02:78A3  36 81                       ld (hl),C_DSKCHG
     271.  02:78A5  CD 0D 76                    call enableNowindPage0
     272.  02:78A8  26 20                       ld h,HIGH usbrd
     273.  02:78AA  CD 8E 74                    call getHeader
     274.  02:78AD  4E                          ld c,(hl)               ; media descriptor (when disk was changed)
     275.  02:78AE  F5                          push af
     276.  02:78AF  C5                          push bc
     277.  02:78B0  CD 18 76                    call restorePage0
     278.  02:78B3  C1                          pop bc
     279.  02:78B4  F1                          pop af
     280.  02:78B5  E1                          pop hl
     281.  02:78B6  D8                          ret c           ; not ready
     282.  02:78B7  B7                          or a
     283.  02:78B8  06 01                       ld b,1
     284.  02:78BA  C8                          ret z           ; not changed
     285.  02:78BB  41                          ld b,c
     286.  02:78BC  CD C5 78                    call GETDPB
     287.  02:78BF  3E 0A                       ld a,10
     288.  02:78C1  D8                          ret c
     289.  02:78C2  06 FF                       ld b,255
     290.  02:78C4  C9                          ret
     291.  02:78C5                      
     292.  02:78C5                      GETDPB:
     293.  02:78C5                      ; Input     A   Drive number
     294.  02:78C5                      ;           B   Media descriptor (first byte of FAT)
     295.  02:78C5                      ;           C   Previous media descriptor (does not seem to be used in other drivers)
     296.  02:78C5                      ;           HL  Base address of HL
     297.  02:78C5                      ; Output    DPB for specified drive in [HL+1]..[HL+18]
     298.  02:78C5                      
     299.  02:78C5                              DEBUGMESSAGE "GETDPB"
     299.  02:78C5                    >         ifdef DEBUG
     299.  02:78C5  52                >         ld d,d
     299.  02:78C6  18 06             >         jr .skip
     299.  02:78C8  47 45 54 44 50 42 >         db string
     299.  02:78CE                    > .skip:
     299.  02:78CE                    >         endif
     300.  02:78CE  EB                          ex de,hl
     301.  02:78CF  13                          inc de
     302.  02:78D0  67                          ld h,a
     303.  02:78D1  78                          ld a,b
     304.  02:78D2  FE F0                       cp $f0
     305.  02:78D4  7C                          ld a,h
     306.  02:78D5  28 24                       jr z,.hddImage
     307.  02:78D7                              
     308.  02:78D7                              MESSAGE "ROM GETDPB"
     308.  02:78D7  CD BC 74          >         call sendMessage
     308.  02:78DA                    >         db string
     308.  02:78DA  52 4F 4D 20 47 45 54 44 50 42 
     308.  02:78E4  00                > .skip2: nop
     309.  02:78E5                      
     310.  02:78E5  78                          ld a,b
     311.  02:78E6  D6 F8                       sub $f8
     312.  02:78E8  D8                          ret c                           ; not supported in msxdos1
     313.  02:78E9  07                          rlca                            ; 2x
     314.  02:78EA  4F                          ld c,a
     315.  02:78EB  07                          rlca                            ; 4x
     316.  02:78EC  07                          rlca                            ; 8x
     317.  02:78ED  07                          rlca                            ; 16x
     318.  02:78EE  81                          add a,c                         ; 18x
     319.  02:78EF  4F                          ld c,a
     320.  02:78F0  06 00                       ld b,0        
     321.  02:78F2  21 6A 7C                    ld hl,supportedMedia
     322.  02:78F5  09                          add hl,bc
     323.  02:78F6  0E 12                       ld c,18
     324.  02:78F8  ED B0                       ldir
     325.  02:78FA  C9                          ret
     326.  02:78FB                      
     327.  02:78FB                      .hddImage:
     328.  02:78FB                              DEBUGMESSAGE ".hddImage"
     328.  02:78FB                    >         ifdef DEBUG
     328.  02:78FB  52                >         ld d,d
     328.  02:78FC  18 09             >         jr .skip
     328.  02:78FE                    >         db string
     328.  02:78FE  2E 68 64 64 49 6D 61 67 65 
     328.  02:7907                    > .skip:
     328.  02:7907                    >         endif
     329.  02:7907                                      MESSAGE "HOST GETDPB"
     329.  02:7907  CD BC 74          >         call sendMessage
     329.  02:790A                    >         db string
     329.  02:790A  48 4F 53 54 20 47 45 54 44 50 42 
     329.  02:7915  00                > .skip2: nop
     330.  02:7916  CD 7C 74                    call sendRegisters
     331.  02:7919  36 82                       ld (hl),C_GETDPB
     332.  02:791B  CD 0D 76                    call enableNowindPage0
     333.  02:791E  26 20                       ld h,HIGH usbrd
     334.  02:7920  CD 8E 74                    call getHeader
     335.  02:7923  38 09                       jr c,.exit                      ; not ready
     336.  02:7925  5F                          ld e,a                          ; destination
     337.  02:7926  56                          ld d,(hl)
     338.  02:7927  01 12 00                    ld bc,18
     339.  02:792A                              DEBUGDUMPREGISTERS
     339.  02:792A                    >         ifdef DEBUG
     339.  02:792A  ED 07             >         db $ed,7
     339.  02:792C                    >         endif
     339.  02:792C                    >         
     339.  02:792C                    >         ifdef USBDEBUG
     339.  02:792C                    ~         assert ($ < $8000)
     339.  02:792C                    ~         call sendCpuInfo
     339.  02:792C                    ~         endif
     340.  02:792C  ED B0                       ldir
     341.  02:792E                              ;DB $ed, $0a       
     342.  02:792E  C3 18 76            .exit:  jp restorePage0        
     343.  02:7931                      
     344.  02:7931                      CHOICE:
     345.  02:7931                              ;DEBUGMESSAGE "CHOICE"
     346.  02:7931                              ifdef MSXDOS2
     347.  02:7931                    ~         ld hl,.noFormat
     348.  02:7931                    ~         else
     349.  02:7931  21 00 00                    ld hl,0                         ; no choice
     350.  02:7934                              endif
     351.  02:7934  C9                          ret
     352.  02:7935                      
     353.  02:7935                      .noFormat:
     354.  02:7935  00                          db 0
     355.  02:7936                      
     356.  02:7936                      DSKFMT:
     357.  02:7936  37                          scf
     358.  02:7937  3E 10                       ld a,16                         ; other error
     359.  02:7939  C9                          ret
     360.  02:793A                              
     361.  02:793A  (B93A)                      PHASE $ + $4000
     362.  02:B93A                              
     363.  02:B93A                      readSectors01:
     364.  02:B93A                              DEBUGMESSAGE "readSectors01"
     364.  02:B93A                    >         ifdef DEBUG
     364.  02:B93A  52                >         ld d,d
     364.  02:B93B  18 0D             >         jr .skip
     364.  02:B93D                    >         db string
     364.  02:B93D  72 65 61 64 53 65 63 74 6F 72 73 30 31 
     364.  02:B94A                    > .skip:
     364.  02:B94A                    >         endif
     365.  02:B94A  26 80                       ld h,HIGH usb2
     366.  02:B94C  CD 8E B4                    call getHeader + $4000                                  
     367.  02:B94F  D8                          ret c                           ; carry means timeout, no carry: A == 0 means slow transfer, A == 1 means exit, A == 2 means fast transfer                                      
     368.  02:B950  3D                          dec a
     369.  02:B951  C8                          ret z
     370.  02:B952  FA 5C B9                    jp m,.slowTransfer                              
     371.  02:B955  CD CE B9                    call reverseTransfer + $4000
     372.  02:B958  70                          ld (hl),b
     373.  02:B959  71                          ld (hl),c
     374.  02:B95A  18 DE                       jr readSectors01
     375.  02:B95C                      
     376.  02:B95C                      .slowTransfer:
     377.  02:B95C  5E                          ld e,(hl)                       ; transfer address
     378.  02:B95D  56                          ld d,(hl)
     379.  02:B95E  4E                          ld c,(hl)                       ; transfer amount 
     380.  02:B95F  46                          ld b,(hl)
     381.  02:B960  ED B0                       ldir        
     382.  02:B962                              
     383.  02:B962  56                          ld d,(hl)                       ; BUG in emulator (byte direct terugschrijven, geeft 'rukkert!')
     384.  02:B963  7E                          ld a,(hl)
     385.  02:B964  72                          ld (hl),d                       ; return end marker ($af, $0f)
     386.  02:B965  77                          ld (hl),a
     387.  02:B966  18 D2                       jr readSectors01
     388.  02:B968                      
     389.  02:B968                      writeLoop01:
     390.  02:B968  26 80                       ld h,HIGH usb2
     391.  02:B96A  CD 8E B4                    call getHeader + $4000
     392.  02:B96D  D8                          ret c                           ; exit (not ready)
     393.  02:B96E  B7                          or a
     394.  02:B96F  F8                          ret m                           ; exit (no error)
     395.  02:B970  20 18                       jr nz,.error
     396.  02:B972                      
     397.  02:B972                              DEBUGMESSAGE "send01"
     397.  02:B972                    >         ifdef DEBUG
     397.  02:B972  52                >         ld d,d
     397.  02:B973  18 06             >         jr .skip
     397.  02:B975  73 65 6E 64 30 31 >         db string
     397.  02:B97B                    > .skip:
     397.  02:B97B                    >         endif
     398.  02:B97B  5E                          ld e,(hl)                       ; address
     399.  02:B97C  56                          ld d,(hl)
     400.  02:B97D  4E                          ld c,(hl)                       ; number of bytes        
     401.  02:B97E  46                          ld b,(hl)
     402.  02:B97F  7E                          ld a,(hl)                       ; block sequence number
     403.  02:B980                      
     404.  02:B980  EB                          ex de,hl
     405.  02:B981  11 00 80                    ld de,usb2
     406.  02:B984  12                          ld (de),a                       ; mark block begin
     407.  02:B985  ED B0                       ldir
     408.  02:B987  12                          ld (de),a                       ; mark block end
     409.  02:B988  18 DE                       jr writeLoop01
     410.  02:B98A                      
     411.  02:B98A  37                  .error: scf
     412.  02:B98B  7E                          ld a,(hl)                       ; get error code
     413.  02:B98C  C9                          ret
     414.  02:B98D                      
     415.  02:B98D  (798D)                      DEPHASE
     416.  02:798D                       
     417.  02:798D                      readSectors23:
     418.  02:798D                              DEBUGMESSAGE "readSectors23"
     418.  02:798D                    >         ifdef DEBUG
     418.  02:798D  52                >         ld d,d
     418.  02:798E  18 0D             >         jr .skip
     418.  02:7990                    >         db string
     418.  02:7990  72 65 61 64 53 65 63 74 6F 72 73 32 33 
     418.  02:799D                    > .skip:
     418.  02:799D                    >         endif
     419.  02:799D  26 20                       ld h,HIGH usbrd
     420.  02:799F  CD 8E 74                    call getHeader
     421.  02:79A2  D8                          ret c
     422.  02:79A3  3D                          dec a
     423.  02:79A4  C8                          ret z                           ; no more data
     424.  02:79A5  FA B1 79                    jp m,.slowTransfer        
     425.  02:79A8  CD CE 79                    call reverseTransfer
     426.  02:79AB  26 40                       ld h,HIGH usbwr 
     427.  02:79AD  70                          ld (hl),b
     428.  02:79AE  71                          ld (hl),c
     429.  02:79AF  18 DC                       jr readSectors23
     430.  02:79B1                      
     431.  02:79B1                      .slowTransfer:
     432.  02:79B1                              DEBUGMESSAGE "slowtransfer"
     432.  02:79B1                    >         ifdef DEBUG
     432.  02:79B1  52                >         ld d,d
     432.  02:79B2  18 0C             >         jr .skip
     432.  02:79B4                    >         db string
     432.  02:79B4  73 6C 6F 77 74 72 61 6E 73 66 65 72 
     432.  02:79C0                    > .skip:
     432.  02:79C0                    >         endif
     433.  02:79C0  5E                          ld e,(hl)                       ; transfer address
     434.  02:79C1  56                          ld d,(hl)
     435.  02:79C2  4E                          ld c,(hl)                       ; transfer amount 
     436.  02:79C3  46                          ld b,(hl)
     437.  02:79C4  ED B0                       ldir
     438.  02:79C6  56                          ld d,(hl)
     439.  02:79C7  7E                          ld a,(hl)
     440.  02:79C8  26 40                       ld h,HIGH usbwr
     441.  02:79CA  72                          ld (hl),d                       ; return end marker ($af, $0f)
     442.  02:79CB  77                          ld (hl),a
     443.  02:79CC  18 BF                       jr readSectors23
     444.  02:79CE                                     
     445.  02:79CE                      reverseTransfer:
     446.  02:79CE  FD 21 00 00                 ld iy,0                         ; save stack pointer
     447.  02:79D2  FD 39                       add iy,sp
     448.  02:79D4  5E                          ld e,(hl)                       ; transfer address
     449.  02:79D5  56                          ld d,(hl)
     450.  02:79D6  EB                          ex de,hl
     451.  02:79D7  F9                          ld sp,hl
     452.  02:79D8  EB                          ex de,hl
     453.  02:79D9  46                          ld b,(hl)                       ; number of loops       
     454.  02:79DA                      .loop:
     455.  02:79DA                              repeat 32                       ; blocks of 64 bytes hardcoded (NowindHost.cpp)
     456.  02:79DA                    <         ld d,(hl)
     457.  02:79DA                    <         ld e,(hl)
     458.  02:79DA                    <         push de
     459.  02:79DA                    <         endrepeat
     459.  02:79DA  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     459.  02:79EA  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     459.  02:79FA  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     459.  02:7A0A  56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 
     459.  02:7A1A  5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E 
     459.  02:7A2A  D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 56 5E D5 
     460.  02:7A3A  10 9E                       djnz .loop
     461.  02:7A3C                              
     462.  02:7A3C  FD F9                       ld sp,iy                        ; restore stack pointer
     463.  02:7A3E  46                          ld b,(hl)                       ; return end marker
     464.  02:7A3F  4E                          ld c,(hl)
     465.  02:7A40  C9                          ret
     466.  02:7A41                            
     467.  02:7A41                      OEMSTA:
     468.  02:7A41  E5                          push hl
     469.  02:7A42  21 4F 7A                    ld hl,.statement
     470.  02:7A45  CD 50 74                    call findStatementName
     471.  02:7A48  5E                          ld e,(hl)
     472.  02:7A49  23                          inc hl
     473.  02:7A4A  56                          ld d,(hl)
     474.  02:7A4B  E1                          pop hl        
     475.  02:7A4C  D8                          ret c
     476.  02:7A4D  D5                          push de
     477.  02:7A4E  C9                          ret
     478.  02:7A4F                      
     479.  02:7A4F                      .statement:
     480.  02:7A4F  49 4D 41 47 45 00           db "IMAGE",0
     481.  02:7A55  62 7A                       dw changeImage
     482.  02:7A57                              db "VSTREAM",0
     482.  02:7A57  56 53 54 52 45 41 4D 00 
     483.  02:7A5F  8F 7A                       dw videoStream
     484.  02:7A61  00                          db 0
     485.  02:7A62                      
     486.  02:7A62                      ; send arguments, command, filename, end with ":"
     487.  02:7A62                      changeImage:
     488.  02:7A62                              DEBUGMESSAGE "changeImage"
     488.  02:7A62                    >         ifdef DEBUG
     488.  02:7A62  52                >         ld d,d
     488.  02:7A63  18 0B             >         jr .skip
     488.  02:7A65                    >         db string
     488.  02:7A65  63 68 61 6E 67 65 49 6D 61 67 65 
     488.  02:7A70                    > .skip:
     488.  02:7A70                    >         endif
     489.  02:7A70  E5                          push hl
     490.  02:7A71  CD 7C 74                    call sendRegisters
     491.  02:7A74  36 91                       ld (hl),C_CHANGEIMAGE
     492.  02:7A76  E1                          pop hl
     493.  02:7A77                              
     494.  02:7A77                      call_exit:
     495.  02:7A77                              DEBUGMESSAGE "call_exit"
     495.  02:7A77                    >         ifdef DEBUG
     495.  02:7A77  52                >         ld d,d
     495.  02:7A78  18 09             >         jr .skip
     495.  02:7A7A                    >         db string
     495.  02:7A7A  63 61 6C 6C 5F 65 78 69 74 
     495.  02:7A83                    > .skip:
     495.  02:7A83                    >         endif
     496.  02:7A83  7E                  .loop:  ld a,(hl)
     497.  02:7A84  32 00 40                    ld (usbwr),a
     498.  02:7A87  FE 3A                       cp ":"
     499.  02:7A89  C8                          ret z
     500.  02:7A8A  B7                          or a
     501.  02:7A8B  C8                          ret z
     502.  02:7A8C  23                          inc hl
     503.  02:7A8D  18 F4                       jr .loop
     504.  02:7A8F                              
     505.  02:7A8F                      videoStream: 
     506.  02:7A8F  E5                          push hl
     507.  02:7A90                              include "vram.asm"
       1:  02:7A90                              
       2:  02:7A90                      vramDump:
       3:  02:7A90  F3                  	di
       4:  02:7A91  CD 0D 76                    call enableNowindPage0
       5:  02:7A94                      
       6:  02:7A94  3E 02                       ld a,2
       7:  02:7A96  D3 99                       out ($99),a
       8:  02:7A98  3E 8F                       ld a,$80+15             ; status register pointer at S#2
       9:  02:7A9A  D3 99                       out ($99),a
      10:  02:7A9C                      
      11:  02:7A9C                      evenFrame:
      12:  02:7A9C                              ; vram address 0x0000
      13:  02:7A9C                              
      14:  02:7A9C                              ;xor a
      15:  02:7A9C                              ;out ($99),a
      16:  02:7A9C                              ;ld a,$80+2
      17:  02:7A9C                              ;out ($99),a
      18:  02:7A9C                              
      19:  02:7A9C  3E 03                       ld a,%00000011                 ; pattern generator table
      20:  02:7A9E  D3 99                       out ($99),a
      21:  02:7AA0  3E 84                       ld a,$80+4
      22:  02:7AA2  D3 99                       out ($99),a
      23:  02:7AA4                      
      24:  02:7AA4  AF                          xor a                   ; color table high
      25:  02:7AA5  D3 99                       out ($99),a
      26:  02:7AA7  3E 8A                       ld a,$80+10
      27:  02:7AA9  D3 99                       out ($99),a
      28:  02:7AAB                              
      29:  02:7AAB  3E 04                       ld a,%00000100          ; vram access at 0x10000
      30:  02:7AAD  CD 41 7C                    call setVramAccessPointer
      31:  02:7AB0  CD D9 7A                    call tranferframe
      32:  02:7AB3  CD 4F 7C                    call waitForRetrace
      33:  02:7AB6  CD F3 7B                    call changeColors
      34:  02:7AB9                      
      35:  02:7AB9                      oddFrame:
      36:  02:7AB9                              ; vram address 0x10000
      37:  02:7AB9                      
      38:  02:7AB9                              ;ld a,%01000000
      39:  02:7AB9                              ;out ($99),a
      40:  02:7AB9                              ;ld a,$80+2
      41:  02:7AB9                              ;out ($99),a
      42:  02:7AB9                      
      43:  02:7AB9  3E 23                       ld a,%00100011          ; pattern generator table
      44:  02:7ABB  D3 99                       out ($99),a
      45:  02:7ABD  3E 84                       ld a,$80+4
      46:  02:7ABF  D3 99                       out ($99),a
      47:  02:7AC1                      
      48:  02:7AC1  3E 64                       ld a,00000100           ; color table high
      49:  02:7AC3  D3 99                       out ($99),a
      50:  02:7AC5  3E 8A                       ld a,$80+10
      51:  02:7AC7  D3 99                       out ($99),a
      52:  02:7AC9                      
      53:  02:7AC9  AF                          xor a
      54:  02:7ACA  CD 41 7C                    call setVramAccessPointer
      55:  02:7ACD  CD D9 7A                    call tranferframe
      56:  02:7AD0  CD 4F 7C                    call waitForRetrace
      57:  02:7AD3  CD F3 7B                    call changeColors
      58:  02:7AD6  C3 9C 7A                    jp evenFrame
      59:  02:7AD9                      
      60:  02:7AD9                      tranferframe:
      61:  02:7AD9  CD 7C 74                    call sendRegisters
      62:  02:7ADC  36 FF                       ld (hl),255
      63:  02:7ADE                                      
      64:  02:7ADE  21 00 20                    ld hl,usbrd
      65:  02:7AE1  CD 8E 74                    call getHeader
      66:  02:7AE4                              
      67:  02:7AE4  16 70                       ld d,112			; 224x64 is 1 screen 2 page of data ($3800)
      68:  02:7AE6                      write_more:        
      69:  02:7AE6  21 00 20            	ld hl,usbrd
      70:  02:7AE9  01 98 00                    ld bc,$0098
      71:  02:7AEC                              repeat 128
      72:  02:7AEC                    <         outi
      73:  02:7AEC                    <         endrepeat
      73:  02:7AEC  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7AFC  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B0C  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B1C  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B2C  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B3C  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B4C  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B5C  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B6C  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B7C  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B8C  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7B9C  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BAC  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BBC  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BCC  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      73:  02:7BDC  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      74:  02:7BEC                      
      75:  02:7BEC  15                          dec d
      76:  02:7BED  7A                          ld a,d
      77:  02:7BEE  B7                          or a
      78:  02:7BEF  C2 E6 7A                    jp nz,write_more
      79:  02:7BF2  C9                          ret		
      80:  02:7BF3                      
      81:  02:7BF3                      changeColors:
      82:  02:7BF3  AF                          xor a			; set color register pointer to zero
      83:  02:7BF4  D3 99                       out ($99),a
      84:  02:7BF6  3E 90                       ld a,$80+16
      85:  02:7BF8  D3 99                       out ($99),a
      86:  02:7BFA                              
      87:  02:7BFA  21 00 20                    ld hl,usbrd
      88:  02:7BFD  01 9A 00                    ld bc,$009A		; write to color register
      89:  02:7C00                      
      90:  02:7C00                              repeat 32
      91:  02:7C00                    <         outi
      92:  02:7C00                    <         endrepeat		
      92:  02:7C00  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  02:7C10  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  02:7C20  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      92:  02:7C30  ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 ED A3 
      93:  02:7C40  C9                          ret
      94:  02:7C41                      
      95:  02:7C41                      	
      96:  02:7C41                      setVramAccessPointer:
      97:  02:7C41  D3 99                       out ($99),a
      98:  02:7C43  3E 8E                       ld a,$80+14
      99:  02:7C45  D3 99                       out ($99),a
     100:  02:7C47  AF                          xor a
     101:  02:7C48  D3 99                       out ($99),a
     102:  02:7C4A  3E 40                       ld a,%01000000		; vram write
     103:  02:7C4C  D3 99                       out ($99),a
     104:  02:7C4E  C9                          ret
     105:  02:7C4F                      
     106:  02:7C4F                      waitForRetrace:
     107:  02:7C4F  DB 99                       in a,($99)
     108:  02:7C51  CB 77                       bit 6,a
     109:  02:7C53  20 FA                       jr nz,waitForRetrace       
     110:  02:7C55                      .lp2:        
     111:  02:7C55  DB 99                       in a,($99)
     112:  02:7C57  CB 77                       bit 6,a
     113:  02:7C59  28 FA                       jr z,.lp2       
     114:  02:7C5B  C9                          ret
     115:  02:7C5C                              	
     116:  02:7C5C                      	; just let it go... 
     508.  02:7C5C  E1                          pop hl
     509.  02:7C5D  C3 77 7A                    jp call_exit
     510.  02:7C60                              
     511.  02:7C60                      ; hl points to text
     512.  02:7C60                      printVdpText2:
     513.  02:7C60  F5                                                  push af
     514.  02:7C61  7E                  .loop:  ld a,(hl)
     515.  02:7C62  D3 98                                               out ($98),a 
     516.  02:7C64  23                                                  inc hl
     517.  02:7C65  B7                                                  or a
     518.  02:7C66  20 F9                                               jr nz,.loop
     519.  02:7C68  F1                                                  pop af
     520.  02:7C69  C9                                                  ret
     521.  02:7C6A                              
     522.  02:7C6A                      supportedMedia:
     523.  02:7C6A                                      
     524.  02:7C6A                      .f8:    MAKEDPB $f8, 512, 2, 112, 1 * 80 * 9, 2, 2      ; 360 kB (1 side * 80 tracks * 9 tracks/sector)
     524.  02:7C6A  (02:0001)         > .firfat equ 1
     524.  02:7C6A  (02:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     524.  02:7C6A  (02:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     524.  02:7C6A                    >         if sectorSize = 512
     524.  02:7C6A  (02:0004)         > .shft   equ 4
     524.  02:7C6A                    >         elseif sectorSize = 256
     524.  02:7C6A                    ~ .shft   equ 3
     524.  02:7C6A                    ~         endif
     524.  02:7C6A                    >         
     524.  02:7C6A  F8                >         db media
     524.  02:7C6B  00 02             >         dw sectorSize
     524.  02:7C6D  0F 04             >         db (sectorSize/32)-1, .shft
     524.  02:7C6F  01                >         db sectorsPerCluster-1
     524.  02:7C70  02                >         db sectorsPerCluster
     524.  02:7C71  01 00             >         dw .firfat
     524.  02:7C73  02 70             >         db fatCount, maxEnt
     524.  02:7C75  0C 00             >         dw .firrec
     524.  02:7C77  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     524.  02:7C79  02                >         db fatSiz
     524.  02:7C7A  05 00             >         dw .firdir
     525.  02:7C7C                      .def:   MAKEDPB $f9, 512, 2, 112, 2 * 80 * 9, 3, 2      ; 720 kB
     525.  02:7C7C  (02:0001)         > .firfat equ 1
     525.  02:7C7C  (02:0007)         > .firdir equ .firfat+(fatCount*fatSiz)
     525.  02:7C7C  (02:000E)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     525.  02:7C7C                    >         if sectorSize = 512
     525.  02:7C7C  (02:0004)         > .shft   equ 4
     525.  02:7C7C                    >         elseif sectorSize = 256
     525.  02:7C7C                    ~ .shft   equ 3
     525.  02:7C7C                    ~         endif
     525.  02:7C7C                    >         
     525.  02:7C7C  F9                >         db media
     525.  02:7C7D  00 02             >         dw sectorSize
     525.  02:7C7F  0F 04             >         db (sectorSize/32)-1, .shft
     525.  02:7C81  01                >         db sectorsPerCluster-1
     525.  02:7C82  02                >         db sectorsPerCluster
     525.  02:7C83  01 00             >         dw .firfat
     525.  02:7C85  02 70             >         db fatCount, maxEnt
     525.  02:7C87  0E 00             >         dw .firrec
     525.  02:7C89  CA 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     525.  02:7C8B  03                >         db fatSiz
     525.  02:7C8C  07 00             >         dw .firdir
     526.  02:7C8E                              MAKEDPB $fa, 512, 2, 112, 1 * 80 * 8, 1, 2      ; 320 kB
     526.  02:7C8E  (02:0001)         > .firfat equ 1
     526.  02:7C8E  (02:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     526.  02:7C8E  (02:000A)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     526.  02:7C8E                    >         if sectorSize = 512
     526.  02:7C8E  (02:0004)         > .shft   equ 4
     526.  02:7C8E                    >         elseif sectorSize = 256
     526.  02:7C8E                    ~ .shft   equ 3
     526.  02:7C8E                    ~         endif
     526.  02:7C8E                    >         
     526.  02:7C8E  FA                >         db media
     526.  02:7C8F  00 02             >         dw sectorSize
     526.  02:7C91  0F 04             >         db (sectorSize/32)-1, .shft
     526.  02:7C93  01                >         db sectorsPerCluster-1
     526.  02:7C94  02                >         db sectorsPerCluster
     526.  02:7C95  01 00             >         dw .firfat
     526.  02:7C97  02 70             >         db fatCount, maxEnt
     526.  02:7C99  0A 00             >         dw .firrec
     526.  02:7C9B  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     526.  02:7C9D  01                >         db fatSiz
     526.  02:7C9E  03 00             >         dw .firdir
     527.  02:7CA0                              MAKEDPB $fb, 512, 2, 112, 2 * 80 * 8, 2, 2      ; 640 kB
     527.  02:7CA0  (02:0001)         > .firfat equ 1
     527.  02:7CA0  (02:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     527.  02:7CA0  (02:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     527.  02:7CA0                    >         if sectorSize = 512
     527.  02:7CA0  (02:0004)         > .shft   equ 4
     527.  02:7CA0                    >         elseif sectorSize = 256
     527.  02:7CA0                    ~ .shft   equ 3
     527.  02:7CA0                    ~         endif
     527.  02:7CA0                    >         
     527.  02:7CA0  FB                >         db media
     527.  02:7CA1  00 02             >         dw sectorSize
     527.  02:7CA3  0F 04             >         db (sectorSize/32)-1, .shft
     527.  02:7CA5  01                >         db sectorsPerCluster-1
     527.  02:7CA6  02                >         db sectorsPerCluster
     527.  02:7CA7  01 00             >         dw .firfat
     527.  02:7CA9  02 70             >         db fatCount, maxEnt
     527.  02:7CAB  0C 00             >         dw .firrec
     527.  02:7CAD  7B 02             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     527.  02:7CAF  02                >         db fatSiz
     527.  02:7CB0  05 00             >         dw .firdir
     528.  02:7CB2                              MAKEDPB $fc, 512, 1, 64,  1 * 40 * 9, 2, 2      ; 180 kB
     528.  02:7CB2  (02:0001)         > .firfat equ 1
     528.  02:7CB2  (02:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     528.  02:7CB2  (02:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     528.  02:7CB2                    >         if sectorSize = 512
     528.  02:7CB2  (02:0004)         > .shft   equ 4
     528.  02:7CB2                    >         elseif sectorSize = 256
     528.  02:7CB2                    ~ .shft   equ 3
     528.  02:7CB2                    ~         endif
     528.  02:7CB2                    >         
     528.  02:7CB2  FC                >         db media
     528.  02:7CB3  00 02             >         dw sectorSize
     528.  02:7CB5  0F 04             >         db (sectorSize/32)-1, .shft
     528.  02:7CB7  00                >         db sectorsPerCluster-1
     528.  02:7CB8  01                >         db sectorsPerCluster
     528.  02:7CB9  01 00             >         dw .firfat
     528.  02:7CBB  02 40             >         db fatCount, maxEnt
     528.  02:7CBD  09 00             >         dw .firrec
     528.  02:7CBF  60 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     528.  02:7CC1  02                >         db fatSiz
     528.  02:7CC2  05 00             >         dw .firdir
     529.  02:7CC4                              MAKEDPB $fd, 512, 2, 112, 2 * 40 * 9, 2, 2      ; 360 kB
     529.  02:7CC4  (02:0001)         > .firfat equ 1
     529.  02:7CC4  (02:0005)         > .firdir equ .firfat+(fatCount*fatSiz)
     529.  02:7CC4  (02:000C)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     529.  02:7CC4                    >         if sectorSize = 512
     529.  02:7CC4  (02:0004)         > .shft   equ 4
     529.  02:7CC4                    >         elseif sectorSize = 256
     529.  02:7CC4                    ~ .shft   equ 3
     529.  02:7CC4                    ~         endif
     529.  02:7CC4                    >         
     529.  02:7CC4  FD                >         db media
     529.  02:7CC5  00 02             >         dw sectorSize
     529.  02:7CC7  0F 04             >         db (sectorSize/32)-1, .shft
     529.  02:7CC9  01                >         db sectorsPerCluster-1
     529.  02:7CCA  02                >         db sectorsPerCluster
     529.  02:7CCB  01 00             >         dw .firfat
     529.  02:7CCD  02 70             >         db fatCount, maxEnt
     529.  02:7CCF  0C 00             >         dw .firrec
     529.  02:7CD1  63 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     529.  02:7CD3  02                >         db fatSiz
     529.  02:7CD4  05 00             >         dw .firdir
     530.  02:7CD6                              MAKEDPB $fe, 512, 1, 64,  1 * 40 * 8, 1, 2      ; 160 kB
     530.  02:7CD6  (02:0001)         > .firfat equ 1
     530.  02:7CD6  (02:0003)         > .firdir equ .firfat+(fatCount*fatSiz)
     530.  02:7CD6  (02:0007)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     530.  02:7CD6                    >         if sectorSize = 512
     530.  02:7CD6  (02:0004)         > .shft   equ 4
     530.  02:7CD6                    >         elseif sectorSize = 256
     530.  02:7CD6                    ~ .shft   equ 3
     530.  02:7CD6                    ~         endif
     530.  02:7CD6                    >         
     530.  02:7CD6  FE                >         db media
     530.  02:7CD7  00 02             >         dw sectorSize
     530.  02:7CD9  0F 04             >         db (sectorSize/32)-1, .shft
     530.  02:7CDB  00                >         db sectorsPerCluster-1
     530.  02:7CDC  01                >         db sectorsPerCluster
     530.  02:7CDD  01 00             >         dw .firfat
     530.  02:7CDF  02 40             >         db fatCount, maxEnt
     530.  02:7CE1  07 00             >         dw .firrec
     530.  02:7CE3  3A 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     530.  02:7CE5  01                >         db fatSiz
     530.  02:7CE6  03 00             >         dw .firdir
     531.  02:7CE8                              MAKEDPB $ff, 512, 2, 112, 2 * 40 * 8, 1, 1      ; 320 kB
     531.  02:7CE8  (02:0001)         > .firfat equ 1
     531.  02:7CE8  (02:0002)         > .firdir equ .firfat+(fatCount*fatSiz)
     531.  02:7CE8  (02:0009)         > .firrec equ .firdir+(maxEnt/(sectorSize/32))
     531.  02:7CE8                    >         if sectorSize = 512
     531.  02:7CE8  (02:0004)         > .shft   equ 4
     531.  02:7CE8                    >         elseif sectorSize = 256
     531.  02:7CE8                    ~ .shft   equ 3
     531.  02:7CE8                    ~         endif
     531.  02:7CE8                    >         
     531.  02:7CE8  FF                >         db media
     531.  02:7CE9  00 02             >         dw sectorSize
     531.  02:7CEB  0F 04             >         db (sectorSize/32)-1, .shft
     531.  02:7CED  01                >         db sectorsPerCluster-1
     531.  02:7CEE  02                >         db sectorsPerCluster
     531.  02:7CEF  01 00             >         dw .firfat
     531.  02:7CF1  01 70             >         db fatCount, maxEnt
     531.  02:7CF3  09 00             >         dw .firrec
     531.  02:7CF5  3C 01             >         dw (maxSector-.firrec)/sectorsPerCluster+1
     531.  02:7CF7  01                >         db fatSiz
     531.  02:7CF8  02 00             >         dw .firdir
     532.  02:7CFA                      
     533.  02:7CFA                      ; WARNING: in some cases DEFDPB-1 is expected!
     534.  02:7CFA  (02:7C7C)           DEFDPB  equ supportedMedia.def
     193   02:7CFA                              include "romdisk.asm"
       1.  02:7CFA                      		define	ROMDSKBANK 5			; romdisk starts in bank 5
       2.  02:7CFA                      		define	ROMDSKLAST (FLASHROMSIZE/16)-1
       3.  02:7CFA                      
       4.  02:7CFA                      
       5.  02:7CFA                      ROMDISK_DSKIO:
       6.  02:7CFA                              DEBUGMESSAGE "R_DSKIO"
       6.  02:7CFA                    >         ifdef DEBUG
       6.  02:7CFA  52                >         ld d,d
       6.  02:7CFB  18 07             >         jr .skip
       6.  02:7CFD                    >         db string
       6.  02:7CFD  52 5F 44 53 4B 49 4F 
       6.  02:7D04                    > .skip:
       6.  02:7D04                    >         endif
       7.  02:7D04  F1                          pop af
       8.  02:7D05  3E 00                       ld a,0
       9.  02:7D07  D8                          ret c                           ; write protected
      10.  02:7D08                              
      11.  02:7D08  EB                          ex de,hl
      12.  02:7D09  C5                  .loop:  push bc
      13.  02:7D0A  E5                          push hl        
      14.  02:7D0B                              
      15.  02:7D0B  CB 7A                       bit 7,d
      16.  02:7D0D  20 1C                       jr nz,.directCopy
      17.  02:7D0F  7A                          ld a,d
      18.  02:7D10  FE 3E                       cp $3e        
      19.  02:7D12  38 17                       jr c,.directCopy
      20.  02:7D14                      
      21.  02:7D14  CD 37 7D                    call .findSector
      22.  02:7D17  D5                          push de
      23.  02:7D18  ED 5B 4D F3                 ld de,($f34d)        
      24.  02:7D1C  CD F4 7F                    call copyFromBank
      25.  02:7D1F  D1                          pop de
      26.  02:7D20  01 00 02                    ld bc,512
      27.  02:7D23  2A 4D F3                    ld hl,($f34d)
      28.  02:7D26  CD 6E F3                    call XFER
      29.  02:7D29  18 06                       jr .nextSector           
      30.  02:7D2B                                    
      31.  02:7D2B                      .directCopy:                
      32.  02:7D2B  CD 37 7D                    call .findSector  
      33.  02:7D2E  CD F4 7F                    call copyFromBank
      34.  02:7D31                      .nextSector:
      35.  02:7D31  E1                          pop hl
      36.  02:7D32  23                          inc hl
      37.  02:7D33  C1                          pop bc
      38.  02:7D34  10 D3                       djnz .loop
      39.  02:7D36  C9                          ret
      40.  02:7D37                      
      41.  02:7D37                      .findSector:        
      42.  02:7D37  7D                          ld a,l                          ; determine bank
      43.  02:7D38  E6 E0                       and %11100000
      44.  02:7D3A  B4                          or h
      45.  02:7D3B  07                          rlca
      46.  02:7D3C  07                          rlca
      47.  02:7D3D  07                          rlca
      48.  02:7D3E  47                          ld b,a
      49.  02:7D3F                      
      50.  02:7D3F  7D                          ld a,l
      51.  02:7D40  E6 1F                       and 31
      52.  02:7D42  4F                          ld c,a
      53.  02:7D43  3E FF                       ld a,ROMDSKLAST                 ; banks with b0..5=0 reside in the last bank
      54.  02:7D45  28 05                       jr z,.skip
      55.  02:7D47                      
      56.  02:7D47  78                          ld a,b
      57.  02:7D48  C6 05                       add ROMDSKBANK
      58.  02:7D4A  41                          ld b,c
      59.  02:7D4B  05                          dec b
      60.  02:7D4C  4F                  .skip:  ld c,a
      61.  02:7D4D  78                          ld a,b
      62.  02:7D4E  07                          rlca
      63.  02:7D4F  C6 41                       add $41                         ; disk images starts at $4100
      64.  02:7D51  67                          ld h,a
      65.  02:7D52  2E 00                       ld l,0
      66.  02:7D54  79                          ld a,c
      67.  02:7D55  01 00 02                    ld bc,512
      68.  02:7D58  C9                          ret
      69.  02:7D59                                                               
      70.  02:7D59                      ROMDISK_DSKCHG:
      71.  02:7D59                              ;DEBUGMESSAGE "ROM_DSKCHG"
      72.  02:7D59  F1                          pop af
      73.  02:7D5A  A7                          and a
      74.  02:7D5B  06 01                       ld b,1                          ; not changed
      75.  02:7D5D  C9                          ret
      76.  02:7D5E                      
      77.  02:7D5E                      ROMDISK_GETDPB:
      78.  02:7D5E                              ; not implemented (standard mediadescriptor as used)
      79.  02:7D5E                              
      80.  02:7D5E                      ROMDISK_DSKFMT:
      81.  02:7D5E                              ; not implemented (no disk can be formatted)
      82.  02:7D5E                              
     194   02:7D5E                              include "flashWriter.asm"
       1.  02:7D5E                      ; flashWriter.asm
       2.  02:7D5E                      ; Flashes and erases the AMD29F040/M29F032-D
       3.  02:7D5E                           
       4.  02:7D5E                      flashWriter:
       5.  02:7D5E                              ;DEBUGMESSAGE "flashWriter"
       6.  02:7D5E  3E 03                       ld a,3
       7.  02:7D60  CD 41 01                    call SNSMAT
       8.  02:7D63  E6 08                       and 8
       9.  02:7D65  C0                          ret nz
      10.  02:7D66                              
      11.  02:7D66  CD 86 5F                    call PRINTTEXT
      12.  02:7D69                              db 10,13," FlashROM",10,13," "
      12.  02:7D69  0A 0D 20 46 6C 61 73 68 52 4F 4D 0A 0D 20 
      13.  02:7D77  2E (33)                     ds 33,"."
      14.  02:7D98  0D 20 00                    db 13," ",0
      15.  02:7D9B                              
      16.  02:7D9B  CD 68 76                    call getSlotPage1
      17.  02:7D9E  CD 21 76                    call enableSlotPage0
      18.  02:7DA1                      
      19.  02:7DA1  21 AE 7D                    ld hl,.source
      20.  02:7DA4  11 00 C0                    ld de,$c000
      21.  02:7DA7  D5                          push de
      22.  02:7DA8  01 DB 00                    ld bc,flasherEnd - $c000
      23.  02:7DAB  ED B0                       ldir
      24.  02:7DAD  C9                          ret
      25.  02:7DAE                              
      26.  02:7DAE                      .source:     
      27.  02:7DAE  (C000)                      PHASE $c000  
      28.  02:C000                              
      29.  02:C000                      waitForHeader:
      30.  02:C000  26 20                       ld h,HIGH usbrd
      31.  02:C002  7E                          ld a,(hl)
      32.  02:C003  FE BB               .chkbb: cp $bb
      33.  02:C005  20 F9                       jr nz,waitForHeader
      34.  02:C007  7E                          ld a,(hl)
      35.  02:C008  FE 55                       cp $55
      36.  02:C00A  20 F7                       jr nz,.chkbb       
      37.  02:C00C                      
      38.  02:C00C  7E                          ld a,(hl)
      39.  02:C00D  FE A2                       cp $a2
      40.  02:C00F  CA A9 C0                    jp z,verifyFlash
      41.  02:C012  FE A3                       cp $a3
      42.  02:C014  28 6E                       jr z,writeFlash
      43.  02:C016  FE A4                       cp $a4
      44.  02:C018  28 52                       jr z,chipErase
      45.  02:C01A  FE A5                       cp $a5
      46.  02:C01C  28 1C                       jr z,eraseSector
      47.  02:C01E  FE A6                       cp $a6
      48.  02:C020  28 02                       jr z,autoselectMode
      49.  02:C022                      
      50.  02:C022  20 DC                       jr nz,waitForHeader
      51.  02:C024                          
      52.  02:C024                      autoselectMode:
      53.  02:C024  3E 90                       ld a,$90
      54.  02:C026  CD CC C0                    call writeCommandSequence
      55.  02:C029                      
      56.  02:C029  2A 00 40                    ld hl,($4000)
      57.  02:C02C  EB                          ex de,hl
      58.  02:C02D  26 40                       ld h,HIGH usbwr
      59.  02:C02F  36 AA                       ld (hl),$aa
      60.  02:C031  36 55                       ld (hl),$55
      61.  02:C033  73                          ld (hl),e                       ; manufacturer ID (0x01 = AMD)
      62.  02:C034  72                          ld (hl),d                       ; device ID (0xA4 = AM29F040, 0x41 = AM29F032B)
      63.  02:C035                      
      64.  02:C035  CD 66 C0                    call writeResetCommand
      65.  02:C038  18 C6                       jr waitForHeader
      66.  02:C03A                      
      67.  02:C03A                      eraseSector:
      68.  02:C03A                              ;DEBUGMESSAGE "sector erase"
      69.  02:C03A  3E 65               	ld a,"e"
      70.  02:C03C  D3 98               	out ($98),a
      71.  02:C03E                      
      72.  02:C03E  7E                          ld a,(hl)                       ; get sector number 0..63
      73.  02:C03F  CB 27                       sla a
      74.  02:C041  CB 27                       sla a
      75.  02:C043  32 01 60                    ld (mapper),a                   ; select sector
      76.  02:C046                      
      77.  02:C046  3E 80                       ld a,$80
      78.  02:C048  CD CC C0                    call writeCommandSequence
      79.  02:C04B  3E 30                       ld a,$30        
      80.  02:C04D  CD CC C0                    call writeCommandSequence
      81.  02:C050                      
      82.  02:C050  CD 56 C0                    call waitForCommandToComplete
      83.  02:C053  C3 BD C0                    jp acknowledge
      84.  02:C056                              
      85.  02:C056                      waitForCommandToComplete:
      86.  02:C056  7E                          ld a,(hl)
      87.  02:C057  46                          ld b,(hl)
      88.  02:C058  A8                          xor b
      89.  02:C059  E6 40                       and %01000000                   ; check toggle bit I (DQ6)
      90.  02:C05B  C8                          ret z                           ; operation complete
      91.  02:C05C                              
      92.  02:C05C  78                          ld a,b
      93.  02:C05D  E6 20                       and %00100000                   ; timing limits exceeded? (DQ5)
      94.  02:C05F  28 F5                       jr z,waitForCommandToComplete
      95.  02:C061                      
      96.  02:C061  CD 66 C0                    call writeResetCommand
      97.  02:C064  78                          ld a,b
      98.  02:C065  C9                          ret
      99.  02:C066                      
     100.  02:C066                      writeResetCommand:
     101.  02:C066  3E F0                       ld a,$f0                        ; write RESET command
     102.  02:C068  32 00 00                    ld (0),a
     103.  02:C06B  C9                          ret
     104.  02:C06C                      
     105.  02:C06C                      chipErase:
     106.  02:C06C                              ;DEBUGMESSAGE "chip erase"
     107.  02:C06C  3E 45               	ld a,"E"
     108.  02:C06E  D3 98               	out ($98),a
     109.  02:C070                      
     110.  02:C070  3E 80                       ld a,$80
     111.  02:C072  CD CC C0                    call writeCommandSequence
     112.  02:C075  3E 10                       ld a,$10
     113.  02:C077  CD CC C0                    call writeCommandSequence
     114.  02:C07A                      
     115.  02:C07A  3A 00 40            .wait:  ld a,($4000)                    ; read DQ7 (data# polling) 
     116.  02:C07D  07                          rlca
     117.  02:C07E  30 FA                       jr nc,.wait        
     118.  02:C080  3E 01                       ld a,1
     119.  02:C082  18 39                       jr acknowledge
     120.  02:C084                      
     121.  02:C084                      
     122.  02:C084                      writeFlash:
     123.  02:C084                              ;DEBUGMESSAGE "write"
     124.  02:C084  5E                          ld e,(hl)                       ; address
     125.  02:C085  56                          ld d,(hl)
     126.  02:C086                      
     127.  02:C086  7A                          ld a,d
     128.  02:C087  B3                          or e
     129.  02:C088  CC C7 C0                    call z,updateBar
     130.  02:C08B                      
     131.  02:C08B  7E                          ld a,(hl)                       ; bank
     132.  02:C08C  32 01 60                    ld (mapper),a
     133.  02:C08F  26 40                       ld h,$40
     134.  02:C091                              
     135.  02:C091  06 80                       ld b,128                        ; data is written in blocks of 128 bytes
     136.  02:C093  3E A0               .loop:  ld a,$a0
     137.  02:C095  CD CC C0                    call writeCommandSequence
     138.  02:C098  3A 00 20                    ld a,(usbrd)
     139.  02:C09B  12                          ld (de),a                       ; write data to flash
     140.  02:C09C  13                          inc de
     141.  02:C09D                      
     142.  02:C09D  7E                  .wait:  ld  a,(hl)                      ; write complete?
     143.  02:C09E  AE                          xor (hl)
     144.  02:C09F  E6 40                       and %01000000
     145.  02:C0A1  20 FA                       jr  nz,.wait
     146.  02:C0A3  10 EE                       djnz .loop
     147.  02:C0A5                              
     148.  02:C0A5  3E 02                       ld a,2
     149.  02:C0A7  18 14                       jr acknowledge        
     150.  02:C0A9                              
     151.  02:C0A9                      verifyFlash:
     152.  02:C0A9                              ;DEBUGMESSAGE "verify"
     153.  02:C0A9  21 00 20                    ld hl,usbrd
     154.  02:C0AC  5E                          ld e,(hl)                       ; address
     155.  02:C0AD  56                          ld d,(hl)
     156.  02:C0AE  7E                          ld a,(hl)                       ; bank
     157.  02:C0AF  32 01 60                    ld (mapper),a
     158.  02:C0B2                      
     159.  02:C0B2  06 80                       ld b,128
     160.  02:C0B4  1A                  .loop:  ld a,(de)
     161.  02:C0B5  32 00 40                    ld (usbwr),a
     162.  02:C0B8  13                          inc de
     163.  02:C0B9  10 F9                       djnz .loop
     164.  02:C0BB                      
     165.  02:C0BB  3E 03                       ld a,3
     166.  02:C0BD                      acknowledge:        
     167.  02:C0BD  26 40                       ld h,HIGH usbwr
     168.  02:C0BF  36 AA                       ld (hl),$aa
     169.  02:C0C1  36 55                       ld (hl),$55
     170.  02:C0C3  77                          ld (hl),a
     171.  02:C0C4  C3 00 C0                    jp waitForHeader
     172.  02:C0C7                      
     173.  02:C0C7                      updateBar:
     174.  02:C0C7  3E 77                       ld a,"w"  
     175.  02:C0C9  D3 98                       out ($98),a
     176.  02:C0CB  C9                          ret
     177.  02:C0CC                      
     178.  02:C0CC                      writeCommandSequence:
     179.  02:C0CC  F5                          push af
     180.  02:C0CD  3E AA                       ld a,$aa
     181.  02:C0CF  32 55 05                    ld ($0555),a
     182.  02:C0D2  2F                          cpl
     183.  02:C0D3  32 AA 02                    ld ($02aa),a
     184.  02:C0D6  F1                          pop af
     185.  02:C0D7  32 55 05                    ld ($0555),a
     186.  02:C0DA  C9                          ret
     187.  02:C0DB                              
     188.  02:C0DB                      flasherEnd:
     189.  02:C0DB  (7E89)                      DEPHASE
     195   02:7E89                              include "device.asm"
       1.  02:7E89                      ; device.asm
       2.  02:7E89                      ; implements a basic now: device
       3.  02:7E89                          
       4.  02:7E89                      device:
       5.  02:7E89  E5                          push hl
       6.  02:7E8A  21 9B 7E                    ld hl,deviceFunctions
       7.  02:7E8D  0F                          rrca
       8.  02:7E8E  3C                          inc a
       9.  02:7E8F  07                          rlca
      10.  02:7E90  85                          add a,l
      11.  02:7E91  6F                          ld l,a
      12.  02:7E92  30 01                       jr nc,.nocy
      13.  02:7E94  24                          inc h  
      14.  02:7E95  7E                  .nocy:  ld a,(hl)
      15.  02:7E96  23                          inc hl
      16.  02:7E97  66                          ld h,(hl)
      17.  02:7E98  6F                          ld l,a
      18.  02:7E99  E3                          ex (sp),hl
      19.  02:7E9A  C9                          ret
      20.  02:7E9B                      
      21.  02:7E9B                      deviceFunctions:
      22.  02:7E9B  B1 7E                       dw identifyDevice               ; 0xff
      23.  02:7E9D  D1 7E                       dw open                         ;  0
      24.  02:7E9F  09 7F                       dw close                        ;  2
      25.  02:7EA1  0F 7F                       dw randomIO                     ;  4
      26.  02:7EA3  13 7F                       dw write                        ;  6
      27.  02:7EA5  19 7F                       dw read                         ;  8
      28.  02:7EA7  6F 7F                       dw loc                          ; 10
      29.  02:7EA9  81 7F                       dw lof                          ; 12
      30.  02:7EAB  4D 7F                       dw eof                          ; 14
      31.  02:7EAD  81 7F                       dw fpos                         ; 16
      32.  02:7EAF  81 7F                       dw putback                      ; 18
      33.  02:7EB1                                
      34.  02:7EB1                      identifyDevice:
      35.  02:7EB1                              DEBUGMESSAGE "identifyDevice"
      35.  02:7EB1                    >         ifdef DEBUG
      35.  02:7EB1  52                >         ld d,d
      35.  02:7EB2  18 0E             >         jr .skip
      35.  02:7EB4                    >         db string
      35.  02:7EB4  69 64 65 6E 74 69 66 79 44 65 76 69 63 65 
      35.  02:7EC2                    > .skip:
      35.  02:7EC2                    >         endif
      36.  02:7EC2  21 CA 7E                    ld hl,deviceNameList
      37.  02:7EC5  CD 50 74                    call findStatementName
      38.  02:7EC8  7E                          ld a,(hl)                       ; device number
      39.  02:7EC9  C9                          ret                             ; carry is set when invalid device name
      40.  02:7ECA                              
      41.  02:7ECA                      deviceNameList:
      42.  02:7ECA  4E 4F 57 00 00 00           db "NOW",0,0,0                  ; name, end marker, device number, dummy
      43.  02:7ED0                              ;db "STDIN",0,1,0
      44.  02:7ED0  00                          db 0
      45.  02:7ED1                      
      46.  02:7ED1                      ; Input     D   Global device code
      47.  02:7ED1                      ;           E   File mode    
      48.  02:7ED1                      ;           HL  address fcb
      49.  02:7ED1                      open:
      50.  02:7ED1                      ;        DEBUGMESSAGE "open"
      51.  02:7ED1                      ;        DEBUGDUMPMEMHL 9
      52.  02:7ED1  22 64 F8                    ld (PTRFIL),hl
      53.  02:7ED4  CD 7C 74                    call sendRegisters
      54.  02:7ED7  36 88                       ld (hl),C_DEVICEOPEN
      55.  02:7ED9  EB                          ex de,hl
      56.  02:7EDA  01 0B 00                    ld bc,11
      57.  02:7EDD  21 66 F8                    ld hl,FILNAM
      58.  02:7EE0  ED B0                       ldir
      59.  02:7EE2                      
      60.  02:7EE2  CD 0D 76                    call enableNowindPage0
      61.  02:7EE5  26 20                       ld h,HIGH usbrd
      62.  02:7EE7  CD 8E 74                    call getHeader
      63.  02:7EEA  38 0C                       jr c,deviceIoError              ; time out?
      64.  02:7EEC  B7                          or a
      65.  02:7EED  20 0B                       jr nz,openError
      66.  02:7EEF                      
      67.  02:7EEF  5E                          ld e,(hl)                       ; update fcb (including buffer)
      68.  02:7EF0  56                          ld d,(hl)
      69.  02:7EF1  4E                          ld c,(hl)
      70.  02:7EF2  46                          ld b,(hl)
      71.  02:7EF3  ED B0                       ldir
      72.  02:7EF5  C3 18 76                    jp restorePage0        
      73.  02:7EF8                      
      74.  02:7EF8                      deviceIoError:
      75.  02:7EF8  3E 13                       ld a,19
      76.  02:7EFA                      
      77.  02:7EFA                      openError:
      78.  02:7EFA  CD 18 76                    call restorePage0
      79.  02:7EFD  5F                          ld e,a
      80.  02:7EFE                      
      81.  02:7EFE                      basicError:
      82.  02:7EFE  DD 21 6F 40                 ld ix,$406f
      83.  02:7F02  FD 2A C0 FC                 ld iy,(EXPTBL-1)
      84.  02:7F06  C3 1C 00                    jp CALSLT
      85.  02:7F09                                      
      86.  02:7F09                      close:
      87.  02:7F09                      ;        DEBUGMESSAGE "close"
      88.  02:7F09  CD 7C 74                    call sendRegisters
      89.  02:7F0C  36 89                       ld (hl),C_DEVICECLOSE
      90.  02:7F0E  C9                          ret
      91.  02:7F0F                              
      92.  02:7F0F                      randomIO:
      93.  02:7F0F                      ;        DEBUGMESSAGE "randomIO"
      94.  02:7F0F  1E 3D                       ld e,61                         ; bad file mode
      95.  02:7F11  18 EB                       jr basicError
      96.  02:7F13                      
      97.  02:7F13                      write:
      98.  02:7F13                      ;        DEBUGMESSAGE "write"
      99.  02:7F13  CD 7C 74                    call sendRegisters
     100.  02:7F16  36 8B                       ld (hl),C_DEVICEWRITE
     101.  02:7F18  C9                          ret        
     102.  02:7F19                      
     103.  02:7F19                      read:
     104.  02:7F19                      ;        DEBUGMESSAGE "read"
     105.  02:7F19  11 06 00                    ld de,6
     106.  02:7F1C  19                          add hl,de
     107.  02:7F1D  E5                          push hl
     108.  02:7F1E  5E                          ld e,(hl)
     109.  02:7F1F  23                          inc hl
     110.  02:7F20  23                          inc hl
     111.  02:7F21  23                          inc hl
     112.  02:7F22  19                          add hl,de
     113.  02:7F23  7E                          ld a,(hl)
     114.  02:7F24  E1                          pop hl
     115.  02:7F25  FE 1A                       cp $1a
     116.  02:7F27  37                          scf
     117.  02:7F28  C8                          ret z                           ; end of file
     118.  02:7F29  3F                          ccf
     119.  02:7F2A  34                          inc (hl)                        ; increment position
     120.  02:7F2B  C0                          ret nz                          ; buffer empty?
     121.  02:7F2C                              
     122.  02:7F2C  F5                          push af
     123.  02:7F2D  2B                          dec hl
     124.  02:7F2E  34                          inc (hl)                        ; increment position (high)        
     125.  02:7F2F  11 FB FF                    ld de,-5
     126.  02:7F32  19                          add hl,de
     127.  02:7F33  CD 7C 74                    call sendRegisters
     128.  02:7F36  36 8C                       ld (hl),C_DEVICEREAD
     129.  02:7F38  CD 0D 76                    call enableNowindPage0
     130.  02:7F3B  26 20                       ld h,HIGH usbrd
     131.  02:7F3D  CD 8E 74                    call getHeader
     132.  02:7F40  38 B6                       jr c,deviceIoError
     133.  02:7F42                      
     134.  02:7F42  5E                          ld e,(hl)
     135.  02:7F43  56                          ld d,(hl)
     136.  02:7F44  4E                          ld c,(hl)
     137.  02:7F45  46                          ld b,(hl)
     138.  02:7F46  ED B0                       ldir                            ; update fcb buffer
     139.  02:7F48  CD 18 76                    call restorePage0
     140.  02:7F4B  F1                          pop af                          ; return last character
     141.  02:7F4C  C9                          ret
     142.  02:7F4D                      
     143.  02:7F4D                      eof:
     144.  02:7F4D                      ;        DEBUGMESSAGE "eof"
     145.  02:7F4D  7E                          ld a,(hl)
     146.  02:7F4E  FE 01                       cp 1                            ; input mode?        
     147.  02:7F50  1E 3D                       ld e,61                         ; bad file mode
     148.  02:7F52  C2 FE 7E                    jp nz,basicError
     149.  02:7F55                                      
     150.  02:7F55  11 06 00                    ld de,6
     151.  02:7F58  19                          add hl,de
     152.  02:7F59  5E                          ld e,(hl)
     153.  02:7F5A  23                          inc hl
     154.  02:7F5B  23                          inc hl
     155.  02:7F5C  23                          inc hl
     156.  02:7F5D  19                          add hl,de
     157.  02:7F5E  7E                          ld a,(hl)
     158.  02:7F5F  ED 62                       sbc hl,hl
     159.  02:7F61  FE 1A                       cp $1a        
     160.  02:7F63  20 01                       jr nz,.skip
     161.  02:7F65  2B                          dec hl
     162.  02:7F66  22 F8 F7            .skip:  ld (DAC+2),hl
     163.  02:7F69  3E 02                       ld a,2
     164.  02:7F6B  32 63 F6                    ld (VALTYP),a
     165.  02:7F6E  C9                          ret
     166.  02:7F6F                      
     167.  02:7F6F                      loc:
     168.  02:7F6F  E5                          push hl
     169.  02:7F70  FD E1                       pop iy
     170.  02:7F72  FD 6E 06                    ld l,(iy+6)
     171.  02:7F75  FD 66 05                    ld h,(iy+5)
     172.  02:7F78                      ;        DEBUGASSERT
     173.  02:7F78  22 F8 F7                    ld (DAC+2),hl
     174.  02:7F7B  3E 02                       ld a,2
     175.  02:7F7D  32 63 F6                    ld (VALTYP),a
     176.  02:7F80  C9                          ret
     177.  02:7F81                              
     178.  02:7F81                      putback:
     179.  02:7F81                      ;        DEBUGMESSAGE "putback"
     180.  02:7F81                      ;        push hl
     181.  02:7F81                      ;        pop iy
     182.  02:7F81                      ;        ld (iy+3),c
     183.  02:7F81                      ;        DEBUGASSERT
     184.  02:7F81                      ;        ret
     185.  02:7F81                      
     186.  02:7F81                      lof:
     187.  02:7F81                      fpos:
     188.  02:7F81                              DEBUGMESSAGE "no support!"
     188.  02:7F81                    >         ifdef DEBUG
     188.  02:7F81  52                >         ld d,d
     188.  02:7F82  18 0B             >         jr .skip
     188.  02:7F84                    >         db string
     188.  02:7F84  6E 6F 20 73 75 70 70 6F 72 74 21 
     188.  02:7F8F                    > .skip:
     188.  02:7F8F                    >         endif
     189.  02:7F8F                      
     190.  02:7F8F                      illegalFunctionCall:
     191.  02:7F8F  1E 05                       ld e,5
     192.  02:7F91  C3 FE 7E                    jp basicError
     193.  02:7F94                      
     194.  02:7F94                      ;FCB for DISK BASIC
     195.  02:7F94                      ; +0 FL.MOD     file mode
     196.  02:7F94                      ; +1 FL.FCA     Pointer to FCB for BDOS (low)
     197.  02:7F94                      ; +2 FL.LCA     Pointer to FCB for BDOS (high)
     198.  02:7F94                      ; +3 FL.LSA     Back up character
     199.  02:7F94                      ; +4 FL.DSK     device number
     200.  02:7F94                      ; +5 FL.SLB
     201.  02:7F94                      ; +6 FL.BPS     Position in FL.BUF
     202.  02:7F94                      ; +7 FL.FLG     Holds various information
     203.  02:7F94                      ; +8 FL.OPS     Pseudo head position
     204.  02:7F94                      ; +9 FL.BUF     256-byte file buffer
     205.  02:7F94                      
     206.  02:7F94                      ; device codes
     207.  02:7F94                      ;          SS0           SS1           SS2           SS3
     208.  02:7F94                      ;    ---------------------------------------------------------
     209.  02:7F94                      ;    | 00 04 08 0C | 10 14 18 1C | 20 24 28 2C | 30 34 38 3C | PS0
     210.  02:7F94                      ;    ---------------------------------------------------------
     211.  02:7F94                      ;    | 40 44 48 4C | 50 54 58 5C | 60 64 68 6C | 70 74 78 7C | PS1
     212.  02:7F94                      ;    ---------------------------------------------------------
     213.  02:7F94                      ;    | 80 84 88 8C | 90 94 98 9C | A0 A4 A8 AC | B0 B4 B8 BC | PS2
     214.  02:7F94                      ;    ---------------------------------------------------------
     215.  02:7F94                      ;    | C0 C4 C8 CC | D0 D4 D8 DC | E0 E4 E8 EC | F0 F4 F8 FC | PS3
     216.  02:7F94                      ;    ---------------------------------------------------------
     217.  02:7F94                      
     218.  02:7F94                      ; fileModes
     219.  02:7F94                      ; FOR INPUT (01H)
     220.  02:7F94                      ; FOR OUTPUT (02H)
     221.  02:7F94                      ; FOR APPEND (08H)
     222.  02:7F94                      ; random mode (04H)
     223.  02:7F94                      
     224.  02:7F94                      ; maximum number of files open: MAXFILES=15
     225.  02:7F94                              
     226.  02:7F94                      ; File Control Block
     227.  02:7F94                      ;       0     1     2     3     4     5     6     7     8
     228.  02:7F94                      ;    -------------------------------------------------------
     229.  02:7F94                      ;    | Mod | 00H | 00H | 00H | DEV | 00H | POS | 00H | PPS |
     230.  02:7F94                      ;    -------------------------------------------------------
     231.  02:7F94                      ;                  err? bckup       posHi 
     232.  02:7F94                      ; followed by a 256 byte buffer
     196   02:7F94                              
     197   02:7F94                              ifdef BDOS_NOWIND
     198   02:7F94                    ~         include "nowindbdos.asm"
     199   02:7F94                    ~         endif
     200   02:7F94                              
     201   02:7F94  FF (96)                    ds $8000-(endCopyFromBank-copyFromBank)-$, $ff
     202   02:7FF4                      
     203   02:7FF4                      ; bank switching and data transfer
     204   02:7FF4                      copyFromBank:
     205   02:7FF4  32 01 60                    ld (mapper),a
     206   02:7FF7  ED B0                       ldir
     207   02:7FF9                      enableBank0:
     208   02:7FF9  AF                          xor a
     209   02:7FFA  F5                          push af
     210   02:7FFB  32 01 60                    ld (mapper),a
     211   02:7FFE  F1                          pop af
     212   02:7FFF  C9                          ret
     213   02:8000                      endCopyFromBank:
     214   02:8000                      
     215   02:8000  (03)                        page 3
     216   03:0000  BA (442368)                 ds (512-80)*1024, $ba

    LABELS
---------------------------------------
00:0000000C X RDSLT
00:00000014 X WRSLT
00:0000001C   CALSLT
00:00000024   ENASLT
00:0000005F   CHGMOD
00:00000141   SNSMAT
00:0000015F   EXTROM
00:00000185   SDFSCR
00:0000F33F   LASTDRV
00:0000F342   RAMAD1
00:0000F36E   XFER
00:0000F663   VALTYP
00:0000F7F6   DAC
00:0000F864   PTRFIL
00:0000F866   FILNAM
00:0000FCC1   EXPTBL
00:0000FCC5   SLTTBL
00:0000FCC9 X SLTATR
00:0000FD09   SLTWRK
00:0000FD89   PROCNM
00:0000FD99   DEVICE
00:0000FFCA   EXTBIO
00:0000402D   GETSLT
00:0000FECB X H.RUNC
00:00004000   usbwr
00:00002000   usbrd
00:00008000   usb2
00:00006001   mapper
00:00000080   C_DSKIO
00:00000081   C_DSKCHG
00:00000082   C_GETDPB
00:00000083 X C_CHOICE
00:00000084 X C_DSKFMT
00:00000085   C_DRIVES
00:00000086   C_INIENV
00:00000087 X C_SETDATE
00:00000088   C_DEVICEOPEN
00:00000089   C_DEVICECLOSE
00:0000008A X C_DEVICERNDIO
00:0000008B   C_DEVICEWRITE
00:0000008C   C_DEVICEREAD
00:0000008D X C_DEVICEEOF
00:0000008E   C_AUXIN
00:0000008F   C_AUXOUT
00:00000090   C_MESSAGE
00:00000091   C_CHANGEIMAGE
00:00000092   C_BOOTARGS
00:00000093 X C_CMDREQUEST
00:000072F0   MSXDOS2_PART.getBootArgs
00:00007310   MSXDOS2_PART.nowindInit
00:00007343   MSXDOS2_PART.initDiskBasic
00:0000735B   MSXDOS2_PART.findStatementName
00:00007372   MSXDOS2_PART.findStatementName.loop
00:0000737C   MSXDOS2_PART.findStatementName.nextStatement
00:00007387   MSXDOS2_PART.sendRegisters
00:00007399   MSXDOS2_PART.getHeader
00:0000739B   MSXDOS2_PART.getHeader.loop
00:0000739C   MSXDOS2_PART.getHeader.chkaf
00:000073C0   MSXDOS2_PART.getHeader.chk05
00:000073C7   MSXDOS2_PART.sendMessage
00:000073D1   MSXDOS2_PART.sendMessage.loop
00:000073DD   MSXDOS2_PART.newAUX
00:000073E7   MSXDOS2_PART.AUXin
00:00007415   MSXDOS2_PART.AUXin.exit
00:0000741B   MSXDOS2_PART.AUXin.getCharacter
00:0000742C   MSXDOS2_PART.AUXout
00:00007444 X MSXDOS2_PART.sdendFCB
00:00007448   MSXDOS2_PART.sdendFCB.loop
00:00007452 X MSXDOS2_PART.receiveFCB
00:00007456   MSXDOS2_PART.receiveFCB.loop
00:00007463   MSXDOS2_PART.installExtendedBios
00:00007498   MSXDOS2_PART.extendedBios
00:0000749F   MSXDOS2_PART.extendedBios.exit
00:000074AD   MSXDOS2_PART.determineFunction
00:000074B9   MSXDOS2_PART.functionTable
00:000074BF   MSXDOS2_PART.getNowindSlot
00:000074DB   MSXDOS2_PART.numberOfDevices
00:000074F2   MSXDOS2_PART.debugMessage
00:0000750E   MSXDOS2_PART.debugMessage.loop
00:00007518   MSXDOS2_PART.enableNowindPage0
00:00007523   MSXDOS2_PART.restorePage0
00:0000752C   MSXDOS2_PART.enableSlotPage0
00:0000753D   MSXDOS2_PART.enableSlotPage0.expanded
00:00007568   MSXDOS2_PART.getSlotPage0
00:00007573   MSXDOS2_PART.getSlotPage1
00:0000757E   MSXDOS2_PART.getSlotPage2
00:0000758D   MSXDOS2_PART.expanded
00:000075A1   MSXDOS2_PART.notExpanded
00:000075A3   MSXDOS2_PART.getEntrySLTWRK
00:00000008   MSXDOS2_PART.MYSIZE
00:00000200   MSXDOS2_PART.SECLEN
00:000075B8   MSXDOS2_PART.INIHRD
00:000075C7   MSXDOS2_PART.INIHRD.loop
00:000075DB   MSXDOS2_PART.DRIVES
00:0000761E   MSXDOS2_PART.DRIVES.exit
00:00007627   MSXDOS2_PART.DRIVES.notconnected
00:00007644   MSXDOS2_PART.INIENV
00:00007688   MSXDOS2_PART.INIENV.exit
00:0000768B   MSXDOS2_PART.checkWorkArea
00:00007696   MSXDOS2_PART.DSKIO
00:000076AD X MSXDOS2_PART.dskioRead
00:0000B6CA   MSXDOS2_PART.dskioRead.page2
00:000076DF   MSXDOS2_PART.dskioRead.page1
00:000076EF   MSXDOS2_PART.dskioRead.page2and3
00:00007705   MSXDOS2_PART.dskioWrite
00:0000B725   MSXDOS2_PART.dskioWrite.page2
00:0000773B   MSXDOS2_PART.dskioWrite.page1
00:00007751   MSXDOS2_PART.dskioWrite.page2and3
00:00007766   MSXDOS2_PART.dskioWrite.writeLoop23
00:00007796   MSXDOS2_PART.dskioWrite.error
00:00007799   MSXDOS2_PART.DSKCHG
00:000077D0   MSXDOS2_PART.GETDPB
00:00007806   MSXDOS2_PART.GETDPB.hddImage
00:00007839   MSXDOS2_PART.GETDPB.exit
00:0000783C   MSXDOS2_PART.CHOICE
00:00007840 X MSXDOS2_PART.CHOICE.noFormat
00:00007841   MSXDOS2_PART.DSKFMT
00:0000B845   MSXDOS2_PART.readSectors01
00:0000B867   MSXDOS2_PART.readSectors01.slowTransfer
00:0000B873   MSXDOS2_PART.writeLoop01
00:0000B895   MSXDOS2_PART.writeLoop01.error
00:00007898   MSXDOS2_PART.readSectors23
00:000078BC   MSXDOS2_PART.readSectors23.slowTransfer
00:000078D9   MSXDOS2_PART.reverseTransfer
00:000078E5   MSXDOS2_PART.reverseTransfer.loop
00:0000794C   MSXDOS2_PART.OEMSTA
00:0000795A   MSXDOS2_PART.OEMSTA.statement
00:0000796D   MSXDOS2_PART.changeImage
00:00007982   MSXDOS2_PART.call_exit
00:0000798E   MSXDOS2_PART.call_exit.loop
00:0000799A   MSXDOS2_PART.videoStream
00:0000799B X MSXDOS2_PART.vramDump
00:000079A7   MSXDOS2_PART.evenFrame
00:000079C4 X MSXDOS2_PART.oddFrame
00:000079E4   MSXDOS2_PART.tranferframe
00:000079F1   MSXDOS2_PART.write_more
00:00007AFE   MSXDOS2_PART.changeColors
00:00007B4C   MSXDOS2_PART.setVramAccessPointer
00:00007B5A   MSXDOS2_PART.waitForRetrace
00:00007B60   MSXDOS2_PART.waitForRetrace.lp2
00:00007B6B   MSXDOS2_PART.printVdpText2
00:00007B6C   MSXDOS2_PART.printVdpText2.loop
00:00007B75   MSXDOS2_PART.supportedMedia
00:00007B75 X MSXDOS2_PART.supportedMedia.f8
00:00007B87   MSXDOS2_PART.supportedMedia.def
00:00007B87   MSXDOS2_PART.DEFDPB
00:00007C05   MSXDOS2_PART.ROMDISK_DSKIO
00:00007C14   MSXDOS2_PART.ROMDISK_DSKIO.loop
00:00007C36   MSXDOS2_PART.ROMDISK_DSKIO.directCopy
00:00007C3C   MSXDOS2_PART.ROMDISK_DSKIO.nextSector
00:00007C42   MSXDOS2_PART.ROMDISK_DSKIO.findSector
00:00007C57   MSXDOS2_PART.ROMDISK_DSKIO.skip
00:00007C64   MSXDOS2_PART.ROMDISK_DSKCHG
00:00007C69 X MSXDOS2_PART.ROMDISK_GETDPB
00:00007C69 X MSXDOS2_PART.ROMDISK_DSKFMT
00:00007C69   MSXDOS2_PART.flashWriter
00:00007CB9   MSXDOS2_PART.flashWriter.source
00:0000C000   MSXDOS2_PART.waitForHeader
00:0000C003   MSXDOS2_PART.waitForHeader.chkbb
00:0000C024   MSXDOS2_PART.autoselectMode
00:0000C03A   MSXDOS2_PART.eraseSector
00:0000C056   MSXDOS2_PART.waitForCommandToComplete
00:0000C066   MSXDOS2_PART.writeResetCommand
00:0000C06C   MSXDOS2_PART.chipErase
00:0000C07A   MSXDOS2_PART.chipErase.wait
00:0000C084   MSXDOS2_PART.writeFlash
00:0000C093   MSXDOS2_PART.writeFlash.loop
00:0000C09D   MSXDOS2_PART.writeFlash.wait
00:0000C0A9   MSXDOS2_PART.verifyFlash
00:0000C0B4   MSXDOS2_PART.verifyFlash.loop
00:0000C0BD   MSXDOS2_PART.acknowledge
00:0000C0C7   MSXDOS2_PART.updateBar
00:0000C0CC   MSXDOS2_PART.writeCommandSequence
00:0000C0DB   MSXDOS2_PART.flasherEnd
00:00007D94   MSXDOS2_PART.device
00:00007DA0   MSXDOS2_PART.device.nocy
00:00007DA6   MSXDOS2_PART.deviceFunctions
00:00007DBC   MSXDOS2_PART.identifyDevice
00:00007DD5   MSXDOS2_PART.deviceNameList
00:00007DDC   MSXDOS2_PART.open
00:00007E03   MSXDOS2_PART.deviceIoError
00:00007E05   MSXDOS2_PART.openError
00:00007E09   MSXDOS2_PART.basicError
00:00007E14   MSXDOS2_PART.close
00:00007E1A   MSXDOS2_PART.randomIO
00:00007E1E   MSXDOS2_PART.write
00:00007E24   MSXDOS2_PART.read
00:00007E58   MSXDOS2_PART.eof
00:00007E71   MSXDOS2_PART.eof.skip
00:00007E7A   MSXDOS2_PART.loc
00:00007E8C   MSXDOS2_PART.putback
00:00007E8C   MSXDOS2_PART.lof
00:00007E8C   MSXDOS2_PART.fpos
00:00007E9A X MSXDOS2_PART.illegalFunctionCall
00:00007FF4   MSXDOS2_PART.copyFromBank
00:00007FF9 X MSXDOS2_PART.enableBank0
00:00007FFA   MSXDOS2_PART.switchBank
00:00008000   MSXDOS2_PART.endCopyFromBank
02:00007405   MSXDOS1_PART.nowindInit
02:00007438   MSXDOS1_PART.initDiskBasic
02:00007450   MSXDOS1_PART.findStatementName
02:00007467   MSXDOS1_PART.findStatementName.loop
02:00007471   MSXDOS1_PART.findStatementName.nextStatement
02:0000747C   MSXDOS1_PART.sendRegisters
02:0000748E   MSXDOS1_PART.getHeader
02:00007490   MSXDOS1_PART.getHeader.loop
02:00007491   MSXDOS1_PART.getHeader.chkaf
02:000074B5   MSXDOS1_PART.getHeader.chk05
02:000074BC   MSXDOS1_PART.sendMessage
02:000074C6   MSXDOS1_PART.sendMessage.loop
02:000074D2   MSXDOS1_PART.newAUX
02:000074DC   MSXDOS1_PART.AUXin
02:0000750A   MSXDOS1_PART.AUXin.exit
02:00007510   MSXDOS1_PART.AUXin.getCharacter
02:00007521   MSXDOS1_PART.AUXout
02:00007539 X MSXDOS1_PART.sdendFCB
02:0000753D   MSXDOS1_PART.sdendFCB.loop
02:00007547 X MSXDOS1_PART.receiveFCB
02:0000754B   MSXDOS1_PART.receiveFCB.loop
02:00007558   MSXDOS1_PART.installExtendedBios
02:0000758D   MSXDOS1_PART.extendedBios
02:00007594   MSXDOS1_PART.extendedBios.exit
02:000075A2   MSXDOS1_PART.determineFunction
02:000075AE   MSXDOS1_PART.functionTable
02:000075B4   MSXDOS1_PART.getNowindSlot
02:000075D0   MSXDOS1_PART.numberOfDevices
02:000075E7   MSXDOS1_PART.debugMessage
02:00007603   MSXDOS1_PART.debugMessage.loop
02:0000760D   MSXDOS1_PART.enableNowindPage0
02:00007618   MSXDOS1_PART.restorePage0
02:00007621   MSXDOS1_PART.enableSlotPage0
02:00007632   MSXDOS1_PART.enableSlotPage0.expanded
02:0000765D   MSXDOS1_PART.getSlotPage0
02:00007668   MSXDOS1_PART.getSlotPage1
02:00007673   MSXDOS1_PART.getSlotPage2
02:00007682   MSXDOS1_PART.expanded
02:00007696   MSXDOS1_PART.notExpanded
02:00007698   MSXDOS1_PART.getEntrySLTWRK
02:00000008   MSXDOS1_PART.MYSIZE
02:00000200   MSXDOS1_PART.SECLEN
02:000076AD   MSXDOS1_PART.INIHRD
02:000076BC   MSXDOS1_PART.INIHRD.loop
02:000076D0   MSXDOS1_PART.DRIVES
02:00007713   MSXDOS1_PART.DRIVES.exit
02:0000771C   MSXDOS1_PART.DRIVES.notconnected
02:00007739   MSXDOS1_PART.INIENV
02:0000777D   MSXDOS1_PART.INIENV.exit
02:00007780   MSXDOS1_PART.checkWorkArea
02:0000778B   MSXDOS1_PART.DSKIO
02:000077A2 X MSXDOS1_PART.dskioRead
02:0000B7BF   MSXDOS1_PART.dskioRead.page2
02:000077D4   MSXDOS1_PART.dskioRead.page1
02:000077E4   MSXDOS1_PART.dskioRead.page2and3
02:000077FA   MSXDOS1_PART.dskioWrite
02:0000B81A   MSXDOS1_PART.dskioWrite.page2
02:00007830   MSXDOS1_PART.dskioWrite.page1
02:00007846   MSXDOS1_PART.dskioWrite.page2and3
02:0000785B   MSXDOS1_PART.dskioWrite.writeLoop23
02:0000788B   MSXDOS1_PART.dskioWrite.error
02:0000788E   MSXDOS1_PART.DSKCHG
02:000078C5   MSXDOS1_PART.GETDPB
02:000078FB   MSXDOS1_PART.GETDPB.hddImage
02:0000792E   MSXDOS1_PART.GETDPB.exit
02:00007931   MSXDOS1_PART.CHOICE
02:00007935 X MSXDOS1_PART.CHOICE.noFormat
02:00007936   MSXDOS1_PART.DSKFMT
02:0000B93A   MSXDOS1_PART.readSectors01
02:0000B95C   MSXDOS1_PART.readSectors01.slowTransfer
02:0000B968   MSXDOS1_PART.writeLoop01
02:0000B98A   MSXDOS1_PART.writeLoop01.error
02:0000798D   MSXDOS1_PART.readSectors23
02:000079B1   MSXDOS1_PART.readSectors23.slowTransfer
02:000079CE   MSXDOS1_PART.reverseTransfer
02:000079DA   MSXDOS1_PART.reverseTransfer.loop
02:00007A41   MSXDOS1_PART.OEMSTA
02:00007A4F   MSXDOS1_PART.OEMSTA.statement
02:00007A62   MSXDOS1_PART.changeImage
02:00007A77   MSXDOS1_PART.call_exit
02:00007A83   MSXDOS1_PART.call_exit.loop
02:00007A8F   MSXDOS1_PART.videoStream
02:00007A90 X MSXDOS1_PART.vramDump
02:00007A9C   MSXDOS1_PART.evenFrame
02:00007AB9 X MSXDOS1_PART.oddFrame
02:00007AD9   MSXDOS1_PART.tranferframe
02:00007AE6   MSXDOS1_PART.write_more
02:00007BF3   MSXDOS1_PART.changeColors
02:00007C41   MSXDOS1_PART.setVramAccessPointer
02:00007C4F   MSXDOS1_PART.waitForRetrace
02:00007C55   MSXDOS1_PART.waitForRetrace.lp2
02:00007C60   MSXDOS1_PART.printVdpText2
02:00007C61   MSXDOS1_PART.printVdpText2.loop
02:00007C6A   MSXDOS1_PART.supportedMedia
02:00007C6A X MSXDOS1_PART.supportedMedia.f8
02:00007C7C   MSXDOS1_PART.supportedMedia.def
02:00007C7C   MSXDOS1_PART.DEFDPB
02:00007CFA   MSXDOS1_PART.ROMDISK_DSKIO
02:00007D09   MSXDOS1_PART.ROMDISK_DSKIO.loop
02:00007D2B   MSXDOS1_PART.ROMDISK_DSKIO.directCopy
02:00007D31   MSXDOS1_PART.ROMDISK_DSKIO.nextSector
02:00007D37   MSXDOS1_PART.ROMDISK_DSKIO.findSector
02:00007D4C   MSXDOS1_PART.ROMDISK_DSKIO.skip
02:00007D59   MSXDOS1_PART.ROMDISK_DSKCHG
02:00007D5E X MSXDOS1_PART.ROMDISK_GETDPB
02:00007D5E X MSXDOS1_PART.ROMDISK_DSKFMT
02:00007D5E   MSXDOS1_PART.flashWriter
02:00007DAE   MSXDOS1_PART.flashWriter.source
02:0000C000   MSXDOS1_PART.waitForHeader
02:0000C003   MSXDOS1_PART.waitForHeader.chkbb
02:0000C024   MSXDOS1_PART.autoselectMode
02:0000C03A   MSXDOS1_PART.eraseSector
02:0000C056   MSXDOS1_PART.waitForCommandToComplete
02:0000C066   MSXDOS1_PART.writeResetCommand
02:0000C06C   MSXDOS1_PART.chipErase
02:0000C07A   MSXDOS1_PART.chipErase.wait
02:0000C084   MSXDOS1_PART.writeFlash
02:0000C093   MSXDOS1_PART.writeFlash.loop
02:0000C09D   MSXDOS1_PART.writeFlash.wait
02:0000C0A9   MSXDOS1_PART.verifyFlash
02:0000C0B4   MSXDOS1_PART.verifyFlash.loop
02:0000C0BD   MSXDOS1_PART.acknowledge
02:0000C0C7   MSXDOS1_PART.updateBar
02:0000C0CC   MSXDOS1_PART.writeCommandSequence
02:0000C0DB   MSXDOS1_PART.flasherEnd
02:00007E89   MSXDOS1_PART.device
02:00007E95   MSXDOS1_PART.device.nocy
02:00007E9B   MSXDOS1_PART.deviceFunctions
02:00007EB1   MSXDOS1_PART.identifyDevice
02:00007ECA   MSXDOS1_PART.deviceNameList
02:00007ED1   MSXDOS1_PART.open
02:00007EF8   MSXDOS1_PART.deviceIoError
02:00007EFA   MSXDOS1_PART.openError
02:00007EFE   MSXDOS1_PART.basicError
02:00007F09   MSXDOS1_PART.close
02:00007F0F   MSXDOS1_PART.randomIO
02:00007F13   MSXDOS1_PART.write
02:00007F19   MSXDOS1_PART.read
02:00007F4D   MSXDOS1_PART.eof
02:00007F66   MSXDOS1_PART.eof.skip
02:00007F6F   MSXDOS1_PART.loc
02:00007F81   MSXDOS1_PART.putback
02:00007F81   MSXDOS1_PART.lof
02:00007F81   MSXDOS1_PART.fpos
02:00007F8F X MSXDOS1_PART.illegalFunctionCall
02:00007FF4   MSXDOS1_PART.copyFromBank
02:00007FF9 X MSXDOS1_PART.enableBank0
02:00008000   MSXDOS1_PART.endCopyFromBank


Output: nowind.out
--------------------------------------

 Page: 00
  Org: 00000000  Size: *  Used: 00000000

    No output

Output: nowind.rom
--------------------------------------

 Page: 00
  Org: 00004000  Size: 00004000  Used: 00004000

   Address   Length Align  Label
   00004000   13040        
   000072F0    3344     @  MSXDOS2_PART.getBootArgs

  Overlay parts:
   Address   Length Align  Label
   00004006       2     @  
   00004010      18     @  
   00004093       2     @  
   000047D7       2     @  
   00004881       1     @  
   00004884       1     @  
   0000488D       2     @  
   0000489F       2     @  
   000048B9       2     @  
   000048EB       2     @  
   000048F7       2     @  
   000049A3      16     @  
   00005797       2     @  

 Page: 01
  Org: 00004000  Size: 0000C000  Used: 0000C000

   Address   Length Align  Label
   00004000   49152        

  Overlay parts:
   Address   Length Align  Label
   00004093       2     @  
   00008093       2     @  
   0000C093       2     @  

 Page: 02
  Org: 00004000  Size: 00004000  Used: 00004000

   Address   Length Align  Label
   00004000   13317        
   00007405    3067     @  MSXDOS1_PART.nowindInit

  Overlay parts:
   Address   Length Align  Label
   00004006       2     @  
   00004010      18     @  
   00005770       2     @  
   000057AA       2     @  
   00005809       2     @  
   0000581E       2     @  
   0000582F       2     @  
   00005851       2     @  
   00005884       2     @  
   00005890       2     @  
   0000595D      15     @  
   00005AE8       2     @  
   000065AF       2     @  

 Page: 03
  Org: 00000000  Size: 0006C000  Used: 0006C000

   Address   Length Align  Label
   00000000  442368        
